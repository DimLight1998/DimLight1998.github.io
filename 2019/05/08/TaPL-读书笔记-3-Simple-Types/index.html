<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">























  
  
  
  

  

  

  

  

  

  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="笔记对应原书 8-14 章。  上一部分（Untyped Systems）的重点回顾：  term 是具有实际意义的合法程序单元 语法 是对 term 的定义；定义一般是递归的，方便用归纳法证明相关性质 语义 给出了对 term 的求值规则，小步操作语义给出了 term 之间的变换规则 value 是 term 的一个子集，value 不能继续求值 如果找不到对 term 继续求值的规则，这个">
<meta name="keywords" content="编程语言理论,类型论,TaPL">
<meta property="og:type" content="article">
<meta property="og:title" content="TaPL 读书笔记 3 Simple Types">
<meta property="og:url" content="http://DimLight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/index.html">
<meta property="og:site_name" content="Computation &amp; Design">
<meta property="og:description" content="笔记对应原书 8-14 章。  上一部分（Untyped Systems）的重点回顾：  term 是具有实际意义的合法程序单元 语法 是对 term 的定义；定义一般是递归的，方便用归纳法证明相关性质 语义 给出了对 term 的求值规则，小步操作语义给出了 term 之间的变换规则 value 是 term 的一个子集，value 不能继续求值 如果找不到对 term 继续求值的规则，这个">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519200316.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519200616.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519205126.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519210711.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519212115.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519214553.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519214841.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519215410.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519215519.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519215720.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520003414.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520003909.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520005832.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520010222.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520010335.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520010444.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190521170221.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520012317.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190521164841.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190521165105.png">
<meta property="og:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190521165733.png">
<meta property="og:updated_time" content="2019-05-24T07:51:18.076Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TaPL 读书笔记 3 Simple Types">
<meta name="twitter:description" content="笔记对应原书 8-14 章。  上一部分（Untyped Systems）的重点回顾：  term 是具有实际意义的合法程序单元 语法 是对 term 的定义；定义一般是递归的，方便用归纳法证明相关性质 语义 给出了对 term 的求值规则，小步操作语义给出了 term 之间的变换规则 value 是 term 的一个子集，value 不能继续求值 如果找不到对 term 继续求值的规则，这个">
<meta name="twitter:image" content="http://dimlight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519200316.png">






  <link rel="canonical" href="http://DimLight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>TaPL 读书笔记 3 Simple Types | Computation & Design</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Computation & Design</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://DimLight1998.github.io/2019/05/08/TaPL-读书笔记-3-Simple-Types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Yang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Computation & Design">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">TaPL 读书笔记 3 Simple Types

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-08 15:40:17" itemprop="dateCreated datePublished" datetime="2019-05-08T15:40:17+08:00">2019-05-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-24 15:51:18" itemprop="dateModified" datetime="2019-05-24T15:51:18+08:00">2019-05-24</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>笔记对应原书 8-14 章。</p>
</blockquote>
<p>上一部分（Untyped Systems）的重点回顾：</p>
<ul>
<li><strong>term</strong> 是具有实际意义的合法程序单元</li>
<li><strong>语法</strong> 是对 term 的定义；定义一般是递归的，方便用归纳法证明相关性质</li>
<li><strong>语义</strong> 给出了对 term 的求值规则，小步操作语义给出了 term 之间的变换规则</li>
<li><strong>value</strong> 是 term 的一个子集，value 不能继续求值</li>
<li>如果找不到对 term 继续求值的规则，这个 term 是 <strong>normal form</strong>，但不一定是 value（如果确实不是 value，称为 stuck）</li>
<li>即使找得到对 term 继续求值的规则，也有可能出现求值 <strong>无法终止</strong> 的情况</li>
<li>书中使用的 lambda 演算是 call by value 的</li>
<li>无类型 lambda 演算可以用来编码各种东西，也能表示递归；也可对其进行语法和语义的扩展</li>
</ul>
<h2 id="为什么需要类型"><a href="#为什么需要类型" class="headerlink" title="为什么需要类型"></a>为什么需要类型</h2><h3 id="类型系统是干嘛的"><a href="#类型系统是干嘛的" class="headerlink" title="类型系统是干嘛的"></a>类型系统是干嘛的</h3><p>回到最开始对类型系统的定义：</p>
<blockquote>
<p>类型系统本质上是一个轻量级的形式化方法，用来拒绝一部分可能存在错误的程序。它不会引入很多复杂性，因此是轻量级的。具体要拒绝具有哪些性质的程序由语言的定义者定夺取舍。</p>
</blockquote>
<p>在无类型 lambda 演算中，会出现以下两种情况：</p>
<ol>
<li>存在不是 value 的 norm form</li>
<li>存在不能终止求值的 term</li>
</ol>
<p>当我们希望程序总是终止并且能够求出一个 value 时，我们不希望这两种情况出现。写了一个程序之后，我们想让某个东西告诉我们这个程序是否会 stuck。类型系统可以实现这一点。通过引入类型系统，我们能够“静态地”在实际运行程序前，就分析出这个程序是否可能存在上述两种情况，据此决定是否要拒绝它。</p>
<p>简单的类型系统可以让以上两点被拒绝，如果类型系统更加复杂的话，第二点可能无法被拒绝。</p>
<h3 id="类型的一些性质"><a href="#类型的一些性质" class="headerlink" title="类型的一些性质"></a>类型的一些性质</h3><p>在导出类型系统的性质之前有必要引入相应的符号和定义：</p>
<ul>
<li>term $t$ 具有类型 $T$ 记作 $t:T$</li>
<li>如果存在类型 $T$ 使得 $t:T$，则称 term $t$ 是 well typed 的</li>
</ul>
<p>确实可以构造出符合语法规定的，但是不是 well typed 的 term，比如 <code>succ(true)</code>，这种 term 在求值时会 stuck。</p>
<p>关于类型的规则在定义语言时就应当被给出，它作为 typing rules，是独立的一套规则。现在，语言的定义包括语法、语义、类型、类型规则这几个部分。语言的 typing rules 一般是以 inference 的形式给出的，长这样：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519200316.png">
<p>有了这些规则，就可以从语法树的叶子开始逐渐推导出整个 term 的类型。<strong>需要注意的是所有 well typed terms 的类型只能有 inference 规则得到，你不能凭空构造一个 <code>succ(true)</code> 然后强行定义它的类型就是 <code>Bool</code>，除非把 inference rules 给改了</strong>。实际中用得更多的是 inference rules 的等价形式，称作 inversion lemma，实际上就是把条件和结论换一下：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519200616.png">
<p>这么换的道理应该是每种 term 只有一条对应的 typing rule。用这些规则可以从语法树根部开始递归地计算出整个 term 的类型。</p>
<p>在有类型系统的语言的相关性质的证明中，一个常用的套路是根据类型进行归纳。例如我们要证明 term $t$ 具有某个性质，首先分析 $t$ 可能的类型有哪些，然后对于每种类型，分析出它为什么会具有这种类型（通过哪一条 typing rule），完成这一步之后，$t$ 的形式就固定了（比如 $t$ 必然是 $\texttt{if }t_1\texttt{ then }t_2\texttt{ else }t_3$ 结构的），然后归纳证明即可。</p>
<p>类型系统的一个性质是 <strong>每个 well typed term 只可能有一种类型，并且只有一棵推导出该类型的推导树</strong>。不过并非所有的类型系统都会满足这个性质（比如包括子类型的语言就不会）。这个性质称为 <strong>uniqueness</strong>。具有 uniqueness 性质的类型系统可以让编译器只扫描一遍 AST 就分析出各个 term 的类型，而不会有“猜测”的过程。</p>
<p>类型系统的另一个性质是保证了每种类型对应的 value 一定会具有某种形式，就像 inversion lemma 给出的那样。这个性质称为 <strong>canonical forms</strong>。</p>
<a id="more"></a>
<h3 id="类型系统是如何工作的"><a href="#类型系统是如何工作的" class="headerlink" title="类型系统是如何工作的"></a>类型系统是如何工作的</h3><p>类型系统会保证程序是“安全的”，这里的安全指的是不会进入 stuck 的状态。</p>
<p>这是由两条性质保证的。靠谱的类型系统一般都会让这两条性质成立：</p>
<ul>
<li><strong>Progress</strong>：一个 well typed term 要么是 value，要么就能继续求值。</li>
<li><strong>Preservation</strong>：一个 well typed term 如果求值了，那么得到的 term 还是 well typed 的。</li>
</ul>
<p>仅凭 progress 还不足以证明安全性：即使一个 term 是 well typed 的，如果它求值一步后就到了不是 well typed 的状态然后 stuck 了，那么它没有违反 progress 性质，但是确实违背了类型系统存在的初衷。所以还要靠 preservation 性质进一步约束。</p>
<p>这两条性质保证的是安全性——程序不可能 stuck。不过 <strong>它们不保证程序可以终止</strong>！</p>
<p>Preservation 有个更强的版本：一个 term 如果求值了，得到的 term 不仅具有类型，而且和原来的类型一致。但是很多复杂的类型系统中这一点是不成立的（还是具有子类型的类型系统）。</p>
<h2 id="简单类型-Lambda-演算"><a href="#简单类型-Lambda-演算" class="headerlink" title="简单类型 Lambda 演算"></a>简单类型 Lambda 演算</h2><h3 id="新的规则"><a href="#新的规则" class="headerlink" title="新的规则"></a>新的规则</h3><p>首先会上一部分的无类型 lambda 演算系统引入类型。这个系统中所有的东西都是函数，如果用 $\rightarrow$ 来描述“函数”这个类型的话，表达能力显然是不够的，因此我们使用 $T_1\rightarrow T_2$ 的方式描述类型，其中 $T_1$ 和 $T_2$ 分别是函数的参数类型和返回值类型，$\rightarrow$ 是右结合的。</p>
<p>那么对于一个 term 如何得知它的类型？大部分情况下都可以根据 inference rules 直接推断出来，唯一的例外是 <strong>函数抽象时参数的类型</strong>。一种解决方法是观察参数在函数体中到底是怎么被使用的，但这似乎解决不了 $\lambda x.x$ 这样的函数的问题。另一种解决方法是让程序员在定义函数时标记出参数的类型，我们采用这种方式。现在定义函数要写成这样：</p>
<script type="math/tex; mode=display">
\lambda x:\texttt{Bool}.x</script><p>现在简单类型 lambda 演算的所有规则如下：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519205126.png">
<p>这里面还加入了一个叫做 typing context 的符号为 $\Gamma$ 的东西。它是一个从变量到类型的映射，用来在推导类型时“记录”当前这个 term 所在的环境中的变量的类型，并且可以用逗号进行扩展。例如在 T-ABS 规则的条件 $\Gamma, x:T_1\vDash t_2:T_2$ 中，因为 $t_2$ 可能不是封闭的，所以需要维护一个记录了外部信息的环境。</p>
<blockquote>
<p>像 T-ABS 这样的规则叫做 <em>introduction rule</em>，它指出了如何构建新的类型。</p>
<p>像 T-APP 这样的规则叫做 <em>elimination rule</em>，它指出了如何使用存在的类型。</p>
</blockquote>
<p>它也有对应的 inversion lemmas：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519210711.png">
<h3 id="简单类型-Lambda-演算的性质"><a href="#简单类型-Lambda-演算的性质" class="headerlink" title="简单类型 Lambda 演算的性质"></a>简单类型 Lambda 演算的性质</h3><p>上面定义的演算系统写作 $\lambda_\rightarrow$，它具有之前说的类型系统的所有四条性质：</p>
<ul>
<li><strong>Uniqueness</strong>：给定了 $\Gamma$ 的情况下每个 term 只有一个类型，并且只有一棵类型推导树</li>
<li><strong>Canonical form</strong>：例如，如果一个 value 的类型是 $T_1 \rightarrow T_2$，它必然具有形式 $\lambda x:T_1.t$</li>
<li><strong>Progress</strong>：封闭的 well typed terms 要么是 value 要么可以进一步求值</li>
<li><strong>Preservation</strong>：可以进一步求值的 well typed terms 求值后还是 well typed terms，并且类型保持不变</li>
</ul>
<p>然而，上面的演算系统并没有什么用，因为它实际上没办法构造出一个 well typed term！它的类型只有 $T_1 \rightarrow T_2$ 这一种，但是你并不知道 $T_1$ 具体能够是什么。这种不能干活的系统当然是安全的。</p>
<p>后面会通过一些扩展解决这个问题。</p>
<hr>
<p>在原生简单类型 lambda 演算中，所有的 well typed term 都是 <strong>normalizable</strong> 的，就是说只要你不断求值，总是可以到达一个 normal form。而再根据 progress 性质，我们知道所有的 normal form 进一步还都是 value。这个结论很重要。</p>
<p>但是如果引入一些奇怪的扩展（比如后面的递归），或者使用更加高级的类型系统（含有 recursive type 的），这个 normalizable 的性质就得不到保证了。<strong>但是</strong>，在更高的层面上，研究这些类型系统的程序（比如一个非常复杂的语言的编译器的类型检查部分）的类型系统可能还是简单类型 lambda 演算，它本身可能还是 normalizable 的。</p>
<h3 id="比较抽象的话题"><a href="#比较抽象的话题" class="headerlink" title="比较抽象的话题"></a>比较抽象的话题</h3><blockquote>
<p>这里的东西实际上没看太懂。</p>
</blockquote>
<h4 id="Curry-Howard-同构"><a href="#Curry-Howard-同构" class="headerlink" title="Curry-Howard 同构"></a>Curry-Howard 同构</h4><p>类型和命题之间存在一些联系，同样地，程序和逻辑证明之间也存在一些联系。比如上面的 T-APP 规则，它的前提中有两个类型，结论中是一个类型，这三个类型的对应关系可以直接转换到命题逻辑中。如果需要证明命题逻辑 $P\land P\rightarrow Q\Rightarrow Q$ 的话，只要构造出一个类型为 $T_1$ 的 term 和一个类型为 $T_1\rightarrow T_2$ 的 term，然后作一下函数应用即可。</p>
<p>这种同构关系在更加复杂的类型系统和逻辑系统中也存在。比如多态和一阶逻辑的对应关系。</p>
<h4 id="lambda-rightarrow-演算和-lambda-演算的转换"><a href="#lambda-rightarrow-演算和-lambda-演算的转换" class="headerlink" title="$\lambda_\rightarrow$ 演算和 $\lambda$ 演算的转换"></a>$\lambda_\rightarrow$ 演算和 $\lambda$ 演算的转换</h4><p>将有类型的 term 转换为无类型的 term 的过程称为 <strong>type erasure</strong>，它的严格定义是：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519212115.png">
<p>在检查完类型后，运行时我们就不需要这个东西了，因为类型系统的目的已经达到了。在完成了 type erasure 之后，得到的无类型 term 和原来有类型 term 在是否 stuck 以及是否终止等方面是一致的，这可以被证明。因此可以通过 type erasure 保证运行时的效率。就是说引入类型系统只会引入静态的额外开销，而不会有动态的运行开销。</p>
<p>相反的过程是 <strong>type reconstruction</strong>：给定无类型 lambda 演算的 term，并构造简单类型 lambda 演算中的 term，使得后者被 erasure 之后正好是前者。此处它并没有什么用。</p>
<h4 id="Curry-Style-和-Church-Style"><a href="#Curry-Style-和-Church-Style" class="headerlink" title="Curry-Style 和 Church-Style"></a>Curry-Style 和 Church-Style</h4><p>这两种 style 是定义语义时的风格。</p>
<ul>
<li>在 curry style 中先定义语义，然后用类型规则拒绝掉一些会出错的 term。</li>
<li>在 church style 中，定义了语法之后马上用类型规则确定哪些 term 是合法的，然后定义它们的语义。</li>
</ul>
<p>Church style 中不存在 <em>ill typed terms 求值时的行为是怎么样的</em> 这样的问题，因为这样的 terms 不会存在。</p>
<h2 id="一些简单的类型扩展"><a href="#一些简单的类型扩展" class="headerlink" title="一些简单的类型扩展"></a>一些简单的类型扩展</h2><h3 id="Base-Type"><a href="#Base-Type" class="headerlink" title="Base Type"></a>Base Type</h3><p>前面提到了原生的简单类型 lambda 演算无法构造出任何 well typed form。这一点可以通过引入一个 base type 加以修正，比如可以加入 Bool 类型。</p>
<p>我们可以仅仅只是加入 Bool 类型，以及对应的 value，而不做其它任何语法或者语义的修改。现在可以构造出 well typed form 了，例如：</p>
<script type="math/tex; mode=display">
(\lambda x:\texttt{Bool}.x) \texttt{true}</script><hr>
<p>理论上我们甚至可以仅仅加入一个类型，但是不加入任何 value。这样的 base type 称为 uninterpreted base type。引入了它之后依然可以构造出 well typed form，但是对于类型为该 base type 的变量，我们不知道它到底可以取什么值。</p>
<h3 id="Unit-类型"><a href="#Unit-类型" class="headerlink" title="Unit 类型"></a><code>Unit</code> 类型</h3><p><code>Unit</code> 类型唯一的 value 就是 <code>unit</code>，如果想要实现不返回有意义内容的函数，这样的类型就会有用。它一般和有副作用的函数配合起来使用。</p>
<p>在引入 <code>Unit</code> 类型后我们可以实现一些 <strong>derived form</strong>，我们需要为这种 form 定义新的语法，但是本质上它们可以被原有的语法等价表达出来，因此只是语法糖而已。一个 derived form 的例子是不使用参数的函数。与其随便写一个形参的名字然后传一个毫无意义的实参，不如直接省略掉参数的名字。语法上可以使用 $\lambda_:S.t$ 来替换掉原来的 $\lambda x:S.t$（这个 $x$ 从来没有被使用）。</p>
<p>在引入 <code>Unit</code> 后我们可以实现 <strong>执行序列</strong>（Sequence）这个语法糖：$t_1;t_2$ 会先对 $t_1$ 求值然后对 $t_2$ 求值。它会被脱糖为 $(\lambda x:\texttt{Unit}.t_2)t_1$，并且要求 $t_1$ 返回类型必须是 <code>Unit</code>。不过，如果愿意也可以将它实现为语言核心语法和语义的一部分，这会让语言核心更加复杂：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519214553.png">
<h3 id="Ascription-Term"><a href="#Ascription-Term" class="headerlink" title="Ascription Term"></a>Ascription Term</h3><p>这个新扩展的实际上是程序员对 term 的类型的 assertion。进行类型检查时会检查这个 assertion 是否成立。它可以用作某种形式的文档。</p>
<p>规则为：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519214841.png">
<h3 id="Let-绑定-Term"><a href="#Let-绑定-Term" class="headerlink" title="Let 绑定 Term"></a>Let 绑定 Term</h3><p>这个扩展可以让你写出 Haskell 中 <code>let x = y in z</code> 这样的语句。在不考虑类型的情况下，它实际上是个语法糖：</p>
<script type="math/tex; mode=display">
\texttt{let }x = t_1 \texttt{ in } t_2 = (\lambda x:T_1.t_2)t_1</script><p>但是实现上存在一些问题。我们不能像 sequence 语法糖那样直接做文本替换，因为右侧的 $T_1$ 没有出现在左侧。为了将其用核心语言表达出来，我们需要先推断出 $t_1$ 的类型，这会导致上面的等式两边的类型的推导树不一致。因此，这个扩展只能集成到核心语言中。</p>
<p>规则为：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519215410.png">
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>这个扩展就比较简单了，它就是个 product type：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519215519.png">
<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p>这个扩展也比较简单。本质上，元组也是一种记录。另外，这里的记录的键是 <strong>有序的</strong>，调换了键的顺序之后不是同一个类型。</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190519215720.png">
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>从记录中取出元素除了使用 projection 之外，还可以引入模式匹配的语法。这是一种新的语法，需要引入新的叫做 pattern 的 syntactic category，对应的 matching rules，以及对应的 <code>let pattern = record in expr</code> 表达式。</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520003414.png">
<h3 id="Variants-扩展"><a href="#Variants-扩展" class="headerlink" title="Variants 扩展"></a>Variants 扩展</h3><p>这个扩展类似于 ML 系语言中的 datatype，不过稍微有些不同。</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520003909.png">
<p>首先看新引入的类型，它的类型是 $\langle{l_i:T_i}^{i\in 1..n}\rangle$，它的值的形式都是 $\langle l_j = t_j\rangle \texttt{ as }\langle{l_i:T_i}^{i\in 1..n}\rangle$，其中 $t_j$ 具有 $T_j$ 类型。本质上它就是一个 sum type。</p>
<p>构造一个 variants 要用到 <code>as</code> 语句（这个过程叫做 tagging），解构一个 variants 要用到 <code>case ... of ...</code> 语句。为什么要引入 tagging 的过程呢？因为如果直接将 $\langle l = t\rangle$ 这个东西看做一个 variants 的话，你是没办法知道它的类型的，它可能是 $\langle l:T\rangle$ 或者 $\langle l:T, m: U\rangle$ 或者 $\langle l:T, n:V\rangle$ 或者什么东西，这个违背了 uniqueness 的性质，所以需要一个 tagging 的过程。</p>
<p>而在 ML 系语言中没有这个问题，因为不同 datatype 的各个构造子名字不能相同。给出构造子的名字之后就知道了对应的 datatype 到底是什么。</p>
<hr>
<p>Variants 的一些有趣的用法：</p>
<ul>
<li>把它和 <code>Unit</code> 类型一起用，可以实现出 Haskell 中的 <code>Maybe</code> 效果</li>
<li>如果所有的分支的类型都是 <code>Unit</code>，这时只能通过对应的 label 区分它们，就实现了 enumeration 的效果</li>
<li>如果只有一个分支，相当于 type alias，它可以起到文档化的效果</li>
<li>可以用它来实现动态类型</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>在无类型 lambda 演算中我们通过引入 <code>fix</code> 组合子实现了递归，但是在简单类型 lambda 演算中就没这么舒服了，因为 <code>fix</code> 不是 well typed 的。在目前，<strong>所有 well typed terms 都是可以终止的</strong>，而 <code>fix</code> 显然不满足这一点。</p>
<p>为了实现递归，我们要将 <code>fix</code> 作为核心语言的一部分，添加新的求值规则。同时，我们会引入 <code>letrec</code> 的语法糖（它会被解释成 <code>let</code> 和 <code>fix</code> 的组合）：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520005832.png">
<p>由于在这个情况下，<code>fix</code> 可以认为是语法的一部分，而非一个函数，所以类型系统上没有漏洞。但是我们确实引入了递归，所以这个演算系统的 well typed forms 的求值并非总是可以终止。实际上书中给出了一个例子，它对任意的类型 $T$ 都是不可终止的：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520010222.png">
<p>结合递归和记录，可以写出 mutually recursive 的函数：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520010335.png">
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>这个扩展我没有细看，不过作为强迫症还是放张图。</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520010444.png">
<h2 id="实现简单类型-Lambda-演算"><a href="#实现简单类型-Lambda-演算" class="headerlink" title="实现简单类型 Lambda 演算"></a>实现简单类型 Lambda 演算</h2><p>要实现一个简单类型 lambda 演算的系统，实际上和无类型 lambda 演算系统差不多。它只多了一个环节，就是在 evalute 前检查整个 term 是不是 well typed 的，只有是才会进行计算。这样可以保证总是能够求出 value 并且终止。</p>
<p>我的实现中实现了一些扩展。</p>
<p>Datatype 的定义：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Term</span> =</span></span><br><span class="line">    <span class="type">TmFunc</span> <span class="type">Type</span> <span class="type">Term</span></span><br><span class="line">  | <span class="type">TmApp</span> <span class="type">Term</span> <span class="type">Term</span></span><br><span class="line">  | <span class="type">TmVar</span> <span class="type">Int</span></span><br><span class="line">  | <span class="type">TmTrue</span>                          <span class="comment">-- bool extension</span></span><br><span class="line">  | <span class="type">TmFalse</span></span><br><span class="line">  | <span class="type">TmIf</span> <span class="type">Term</span> <span class="type">Term</span> <span class="type">Term</span></span><br><span class="line">  | <span class="type">TmUnit</span>                          <span class="comment">-- unit extension</span></span><br><span class="line">  | <span class="type">TmSeq</span> <span class="type">Term</span> <span class="type">Term</span></span><br><span class="line">  | <span class="type">TmWild</span> <span class="type">Term</span></span><br><span class="line">  | <span class="type">TmAs</span> <span class="type">Term</span> <span class="type">Type</span>                  <span class="comment">-- ascription extension</span></span><br><span class="line">  | <span class="type">TmLet</span> <span class="type">Term</span> <span class="type">Term</span>                 <span class="comment">-- let extension</span></span><br><span class="line">  | <span class="type">TmTuple</span> [<span class="type">Term</span>]                  <span class="comment">-- tuple extension</span></span><br><span class="line">  | <span class="type">TmIndex</span> <span class="type">Term</span> <span class="type">Int</span></span><br><span class="line">  | <span class="type">TmRecord</span> (<span class="type">Map</span>.<span class="type">Map</span> <span class="type">String</span> <span class="type">Term</span>)  <span class="comment">-- record extension</span></span><br><span class="line">  | <span class="type">TmProj</span> <span class="type">Term</span> <span class="type">String</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Type</span> =</span></span><br><span class="line">    <span class="type">TpFunc</span> <span class="type">Type</span> <span class="type">Type</span></span><br><span class="line">  | <span class="type">TpBool</span>                          <span class="comment">-- bool extension</span></span><br><span class="line">  | <span class="type">TpUnit</span>                          <span class="comment">-- unit extension</span></span><br><span class="line">  | <span class="type">TpTuple</span> [<span class="type">Type</span>]                  <span class="comment">-- tuple extension</span></span><br><span class="line">  | <span class="type">TpRecord</span> (<span class="type">Map</span>.<span class="type">Map</span> <span class="type">String</span> <span class="type">Type</span>)  <span class="comment">-- record extension</span></span><br><span class="line">  | <span class="type">TpError</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">TypeContext</span> = <span class="type">Map</span>.<span class="type">Map</span> <span class="type">Int</span> <span class="type">Type</span></span></span><br></pre></td></tr></table></figure>
<p>和之前的相比，无非是 <code>TmFunc</code> 还要求提供一个 <code>Type</code>。这和简单类型 lambda 演算的语法一致。</p>
<p>维护 type context 的一些实用函数。因为我用的是 nameless lambda calculus，所以 type context 是整数到类型的映射：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- type context utilities</span></span><br><span class="line"><span class="title">emptyTypeContext</span> :: <span class="type">TypeContext</span></span><br><span class="line"><span class="title">emptyTypeContext</span> = <span class="type">Map</span>.empty</span><br><span class="line"></span><br><span class="line"><span class="title">liftTypeContext</span> :: <span class="type">TypeContext</span> -&gt; <span class="type">TypeContext</span></span><br><span class="line"><span class="title">liftTypeContext</span> = <span class="type">Map</span>.mapKeysMonotonic (+ <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">pushTypeContext</span> :: <span class="type">Type</span> -&gt; <span class="type">TypeContext</span> -&gt; <span class="type">TypeContext</span></span><br><span class="line"><span class="title">pushTypeContext</span> tp tc = <span class="type">Map</span>.insert <span class="number">0</span> tp (liftTypeContext tc)</span><br></pre></td></tr></table></figure>
<p>最核心的函数在下面，它基于 type rules 导出的 inference lemmas。这个函数大量使用了 <code>TpError</code> 表示类型检测没有通过：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">getType</span> :: <span class="type">TypeContext</span> -&gt; <span class="type">Term</span> -&gt; <span class="type">Type</span></span><br><span class="line"><span class="title">getType</span> tc tm = <span class="keyword">case</span> tm <span class="keyword">of</span></span><br><span class="line">    <span class="type">TmFunc</span> tArg body -&gt; <span class="keyword">let</span></span><br><span class="line">        tc' = pushTypeContext tArg tc</span><br><span class="line">        tRet = getType tc' body</span><br><span class="line">        <span class="keyword">in</span> <span class="type">TpFunc</span> tArg tRet</span><br><span class="line">    <span class="type">TmApp</span> func arg</span><br><span class="line">      | <span class="type">TpFunc</span> left right &lt;- tFunc -&gt; <span class="keyword">if</span> left == tArg <span class="keyword">then</span> right <span class="keyword">else</span> <span class="type">TpError</span></span><br><span class="line">      | otherwise -&gt; <span class="type">TpError</span></span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">        tFunc = getType tc func</span><br><span class="line">        tArg = getType tc arg</span><br><span class="line">    <span class="type">TmVar</span> i -&gt; <span class="type">Map</span>.findWithDefault <span class="type">TpError</span> i tc</span><br><span class="line">    <span class="type">TmTrue</span> -&gt; <span class="type">TpBool</span></span><br><span class="line">    <span class="type">TmFalse</span> -&gt; <span class="type">TpBool</span></span><br><span class="line">    <span class="type">TmIf</span> tm1 tm2 tm3 -&gt; <span class="keyword">let</span></span><br><span class="line">        tp1 = getType tc tm1</span><br><span class="line">        tp2 = getType tc tm2</span><br><span class="line">        tp3 = getType tc tm3</span><br><span class="line">        <span class="keyword">in</span> <span class="keyword">if</span> tp1 == <span class="type">TpBool</span> &amp;&amp; tp2 == tp3 <span class="keyword">then</span> tp2 <span class="keyword">else</span> <span class="type">TpError</span></span><br><span class="line">    <span class="type">TmUnit</span> -&gt; <span class="type">TpUnit</span></span><br><span class="line">    <span class="type">TmSeq</span> tm1 tm2 -&gt; <span class="keyword">let</span></span><br><span class="line">        tp1 = getType tc tm1</span><br><span class="line">        tp2 = getType tc tm2</span><br><span class="line">        <span class="keyword">in</span> <span class="keyword">if</span> tp1 == <span class="type">TpUnit</span> <span class="keyword">then</span> tp2 <span class="keyword">else</span> <span class="type">TpError</span></span><br><span class="line">    <span class="type">TmWild</span> body -&gt; <span class="keyword">let</span></span><br><span class="line">        tc' = pushTypeContext <span class="type">TpUnit</span> tc</span><br><span class="line">        tRet = getType tc' body</span><br><span class="line">        <span class="keyword">in</span> <span class="type">TpFunc</span> <span class="type">TpUnit</span> tRet</span><br><span class="line">    <span class="type">TmAs</span> tm tp -&gt; <span class="keyword">if</span> tp == getType tc tm <span class="keyword">then</span> tp <span class="keyword">else</span> <span class="type">TpError</span></span><br><span class="line">    <span class="type">TmLet</span> t1 t2 -&gt; <span class="keyword">let</span></span><br><span class="line">        tp1 = getType tc t1</span><br><span class="line">        tc' = pushTypeContext tp1 tc</span><br><span class="line">        <span class="keyword">in</span> getType tc' t2</span><br><span class="line">    <span class="type">TmTuple</span> tms -&gt; <span class="type">TpTuple</span> $ map (getType tc) tms</span><br><span class="line">    <span class="type">TmIndex</span> tm i</span><br><span class="line">      | <span class="type">TpTuple</span> tps &lt;- tpTp -&gt; tps !! i</span><br><span class="line">      | otherwise -&gt; <span class="type">TpError</span></span><br><span class="line">      <span class="keyword">where</span> </span><br><span class="line">        tpTp = getType tc tm</span><br><span class="line">    <span class="type">TmRecord</span> r -&gt; <span class="type">TpRecord</span> $ getType tc &lt;$&gt; r</span><br><span class="line">    <span class="type">TmProj</span> r l</span><br><span class="line">      | <span class="type">TpRecord</span> tps &lt;- tpRc -&gt; <span class="type">Map</span>.findWithDefault <span class="type">TpError</span> l tps</span><br><span class="line">      | otherwise -&gt; <span class="type">TpError</span></span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">        tpRc = getType tc r</span><br><span class="line"></span><br><span class="line"><span class="comment">-- implementation should not be modified</span></span><br><span class="line"><span class="title">typeCheck</span> :: <span class="type">Term</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">typeCheck</span> tm = getType emptyTypeContext tm /= <span class="type">TpError</span></span><br></pre></td></tr></table></figure>
<p>在最后的 <code>evaluate</code> 函数中，我们拒绝接受没通过类型检查的 term 即可：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">evaluate</span> :: <span class="type">Term</span> -&gt; <span class="type">Term</span></span><br><span class="line"><span class="title">evaluate</span> tm = <span class="keyword">let</span></span><br><span class="line">    evaluateWithoutTypeCheck :: <span class="type">Term</span> -&gt; <span class="type">Term</span></span><br><span class="line">    evaluateWithoutTypeCheck term =</span><br><span class="line">        <span class="keyword">if</span> isVal term <span class="keyword">then</span> term <span class="keyword">else</span> evaluateWithoutTypeCheck $ progress term</span><br><span class="line">    <span class="keyword">in</span> <span class="keyword">if</span> typeCheck tm <span class="keyword">then</span> evaluateWithoutTypeCheck tm <span class="keyword">else</span> error <span class="string">"type check failed"</span></span><br></pre></td></tr></table></figure>
<h2 id="引用与异常"><a href="#引用与异常" class="headerlink" title="引用与异常"></a>引用与异常</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用是为了实现可变数据类型。</p>
<ul>
<li>使用 $\texttt{ref}\ t$ 来创建一个引用，指向的“单元”的初值为 $t$。这个单元可能是内存，但是这里被抽象为 store。</li>
<li>使用 $\texttt{!}\ r$ 来解引用。</li>
<li>使用 $a\ \texttt{:=}\ b$ 来更新单元中的值，这个操作返回值为 <code>unit</code>。</li>
</ul>
<p>这几个操作的 typing rules 如下：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190521170221.png">
<p>由于引入了可变状态，所以现在程序的状态不能仅仅用 term 来表示了，它还和 store 的状态有关。Store 中的单元的名字用 $l$（location）来表示（store 是内存的话，$l$ 可能是地址），我们引入 $\mu$ 这个符号表示 store 的状态，它将 location 映射到 value。</p>
<p>在之前，程序只用一个 term $t$ 就能表示状态，现在引入了 store 后需要用 $t|\mu$ 来表示状态。有了这种新的表示法之后要重新定义求值规则。</p>
<p>然后考虑类型的问题。当涉及到引用时类型检查会有一些额外的规则，比如从 store 中取出的东西到底是什么类型。一种办法是跟踪 $\mu$ 来解决这个问题，但是这会导致类型检查的系统很低效（一些情况下甚至无法终止）。另一种方法是引入 $\Sigma$，叫做 store type，它会将 location 直接映射到 type。在创建了存储单元之后，后续的操作不会改变存储单元中值的类型，这是 store type 的思路的基础。使用 store type 的话类型检查会变得比较容易。</p>
<p>即使引入了引用，整个类型系统依然是安全的。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常实际上是控制流的转移。</p>
<p>书中一共提出了三种不同类型的异常，复杂程度递增：</p>
<ol>
<li>只知道发生了异常，无法进行拦截</li>
<li>知道发生了异常并且可以拦截，但是不知道异常的具体内容</li>
<li>知道异常并且可以拦截，同时知道异常的具体内容</li>
</ol>
<h4 id="第一种异常规则：不可拦截的不带信息的异常"><a href="#第一种异常规则：不可拦截的不带信息的异常" class="headerlink" title="第一种异常规则：不可拦截的不带信息的异常"></a>第一种异常规则：不可拦截的不带信息的异常</h4><p>引入新的 term：<code>error</code> 以及对应的类型规则和求值规则。</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190520012317.png">
<p>需要注意的点：</p>
<ul>
<li><code>error</code> 不是一个 value，因此加入了这个规则后的简单类型 lambda 演算不会有歧义。如果它是 value 的话，<ul>
<li>$(\lambda x:\texttt{Nat}.0)\texttt{error}$ 既可以返回 <code>error</code> 也可以返回 $0$；</li>
<li>$(\texttt{fix}(\lambda x:\texttt{Nat}.x))\texttt{error}$ 既可以终止也可以不终止；</li>
</ul>
</li>
<li><code>error</code> 的类型是任意的，这违反了 uniqueness 性质，因此实现上会有些麻烦；</li>
<li>引入这个东西后系统的 progress 性质要改成：要么可以继续运算，要么是个 value，要么是 <code>error</code>。</li>
</ul>
<h4 id="第二种规则：可拦截的不带信息的异常"><a href="#第二种规则：可拦截的不带信息的异常" class="headerlink" title="第二种规则：可拦截的不带信息的异常"></a>第二种规则：可拦截的不带信息的异常</h4><p>在上一种规则的情况下引入 <code>try with</code> 结构进行异常处理：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190521164841.png">
<h4 id="第三种规则：可拦截的带信息的异常"><a href="#第三种规则：可拦截的带信息的异常" class="headerlink" title="第三种规则：可拦截的带信息的异常"></a>第三种规则：可拦截的带信息的异常</h4><p>首先引入一个表示异常的类型 $T_{exn}$，然后引入 <code>raise</code> 结构抛出这样的异常（见两个类型规则）。<code>raise</code> 一个 $T_{exn}$ 后的表达式的类型还是任意的。</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190521165105.png">
<p>现在的 <code>try t_1 with t_2</code> 中，<code>t_2</code> 不再是一个值，而是一个类似 handler 的东西，它会接受 $T_{exn}$ 类型的值然后进行处理。</p>
<p>很多语言实现的就是这种机制，随着 $T_{exn}$ 的选择不同，这些语言的异常机制不同。例如将它设定为 <code>Nat</code> 可以实现 Linux 中程序返回非零值表示不同异常的效果，实现为一个 variant 就可以表示不同类型的错误（同时附带额外信息）。像 ML 这样的语言则允许让用户定义更多的异常类型。</p>
<p>如果 $T_{exn}$ 是一个 variant，则可以选择性地处理其中的一部分异常。它的实现是这样的：</p>
<img src="/2019/05/08/TaPL-读书笔记-3-Simple-Types/DeepinScreenshot_select-area_20190521165733.png">
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/编程语言理论/" rel="tag"># 编程语言理论</a>
          
            <a href="/tags/类型论/" rel="tag"># 类型论</a>
          
            <a href="/tags/TaPL/" rel="tag"># TaPL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/08/TaPL-读书笔记-2-Untyped-Systems/" rel="next" title="TaPL 读书笔记 2 Untyped Systems">
                <i class="fa fa-chevron-left"></i> TaPL 读书笔记 2 Untyped Systems
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/08/TaPL-读书笔记-4-Subtyping/" rel="prev" title="TaPL 读书笔记 4 Subtyping">
                TaPL 读书笔记 4 Subtyping <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhang Yang</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">124</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/dimlight1998" title="GitHub &rarr; https://github.com/dimlight1998" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:dimlight1998@gmail.com" title="E-Mail &rarr; mailto:dimlight1998@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么需要类型"><span class="nav-number">1.</span> <span class="nav-text">为什么需要类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型系统是干嘛的"><span class="nav-number">1.1.</span> <span class="nav-text">类型系统是干嘛的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型的一些性质"><span class="nav-number">1.2.</span> <span class="nav-text">类型的一些性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型系统是如何工作的"><span class="nav-number">1.3.</span> <span class="nav-text">类型系统是如何工作的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单类型-Lambda-演算"><span class="nav-number">2.</span> <span class="nav-text">简单类型 Lambda 演算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新的规则"><span class="nav-number">2.1.</span> <span class="nav-text">新的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单类型-Lambda-演算的性质"><span class="nav-number">2.2.</span> <span class="nav-text">简单类型 Lambda 演算的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较抽象的话题"><span class="nav-number">2.3.</span> <span class="nav-text">比较抽象的话题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Curry-Howard-同构"><span class="nav-number">2.3.1.</span> <span class="nav-text">Curry-Howard 同构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda-rightarrow-演算和-lambda-演算的转换"><span class="nav-number">2.3.2.</span> <span class="nav-text">$\lambda_\rightarrow$ 演算和 $\lambda$ 演算的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Curry-Style-和-Church-Style"><span class="nav-number">2.3.3.</span> <span class="nav-text">Curry-Style 和 Church-Style</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些简单的类型扩展"><span class="nav-number">3.</span> <span class="nav-text">一些简单的类型扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Base-Type"><span class="nav-number">3.1.</span> <span class="nav-text">Base Type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unit-类型"><span class="nav-number">3.2.</span> <span class="nav-text">Unit 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ascription-Term"><span class="nav-number">3.3.</span> <span class="nav-text">Ascription Term</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Let-绑定-Term"><span class="nav-number">3.4.</span> <span class="nav-text">Let 绑定 Term</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元组"><span class="nav-number">3.5.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记录"><span class="nav-number">3.6.</span> <span class="nav-text">记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式匹配"><span class="nav-number">3.7.</span> <span class="nav-text">模式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Variants-扩展"><span class="nav-number">3.8.</span> <span class="nav-text">Variants 扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">3.9.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表"><span class="nav-number">3.10.</span> <span class="nav-text">列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现简单类型-Lambda-演算"><span class="nav-number">4.</span> <span class="nav-text">实现简单类型 Lambda 演算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用与异常"><span class="nav-number">5.</span> <span class="nav-text">引用与异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用"><span class="nav-number">5.1.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常"><span class="nav-number">5.2.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一种异常规则：不可拦截的不带信息的异常"><span class="nav-number">5.2.1.</span> <span class="nav-text">第一种异常规则：不可拦截的不带信息的异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二种规则：可拦截的不带信息的异常"><span class="nav-number">5.2.2.</span> <span class="nav-text">第二种规则：可拦截的不带信息的异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三种规则：可拦截的带信息的异常"><span class="nav-number">5.2.3.</span> <span class="nav-text">第三种规则：可拦截的带信息的异常</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Yang</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('3');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow-x: scroll;
  overflow-y: hidden;
}
</style>

    
  


  

  

  

  

  

  

  

  

  

</body>
</html>

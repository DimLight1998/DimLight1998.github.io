<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- <title>|Title|</title> -->
  <link rel="stylesheet" href="/res/page.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto Slab">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Courier Prime">
</head>
<body>
<h1 id="practical-vim">Practical VIM</h1>
<h2 id="the-vim-way">The Vim Way</h2>
<h3 id="vim-principle">Vim Principle</h3>
<p>the vim principle: <strong>don’t repeat yourself</strong></p>
<h3 id="dot-command">Dot Command</h3>
<p>use <code>.</code> to replay last change</p>
<ul>
<li>if you stay in normal mode, dot repeat your last action
<ul>
<li><em>e.g.</em> <code>dd</code> to delete current line, use <code>.</code> will delete multiple lines</li>
</ul></li>
<li>if you enter insert mode, dot repeat the action you used to enter insert mode and modifcations you perform there, then get back to normal mode
<ul>
<li><em>e.g.</em> <code>cw</code> change a word, use <code>.</code> will change multiple words to a same word</li>
<li>using arrow key in insert mode will interrupt a complete modification</li>
</ul></li>
</ul>
<h3 id="repeat-and-reverse">Repeat and Reverse</h3>
<ul>
<li><strong>repeat</strong>: do it again</li>
<li><strong>reverse</strong>: undo</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">action</th>
<th style="text-align: center;">shortcut</th>
<th style="text-align: center;">repeat</th>
<th style="text-align: center;">reverse</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">change, modification</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;"><code>.</code></td>
<td style="text-align: center;"><code>u</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">find by character</td>
<td style="text-align: center;"><code>f</code>, <code>F</code>, <code>t</code>, <code>T</code></td>
<td style="text-align: center;"><code>;</code></td>
<td style="text-align: center;"><code>,</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">find by pattern</td>
<td style="text-align: center;"><code>/</code>, <code>?</code></td>
<td style="text-align: center;"><code>n</code></td>
<td style="text-align: center;"><code>N</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">substitude by pattern</td>
<td style="text-align: center;"><code>:s/../../</code></td>
<td style="text-align: center;"><code>&amp;</code></td>
<td style="text-align: center;"><code>u</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">execute sequence of change</td>
<td style="text-align: center;"><code>qx...q</code></td>
<td style="text-align: center;"><code>@x</code></td>
<td style="text-align: center;"><code>u</code></td>
</tr>
</tbody>
</table>
<h3 id="dot-formula">Dot Formula</h3>
<p>one keystroke to move, one keystroke to execute, enabling patterns like:</p>
<ul>
<li><code>j.j.j.</code> execute an action on each line
<ul>
<li><em>e.g.</em> append semicolon to each line</li>
</ul></li>
<li><code>n.nnn.</code> execute an action with confirmation
<ul>
<li><em>e.g.</em> replace some words to another word</li>
</ul></li>
</ul>
<h2 id="modes">Modes</h2>
<h3 id="normal-mode">Normal Mode</h3>
<h4 id="granularity-of-undo">Granularity of Undo</h4>
<ul>
<li>modifications and undos are performed by chunk; one undo reverts one chunk</li>
<li>entering, modifying and then exiting insert mode creates a chunk</li>
<li>using arrow keys (or <code>&lt;home&gt;</code> / <code>&lt;end&gt;</code> …) in insert mode creates a new chunk</li>
</ul>
<h4 id="best-practices-when-editing-for-using-undo">Best Practices When Editing for Using Undo</h4>
<ul>
<li>choose the way that is most repeatable if there are multiple ways to do something
<ul>
<li><em>e.g.</em> if at the last character of a word and you want to delete the word, <code>daw</code> is better than <code>bdw</code>, which is better than <code>dbx</code></li>
<li>use the “action” with biggest granularity</li>
</ul></li>
<li>choose wisely between repeat and count
<ul>
<li>if you can repeat, don’t count (after all, if you have time to count, you have time to repeat…)</li>
<li><em>e.g.</em> delete 8 words, <code>dw.......</code> is better than <code>d8w</code>, which is almost the same as <code>8dw</code></li>
<li>if use finer undo granularity, no need to count (but need to repeat)
<ul>
<li>but count can gives a coherent undo history</li>
<li>change 3 words to some other words, <code>c3w</code> &gt; <code>dw..i</code> (you can undo easily after)</li>
</ul></li>
</ul></li>
</ul>
<p><strong>conclusion</strong>:</p>
<ul>
<li>big granularity: easy to undo</li>
<li>small granularity: easy to reuse, no need to count</li>
</ul>
<h4 id="operators-in-normal-mode">Operators in Normal Mode</h4>
<h5 id="common-operators">Common Operators</h5>
<ul>
<li>basics
<ul>
<li><code>c</code>: change</li>
<li><code>d</code>: delete</li>
<li><code>y</code>: yank (copy)</li>
</ul></li>
<li>case changing
<ul>
<li><code>g~</code>: swap case</li>
<li><code>gu</code>: change to lower case</li>
<li><code>gU</code>: change to upper case</li>
</ul></li>
<li>indent and shifting
<ul>
<li><code>&gt;</code>: shift right</li>
<li><code>&lt;</code>: shift left</li>
<li><code>=</code>: auto indent</li>
</ul></li>
<li>pipe to external program
<ul>
<li><code>!</code>: pipe LINES to external program</li>
</ul></li>
</ul>
<h5 id="use-of-operators">Use of Operators</h5>
<h6 id="rule-1.-operator-motion-action">Rule 1. Operator + Motion = Action</h6>
<ul>
<li><code>caw</code>: change the word under cursor</li>
<li><code>d2w</code>: delete 2 words after cursor</li>
<li><code>gUp</code>: change this paragraph to uppercase</li>
</ul>
<h6 id="rule-2.-operator-operator-edit-current-line">Rule 2. Operator + Operator = Edit Current Line</h6>
<ul>
<li><code>dd</code>: delete this line</li>
<li><code>&lt;&lt;</code>, <code>&gt;&gt;</code>: outdent/indent this line
<ul>
<li>use <code>&lt;C-t&gt;</code> and <code>&lt;C-d&gt;</code> to indent/outdent current line in insert mode</li>
</ul></li>
<li><code>gUgU</code> (also <code>gUU</code>): change current line to uppercase</li>
</ul>
<h6 id="rule-3.-defining-new-operators-and-motions">Rule 3. Defining New Operators and Motions</h6>
<p>some plugins defines new operators and motions</p>
<ul>
<li><em>vim-commentary</em>: new operator to toggle comment</li>
<li><em>vim-textobj-entire</em>: new motion to manipulate the entire file</li>
</ul>
<h3 id="insert-mode">Insert Mode</h3>
<h4 id="derectly-delete-in-insert-mode">Derectly Delete in Insert Mode</h4>
<p>(they also work in terminal!)</p>
<ul>
<li><code>C-h</code>: delete character (backspace)</li>
<li><code>C-w</code>: delete word</li>
<li><code>C-u</code>: delete to beginning of the line</li>
</ul>
<p>(note <code>C-k</code> can delete to line end in terminal, but now work in vim insertion mode)</p>
<h4 id="special-modes-under-insert-mode">Special Modes Under Insert Mode</h4>
<h5 id="insert-normal-mode">Insert Normal Mode</h5>
<ul>
<li><strong>description</strong>: temporarily leave insert mode</li>
<li><strong>trigger by</strong>: <code>&lt;C-o&gt;</code> (in insert mode, <code>o</code> for out)</li>
<li><strong>function</strong>: return to normal mode, execute a command, then return to insert mode</li>
<li>useful if only what to do one thing in insert mode</li>
</ul>
<h5 id="replace-mode">Replace Mode</h5>
<ul>
<li><strong>description</strong>: like insert mode but overwrite content</li>
<li><strong>trigger by</strong>: <code>R</code> or <code>&lt;Insert&gt;</code> (<code>R</code> for replace)</li>
</ul>
<h5 id="virtual-replace-mode">Virtual Replace Mode</h5>
<ul>
<li><strong>description</strong>: like replace mode, but treat tab as many spaces</li>
<li><strong>trigger by</strong>: <code>gR</code></li>
<li>recommended (use always possible)</li>
</ul>
<h5 id="one-shot-replace-mode">(One Shot) Replace Mode</h5>
<ul>
<li><strong>description</strong>: like replace mode, but with only one character</li>
<li><strong>trigger by</strong>: <code>r</code></li>
</ul>
<h5 id="one-shot-virtual-replace-mode">(One Shot) Virtual Replace Mode</h5>
<ul>
<li><strong>description</strong>: like virtual replace mode, but with only one character</li>
<li><strong>trigger by</strong>: <code>gr</code></li>
</ul>
<h4 id="register">Register</h4>
<h5 id="use-register-in-insert-mode">Use Register in Insert Mode</h5>
<ul>
<li><code>&lt;C-r&gt;{register}</code>: paste as typed, may case indentation issue</li>
<li><code>&lt;C-r&gt;&lt;C-p&gt;{register}</code>: smart paste, auto-resovle indentation</li>
</ul>
<p>you can view content of each register by <code>:reg</code></p>
<h5 id="expression-register">Expression Register</h5>
<ul>
<li>evaluate vim script and return result</li>
<li>access in insert mode by <code>&lt;C-r&gt;=</code></li>
<li>enter the scirpt, then press enter; result will be pasted to the buffer</li>
</ul>
<h4 id="insert-unusual-characters">Insert Unusual Characters</h4>
<ul>
<li>to get the code of a character
<ul>
<li>(normal mode) <code>ga</code></li>
</ul></li>
<li>insert by decimal code
<ul>
<li>(insert mode) <code>&lt;C-v&gt;{decimal-code}</code></li>
</ul></li>
<li>insert by hexadecimal code (unicode)
<ul>
<li>(insert mode) <code>&lt;C-v&gt;u{hex-code}</code></li>
</ul></li>
<li>insert by digraphs
<ul>
<li>use <code>:h digraphs-table</code> to query</li>
<li>(insert mode) <code>&lt;C-k&gt;{char1}{char2}</code></li>
</ul></li>
<li>insert literal key (e.g. <code>Tab</code>)
<ul>
<li>(insert mode) <code>&lt;C-v&gt;{literal-key}</code></li>
<li><em>e.g.</em> <code>&lt;C-v&gt;&lt;Tab&gt;</code> inserts a real tab</li>
</ul></li>
</ul>
<h3 id="visual-mode">Visual Mode</h3>
<h4 id="comparasion-with-operator-motion">Comparasion with Operator + Motion</h4>
<h5 id="operator-motion">Operator + Motion</h5>
<ul>
<li>use oprator to specify an action</li>
<li>then use motion to sepcify a range</li>
</ul>
<p><strong>example</strong>: <code>ciw</code> will change a word, where:</p>
<ul>
<li><code>c</code>: operator, change</li>
<li><code>iw</code>: inner word</li>
</ul>
<h5 id="visual-mode-oprator">Visual Mode + Oprator</h5>
<ul>
<li>use visual mode to specify a range</li>
<li>then use operator to sepcify an action</li>
</ul>
<p><strong>example</strong>: <code>viwc</code> will change a word, where</p>
<ul>
<li><code>v</code>: enter visual mode</li>
<li><code>iw</code>: select inner word</li>
<li><code>c</code>: operator, change</li>
</ul>
<p><strong>note</strong>: use <code>viwr</code> will change all letters to a same letter for that word</p>
<h5 id="best-practices">Best Practices</h5>
<ul>
<li>if doing repetitive actions, use normal mode (operator + motion)
<ul>
<li>visual mode (character-wise) can have surprising results when using <code>.</code> to repeat</li>
</ul></li>
<li>except for repetitive actions for lines
<ul>
<li><em>e.g.</em> to indent/outdent multiple lines multiple times:
<ol type="1">
<li>select these lines using visual mode</li>
<li>use <code>&gt;</code> for indenting</li>
<li>use <code>.</code> to repeat the indenting (vim will perform repetition on the same selection)</li>
</ol></li>
</ul></li>
</ul>
<h4 id="entering-select-mode-in-visual-mode">Entering Select Mode in Visual Mode</h4>
<ul>
<li>in visual mode, after selection, use <code>&lt;C-g&gt;</code> to enter select mode</li>
<li>in select mode, if you type anything, the selection will be replaced by what you typed</li>
<li>behaves like many other text editors (entering text will replace selection)</li>
</ul>
<p>don’t use this too often, because you can use <code>c</code> to change to selected area in visual mode to achieve the same effect</p>
<h4 id="switch-between-visual-modes-and-normal-mode">Switch Between Visual Modes and Normal Mode</h4>
<p>there are three visual modes:</p>
<ul>
<li><strong>character-wise</strong>: <code>v</code></li>
<li><strong>line-wise</strong>: <code>V</code></li>
<li><strong>block-wise</strong>: <code>&lt;C-v&gt;</code> (select a rectangular area; useful for code and table)</li>
</ul>
<p>if you are not in that mode:</p>
<ul>
<li>press the key to enter that mode</li>
<li>press the key again to get into normal mode</li>
</ul>
<h4 id="block-wise-visual-mode">Block-Wise Visual Mode</h4>
<ul>
<li>use <code>r</code> to replace the whole selection to a character</li>
<li>use <code>c</code> to change, will enter insert mode, all rows will be changed
<ul>
<li>however, the effect can only be observed after return to normal mode</li>
</ul></li>
<li>block-wise visual mode can select areas that are not regtangular
<ul>
<li><em>e.g.</em> five lines, from column 8 to each line’s ending (ragged visual block)</li>
<li>useful to append some thing to each line at the end (by using <code>A</code>), such as a semicolon)</li>
</ul></li>
</ul>
<h4 id="useful-shortcut-for-visual-mode">Useful Shortcut for Visual Mode</h4>
<ul>
<li>to <strong>reselect last selection</strong> (not usable if the selection is deleted): <code>gv</code></li>
<li>to <strong>go to the other end of the selection</strong>, i.e. switch <em>free end</em> and <em>fixed end</em>: <code>o</code></li>
<li>to <strong>change letters to uppercase in visual mode</strong>, use <code>U</code> after selection</li>
<li>to <strong>repeat the action on the previous selection</strong>, use <code>.</code> (useful for line-wise selection)</li>
</ul>
<h3 id="command-line-mode">Command-Line Mode</h3>
<h4 id="introduction">Introduction</h4>
<ul>
<li><strong>trigger</strong> to command-line mode in normal mode:
<ul>
<li><code>:</code> to enter <strong>ex command</strong></li>
<li><code>/</code> or <code>?</code> to perform search</li>
<li><code>&lt;C-r&gt;=</code> to access expression register</li>
</ul></li>
<li>some <strong>shortcuts</strong> can be used when in command-line mode:
<ul>
<li>command-line mode is like insert mode</li>
<li><code>&lt;C-u&gt;</code>, <code>&lt;C-w&gt;</code> and <code>&lt;C-r&gt;{register}</code> work</li>
<li>escape command-line mode using <code>&lt;Esc&gt;</code></li>
</ul></li>
</ul>
<h4 id="most-useful-ex-commands-to-edit-text">Most Useful Ex Commands to Edit Text</h4>
<p><strong>range</strong> is a pair of <strong>address</strong>, which is either <strong>line number</strong>, <strong>mark</strong> or <strong>pattern</strong></p>
<ul>
<li><code>:[range]delete [x]</code>: delete specified lines (into register <code>x</code>)</li>
<li><code>:[range]yank [x]</code>: yank specified lines (into register <code>x</code>)</li>
<li><code>:[line]put [x]</code>: put content of register <code>x</code> after <code>line</code></li>
<li><code>:[range]copy {address}</code>: copy content in specified lines, put them to <code>address</code></li>
<li><code>:[range]move {address}</code>: cut content in specified lines, put them to <code>address</code></li>
<li><code>:[range]join</code>: join specified lines</li>
<li><code>:[range]normal {commands}</code>: execute normal mode <code>commands</code> on specified lines</li>
<li><code>:[range]substitute/{pattern}/{string}/[flags]</code>: replace <code>pattern</code> with <code>string</code> in specified lines</li>
<li><code>:[range]global/{pattern}/[command]</code>: execute ex <code>command</code> on specified lines matching <code>pattern</code></li>
<li><code>:[range]print</code>: print specified lines (in prompt)</li>
</ul>
<h5 id="shorthand-version">Shorthand Version</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">full command</th>
<th style="text-align: center;">short command</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>copy</code></td>
<td style="text-align: center;"><code>co</code>, <code>t</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>move</code></td>
<td style="text-align: center;"><code>m</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>normal</code></td>
<td style="text-align: center;"><code>norm</code></td>
</tr>
</tbody>
</table>
<h4 id="specifying-range">Specifying Range</h4>
<h5 id="by-line-number">By Line Number</h5>
<p>when using <strong>line number</strong>, the range format is <code>{line-start},{line-end}</code>:</p>
<ul>
<li>use line number for <code>{line-start}</code> and <code>{line-end}</code></li>
<li>use <code>1</code> for the first line</li>
<li>use <code>0</code> for the virtual line before the first line
<ul>
<li>this is useful for moving text (move to the top of the file)</li>
</ul></li>
<li>use <code>$</code> for the last line</li>
<li>use <code>.</code> for the current line</li>
<li>use <code>%</code> to refer to the whole text, i.e. <code>1,$</code></li>
<li>use <code>'&lt;</code> to refer to the first line of the most recent selection</li>
<li>use <code>'&gt;</code> to refer to the last line of the most recent selection</li>
</ul>
<h5 id="by-visual-selection">By Visual Selection</h5>
<ul>
<li>“by visual selection” is a special form of “by line number”</li>
<li>enter line-wise visual mode, select lines, press <code>:</code></li>
<li>the prompt will be filled with <code>:'&lt;,'&gt;</code> and you can modify it now</li>
<li><code>'&lt;</code> and <code>'&gt;</code> also work after leaving visual mode (refer to the most recent one)</li>
</ul>
<h5 id="by-pattern">By Pattern</h5>
<ul>
<li>“by pattern” is a special form of “by line number”</li>
<li><code>{line-start}</code> and <code>{line-end}</code> are patterns now, usually presented as <code>/..../</code></li>
<li><em>e.g.</em> <code>/&lt;html&gt;/,/&lt;\/html&gt;/</code> is a valid range:
<ul>
<li>the first line should match <code>&lt;html&gt;</code></li>
<li>the last line should match <code>&lt;\/html&gt;</code></li>
<li>don’t need to care how many lines are in between</li>
</ul></li>
</ul>
<h5 id="by-mark">By Mark</h5>
<ul>
<li>like “by pattern”, use <code>'m</code> for line that containing mark <code>m</code></li>
</ul>
<h5 id="by-offset">By Offset</h5>
<ul>
<li>range bound (line number, visual selection or pattern) can be modified by number</li>
<li>use <code>+n</code> and <code>-n</code> after the bound (if <code>n</code> is omitted, default to <span class="math inline">1</span>)</li>
<li><em>e.g.</em> <code>.,.+3p</code> will print four lines from current line</li>
<li><em>e.g.</em> <code>/&lt;html&gt;/+1,/&lt;\/html&gt;/-1p</code> will print content inside the <code>html</code> tag</li>
</ul>
<h4 id="use-normal-mode-commands">Use Normal Mode Commands</h4>
<ul>
<li>recall syntax: <code>[range]normal {command}</code>: run <code>command</code> on lines specified by <code>range</code></li>
<li>when command is executed, the cursor will be at the beginning of that line</li>
<li><em>e.g.</em> append semicolon to five lines from current line: <code>.,.+4normal A;</code></li>
<li><em>e.g.</em> comment all the file: <code>%normal i//</code></li>
<li>useful when combined with dot command</li>
</ul>
<h4 id="repeat-last-ex-command">Repeat Last Ex Command</h4>
<ul>
<li>dot command won’t replay command line mode modifications</li>
<li>use normal command <code>.</code> to replay last normal command</li>
<li>use normal command <code>@:</code> to replay last Ex command
<ul>
<li>this is playing macro in <code>:</code> which stores last Ex command</li>
<li>use <code>@@</code> to replay last macro subsquently</li>
</ul></li>
<li><strong>best practice</strong>: repeat Ex comamnds like <code>:bnext</code>
<ul>
<li>for the first time, enter <code>:bnext</code></li>
<li>now you can use <code>@:</code> and then <code>@@</code> to change to next buffer</li>
<li>if you want to revert, use <code>&lt;C-o&gt;</code> as it doesn’t change the most recent used Ex command</li>
</ul></li>
<li><strong>best practice</strong>: repeat Ex comamnds like <code>:.d</code>
<ul>
<li>for the first time, enter <code>:.d</code></li>
<li>now you can use <code>@:</code> and then <code>@@</code> to delete current line</li>
<li>if you want to revert, use <code>u</code> as it doesn’t change the most recent used Ex command</li>
</ul></li>
</ul>
<h4 id="editing-the-command-in-command-line-mode">Editing the Command in command Line Mode</h4>
<ul>
<li>for tab completion:
<ul>
<li>use <code>&lt;C-d&gt;</code> to show auto completion options</li>
<li>use <code>&lt;Tab&gt;</code> and <code>&lt;S-Tab&gt;</code> to cycle through them</li>
</ul></li>
<li>for inserting content from buffer
<ul>
<li>use <code>&lt;C-r&gt;&lt;C-w&gt;</code> to insert the word under cursor into command line</li>
<li>use <code>&lt;C-r&gt;&lt;C-a&gt;</code> to insert the WORD under cursor into command line</li>
</ul></li>
<li>for scrolling in the recent command list (may be <code>:</code> or <code>/</code> or others)
<ul>
<li>use <code>&lt;Up&gt;</code> and <code>&lt;Down&gt;</code> to scroll</li>
<li>type then scroll will filter by prefix</li>
</ul></li>
<li>use <strong>command line window</strong> to bring/execute history commands
<ul>
<li>summon the command line window
<ul>
<li>in normal mode, <code>q/</code> summons search history</li>
<li>in normal mode, <code>q:</code> summons Ex command history</li>
<li>in command line mode, <code>&lt;C-f&gt;</code> summons Ex command history</li>
</ul></li>
<li>content in the command line window can be directly modified</li>
<li>pressing <code>&lt;CR&gt;</code> on item will <strong>execute it</strong></li>
<li>pressing <code>&lt;C-c&gt;</code> on item can <strong>quit command line window and edit</strong></li>
</ul></li>
</ul>
<h4 id="using-shell-in-vim">Using Shell in Vim</h4>
<ul>
<li>run one-shot command, <strong>view output</strong>:
<ul>
<li>use <code>:!{command}</code> to execute a shell <code>command</code></li>
<li><code>%</code> symbol represets current file</li>
<li><em>e.g.</em> <code>:!ls ~</code> will list home directory</li>
<li><em>e.g.</em> <code>:!python %</code> will execute current file</li>
</ul></li>
<li>run one-shot command, <strong>read output</strong>:
<ul>
<li>use <code>:read !{command}</code> to execute a shell <code>command</code></li>
<li>output will be put into current buffer</li>
</ul></li>
<li>run one-shot command, <strong>provide input</strong>:
<ul>
<li>use <code>:[range]write !{command}</code> to execute a shell <code>command</code></li>
<li>content specifie by <code>range</code> will be the standard input</li>
<li>if <code>range</code> is omitted, the whole buffer will be input</li>
<li><em>e.g.</em> <code>:write !wc -l</code> shows number of lines of current file</li>
<li><em>e.g.</em> <code>:write !python</code> executes the current python script</li>
</ul></li>
<li>run one-shot command, <strong>use as a filter</strong>:
<ul>
<li>use <code>:{range}!{command}</code> to execute a shell <code>command</code></li>
<li>lines specified by <code>range</code> will be used as input, replaced by output</li>
<li>in normal mode, use <code>!{motion}</code> to quickly select a range that will be filtered</li>
</ul></li>
<li>open a <strong>real shell</strong>:
<ul>
<li>use <code>:shell</code> to start a new shell (attached to current vim process)
<ul>
<li>allows you to execute multiple complex commands</li>
</ul></li>
<li>alternatively, if using shell with job control
<ul>
<li>use <code>&lt;C-z&gt;</code> to suspend current vim process</li>
<li>use <code>fg</code> in shell to bring it to foreground</li>
</ul></li>
</ul></li>
</ul>
<h4 id="run-multiple-ex-commands-as-batch">Run Multiple Ex Commands as Batch</h4>
<ul>
<li>multiple Ex commands can be <strong>saved</strong> into a file (as a script)
<ul>
<li>typical extension is <code>vim</code></li>
<li>don’t add the semicolon in command line mode</li>
</ul></li>
<li>the script can be executed by using <code>:source</code>
<ul>
<li>content in the script will be executed line by line</li>
</ul></li>
</ul>
<p>to change multiple files with one script:</p>
<ol type="1">
<li>saved the script (e.g. as <code>batch.vim</code>)</li>
<li>open multiple files with vim (e.g. <code>vim *.html</code>, use the wildcard to open multiple files)</li>
<li>(optional) check opened files by using <code>:args</code> (note this is not command line arguments)</li>
<li>perform the script on each file (e.g. <code>:argdo source batch.vim</code>)</li>
</ol>
<h3 id="others">Others</h3>
<h4 id="operator-pending-mode">Operator-Pending Mode</h4>
<p>operator-pending mode is a mode after you enter an operator, and befire you enter a motion</p>
<p>if use OP for operator-pending mode, in a state machine view:</p>
<pre class="plain"><code>NORMAL --(operator)--&gt; OP --(motion)--&gt; NORMAL
NORMAL --(operator)--&gt; OP --(&lt;ESC&gt;)---&gt; NORMAL (escape this mode by &lt;ESC&gt;)</code></pre>
<p>take <code>dw</code> for an example:</p>
<pre class="plain"><code>dw: NORMAL --(d)--&gt; OP --(w)--&gt; NORMAL</code></pre>
<ul>
<li>decouples operator and motion</li>
<li>enables defining new operators and motions</li>
</ul>
<p>distinguish it with namespaces, for example:</p>
<p><code>g</code> in <code>gu</code> (change to lowercase) is not an operator (<code>gu</code> is the operator, <code>g</code> is the namespace prefix)</p>
<h2 id="files">Files</h2>
<h3 id="basic-concepts">Basic Concepts</h3>
<ul>
<li><strong><em>file</em></strong>: a file is a file (which is stored on a disk)</li>
<li><strong><em>buffer</em></strong>: a buffer is an in-memory representation of a file</li>
<li><strong><em>window</em></strong>: a viewport onto a buffer</li>
<li><strong><em>tab</em></strong>: a tab page is a collection of windows</li>
<li><strong><em>buffer list</em></strong>: a list of buffers</li>
<li><strong><em>argument list</em></strong>: a argument list is a collection of buffers</li>
</ul>
<h3 id="buffer-list-and-argument-list">Buffer List and Argument List</h3>
<h4 id="buffer-list">Buffer List</h4>
<ul>
<li>use <code>:ls</code> to <strong>view</strong> the buffer list when opening multiple files</li>
<li><strong>annotations</strong> in buffer list (see <code>:help :buffers</code> for all)
<ul>
<li>a number will be assigned to each buffer, shown at first</li>
<li><code>%</code> means buffer in current window</li>
<li><code>#</code> means alternate</li>
<li><code>+</code> means this buffer has been modified but not saved</li>
<li><code>a</code> means this buffer is currently visible (active)</li>
<li><code>h</code> means this buffer is hidden (modified but not saved, not active)</li>
</ul></li>
<li><strong>switching</strong> between buffers
<ul>
<li>use <code>:bnext</code> / <code>:bprev</code> to switch to next / previous buffer</li>
<li>use <code>:bfirst</code> / <code>:blast</code> to jump to the first / last buffer</li>
<li>use <code>&lt;C-^&gt;</code> to switch to alternate buffer (back and forth)</li>
<li>use <code>:buffer {n}</code> to jump to buffer with number <code>n</code></li>
<li>use <code>:buffer {name}</code> to jump to buffer whose path is uniquely determined by <code>name</code></li>
</ul></li>
<li>use <code>:bufdo {command}</code> to <strong>perform Ex command</strong> on all buffers
<ul>
<li>consider <code>:argdo</code> instead, more practical</li>
</ul></li>
<li>to <strong>delete</strong> buffers
<ul>
<li>use <code>:bdelete N1 N2 N3</code> to delete buffer with number <code>N1</code>, <code>N2</code> and <code>N3</code></li>
<li>use <code>:N,M bdelete</code> to delete buffer from <code>N</code> to <code>M</code></li>
</ul></li>
</ul>
<h4 id="argument-list">Argument List</h4>
<ul>
<li>after launching vim, the argument list is the files opened
<ul>
<li>but may be changed later</li>
</ul></li>
<li>you can only have one argument list</li>
<li>use <code>:args</code> to <strong>view</strong> the argument list</li>
<li><strong>annotations</strong> in argument list
<ul>
<li>current active file will be surrounded in <code>[</code> and <code>]</code></li>
</ul></li>
<li>to <strong>populate</strong> the argument list (see <code>:h cmdline-special</code> for all)
<ul>
<li>specify by <strong>name</strong>: <code>:args {name-1} {name-2} {name-3}</code></li>
<li>specify by <strong>glob</strong>: <code>:args {glob-1} {glob-2} {glob-3}</code></li>
<li>specify by <strong>backtick expansion</strong>: this will execute a command, use it output, e.g. <code>:args `cat chapters`</code></li>
</ul></li>
<li>to <strong>change</strong> the argument list, use commands like populating</li>
<li>to <strong>switching</strong> between buffers in argument list
<ul>
<li>use <code>:next</code> / <code>:prev</code> to switch to next / previous buffer in argument list</li>
<li>use <code>:first</code> / <code>:last</code> to jump to the first / last buffer in argument list</li>
</ul></li>
<li>use <code>:argdo {command}</code> to <strong>execute Ex command</strong> on all buffers in argument list</li>
</ul>
<h4 id="best-practices-1">Best Practices</h4>
<ul>
<li>use buffer list to manage all opened files, often messy</li>
<li>use argument list to manage files that should be kept tidy</li>
</ul>
<h3 id="hidden-buffer">Hidden Buffer</h3>
<ul>
<li>a hidden buffer is a modified but unsaved buffer</li>
<li>by default, vim disallows unfocusing buffers if the it is dirty</li>
<li>if you insist, often need to append <code>!</code> to commands
<ul>
<li><em>e.g.</em> switch to next buffer without saving current: <code>:bnext!</code></li>
<li><em>e.g.</em> quit without saving: <code>:quit!</code></li>
<li><em>e.g.</em> reload file without saving: <code>:edit!</code></li>
</ul></li>
<li>if there are multiple hidden buffers:
<ul>
<li><em>e.g.</em> quit all without saving any: <code>:qall!</code></li>
<li><em>e.g.</em> write: <code>:wall</code></li>
</ul></li>
</ul>
<p>to use <code>argdo</code> or <code>bufdo</code> which modify files:</p>
<ol type="1">
<li>enable ‘hidden’ settings so vim allows unfocusing without saving</li>
<li>run <code>:argdo {command}</code> or <code>:bufdo {command}</code></li>
<li>now there are many affected buffers being hidden</li>
<li>save buffers
<ul>
<li>to <strong>inspect and modify each</strong>, use <code>:wn</code> repeatly</li>
<li>to <strong>save all without inspecting</strong>, use <code>:wall</code> or <code>:argdo write</code> or <code>:bufdo write</code></li>
</ul></li>
</ol>
<h3 id="split-windows">Split Windows</h3>
<h4 id="buffer-and-window">Buffer and Window</h4>
<ul>
<li>a buffer can be presented in different windows</li>
<li>a window can contain different buffers</li>
</ul>
<h4 id="operating-windows">Operating Windows</h4>
<ul>
<li>divide windows to <strong>create</strong> new window
<ul>
<li>divide <strong>horizontally</strong>: <code>&lt;C-w&gt;s</code> or <code>:split</code>, divide to up and down</li>
<li>divide <strong>vertically</strong>: <code>&lt;C-w&gt;v</code> or <code>:vsplit</code>, divide to left and right</li>
</ul></li>
<li><strong>loading</strong> file
<ul>
<li>after dividing, the newly created window and the original window share a buffer</li>
<li>use <code>:edit {filename}</code> to load a file</li>
<li>use <code>:split {filename}</code> or <code>:vsplit {filename}</code> to divide and edit with one command</li>
</ul></li>
<li>change <strong>focus</strong> between different windows
<ul>
<li>use <code>&lt;C-w&gt;w</code> to cycle between windows</li>
<li>use <code>&lt;C-w&gt;h</code>, <code>&lt;C-w&gt;j</code>, <code>&lt;C-w&gt;k</code>, <code>&lt;C-w&gt;l</code> to navigate to a certain direction</li>
<li>when pressing the second key, the control key can still be hold, e.g. <code>&lt;C-w&gt;&lt;C-w&gt;</code> to cycle between windows</li>
</ul></li>
<li><strong>closing</strong> windows
<ul>
<li>Ex command <code>:close</code> or normal command <code>&lt;C-w&gt;c</code> to close current</li>
<li>Ex command <code>:only</code> or normal command <code>&lt;C-w&gt;o</code> to only keep current (close all others)</li>
</ul></li>
<li><strong>resizing</strong> windows
<ul>
<li><strong>maximize</strong>: <code>&lt;C-w&gt;_</code> to maximize height, <code>&lt;C-w&gt;|</code> to maximize width</li>
<li><strong>set to value</strong>: <code>[N]&lt;C-w&gt;_</code> set height to <code>N</code> rows, <code>[N]&lt;C-w&gt;|</code> set width to <code>N</code> rows</li>
<li><strong>equalize</strong> all windows: <code>&lt;C-w&gt;=</code></li>
</ul></li>
<li>to change current directory of current window, use <code>:lcd {path}</code></li>
</ul>
<h3 id="tab-pages">Tab Pages</h3>
<h4 id="tab-page-and-windows">Tab Page and Windows</h4>
<ul>
<li>a tab page can have multiple windows</li>
<li>use <code>:windo {command}</code> to perform command on all windows on a page</li>
</ul>
<h4 id="operating-tab-pages">Operating Tab Pages</h4>
<ul>
<li>to <strong>create</strong> a new tab page
<ul>
<li>use <code>:tabedit</code> to create an empty tab</li>
<li>use <code>:tabedit {filename}</code> to create a tab editing file</li>
<li>use <code>&lt;C-w&gt;T</code> to move current window to a new tab</li>
</ul></li>
<li>to <strong>close</strong> a tab page
<ul>
<li>use <code>:tabclose</code> to close current tab (no matter how many windows are there)</li>
<li>use <code>:tabonly</code> to close all other tabs</li>
<li>if current tab has only one window and it is closed, the tab will be closed</li>
</ul></li>
<li>to change <strong>focus</strong> between tabs
<ul>
<li>use <code>:tabnext</code> or <code>gt</code> to switch to next tab (abbr <code>:tabn</code>)</li>
<li>use <code>:tabprevious</code> or <code>gT</code> to switch to previous tab (abbr <code>:tabp</code>)</li>
<li>use <code>:tabnext {N}</code> or <code>{N}gt</code> to switch to tab <code>N</code>, count from 1 (abbr <code>:tabn</code>)</li>
</ul></li>
<li>to <strong>rearrange</strong> tabs
<ul>
<li>use <code>:tabmove</code> to move current tab to the end</li>
<li>use <code>:tabmove 0</code> to move current tab to the front</li>
<li>use <code>:tabmove {N}</code> to move current tab after tab numbered with <code>N</code></li>
</ul></li>
</ul>
<h3 id="opening-and-saving-files">Opening and Saving Files</h3>
<ul>
<li>open files with <code>:edit</code> <strong>by pathname</strong>
<ul>
<li>use <code>:edit {filename}</code> to open a file, filename is relative to current working directory</li>
<li>when typing filename, use <code>%</code> to refer to current file</li>
<li>when typing filename, use <code>%:h</code> to refer to the directory containing current file</li>
<li><code>%</code> and <code>%:h</code> can be expanded with <code>&lt;Tab&gt;</code></li>
</ul></li>
<li>open files with <code>:find</code> <strong>by partial filename</strong>
<ul>
<li>vim will search the file under paths (which can be shown with <code>:set path?</code>)
<ul>
<li><code>.</code> represents directory of current file</li>
<li>empty string represents working directory</li>
</ul></li>
<li>to use <code>:find</code>, modify path first like <code>:set path+=~/Workspace/My-Project</code></li>
<li>use <code>:find {partial-filename}</code> to open file, use <code>&lt;Tab&gt;</code> to autocomplete</li>
</ul></li>
<li>save files to <strong>nonexistent directories</strong>
<ul>
<li>before saving, use <code>:!mkdir -p %:h</code> to create the directories</li>
<li>then you can save</li>
</ul></li>
<li>save files <strong>as super user</strong>
<ul>
<li>case: edit a file without write permission, but can use sudo</li>
<li>execute <code>:w !sudo tee % &gt;/dev/null</code> to save as super user</li>
<li>how does it work
<ul>
<li><code>:w !{command}</code> invoke shell <code>command</code> with current buffer as standard input</li>
<li><code>%</code> will be expanded to full file path by vim in command line mode</li>
<li><code>sudo tee full-path-to-file &gt;/dev/null</code> will read from standard input, write to <code>full-path-to-file</code> and standard output</li>
<li>standard output is redirected to <code>/dev/null</code></li>
</ul></li>
</ul></li>
</ul>
<h3 id="viewing-folders">Viewing Folders</h3>
<ul>
<li>vim has a built-in plugin called netrw to view folders</li>
<li>when opening vim for a directory, netrw will show up
<ul>
<li><em>e.g.</em> start vim with a directory: <code>vim ~/Temp</code></li>
<li><em>e.g.</em> use edit command in vim: <code>:edit ~/Temp</code></li>
</ul></li>
<li>some useful commands
<ul>
<li><code>:edit .</code> or <code>:e .</code> to open working directory</li>
<li><code>:edit %:h</code> or <code>:e %:h</code> to open directory containing current buffer</li>
<li><code>:Expolor</code> or <code>:E</code> to open directory containing current buffer (from netrw plugin)</li>
<li><code>:Sexplore</code> and <code>:Vexplore</code> to split and open directory</li>
</ul></li>
<li>note netrw can do many other things like a file manager
<ul>
<li>can manage a filesystem through network</li>
</ul></li>
</ul>
<h2 id="getting-around-faster">Getting Around Faster</h2>
<h3 id="character-and-line-wise-motion">Character and Line-Wise Motion</h3>
<ul>
<li>vim distinguishes real lines and display lines</li>
<li>a <strong>real line</strong> is a line ended with line break
<ul>
<li>use <code>j</code>, <code>k</code> to move to next / previous real line</li>
<li>use <code>0</code>, <code>^</code>, <code>$</code> to move to the first character / first nonblank space character / last character of current real line</li>
</ul></li>
<li>a <strong>display line</strong> is a part of a real line (caused by wrapping)
<ul>
<li>use <code>gj</code>, <code>gk</code> to move to next / previous display line</li>
<li>use <code>g0</code>, <code>g^</code>, <code>g$</code> to move to the first character / first nonblank space character / last character of current display line</li>
</ul></li>
<li>motions related display lines are prefixed with <code>g</code></li>
</ul>
<h3 id="word-wise-motion">Word-Wise Motion</h3>
<ul>
<li>vim distinguishes words and WORDs</li>
<li>a <strong>word</strong> can be a sequence of letters, digits, and underscores</li>
<li>or, a <strong>word</strong> can be a sequence of other nonblank characters (excluding letters, digits, and underscores)</li>
<li>a <strong>WORD</strong> can be a sequence of nonblank characters</li>
<li>motions about <strong>word</strong> don’t require <code>&lt;SHIFT&gt;</code>
<ul>
<li>use <code>w</code> and <code>b</code> to move to the begining of next / previous word</li>
<li>use <code>e</code> and <code>ge</code> to move to the ending of next / previous word</li>
</ul></li>
<li>motions about <strong>WORD</strong> require <code>&lt;SHIFT&gt;</code>
<ul>
<li>use <code>W</code> and <code>B</code> to move to the begining of next / previous WORD</li>
<li>use <code>E</code> and <code>GE</code> to move to the ending of next / previous WORD</li>
</ul></li>
</ul>
<h3 id="motion-with-searching">Motion with Searching</h3>
<h4 id="character-based-searching">Character-Based Searching</h4>
<ul>
<li>one of the <strong>fastest</strong> way for moving in vim</li>
<li>use <code>f{char}</code> to find <code>char</code> forward, <code>F{char}</code> to find <code>char</code> backward, in current line</li>
<li>use <code>t{char}</code> to find till <code>char</code> forward, <code>T{char}</code> to find till <code>char</code> backward, in current line</li>
<li>use <code>;</code> to repeat last character search, <code>,</code> to reverse last character search</li>
<li><strong>best practice</strong>: use <code>f</code> and <code>F</code> in normal mode, use <code>t</code> and <code>T</code> in operator-pending mode</li>
<li><strong>best practice</strong>: search for characters with low frequency of occurence</li>
</ul>
<h4 id="pattern-based-searching">Pattern-Based Searching</h4>
<ul>
<li><strong>not only in normal mode</strong>: pattern-based searching can alse be used in visual mode and operator-pending mode</li>
<li>pattern-based searching, <code>/{pattern}&lt;CR&gt;</code>, is also a motion</li>
<li><em>e.g.</em> use <code>d/hello&lt;CR&gt;</code> to delete from current cursor to the first occurrence of the word “hello”</li>
<li><em>e.g.</em> use <code>/hello&lt;CR&gt;</code> to move the free end of selection to the word “hello” in visual mode</li>
</ul>
<h3 id="text-objects">Text-Objects</h3>
<ul>
<li>text objects define <strong>regions of text by common structure</strong></li>
<li>text objects are not motions, but can be used in visual mode and operator-pending mode
<ul>
<li><em>e.g.</em> <code>ci"</code> to change content inside double quotes</li>
</ul></li>
<li>each text object contains two parts
<ul>
<li><code>i</code> for inside (excluding delimeters) and <code>a</code> for around (including delimeters)</li>
<li>a character representing the delimeter</li>
</ul></li>
<li>commly used delimeters
<ul>
<li>delimited text objects
<ul>
<li><code>(</code> or <code>)</code>: parentheses</li>
<li><code>[</code> or <code>]</code>: brackets</li>
<li><code>{</code> or <code>}</code>: braces</li>
<li><code>&lt;</code> or <code>&gt;</code>: angle brackets</li>
<li><code>'</code>: single quotes</li>
<li><code>"</code>: double quotes</li>
<li><code>`</code>: backticks</li>
<li><code>t</code>: xml tags</li>
</ul></li>
<li>bounded text objects
<ul>
<li><code>w</code> for word</li>
<li><code>W</code> for WORD</li>
<li><code>s</code> for sentence</li>
<li><code>p</code> for paragraph</li>
</ul></li>
</ul></li>
<li>paired delimeters are equivalent, e.g. <code>i(</code> and <code>i)</code> are the same</li>
<li>when delimeters are word, WORD, sentence
<ul>
<li><code>i</code> only select text, not including spaces</li>
<li><code>a</code> also includes spaces</li>
</ul></li>
<li>when delimeters are paragraph
<ul>
<li><code>i</code> only select current paragraph without blank lines</li>
<li><code>a</code> also includes blank lines</li>
</ul></li>
<li><strong>best practice</strong>: for bounded text objects
<ul>
<li><code>i</code> works well for changing (e.g. <code>ciw</code>)</li>
<li><code>a</code> works well for deleting (e.g. <code>dap</code>)</li>
</ul></li>
</ul>
<h3 id="marking-and-jumping">Marking and Jumping</h3>
<h4 id="mark-manully">Mark Manully</h4>
<ul>
<li>use <code>m[a-z]</code> to mark (only take effects in current buffer)</li>
<li>use <code>m[A-Z]</code> to mark (take effects anywhere)</li>
<li>use <code>'m</code> to jump to a mark, cursor positioned at first nonblank character</li>
<li>use <code>`m</code> to jump to a mark, cursor positioned at the column when marking</li>
<li><code>'m</code> can be used in Ex commands as a line boundary</li>
</ul>
<h4 id="automatic-marks">Automatic Marks</h4>
<p>some marks are automatically generated and maintained:</p>
<ul>
<li><code>`</code>: position before last jump</li>
<li><code>.</code>: position of last change</li>
<li><code>^</code>: position of last insertion</li>
<li><code>[</code>: start of last change / yank</li>
<li><code>]</code>: end of last change / yank</li>
<li><code>&lt;</code>: start of last visual selection</li>
<li><code>&gt;</code>: end of last visual selection</li>
</ul>
<h3 id="jump-between-brackets-and-others">Jump Between Brackets (and Others)</h3>
<ul>
<li>use <code>%</code> to jump to matching brackets (or parenthesis, braces, angel brackets)</li>
<li><strong>best practice</strong>: if you want to change a pair of brackets with <code>%</code>
<ol type="1">
<li>go to one bracket</li>
<li>jump to the matched one with <code>%</code></li>
<li>change this bracket</li>
<li>jump back with <code>`</code> <code>`</code> (two backquotes, hard to type in markdown)</li>
<li>change this bracket</li>
</ol></li>
</ul>
<h3 id="jump-list-and-change-list">Jump List and Change List</h3>
<h4 id="traverse-the-jump-list">Traverse the Jump List</h4>
<ul>
<li><strong>jumps</strong> are long-ranged</li>
<li>use <code>:jumps</code> to view the jump list</li>
<li>each <strong>window</strong> has its own jump list</li>
<li>use <code>&lt;C-o&gt;</code> to step backward in the jump list</li>
<li>use <code>&lt;C-i&gt;</code> to step forward in the jump list</li>
</ul>
<p>some motions and actions are considered as jump by vim:</p>
<table>
<thead>
<tr class="header">
<th>Command</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[count]G</code></td>
<td>jump to line <code>count</code></td>
</tr>
<tr class="even">
<td><code>/[pattern]&lt;CR&gt;</code> / <code>?[pattern]&lt;CR&gt;</code> / <code>n</code> / <code>N</code></td>
<td>search and navigate</td>
</tr>
<tr class="odd">
<td><code>%</code></td>
<td>jump to matching parenthesis</td>
</tr>
<tr class="even">
<td><code>(</code> / <code>)</code></td>
<td>jump to previous / next sentence</td>
</tr>
<tr class="odd">
<td><code>{</code> / <code>}</code></td>
<td>jump to previous / next paragraph</td>
</tr>
<tr class="even">
<td><code>H</code> / <code>M</code> / <code>L</code></td>
<td>jump to high / middle / low part of screen</td>
</tr>
<tr class="odd">
<td><code>gf</code></td>
<td>jump to file under cursor</td>
</tr>
<tr class="even">
<td><code>&lt;C-]&gt;</code></td>
<td>jump to definition of keyword under cursor</td>
</tr>
<tr class="odd">
<td><code>'{mark}</code> / <code>`{mark}</code></td>
<td>jump to mark</td>
</tr>
</tbody>
</table>
<h4 id="traverse-the-change-list">Traverse the Change List</h4>
<ul>
<li>vim maintains changes in each buffer in the <strong>change list</strong></li>
<li>use <code>:changes</code> to view the change list</li>
<li>each <strong>buffer</strong> has its own change list</li>
<li>use <code>g;</code> to step backward in the change list</li>
<li>use <code>g,</code> to step forward in the change list</li>
<li>(recall) use <code>.</code> mark for last modification, <code>^</code> for last insertion</li>
<li>use <code>gi</code> to step to the location of last insertion, and change to insert mode</li>
</ul>
<h3 id="jump-between-files">Jump Between Files</h3>
<h4 id="jump-to-file-under-cursor">Jump to File under Cursor</h4>
<ul>
<li>use <code>gf</code> to jump to file under cursor (memonic: goto file)</li>
<li>you can specify extensions if the filename doesn’t include one by <code>suffixesadd</code> option
<ul>
<li><em>e.g.</em> <code>:set suffixesadd+=.py</code> so vim can jump to <code>hello.py</code> on word <code>hello</code></li>
</ul></li>
<li>vim will search for files according to <code>path</code>
<ul>
<li><strong>view</strong> path: <code>:set path?</code></li>
<li><strong>modify</strong> path: <code>:set path+=path-to-directory</code></li>
</ul></li>
</ul>
<h4 id="jump-to-files-with-global-marks">Jump to Files with Global Marks</h4>
<p><strong>recall</strong>:</p>
<ul>
<li>use <code>m[A-Z]</code> to set a global mark</li>
<li>use <code>'[A-Z]</code> or <code>`[A-Z]</code> to jump back</li>
</ul>
<p><strong>note</strong>:</p>
<ul>
<li>global marks are persistent across edit sessions</li>
<li>use global mark whenevery you think you will come back to this file later</li>
</ul>
<h2 id="registers">Registers</h2>
<h3 id="how-to-use-registers">How to Use Registers</h3>
<ul>
<li><code>x</code>, <code>s</code>, <code>d</code>, <code>c</code>, <code>y</code>, <code>p</code> and their uppercase friends will interact with registers</li>
<li>use <code>:reg</code> to inspect registers</li>
<li>prefix with <code>"{register-name}</code> to <strong>specify</strong> a register
<ul>
<li><em>e.g.</em> <code>"ax</code> will delete a character and save it to register <code>a</code></li>
<li><em>e.g.</em> <code>"bP</code> will put content from register <code>b</code> before cursor</li>
</ul></li>
<li>delete, yank and put will manipulate <strong>unnamed register</strong> by default, enabling:
<ul>
<li><em>e.g.</em> transpose two characters: <code>xp</code></li>
<li><em>e.g.</em> transpose two lines: <code>ddp</code></li>
<li><em>e.g.</em> duplicate lines: <code>yyp</code></li>
</ul></li>
</ul>
<h3 id="special-registers">Special Registers</h3>
<ul>
<li>some useful special registers
<ul>
<li>explicitly use <strong>default register</strong>: <code>"</code></li>
<li><strong>black hole register</strong>, can’t read from it (like <code>/dev/null</code>): <code>_</code>
<ul>
<li>use if to delete something without putting it into any register</li>
<li><em>e.g.</em> if delete to <code>_</code>, unnamed register won’t change</li>
</ul></li>
<li><strong>yank register</strong>, storing content of you last yanked: <code>0</code></li>
<li><strong>numbered registers</strong>, from <code>1</code> to <code>9</code> (newest to oldest), storing recently yanked/deleted content</li>
<li><strong>named registers</strong>, explicitly used by users, from <code>a</code> to <code>z</code>
<ul>
<li>when referred to as <code>a</code> to <code>z</code>, modification overwrites register content</li>
<li>when referred to as <code>A</code> to <code>Z</code>, modification appends to register content</li>
</ul></li>
<li><strong>system clipboard</strong>, <code>+</code>, can be used to interact with external programs</li>
<li><strong>system primary</strong>, <code>*</code>, on Linux X11, this is the most recently selected text</li>
<li><strong>expression register</strong>, <code>=</code>, can be used for calculation and scripting</li>
</ul></li>
<li>some registers are read only, including:
<ul>
<li><strong>name of current file</strong>, <code>%</code></li>
<li><strong>name of alternate file</strong>, <code>#</code></li>
<li><strong>last inserted text</strong>, <code>.</code></li>
<li><strong>last Ex command</strong>, <code>:</code></li>
<li><strong>last search pattern</strong>, <code>/</code></li>
</ul></li>
</ul>
<h3 id="pasting-from-registers">Pasting from Registers</h3>
<h4 id="in-visual-mode">In Visual Mode</h4>
<ul>
<li>when use <code>p</code> in visual mode, selected text will be overwritten</li>
<li>unnamed register will be set (this behaves like a swapping)</li>
</ul>
<h4 id="in-insert-mode">In Insert Mode</h4>
<ul>
<li>use <code>&lt;C-r&gt;{register}</code> to paste text from <code>register</code>
<ul>
<li><em>e.g.</em> use <code>&lt;C-r&gt;"</code> to paste from unnamed register</li>
</ul></li>
</ul>
<h4 id="in-normal-mode">In Normal Mode</h4>
<ul>
<li>registers can be <strong>line-wise</strong> or <strong>character-wise</strong> (depending on how does it content come from)
<ul>
<li><em>e.g.</em> if the content is from <code>x</code>, it’s character-wise</li>
<li><em>e.g.</em> if the content is from <code>dd</code>, it’s line-wise</li>
</ul></li>
<li>when line-wise
<ul>
<li>use <code>p</code> to put line below current line</li>
<li>use <code>P</code> to put line above current line</li>
</ul></li>
<li>when character-wise
<ul>
<li>use <code>p</code> to put content after cursor</li>
<li>use <code>P</code> to put content before cursor</li>
</ul></li>
<li><code>:put {register}</code> will always perform line-wise putting</li>
<li><code>gp</code> and <code>gP</code> behave like <code>p</code> and <code>P</code>, but will put cursor at the past-end of pasted content</li>
</ul>
<h2 id="macros">Macros</h2>
<h3 id="introduction-to-macros">Introduction to Macros</h3>
<ul>
<li>macros allow <strong>recording</strong> and <strong>replaying</strong> sequence of changes</li>
<li><strong>recording</strong>: use <code>q{register}</code> to start recording and save to <code>register</code>, use <code>q</code> to stop
<ul>
<li>all changes will be recorded, including motions in normal mode</li>
<li>you can inspect the macro using <code>:reg {register}</code></li>
</ul></li>
<li><strong>play back</strong>: use <code>@{register}</code> to play back macros in <code>register</code>
<ul>
<li>use <code>@@</code> to replay the most recently used macro</li>
<li>prefix with a number <code>n</code> to repeat <code>n</code> times, e.g. <code>10@@</code> or <code>10@a</code></li>
<li>vim will replay the macro blindly</li>
</ul></li>
</ul>
<h3 id="best-practices-to-use-macros">Best Practices to Use Macros</h3>
<p>follow these practices to reduce unexpected results when using macros:</p>
<ul>
<li>before doing anything, <strong>normalize cursor position</strong>
<ul>
<li><em>e.g.</em> use <code>0</code> to start from the first column</li>
<li><em>e.g.</em> use <code>gg</code> to start from the first line</li>
<li><em>e.g.</em> use <code>n</code> or <code>;</code> to locate to next search match</li>
</ul></li>
<li>use <strong>repeatable</strong> motions to reach target
<ul>
<li><em>e.g.</em> instead of moving right by <code>l</code>, consider using <code>e</code></li>
</ul></li>
<li>when a motion <strong>fails</strong>, vim will <strong>stop</strong> the execution of rest of the macro
<ul>
<li>this feature can be used for testing whether a macro should be executed</li>
<li>when repeating macro with count, and normalizing cursor using <code>n</code> or <code>;</code>, you can provide a enoughly big number without causing unexpected results</li>
<li>when repeating by number, if one macro fails, the rest of these repetitions fail</li>
</ul></li>
</ul>
<h3 id="running-model---serially-and-parallelly">Running Model - Serially and Parallelly</h3>
<h4 id="running-macro-on-continous-lines">Running Macro on Continous Lines</h4>
<ul>
<li>to run the macro <strong>serially</strong>, at the end of the macro, use <code>j</code> to move to next line
<ul>
<li>use <code>{number}@{register}</code> to execute the macro <code>number</code> times</li>
<li><strong>behavior</strong>: if fail on some line, the whole process fails</li>
</ul></li>
<li>to run the macro <strong>parallelly</strong>, don’t append a <code>j</code> at the end; edit in-line
<ul>
<li>use Ex command to repeat the macro on lines: <code>:{selection}normal @{register}</code></li>
<li><em>e.g.</em> <code>:'&lt;,'&gt;normal @a</code> to run macro in register <code>a</code> on all lines in last selection</li>
<li><strong>behavior</strong>: if fail on some line, other lines are not affected (useful to ignore comment line)</li>
</ul></li>
<li>best practice: choose depending on situation</li>
</ul>
<h4 id="running-macro-on-multiple-files">Running Macro on Multiple Files</h4>
<ul>
<li>first, load files to edit into argument list (recall, use <code>:args {files}</code>)</li>
<li>use <code>:first</code> to go to the first file</li>
<li>to run the macro <strong>serially</strong> on files:
<ol type="1">
<li>perform and record the action on the first file</li>
<li>at the end of the macro, use <code>:next</code> to switch to next buffer in argument list</li>
<li>save the macro, then repeat it with number</li>
</ol></li>
<li>notes on running serially:
<ul>
<li>use <code>:wnext</code> instead of <code>:next</code> if you want to save before switching</li>
<li>the number can be big enough, since <code>:next</code> will stop on the last file</li>
<li><strong>behavior</strong>: if the macro fails on one file, the whole process will abort on the error location</li>
</ul></li>
<li>to run the macro <strong>parallelly</strong> on files:
<ol type="1">
<li>perform and record the action on the first file (don’t save first)</li>
<li>don’t append anything about switching at the end of the macro</li>
<li>save the macro, use <code>:edit!</code> to revert all changes made in the first file</li>
<li>use <code>:argdo normal @{register}</code> to perform the macro on all files in the argument list</li>
</ol></li>
<li>notes on running parallelly:
<ul>
<li>if the file is saved, try to remove it out of the argument list</li>
<li>otherwise, the macro will be executed twice on the file (one when recording, one when replaying)</li>
<li><strong>behavior</strong>: if the macro fails on one file, other files are not affected</li>
</ul></li>
</ul>
<h3 id="modify-macros">Modify Macros</h3>
<h4 id="modify-as-plain-text">Modify as Plain Text</h4>
<ul>
<li>macros in registers are just <strong>plain text</strong>
<ul>
<li>can be modifed as plain text but putting, editing then saving</li>
</ul></li>
<li>to put the content of a macro, always use <code>:put</code> to enforce line-wise putting</li>
<li>to yank it back to registers, always use <code>0"{register}y$</code> to enforce character-wise yanking
<ul>
<li>otherwise, an extra <code>^J</code> will be appended to the macro</li>
</ul></li>
<li>there may be control characters in the register of macro</li>
</ul>
<h4 id="shortcut-for-appending-actions">Shortcut for Appending Actions</h4>
<ul>
<li>if the modification only needs to append something to a marco, there is a shortcut</li>
<li>when use <code>q{register-lowercase}</code> like <code>qa</code>, actions will overwrite content of <code>a</code></li>
<li>when use <code>q{register-uppercase}</code> like <code>qA</code>, actions will be appended to content of <code>a</code></li>
</ul>
<h3 id="example-of-using-macro">Example of Using Macro</h3>
<h4 id="add-line-number-to-each-line">Add Line Number To Each Line</h4>
<p>this example shows how to use macro to add a line number to each line in the file (with basic vimscript):</p>
<ol type="1">
<li><code>:let i = 1</code> (vimscript to set a variable)</li>
<li><code>gg</code> to go the first line, first column</li>
<li><code>qa</code> starts recording</li>
<li><code>I&lt;C-r&gt;=i&lt;CR&gt;&lt;Space&gt;&lt;Esc&gt;</code>:
<ul>
<li>go to first column (nonblank)</li>
<li>use expression register to evaluate <code>i</code> and insert it</li>
</ul></li>
<li><code>:let i += 1</code> (vimscript to update a variable)</li>
<li><code>q</code> end recording</li>
</ol>
<p>notes:</p>
<ul>
<li>this script can be run parallely, and the number will be correct</li>
<li>under the hood, vim execute macros sequentially line by line</li>
<li>this task can also be done with yank, put and <code>&lt;C-a&gt;</code></li>
</ul>
<h4 id="clear-a-register">Clear A Register</h4>
<ul>
<li>use <code>q{register}q</code> to clear a register quickly
<ul>
<li><code>q{register}</code> starts recording a macro</li>
<li><code>q</code> ends recording, with empty content</li>
</ul></li>
</ul>
<h2 id="patterns">Patterns</h2>
<h3 id="patterns-in-vim">Patterns in Vim</h3>
<h4 id="specify-case-sensitivity">Specify Case Sensitivity</h4>
<ul>
<li>use <code>:set ignorecase</code> to ignore case <strong>globally</strong></li>
<li>to change case sensitivity <strong>for a single search</strong>
<ul>
<li>include <code>\c</code> in the pattern to ignore case</li>
<li>include <code>\C</code> in the pattern to be case sensitive</li>
<li>these marks can be anywhere in the pattern</li>
</ul></li>
<li>use <code>:set smartcase</code> to use <strong>smart</strong> case sensitivity <strong>globally</strong>
<ul>
<li>when there are no uppercase letters in the pattern, it’s insensitive</li>
<li>when there are uppercase letters in the pattern, it’s sensitive</li>
</ul></li>
</ul>
<h4 id="change-regex-mode">Change Regex Mode</h4>
<ul>
<li>vim’s has its own regex language, which is different from regex in Python, Perl, etc.
<ul>
<li>historically, vim’s default regex mode is <strong><em>magic</em></strong> (enabled by <code>\m</code>)</li>
<li>it has a <strong><em>nomagic</em></strong> mode emulating behavior of vi (enabled by <code>\M</code>)</li>
</ul></li>
<li>use <code>:help /character-classes</code> for avaiable character classes</li>
<li><strong>useful</strong>: use <code>\v</code> to enable <strong><em>very magic</em></strong> regex (hehaves like Python)
<ul>
<li>only <code>[0-9a-zA-Z_]</code> don’t have special meanings</li>
<li>avoid using too much backslashes</li>
</ul></li>
<li><strong>useful</strong>: use <code>\V</code> to enable <strong><em>very nomagic</em></strong> regex (bahaves like plain search)
<ul>
<li>only backslash, <code>/</code> and <code>?</code> have special meanings</li>
<li>add <code>\</code> before special meaning characters to escape them</li>
<li>can be used for matching verbatimly</li>
</ul></li>
<li><code>\v</code>, <code>\V</code>, <code>\m</code>, <code>\M</code> only affect sub-patterns after them</li>
</ul>
<h4 id="use-submatch-for-capturing">Use Submatch for Capturing</h4>
<ul>
<li>use parentheses to make a submatch, <em>e.g.</em> <code>/\v(hello), world</code></li>
<li>when use parentheses for grouping, prefix a <code>%</code> can avoid unnecessary submatching
<ul>
<li><em>e.g.</em> <code>/\v%(And|D)rew Neil</code>, <code>\1</code> refers to nothing</li>
</ul></li>
<li>use <code>\1</code> up to <code>\9</code> to refer to the matched submatch, <em>e.g.</em> <code>/\v(hello), world, \1</code></li>
<li><code>\0</code> always refers to the whole match</li>
</ul>
<h4 id="boundary-of-matching">Boundary of Matching</h4>
<ul>
<li>pattern and match can be different
<ul>
<li><strong>pattern</strong> is the regex we use to search for text</li>
<li><strong>match</strong> is the part we want to highlight (and may modify)</li>
<li>match can be a subset of pattern (if you want to <strong>limit match by prefix and postfix</strong>)</li>
</ul></li>
<li>in pattern, use <code>\zs</code> for start of the match, <code>\ze</code> for end of the match
<ul>
<li><em>e.g.</em> use <code>/\v#\s*\zs\w</code> to match the first word in the comment</li>
<li><em>e.g.</em> use <code>/\v"\zs[^"]+\ze"</code> to match content in the double quotes (excluding quotes)</li>
</ul></li>
<li>this feature is like positive lookahead and positive lookbehind in other languages’ regex
<ul>
<li>vim also supports negative lookahead and lookbehind, see <code>:help perl-patterns</code></li>
<li><strong>positive</strong>: start of match as <code>@&lt;=</code>, end of match as <code>@=</code></li>
<li><strong>negative</strong>: start of match as <code>@&lt;!</code>, end of match as <code>@!</code></li>
</ul></li>
</ul>
<h3 id="use-pattern-for-searching">Use Pattern for Searching</h3>
<h4 id="perform-a-search">Perform A Search</h4>
<ul>
<li>use <code>wrapscan</code> option to control whether the search will <strong>wrap</strong> the document</li>
<li>use <code>/</code> to search <strong>forward</strong>, <code>?</code> to search <strong>backward</strong></li>
<li>if you use <code>/</code> and <code>?</code> without providing a pattern, the <strong>last pattern will be used</strong>
<ul>
<li>useful to change the direction of searching</li>
</ul></li>
<li>to reuse <strong>history</strong> patterns
<ul>
<li>use <code>&lt;Up&gt;</code> and <code>&lt;Down&gt;</code> to use history patterns with typed text as prefix</li>
<li>use <code>q/</code> or <code>q?</code> to summon the history window (can be edited and select directly)</li>
</ul></li>
<li>use <code>n</code> to go to next match, <code>N</code> to go to previous match</li>
<li>to select a match and go to visual mode
<ul>
<li>if cursor is on a match
<ul>
<li><code>gn</code> will select current match, with free end at the end</li>
<li><code>gN</code> will select current match, with free end at the beginning</li>
</ul></li>
<li>if cursor is not on a match
<ul>
<li><code>gn</code> will select next match, with free end at the end</li>
<li><code>gN</code> will select previous match, with free end at the beginning</li>
</ul></li>
<li>handy when hused with <code>.</code>
<ul>
<li><em>e.g.</em> <code>gUgn</code> can change current match to uppercase; use with <code>.</code> (don’t need <code>n</code>) to repeat</li>
<li><em>e.g.</em> <code>dgn</code> with <code>.</code> can delete many matched string</li>
</ul></li>
</ul></li>
<li>use <code>:hlsearch</code> option to highlight searches, and use <code>:nohlsearch</code> to temporarily disable it</li>
<li>use <code>&lt;C-r&gt;&lt;C-w&gt;</code> to autocomplete the pattern using the first search (if <code>incsearch</code> is on)
<ul>
<li>because <code>&lt;C-r&gt;&lt;C-w&gt;</code> will insert the word under cursor</li>
<li>when using <code>incsearch</code>, the cursor is on the first match</li>
</ul></li>
<li>use <code>*</code> to search for the word under cursor (<code>n</code> / <code>N</code> to navigate)</li>
<li>in pattern, use <code>\&lt;</code> for start of a word, use <code>\&gt;</code> for end of a word</li>
</ul>
<h4 id="offset-the-cursor-on-a-match">Offset the Cursor on A Match</h4>
<ul>
<li>by defualt, cursor is placed on the first character of a match</li>
<li>append <code>/e</code> to pattern to replace the cursor at the end of a match
<ul>
<li><em>e.g.</em> <code>/lang/e</code> searches for <code>lang</code>, for each match, the cursor will be placed after the match</li>
</ul></li>
<li><em>e.g.</em> <code>//e</code> will reuse last pattern and place cursor at the end</li>
</ul>
<h4 id="count-of-matches">Count of Matches</h4>
<ul>
<li>use <code>:%s///gn</code> to count number of matches, where
<ul>
<li><code>%</code> means search for entire file</li>
<li><code>s</code> means substitude</li>
<li><code>n</code> echos number, and will suppress the normal substitution procedure</li>
</ul></li>
<li>use <code>:vimgrep //g %</code> to search (for last pattern) in the current file (by using <code>%</code>)
<ul>
<li>results will populate quickfix list</li>
<li>will show information like “current-num/total-num”</li>
<li>use <code>:cnext</code> and <code>:cprev</code> to navigate in the quickfix list</li>
</ul></li>
</ul>
<h3 id="use-pattern-for-substitution">Use Pattern For Substitution</h3>
<h4 id="substitution-command-syntax">Substitution Command Syntax</h4>
<p>full <strong>syntax</strong> is <code>:[range]s[ubstitute]/{pattern}/{string}/[flags]</code> where</p>
<ul>
<li><code>range</code> specifies lines to perform substitution on</li>
<li><code>pattern</code> specifies which part to be substituded
<ul>
<li>leave blank to reuse previously used pattern</li>
<li>or, use <code>&lt;C-r&gt;/</code> to explicitly insert previously used pattern (from register <code>/</code>)</li>
</ul></li>
<li><code>string</code> specifies the content to substitude</li>
<li><code>flags</code> controls the behavior of the substitution command (<code>:h :s_flags</code>)</li>
</ul>
<p><strong>frequently used</strong> commands pattern:</p>
<ul>
<li><strong>replace every occurrence in a file</strong>: <code>:%s/{pattern}/{string}/g</code></li>
<li><strong>replace every occurrence in a file with confirmation</strong>: <code>:%s/{pattern}/{string}/gc</code>
<ul>
<li>you can also use plain find with <code>n</code> and <code>.</code> to do this</li>
</ul></li>
</ul>
<h4 id="flags-to-control-behavior">Flags To Control Behavior</h4>
<ul>
<li><strong>default behavior</strong>: without any additional (range, flags), operates on current line, replace the first match</li>
<li>frequently used <strong>flags</strong>
<ul>
<li><code>g</code> replaces all occurrences (default only replace the first one in each line)</li>
<li><code>c</code> will ask for confirmation before substitution
<ul>
<li><code>y</code> to accept, <code>n</code> to reject</li>
<li><code>q</code> or <code>&lt;Esc&gt;</code> to quit, <code>l</code> to accept this one and quit</li>
<li><code>a</code> substitute all remaining</li>
<li><code>&lt;C-e&gt;</code> scrolls up, <code>&lt;C-y&gt;</code> scrolls down</li>
</ul></li>
<li><code>n</code> suppresses substitution and report how many occurrences will be affected by the command (dry run)</li>
<li><code>e</code> suppresses “Pattern not found” error</li>
<li><code>&amp;</code> reuses same flags from the previous substitution command</li>
</ul></li>
</ul>
<h4 id="advanced-substitution-string">Advanced Substitution String</h4>
<ul>
<li><strong>special characters</strong> in substitution string
<ul>
<li><code>\r</code>, <code>\t</code>, <code>\\</code> for carriage return, tab and single backslash</li>
<li><code>\1</code> to <code>\9</code> for submatch</li>
<li><code>\0</code> or <code>&amp;</code> for entire match</li>
<li><code>~</code> for the string used in the previous substitution command</li>
<li><code>\={vimscript}</code> evaluates <code>vimscript</code> and use result as replacement string</li>
</ul></li>
<li>use <strong>registers</strong> in substitution string
<ul>
<li>pass by <strong>value</strong>
<ul>
<li>do this if the content has only one line and contains no special characters</li>
<li>use <code>&lt;C-r&gt;{register}</code> to insert content from register</li>
<li><em>e.g.</em> <code>:%s//&lt;C-r&gt;0/g</code></li>
</ul></li>
<li>pass by <strong>reference</strong>
<ul>
<li>do this if the content has multiple lines or contains special characters</li>
<li>use <code>\=@{register}</code> as vimscript to insert content</li>
<li><em>e.g.</em> <code>:%s/\=@0/g</code></li>
</ul></li>
</ul></li>
<li><strong>vimscript</strong> examples
<ul>
<li>if you the match is a integer, you can use <code>:%s//\=submatch(0)-1/g</code> to replace this integer with its predecessor</li>
<li><code>{"k1":"v1", "k2":"v2"}</code> defines a dictionary; <code>{...}[...]</code> retrives a value</li>
<li>if you want to swap two words in vim, e.g. “dog” with “man”
<ol type="1">
<li>search words with <code>/\v(&lt;dog&gt;|&lt;man&gt;)</code></li>
<li>replace with <code>:%s//\={"dog":"man", "man":"dog"}[submatch(1)]/g</code></li>
</ol></li>
</ul></li>
</ul>
<h4 id="repeat-substitution">Repeat Substitution</h4>
<ul>
<li><strong>reuse pattern, replacement and flags, on entire file</strong>
<ul>
<li><code>g&amp;</code> will perform exactly <code>:%s//~/&amp;</code>, which uses previous search pattern, previous substitution string and previous flags on all lines</li>
</ul></li>
<li><strong>reuse pattern, replacement, on a new range</strong>
<ul>
<li><code>:{range}&amp;[flags]</code> will reuse previous search pattern and substitution string, but can specifies new flags and range</li>
<li>use <code>:{range}&amp;&amp;</code> to reuse previous flags (recall <code>&amp;</code> flag means reusing flags)</li>
</ul></li>
</ul>
<h3 id="search-and-substitude-in-multiple-files">Search And Substitude In Multiple Files</h3>
<ul>
<li><strong>search</strong> in multiple files: use <code>:vimgrep</code>
<ul>
<li><em>e.g.</em> search in all txt files with last pattern: <code>:vimgrep // **/*.txt</code></li>
<li>the pattern may come from a simple <code>/</code> command</li>
<li>results of <code>:vimgrep</code> will be in the <strong><em>quickfix list</em></strong>, view with <code>:copen</code></li>
</ul></li>
<li><strong>substitude</strong> in multiple files, an example for all txt files:
<ol type="1">
<li>search for the pattern with <code>:vimgrep /{pattern}/ **/*.txt</code></li>
<li>use <code>:cfdo %s//{string}/gc</code> to replace all (<code>:cfdo</code> executes command on all files in the quickfix list)</li>
<li>use <code>:cfdo update</code> to save all updates</li>
</ol></li>
</ul>
<h3 id="global-commands">Global Commands</h3>
<h4 id="function-of-global-commands">Function of Global Commands</h4>
<ul>
<li><code>:global</code> command executes an Ex command on all lines matching a pattern
<ul>
<li>shortcut: <code>:g</code></li>
</ul></li>
<li><code>:global!</code> or <code>:vglobal</code> executes an Ex command on all lines not matching a pattern
<ul>
<li>shortcut: <code>:v</code></li>
</ul></li>
</ul>
<h4 id="global-command-syntax">Global Command Syntax</h4>
<p>the syntax is <code>:[range] global[!] /{pattern}/ [cmd]</code> where</p>
<ul>
<li>default range is <code>%</code></li>
<li>default <code>pattern</code> is the last pattern used</li>
<li><code>cmd</code> can be an Ex command except for another global command, default is <code>:print</code>
<ul>
<li>if use default command, backslash after pattern is not needed</li>
</ul></li>
</ul>
<h4 id="global-command-examples">Global Command Examples</h4>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 28%" />
<col style="width: 27%" />
<col style="width: 19%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>No.</th>
<th>Behavior</th>
<th>Application</th>
<th>Global Command</th>
<th>Executed Ex Command</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>delete matching lines</td>
<td>remove all HTML tags</td>
<td><code>:g/\v\&lt;\/?\w+&gt;/d</code></td>
<td><code>delete</code></td>
</tr>
<tr class="even">
<td>2</td>
<td>keep only matching lines</td>
<td>preserve all <code>&lt;a&gt;</code> tags</td>
<td><code>:v/href/d</code></td>
<td><code>delete</code></td>
</tr>
<tr class="odd">
<td>3</td>
<td>gather lines into a register</td>
<td>collect all TODOs in a file</td>
<td><code>:g/TODO/y A</code></td>
<td><code>yank A</code></td>
</tr>
<tr class="even">
<td>4</td>
<td>gather lines to bottom</td>
<td>collect all TODOs in a file</td>
<td><code>:g/TODO/t$</code></td>
<td><code>copy $</code></td>
</tr>
</tbody>
</table>
<p>notes:</p>
<ul>
<li>in 3, before executing, clear register <code>a</code>; here <code>A</code> is used for <strong>appending</strong> to register <code>a</code></li>
<li>4 is more clear than 3, but 3 can be executed on multiple files with <code>:argdo</code></li>
</ul>
<h4 id="run-ex-commands-on-ranges-of-lines">Run Ex Commands On Ranges Of Lines</h4>
<ul>
<li>generalized <strong>syntax</strong>: <code>:g/{range-start}/ .,{range-stop} [cmd]</code></li>
<li><strong>function</strong>: find <strong>many</strong> “ranges of lines”, for each group of these lines, execute <code>cmd</code></li>
<li><strong>composition</strong>
<ul>
<li><code>:g</code>, global command</li>
<li><code>/{range-start}/</code> match lines, each line is a reference point of a range</li>
<li><code>.,{range-stop} [cmd]</code> is an Ex command, where
<ul>
<li><code>.</code>, range start</li>
<li><code>{range-stop}</code>, pattern to match the range stop</li>
<li><code>cmd</code>, command to execute</li>
</ul></li>
<li>Ex command in global command can also have its own range</li>
</ul></li>
<li><code>range-start</code> specifies the pattern of the first line of the range</li>
<li><code>range-stop</code> specifies the pattern of the last line of the range</li>
<li><code>.,{range-stop}</code> specifies the range (<code>.</code> refers to the current line, which is <code>range-start</code>)</li>
<li>offset can be used in the syntax to adjust boundary, such as adjusting <code>.</code> or <code>range-stop</code></li>
<li><strong>examples</strong>
<ul>
<li>sort properties in a css block: <code>:g/{/ .+1,/}/-1 sort</code>
<ul>
<li><code>:g</code>, global command</li>
<li><code>/{/</code> matches a opening brace</li>
<li>the remain part is an Ex command, where
<ul>
<li><code>.+1</code>, range start, next line after current line</li>
<li><code>/}/-1</code>, range stop, previous line before next closing brace</li>
<li><code>sort</code>, perform sort on the range</li>
</ul></li>
</ul></li>
<li>indent lines in a css block: <code>:g/{/ .+1,/}/-1 &gt;</code>
<ul>
<li><code>:&gt;</code> is an Ex command for indenting</li>
<li><code>:&gt;</code> will echoes messages, use <code>:g/{/sil .+1,/}/-1 &gt;</code> to silence (prefix with any Ex command)</li>
</ul></li>
</ul></li>
</ul>
<h2 id="tools">Tools</h2>
<h3 id="ctags">CTags</h3>
<h4 id="basis-of-ctags">Basis Of CTags</h4>
<ul>
<li>what is it: <strong>a tool to generate a database of definitions of keywords for codebase</strong>
<ul>
<li><em>e.g.</em> classes, functions, global variables</li>
</ul></li>
<li><code>ctags</code> typically generate a <code>tags</code> file, in the format that can be recognized by vim</li>
<li>other tools can generate <code>tags</code> for any language as long as they conform the format</li>
<li>basic ctags usage from command line:
<ul>
<li><strong>on specified files</strong>: e.g. <code>ctags *.py</code>, will generate a file named <code>tags</code> (plain text)</li>
<li><strong>recursively</strong> process current directory: <code>ctags -R</code></li>
</ul></li>
</ul>
<h4 id="file-structure-of-tags">File Structure Of <code>tags</code></h4>
<ul>
<li>file structure of <strong>classical</strong> <code>tags</code>
<ul>
<li>head: several lines of <strong>metadata</strong></li>
<li>body, <strong>one keyword per line</strong>, 3 fields: keyword, filename, address</li>
<li>address of a line should be an Ex command to locate the keyword
<ul>
<li>not using absolute line number due to inconvenience (line number is an Ex command, e.g. <code>:42</code>)</li>
<li>using search by pattern since it’s more robust (searching is an Ex command, e.g. <code>:/main</code>)</li>
</ul></li>
<li>keywords are <strong>sorted</strong> alphabetically for binary search</li>
</ul></li>
<li><strong>extended</strong> <code>ctags</code> files can contain metadata
<ul>
<li>like type of the keyword, e.g. function, class or variable</li>
</ul></li>
</ul>
<h4 id="use-ctags-in-vim">Use CTags In Vim</h4>
<ul>
<li>vim looks for <code>tags</code> file in paths specified by the <code>tags</code> option
<ul>
<li>view this option by <code>:set tags?</code></li>
<li>default: <code>./tags,tags</code> (directory of current file, working directory)</li>
<li>use <code>tags-options</code> to control vim’s behavior of finding keywords</li>
</ul></li>
<li>generate <code>tags</code> file without leaving vim
<ul>
<li>use shell in command line mode <strong>mannually</strong>: <code>:! ctags -R</code></li>
<li><strong>automatically</strong> generate when a file is <strong>saved</strong>: <code>:autocmd BufWritePost * call system("ctags -R")</code></li>
<li>use hooks of verision control systems (practical way)</li>
</ul></li>
</ul>
<h4 id="navigation-between-tags">Navigation Between Tags</h4>
<ul>
<li><code>&lt;C-]&gt;</code> jumps to keyword definition under cursor (creates a <strong><em>tag list</em></strong>)
<ul>
<li>jumps to the one with highest priority if has multiple matches (see <code>:h tag-priority</code>)</li>
</ul></li>
<li><code>g&lt;C-]&gt;</code> jumps to keyword definition under cursor, like <code>&lt;C-]&gt;</code>
<ul>
<li>opens a list of choice if there are multiple matches</li>
<li>this list can be reopen with <code>:tselect</code></li>
<li>use <code>:tnext</code>, <code>:tprev</code>, <code>:tfirst</code>, <code>:tlast</code> to navigate between these tags</li>
</ul></li>
<li><code>&lt;C-t&gt;</code> of <code>:pop</code> reverse through tag list (see <code>:h tag-stack</code>)</li>
<li><code>:tag</code> advance through tag list</li>
<li><code>:tag {keyword}</code> behaves like pressing <code>&lt;C-]&gt;</code> when cursor on <code>keyword</code>
<ul>
<li>autocompletion available for inputing <code>keyword</code></li>
<li>use <code>:tag /{pattern}</code> to open a list for all keywords matching <code>pattern</code></li>
</ul></li>
<li><code>:tjump {keyword}</code> behaves like pressing <code>g&lt;C-]&gt;</code> when cursor on <code>keyword</code>
<ul>
<li>autocompletion available for inputing <code>keyword</code></li>
<li>use <code>:tjump /{pattern}</code> to open a list for all keywords matching <code>pattern</code></li>
</ul></li>
</ul>
<h3 id="compile-and-quickfix-list">Compile And Quickfix List</h3>
<h4 id="compile-inside-vim">Compile Inside Vim</h4>
<h5 id="use-default-setup-of-vim">Use Default Setup Of Vim</h5>
<ul>
<li>use <code>:make</code> to invoke <code>make</code> inside vim
<ul>
<li>output of <code>make</code> should contains filename, line number, and error message for each error / warning</li>
<li>vim will parse output and create a record for each error/warning in the <strong><em>quickfix list</em></strong></li>
</ul></li>
<li>after invoking <code>:make</code>
<ul>
<li>if using <code>:make</code>, vim will jump to the first error location (recall, jump back by <code>&lt;C-o&gt;</code>)</li>
<li>if using <code>:make!</code>, vim won’t jump</li>
</ul></li>
</ul>
<h5 id="configure-which-external-compiler">Configure Which External Compiler</h5>
<ul>
<li>program invoked by <code>:make</code> is specified by option <code>makeprg</code>, defaults to <code>make</code></li>
<li>this program doesn’t need to be a compiler
<ul>
<li>the real purpose is to run something and produce an error list</li>
<li>can be used on interpreted langauges or markup languages</li>
<li><em>e.g.</em> render markup languages; run linters; run unit tests</li>
</ul></li>
<li><em>e.g.</em> <code>:setlocal makeprg=ghc\ -dynamic\ %</code> to use <code>ghc</code> to compile current file
<ul>
<li><code>:setlocal</code> only sets options for current buffer</li>
<li>spaces should be escaped by backslashes</li>
<li>use <code>%</code> to refer to current file</li>
</ul></li>
<li>output of customized external compiler may not be parsed by vim, two options:
<ul>
<li>customize external program so its output so it can be parsed by vim</li>
<li>(recommended) customize vim to understand the syntax of the output</li>
</ul></li>
<li>output format is specified by option <code>errorformat</code>
<ul>
<li>multiple patterns seperated by <code>,</code>, spaces and <code>,</code> in error message escaped by backslashes</li>
<li>placeholders (to extract information from) are represented by a token prefixed with <code>%</code>
<ul>
<li><code>%f</code> for name of file, <code>%l</code> for line number, <code>%c</code> for column, <code>%m</code> for error message, etc.</li>
<li>use <code>:h errorformat</code> to view all tokens</li>
</ul></li>
</ul></li>
<li>use <code>:compiler</code> to set <code>:makeprg</code> and <code>:errorformat</code> (and other things) in one command</li>
</ul>
<h4 id="quickfix-list-and-location-list">Quickfix List And Location List</h4>
<ul>
<li><em>quickfix list</em> is global, each vim instance has only one quickfix list</li>
<li><em>quickfix list</em> can be forged by commands like <code>:make</code>, <code>:grep</code> and <code>:vimgrep</code></li>
<li><strong><em>location list</em></strong> is similar to <em>quickfix list</em>, but echo window can have its own <em>location list</em>
<ul>
<li><em>location list</em> can be forged by commands like <code>:lmake</code>, <code>:lgrep</code> and <code>:lvimgrep</code></li>
</ul></li>
</ul>
<h4 id="navigation-in-quickfix-list-and-location-list">Navigation In Quickfix List And Location List</h4>
<p>to navigate in <strong>quickfix list</strong>:</p>
<ul>
<li>go to next / previous error location: <code>:cnext</code> / <code>:cprev</code> (can be prepended with a count)</li>
<li>go to first / next error location: <code>:cfirst</code> / <code>:cnext</code></li>
<li>go to first error in next file / last error in previous file: <code>:cnfile</code> / <code>:cpfile</code></li>
<li>go to nth item: <code>:cc {N}</code></li>
<li>open / close quickfix window: <code>:copen</code> / <code>:cclose</code>
<ul>
<li>press <code>&lt;CR&gt;</code> on an item to open the file and locate to the line</li>
</ul></li>
<li>execute command on each error line: <code>:cdo {cmd}</code></li>
<li>execute command on each file in quickfix list: <code>:cfdo {cmd}</code></li>
</ul>
<p>navigation in <strong>location list</strong> is similar to navigation in quickfix list:</p>
<ul>
<li>most commands change the prefixing <code>c</code> to <code>l</code></li>
<li><em>e.g.</em> <code>:lprev</code> and <code>:lopen</code></li>
<li>except for <code>:cc {N}</code>, which is <code>:ll {N}</code> to jump to nth item in location list</li>
</ul>
<h4 id="navigation-in-quickfix-list-stack">Navigation In Quickfix List Stack</h4>
<ul>
<li>when the source code changes and compiled, quickfix list will change</li>
<li>vim maintains last 10 quickfix lists in <strong><em>quickfix stack</em></strong>, allowing refer to one of them later</li>
<li>use <code>:colder</code> to go to previous quickfix list in the stack</li>
<li>use <code>:cnewer</code> to go to next quickfix list in the stack</li>
<li><code>:colder</code> and <code>:cnewer</code> can be prepended with a count</li>
</ul>
<h3 id="project-wise-searching">Project-Wise Searching</h3>
<h4 id="use-grep-from-inside-vim">Use Grep From Inside Vim</h4>
<ul>
<li>vim’s <code>:grep</code> command is a wrapper of <code>grep</code> (or <code>grep</code>-like programs, defualt to <code>grep</code>)</li>
<li>vim will parse the result of <code>:grep</code> and stores them into quickfix list for use</li>
<li><em>e.g.</em> find all <code>hello</code> in all files in current folder: <code>:grep hello *</code></li>
<li><em>e.g.</em> find all <code>hello</code> in all files in current folder, ignoring case: <code>:grep -i hello *</code></li>
</ul>
<h4 id="customize-grep-program-and-output-format">Customize Grep Program And Output Format</h4>
<ul>
<li><code>:grep</code> can be customized like compilers
<ul>
<li>program invoked by <code>:grep</code> is specified by <code>grepprg</code> (default calls <code>grep</code> with certain parameters)</li>
<li>format of <code>:grep</code> is specified by <code>grepformat</code> used by vim for parsing</li>
<li>tokens used in <code>grepformat</code> are the same with <code>errorformat</code></li>
</ul></li>
<li><em>e.g.</em> use <code>ack</code> instead of <code>grep</code>: <code>:set grepprg=ack\ --nogroup\ $*</code>
<ul>
<li><code>ack</code> is a program similar to <code>grep</code> but designed for programmers</li>
<li><code>$*</code> passes all parameters in vim to <code>ack</code></li>
</ul></li>
</ul>
<h4 id="use-vimgrep">Use Vimgrep</h4>
<ul>
<li><code>:grep</code> default calls <code>grep</code> which uses its own regex syntax (POSIX)</li>
<li><code>:vimgrep</code> uses vim’s native regex engine and uses same regex syntax as vim’s search command</li>
<li><strong>syntax</strong>: <code>:vim[grep][!] /{pattern}/[g][j] {file} ...</code>
<ul>
<li><code>file</code> can be filenames, wildcards, backtick expressions and their combinations
<ul>
<li>use <code>##</code> to refers to all files in argument list</li>
</ul></li>
</ul></li>
<li><strong>examples</strong>
<ul>
<li>find the first “hello” in lines in all files: <code>:vimgrep /hello/ *</code></li>
<li>find all “hello”s in files in the argument list: <code>:vimgrep /hello/g ##</code> (note the <code>g</code> flag)</li>
</ul></li>
<li><strong>best practice</strong>
<ol type="1">
<li>use <code>/ ...</code> to test and construct the regex in current buffer</li>
<li>use <code>:args ...</code> to specify files to search</li>
<li>then use <code>:vimgrep //g ##</code> to search in these files, reusing regex</li>
</ol></li>
</ul>
<h3 id="autocompletion">Autocompletion</h3>
<h4 id="source-of-world-list">Source Of World List</h4>
<ul>
<li>when use autocompletion, vim builds a word list from <strong>many sources</strong></li>
<li>use prefixes <code>&lt;C-x&gt;</code> to specify sources to limit keywords to select from</li>
</ul>
<p>some comman sources:</p>
<ul>
<li><strong>buffer list source</strong>, word from current buffer
<ul>
<li>use <code>&lt;C-x&gt;&lt;C-n&gt;</code> / <code>&lt;C-x&gt;&lt;C-p&gt;</code> to use this source</li>
<li>to source keywords from buffer list, use <code>:ls!</code> (<code>!</code> shows unlisted buffer)</li>
</ul></li>
<li><strong>included files</strong>, word from included files (in C++, <code>include</code>; in Python, <code>import</code>, etc.)
<ul>
<li>use <code>&lt;C-x&gt;&lt;C-i&gt;</code> to use this source</li>
</ul></li>
<li><strong>tag files</strong>, word from the <code>tags</code> file (language object, like function name)
<ul>
<li>use <code>&lt;C-x&gt;&lt;C-]&gt;</code> to use this source</li>
</ul></li>
<li><strong>dictionary</strong>, a file containing words
<ul>
<li>use <code>&lt;C-x&gt;&lt;C-k&gt;</code> to use this source</li>
<li>need to supply vim with suitable word list first
<ul>
<li>(spelling dictionary) use <code>:set spell</code> to enable built-in spell checker</li>
<li>or, use <code>dictionary</code> option to specify files containing word list</li>
</ul></li>
</ul></li>
<li><strong>filenames</strong>, filenames under working directory, relative to working directory
<ul>
<li>use <code>&lt;C-x&gt;&lt;C-f&gt;</code> to use this source</li>
<li>show working directory with <code>:pwd</code>, change with <code>:cd</code> (<code>:cd -</code> works like in shell)</li>
</ul></li>
<li><strong>context awareness</strong>, suggestions based on languages (require plugins) and cursor location (like IDE does)
<ul>
<li>use <code>&lt;C-x&gt;&lt;C-o&gt;</code> to use this source</li>
<li>vim has built-in support for some languages (<code>:h compl-omni-filetypes</code>)</li>
</ul></li>
</ul>
<p>vim combines sources to provide <strong><em>generic keyword autocompletion</em></strong></p>
<ul>
<li>sources to be combined is specified in option <code>complete</code></li>
<li><code>&lt;C-n&gt;</code>: generic keyword autocompletion, select next word in the word list</li>
<li><code>&lt;C-p&gt;</code>: generic keyword autocompletion, select previous word in the word list</li>
</ul>
<h4 id="case-sensitivity-in-autocompletion">Case Sensitivity In Autocompletion</h4>
<ul>
<li>case sensitivity follows <code>ignorecase</code> option</li>
<li>use <code>infercase</code> option for better autocompletion experience
<ul>
<li><em>e.g.</em> vim will transfrom words starting with uppercase letters into lowercase</li>
</ul></li>
</ul>
<h4 id="autocompletion-pop-up-menu">Autocompletion Pop-Up Menu</h4>
<p>when a autocompletion pop-up menu is shown:</p>
<table>
<thead>
<tr class="header">
<th>Keystrokes</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&lt;C-n&gt;</code> / <code>&lt;C-p&gt;</code></td>
<td><strong>use</strong> next / previous word in the word list</td>
</tr>
<tr class="even">
<td><code>&lt;Down&gt;</code> / <code>&lt;Up&gt;</code></td>
<td><strong>select</strong> next / previous word in the word list</td>
</tr>
<tr class="odd">
<td><code>&lt;C-y&gt;</code> / <code>&lt;CR&gt;</code></td>
<td><strong>accept</strong> current selected word</td>
</tr>
<tr class="even">
<td><code>&lt;C-e&gt;</code></td>
<td><strong>exit</strong> from autocompletion and revert to orginally typed text</td>
</tr>
<tr class="odd">
<td><code>&lt;C-h&gt;</code> / <code>&lt;BS&gt;</code></td>
<td><strong>delete</strong> one character from current match</td>
</tr>
<tr class="even">
<td><code>&lt;C-l&gt;</code></td>
<td><strong>append</strong> one character from current selected</td>
</tr>
<tr class="odd">
<td><code>{char}</code></td>
<td>insert <code>char</code></td>
</tr>
</tbody>
</table>
<p>use stroke <code>&lt;C-n&gt;&lt;C-p&gt;</code> or <code>&lt;C-p&gt;&lt;C-n&gt;</code> to open menu without selecting any entry</p>
<h4 id="autocompletion-for-entire-line">Autocompletion For Entire Line</h4>
<ul>
<li>line-wise autocompletion triggered by <code>&lt;C-x&gt;&lt;C-l&gt;</code></li>
<li>sources are the same with generic keyword autocompletion</li>
<li>any indent at the start of the line is ignored</li>
<li>useful for duplicate some line elsewhere (without first copying it)</li>
</ul>
<h4 id="autocompletion-of-sequence-of-words">Autocompletion Of Sequence Of Words</h4>
<ul>
<li>when use autocompletion to complete a word, vim <strong>remembers the context</strong> of the selected words</li>
<li>if autocomplete for <strong>a second time immediately</strong>, vim will use words after the first selected word in these contexts (autocompletion for sequence of words)</li>
<li>if there are multiple choices, use <code>&lt;C-n&gt;</code> / <code>&lt;C-p&gt;</code> to select different context</li>
<li>this is faster than copying and pasting from the context</li>
<li><strong>also works for lines</strong> (autocompletion for sequence of lines)</li>
<li><em>e.g.</em> repeatedly use <code>&lt;C-x&gt;&lt;C-p&gt;</code> for using a sequence of words in current buffer</li>
<li><em>e.g.</em> repeatedly use <code>&lt;C-x&gt;&lt;C-l&gt;</code> for using a sequence of lines</li>
</ul>
<h3 id="spell-check">Spell Check</h3>
<h4 id="use-spell-check">Use Spell Check</h4>
<ul>
<li>use <code>:set spell</code> to <strong>enable</strong> spell check</li>
<li><strong>jump between</strong> misspelled words with <code>[s</code> and <code>]s</code></li>
<li>when on a misspelled word, ask vim for <strong>suggestion</strong> by <code>z=</code>
<ul>
<li>use <code>{count}z=</code> if you are confident, <em>e.g.</em> use the first word is <code>1z=</code></li>
</ul></li>
<li><code>zg</code> <strong>adds</strong> current word to spell file</li>
<li><code>zw</code> <strong>remove</strong> current word from spell file</li>
<li><code>zug</code> <strong>reverts</strong> (redo) <code>zg</code> or <code>zw</code> for current word</li>
<li>if in insert mode, use <code>&lt;C-x&gt;&lt;C-s&gt;</code> or <code>&lt;C-x&gt;s</code> to use the spell check as the form of autocompletion
<ul>
<li>cursor doesn’t need to be placed on the misspelled word</li>
<li>vim will locate cursor to the nearest misspelled word before current cursor location</li>
</ul></li>
</ul>
<h4 id="change-spell-check-dictionary">Change Spell Check Dictionary</h4>
<ul>
<li>default dictionary is English, specified by <code>spelllang</code> option (default is <code>us</code>)</li>
<li>use <code>en_us</code>, <code>en_au</code>, <code>en_ca</code>, <code>en_gb</code>, <code>en_nz</code> to use a regional dialect</li>
</ul>
<h4 id="modify-dictionary">Modify Dictionary</h4>
<ul>
<li>use <code>zg</code>, <code>zw</code> and <code>zug</code> to modify a dictionary</li>
<li>the modification is saved as a new file (not changing dictionary), determined by language and file encoding</li>
<li>use <code>spellfile</code> option to specify which modifications to load
<ul>
<li>multiple spellfiles can be loaded</li>
<li>useful for saving terminologies (which are not in default dictionaires) to a dedicated modification</li>
<li>when you writing something about that domain, load the patch</li>
</ul></li>
<li>use <code>:setlocal spellfile=...</code> or <code>:setlocal spellfile+=...</code> to load modifications</li>
<li>use number before <code>zg</code> to decide which modification the new word belongs to</li>
</ul>
<h2 id="configure-vim">Configure Vim</h2>
<h3 id="change-configuration-on-the-fly">Change Configuration On The Fly</h3>
<ul>
<li><strong>show all options</strong>: <code>:h option-list</code></li>
<li>for boolean values (take <code>ignorecase</code> for example)
<ul>
<li>change to true with <code>:set ignorecase</code></li>
<li>change to false with <code>:set noignorecase</code> (prepend with <code>no</code>)</li>
<li>show current value with <code>:set ignorecase?</code> (append with <code>?</code>)</li>
<li>reset to default value with <code>:set ignorecase&amp;</code> (append with <code>&amp;</code>)</li>
<li>toggle value with <code>:set ignorecase!</code> (append with <code>!</code>)</li>
</ul></li>
<li>for options accepting number and string
<ul>
<li>multiple values can be set together
<ul>
<li><em>e.g.</em> <code>:set tabstop=2 shiftwidth=2 expandtab</code></li>
</ul></li>
<li>many options have shortcuts
<ul>
<li><em>e.g.</em> <code>:set ts=2 sw=2 et</code></li>
</ul></li>
</ul></li>
<li><strong>specify affected window / buffer</strong>
<ul>
<li><code>:setlocal</code> only affects current window or buffer</li>
<li>use <code>:windo setlocal ...</code> to apply settings to all opened windows</li>
<li>use <code>:bufdo setlocal ...</code> to apply settings to all opened buffers</li>
<li><code>:set</code> will affects new windows / buffers</li>
</ul></li>
</ul>
<h3 id="save-configuration-to-files">Save Configuration To Files</h3>
<ul>
<li>configurations can be saved to a file, use <code>:source {filename}</code> to execute it line by line</li>
<li>you can save different configurations to different files and source them selectively</li>
<li>leading <code>:</code> is not needed in a configuration file</li>
<li>vim will load a configuration called <code>vimrc</code>; on linux, it’s <code>~/.vimrc</code>
<ul>
<li>open with <code>:edit $MYVIMRC</code></li>
<li>reload with <code>:source $MYVIMRC</code></li>
<li>if vimrc is active, use <code>:source %</code> is faster (even faster with <code>:so %</code>)</li>
</ul></li>
<li>use <code>autocmd</code> to listen for event (such as saving, filetype, etc.)
<ul>
<li><em>e.g.</em> run command when file type is javascript: <code>autocmd FileType javascript compiler nodelint</code></li>
</ul></li>
</ul>
<h2 id="misc.">Misc.</h2>
<h3 id="compound-commands">Compound Commands</h3>
<p><strong>principles</strong>:</p>
<ul>
<li>uppercases applied to lines</li>
<li>lowercases applied to characters</li>
</ul>
<p><strong>examples</strong>:</p>
<ul>
<li><code>I</code>: prepend to current line (equals to <code>^i</code>)</li>
<li><code>A</code>: append to current line (equals to <code>$a</code>)</li>
<li><code>C</code>: change to line end (equals to <code>c$</code>)</li>
<li><code>S</code>: substitude whole line (equals to <code>^C</code>)</li>
<li><code>s</code>: substitude current character (equals to <code>cl</code>)</li>
</ul>
<h3 id="increase-and-decrease-number">Increase and Decrease Number</h3>
<ul>
<li>if you put cursor on a number:
<ul>
<li><code>&lt;C-a&gt;</code> will increase it by <span class="math inline">1</span></li>
<li><code>&lt;C-x&gt;</code> will decrease it by <span class="math inline">1</span></li>
<li><code>{n}&lt;C-a&gt;</code> and <code>{n}&lt;C-x&gt;</code> will increase/decrease by <span class="math inline"><em>n</em></span></li>
</ul></li>
<li>numbers can be positive or negative</li>
<li>if the cursor is not on a number, the nearest number after the cursor will be modified</li>
</ul>
<h3 id="center-current-line">Center Current Line</h3>
<p>use <code>zz</code></p>
<h3 id="command-line-mode-seperator">Command Line Mode Seperator</h3>
<p>use <code>|</code> to sequentially execute multiple commands. see <code>:h :bar</code></p>

</body>
</html>


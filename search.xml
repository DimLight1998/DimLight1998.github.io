<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Functional Program Design in Scala 笔记 4 Timely Effects</title>
      <link href="/2019/04/19/Functional-Program-Design-in-Scala-%E7%AC%94%E8%AE%B0-4-Timely-Effects/"/>
      <url>/2019/04/19/Functional-Program-Design-in-Scala-%E7%AC%94%E8%AE%B0-4-Timely-Effects/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Functional Program Design in Scala 笔记 3 Functions and State</title>
      <link href="/2019/04/19/Functional-Program-Design-in-Scala-%E7%AC%94%E8%AE%B0-3-Functions-and-State/"/>
      <url>/2019/04/19/Functional-Program-Design-in-Scala-%E7%AC%94%E8%AE%B0-3-Functions-and-State/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Functional Program Design in Scala 笔记 2 Lazy Evaluation</title>
      <link href="/2019/04/19/Functional-Program-Design-in-Scala-%E7%AC%94%E8%AE%B0-2-Lazy-Evaluation/"/>
      <url>/2019/04/19/Functional-Program-Design-in-Scala-%E7%AC%94%E8%AE%B0-2-Lazy-Evaluation/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Functional Program Design in Scala 笔记 1 For Expressions and Monads</title>
      <link href="/2019/04/19/Functional-Program-Design-in-Scala-%E7%AC%94%E8%AE%B0-1-For-Expressions-and-Monads/"/>
      <url>/2019/04/19/Functional-Program-Design-in-Scala-%E7%AC%94%E8%AE%B0-1-For-Expressions-and-Monads/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Functional Programming Principles in Scala 笔记 4 Types and Pattern Matching</title>
      <link href="/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-4-Types-and-Pattern-Matching/"/>
      <url>/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-4-Types-and-Pattern-Matching/</url>
      
        <content type="html"><![CDATA[<h2 id="Scala-是纯-OOP-的吗"><a href="#Scala-是纯-OOP-的吗" class="headerlink" title="Scala 是纯 OOP 的吗"></a>Scala 是纯 OOP 的吗</h2><h3 id="值类型可以被-OOP-实现"><a href="#值类型可以被-OOP-实现" class="headerlink" title="值类型可以被 OOP 实现"></a>值类型可以被 OOP 实现</h3><p>纯 OOP 语言指的是这种语言中所有的东西都是基于类和对象的。Java 不是纯 OOP 语言，因为其中的 primitive types 不是基于类或者对象的。</p><p><strong>Scala 是纯 OOP 的</strong>，尽管它也有像 Java 中的 primitive types，但是 <strong>逻辑上</strong> 这些类型都是用 OOP 实现的。在编译时，编译器会特殊地对待这些类型，将其转化为更加底层的类型以保证运行效率。</p><p>OOP 可以实现诸如 <code>boolean</code> 和 <code>int</code> 这样的类型，并且实现一个原生类型时不需要依赖这个类型，即值类型可以被 OOP 体系实现。比如，可以用 OOP 实现皮亚诺算术进而实现整数，尽管这么做效率很低，但是确实是可行的。</p><h3 id="函数类型可以被-OOP-实现"><a href="#函数类型可以被-OOP-实现" class="headerlink" title="函数类型可以被 OOP 实现"></a>函数类型可以被 OOP 实现</h3><p>函数实际上也可以被 OOP 实现。类型 <code>A =&gt; B</code> 实际上是类型 <code>Function1[A, B]</code>，其中 <code>Function1</code> 是一个 trait。</p><p>对于匿名函数 <code>x =&gt; x * x</code>，Scala 可能会将其展开为一个类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AnonFun</span> <span class="keyword">extends</span> <span class="title">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>) = x * x</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span> <span class="type">AnonFun</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以使用 <a href="#匿名类">匿名类</a> 写得更简单。</p><p>实际上，Scala 在背后正是这么做的。对于每个函数 <code>f</code>，Scala 都会创建一个类，这个类中有一个 <code>apply</code> 方法，并且方法体与 <code>f</code> 的函数体相同。</p><hr><p>可以看到值类型和函数类型都可以被 OOP 实现，因此 Scala 是纯 OOP 的。</p><h2 id="Polymorphism-中的-Bound-和-Variance"><a href="#Polymorphism-中的-Bound-和-Variance" class="headerlink" title="Polymorphism 中的 Bound 和 Variance"></a>Polymorphism 中的 Bound 和 Variance</h2><h3 id="Bound"><a href="#Bound" class="headerlink" title="Bound"></a>Bound</h3><p>所谓的 bound 就是对类型的限制。</p><p>子类型关系是一种 upper bound。先看下面的几个类型定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntList</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">IntNil</span> <span class="keyword">extends</span> <span class="title">IntList</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">IntCons</span>(<span class="params">val head: <span class="type">Int</span>, val tail: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">IntList</span></span></span><br></pre></td></tr></table></figure><p>现在对于类型 <code>S</code>，如果有 <code>S &lt;: IntList</code> 就表示 <code>S</code> 必然是 <code>IntList</code> 的子类型。可以将这种限制关系写在泛型函数的类型参数中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intListId</span></span>[<span class="type">T</span> &lt;: <span class="type">IntList</span>](xs: <span class="type">T</span>): <span class="type">T</span> = xs</span><br></pre></td></tr></table></figure><p>因为显式指明了返回类型，因此这个函数只能应用于 <code>IntList</code> 的子类型上，比如 <code>IntNil</code>、<code>IntCons</code> 或者 <code>Null</code> 等。单就这个例子而言，该函数没有什么卵用。</p><p>同样地，可以进行超类型的限制 <code>&gt;:</code>，也可以将二者混合起来使用。超类型限制是一种 lower bound。</p><h3 id="Variance"><a href="#Variance" class="headerlink" title="Variance"></a>Variance</h3><p>Variance 主要是协变（covariant）与逆变（contravariant）的问题。之前在 Programming Languages 里面已经学习过了，来复习一下。</p><h4 id="Java-数组的问题"><a href="#Java-数组的问题" class="headerlink" title="Java 数组的问题"></a>Java 数组的问题</h4><p>还是上面的例子，下面的代码在 Java 中可以通过编译（未测试）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntNil[] a = <span class="keyword">new</span> IntNil[]&#123;<span class="keyword">new</span> IntNil&#125;;</span><br><span class="line">IntList[] b = a;</span><br><span class="line">b[<span class="number">0</span>] = <span class="keyword">new</span> IntCons(<span class="number">3</span>, <span class="keyword">new</span> IntNil);</span><br><span class="line">IntNil c = a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>但是运行时在第二行会出现异常 <code>ArrayStoreException</code>。因为 Java 在实现上会在每个数组中记录一下这个数组的真实类型是什么，在进行数组写的时候总是会进行判断。这样就引入了额外的开销。为什么会这样设计呢？因为旧版本的 Java 中没有泛型，为了让形如 <code>sort(Object[])</code> 这样的函数可以工作于所有类型的数组上，必须把数组设计成协变的。</p><h4 id="Scala-的设计"><a href="#Scala-的设计" class="headerlink" title="Scala 的设计"></a>Scala 的设计</h4><p>从上面的例子可以看到数组是协变的是有问题的，因此 Scala 设计为数组是逆变的。这样相同的代码在第二行就会直接报错（<code>IntNil &lt;: IntList</code> 蕴含 <code>Array[IntList] &lt;: Array[IntNil]</code>），就没有运行时开销了。</p><h2 id="Variance-进阶"><a href="#Variance-进阶" class="headerlink" title="Variance 进阶"></a>Variance 进阶</h2><h3 id="Scala-泛型类的协变逆变约束"><a href="#Scala-泛型类的协变逆变约束" class="headerlink" title="Scala 泛型类的协变逆变约束"></a>Scala 泛型类的协变逆变约束</h3><p>Scala 中的数组是逆变的，但是不可变的列表（<code>List</code>）呢（答案见后）？大体上讲，所有的 mutable 类型都不应该被设计成协变的，而 immutable 类型只有在满足某些条件的情况下可以设计为协变的。</p><p>对于类型 <code>A</code> 和 <code>B</code> 有 <code>A &lt;: B</code>，如果有某个类型构造子 <code>C</code>，则下面三种情况必有一个成立：</p><ul><li><strong>covariant</strong>：<code>C[A] &lt;: C[B]</code></li><li><strong>contravariant</strong>：<code>C[A] &gt;: C[B]</code></li><li><strong>nonvariant</strong>：上面两个都不成立</li></ul><p>Scala 中，声明泛型类的时候可以声明这个泛型类对于类型参数是协变的、逆变的还是不变的：</p><ul><li><strong>convariant</strong>：<code>class C[+A] { ... }</code></li><li><strong>contravariant</strong>：<code>class C[-A] { ... }</code></li><li><strong>nonvariant</strong>：<code>class C[A] { ... }</code></li></ul><h3 id="函数的协变与逆变"><a href="#函数的协变与逆变" class="headerlink" title="函数的协变与逆变"></a>函数的协变与逆变</h3><p>函数对返回类型是协变的，对参数类型是逆变的。因此在 Scala 中，<code>Function1</code> 的定义为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="type">T</span>, +<span class="type">U</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">T</span>): <span class="type">U</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Scala-对-Variance-的检查"><a href="#Scala-对-Variance-的检查" class="headerlink" title="Scala 对 Variance 的检查"></a>Scala 对 Variance 的检查</h3><p>Scala 编译器对 variance 的检查大概为：</p><ul><li>covariant 类型只能出现在方法的返回结果中</li><li>contravariant 类型只能出现在方法的参数中</li><li>invariant 类型可以出现在任意位置</li></ul><p>这就保证了 <strong>没法</strong> 写出 covariant 的数组：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>[+<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(pos: int, x: <span class="type">T</span>) = &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Object-与协变逆变"><a href="#Object-与协变逆变" class="headerlink" title="Object 与协变逆变"></a>Object 与协变逆变</h3><p>在 <code>List</code> 的定义中我们希望 <code>Nil</code> 是 object，但是 Scala 中 object 不能带有类型参数。考虑到 <code>Nothing</code> 是所有类型的子类型，可以让 <code>Nil</code> 继承 <code>List[Nothing]</code>。但是 Scala 默认 <code>List</code> 是不变的，因此还要改成协变的。最后完成：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>[+<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">Nil</span> <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">Nothing</span>]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">this</span> <span class="title">can</span> <span class="title">be</span> <span class="title">done</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">a</span></span>: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">Nil</span></span><br></pre></td></tr></table></figure><p>去掉 <code>+T</code> 中的 <code>+</code> 是不行的，此时 <code>Nil</code> 类型为（<code>List[Nothing]</code>）不是 <code>List[String]</code> 的子类型。</p><h3 id="使用-Bound"><a href="#使用-Bound" class="headerlink" title="使用 Bound"></a>使用 Bound</h3><p>对于上面的例子，我们已经在 <code>List</code> 的类型参数中将 <code>T</code> 标记为协变的了，根据协变参数只能为返回值的约束，这个签名的函数无法出现在类的定义中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepend</span></span>(x: <span class="type">T</span>): <span class="type">List</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure><p>实际上编译器禁止这么做是合理的！如果上述方法可以使用的话，你完全可以触发前述的 Java 的问题。解决方法是使用 bound：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepend</span></span>[<span class="type">U</span> :&gt; <span class="type">T</span>](x: <span class="type">U</span>): <span class="type">List</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure><p>搞完这些事情后，你就可以把 <code>List</code> 设计成协变的，同时没有各种因为协变引起的 bug 了。</p><h2 id="对问题的解耦"><a href="#对问题的解耦" class="headerlink" title="对问题的解耦"></a>对问题的解耦</h2><p>在 Programming Languages 中学过 FP 和 OOP 是两种对问题的解耦策略。如果用 FP 解决问题较方便时，确实可以使用 OOP 搞出来，但是会比较丑陋。可能需要用到 <a href="#类型转换">类型转换</a>。</p><p>用 FP 解决问题的一大工具就是模式匹配。</p><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><h3 id="Case-Class"><a href="#Case-Class" class="headerlink" title="Case Class"></a>Case Class</h3><p>为了使用模式匹配，需要用到 case class。只要在普通的类定义前加上 <code>case</code> 修饰符即可：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br></pre></td></tr></table></figure><p>此时 Scala 会自动生成两个 object，方便你在不写 <code>new</code> 的情况下构造出对应的对象：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">Number</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span>) = <span class="keyword">new</span> <span class="type">Sum</span>(e1, e2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在要构造对象的时候可以只写 <code>Number(42)</code>，不用加 <code>new</code>。</p><p>随后就可以使用模式匹配了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(e: <span class="type">Expr</span>): <span class="type">Int</span> = e <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; eval(e1) + eval(e2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Scala 的模式匹配的模式中可以包括常量。Scala 对模式的格式有些限制，包括：</p><ul><li>常量必须首字母大写，除了 <code>null</code>，<code>true</code> 和 <code>false</code></li><li>变量必须首字母小写</li><li>同一个用作变量的标识符不能出现多次</li><li>使用 <code>_</code> 进行匹配，但是不绑定值</li></ul><h3 id="在父类中使用模式匹配"><a href="#在父类中使用模式匹配" class="headerlink" title="在父类中使用模式匹配"></a>在父类中使用模式匹配</h3><p>一种使用模式匹配的方法是在父类中使用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; e1.eval + e2.eval</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面的模式匹配的差别在于一个是过程式的，一个是 OOP 式的。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>此处讨论的是 Scala 自带的数据结构。</p><ul><li>构造列表只需要使用 <code>List(x1, x2, x3, ..., xn)</code>，或者可以使用 <code>::</code> 和 <code>Nil</code> 进行构造。此处的语法详见 <a href="右结合的操作符">右结合的操作符</a>。</li><li>列表和数组的区别：列表是不可变的，数组可变；列表是递归的，数组是 flat 的。</li><li>常用方法有 <code>isEmpty</code>，<code>head</code>，和 <code>tail</code>。</li><li>列表常和模式匹配结合。模式甚至可以直接是 <code>List(x1, x2, x3, ..., xn)</code></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>Scala 支持匿名类：如果要定义某个类的子类，但是只使用它一次的话。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> square = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>) = x * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Scala 可以判定一个对象是否是某个类的实例，并且可以进行转换：</p><ul><li><code>x.isInstanceOf[A]</code></li><li><code>x.asInstanceOf[A]</code></li></ul><p>但是这么做是不被推荐的。其中第二个方法如果无法完成转换会抛异常，因此需要被第一个方法包装一下。</p><h3 id="右结合的操作符"><a href="#右结合的操作符" class="headerlink" title="右结合的操作符"></a>右结合的操作符</h3><p>Scala 中的一个 convention 是，以 <code>:</code> 结尾的操作符的结合性一般是右结合的。</p><p>但是这是如何实现的呢？Scala 中的二元操作符本质上只是一个接受一个参数的方法。Scala 规定以 <code>:</code> 结尾的操作符中，操作符右边是具有方法的对象，左边是参数。和正常的操作符刚好反过来。因此：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> :: <span class="number">2</span> :: <span class="number">3</span> :: <span class="number">4</span> :: <span class="type">Nil</span></span><br></pre></td></tr></table></figure><p>实际上是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Nil</span>.::(<span class="number">4</span>).::(<span class="number">3</span>).::(<span class="number">2</span>).::(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Functional Programming Principles in Scala 笔记 6 Collections</title>
      <link href="/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-6-Collections/"/>
      <url>/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-6-Collections/</url>
      
        <content type="html"><![CDATA[<h2 id="其它线性结构"><a href="#其它线性结构" class="headerlink" title="其它线性结构"></a>其它线性结构</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><code>Vector</code></h3><p>实现上，<code>Vector</code> 是一棵很浅的树，每个结点可能有 32 个子结点，这样对缓存是比较友好的。</p><p><code>Vector</code> 的随机访问 <strong>可以看作是</strong> 常数时间的，实际上增长非常缓慢。</p><p><code>Vector</code> 适用于需要批量访问的场景，例如 <code>map</code> 操作。</p><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a><code>Range</code></h3><p><code>Range</code> 表示整数的一个范围。使用 <code>to</code> 表示包括上界，<code>until</code> 不包括上界，可使用 <code>by</code> 指定步长。</p><hr><p>Scala 中有个叫 <code>Seq</code> 的类型。<code>List</code>、<code>Vector</code> 和 <code>Range</code> 都是它的子类型。还有个叫 <code>IndexedSequence</code> 的类，<code>Vector</code> 和 <code>Range</code> 都是它的子类。<code>IndexedSequence</code> 也是 <code>Seq</code> 的子类。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h3><p>来自 Java。</p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a><code>Array</code></h3><p>来自 Java。</p><h3 id="线性结构可以进行的操作"><a href="#线性结构可以进行的操作" class="headerlink" title="线性结构可以进行的操作"></a>线性结构可以进行的操作</h3><p>除了前面提到的列表上的操作外，还有：</p><ul><li><code>exists</code> 和 <code>forall</code> 量词</li><li><code>zip</code> 和 <code>unzip</code></li><li><code>flatMap</code>：将线性结构中的每个元素映射为一个 collection，然后将这些 collection 合并；也可以先进行 <code>map</code> 然后执行 <code>flatten</code></li><li><code>sum</code> 和 <code>product</code> 求和、求积</li><li><code>max</code> 和 <code>min</code> 取出最大元素和最小元素</li><li><code>sorted</code> 按自然序进行排序，<code>sortBy</code> 指定排序依据</li><li><code>groupBy</code> 可以按指定方法进行分组，会得到一个 <a href="#`Map`"><code>Map</code></a></li></ul><p>实际上上述方法对 <code>Iterable</code> 都是可以使用的。</p><h2 id="For-Expression"><a href="#For-Expression" class="headerlink" title="For Expression"></a>For Expression</h2><p>For expression 类似 Python 中的 list comprehension。实际上它就是一个先 <code>filter</code> 再 <code>map</code> 的操作。</p><p>语法示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  i &lt;- <span class="number">1</span> to <span class="number">9</span></span><br><span class="line">  j &lt;- <span class="number">1</span> until <span class="number">10</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#125; <span class="keyword">yield</span> (println(i + <span class="string">"*"</span> + j + <span class="string">"="</span> + i * j))</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h2><p>Scala 中的 <code>Iterable</code> 包括 <code>Seq</code>、<code>Set</code> 和 <code>Map</code>。</p><p><code>Set</code> 和 <code>Seq</code> 的主要区别：</p><ul><li><code>Set</code> 是无序的</li><li><code>Set</code> 不包括重复元素</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h2><p>Scala 中的 <code>Map</code> 即为映射。</p><p>构造方式为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = <span class="type">Map</span>(<span class="string">"one"</span> -&gt; <span class="number">1</span>, <span class="string">"two"</span> -&gt; <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>经过我的测试，<code>a -&gt; b</code> 实际上就是 <code>(a, b)</code>。</p></blockquote><p>有趣的是，<code>Map[A, B]</code> 是 <code>A =&gt; B</code> 的子类型。很多使用函数的地方都可以直接传入一个 <code>Map</code> 进去。如果希望在键不存在的时候返回特殊值而不是抛异常，可以使用 <code>get</code> 函数，它会返回 <code>Option[B]</code>。</p><p>对一个 <code>Map</code> 使用 <code>withDefaultValue</code> 可以将其转化为一个 total 的函数。它对不存在的键会返回默认值。</p><h2 id="Option"><a href="#Option" class="headerlink" title="Option"></a><code>Option</code></h2><p>和 Haskell 中的 <code>Maybe</code> 类似。可能的实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Option</span>[+<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Some</span>[+<span class="type">T</span>](<span class="params">value: <span class="type">A</span></span>) <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">None</span> <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">Nothing</span>]</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="模式匹配的简写"><a href="#模式匹配的简写" class="headerlink" title="模式匹配的简写"></a>模式匹配的简写</h3><p>例如希望计算两个 <code>Vector[Double]</code> 的内积：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerProduct</span></span>(xs: <span class="type">Vector</span>[<span class="type">Double</span>], ys: <span class="type">Vector</span>[<span class="type">Double</span>]): <span class="type">Double</span> = &#123;</span><br><span class="line">  (xs zip ys).map(xy =&gt; xy._1 * xy._2).sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写，在 lambda 函数那里比较丑陋。我们希望能够直接 unpack 出元组的元素，这就要使用模式匹配。此处可以简写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerProduct</span></span>(xs: <span class="type">Vector</span>[<span class="type">Double</span>], ys: <span class="type">Vector</span>[<span class="type">Double</span>]): <span class="type">Double</span> = &#123;</span><br><span class="line">  (xs zip ys).map(&#123; <span class="keyword">case</span> (x, y) =&gt; x * y &#125;).sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体规则是，缺少 <code>match</code> 的模式匹配 <code>{ case ... =&gt; ...; ... }</code> 相当于 <code>x =&gt; match x { case ... =&gt; ...; ... }</code>。</p><p>实际上可以省略掉括号写成：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerProduct</span></span>(xs: <span class="type">Vector</span>[<span class="type">Double</span>], ys: <span class="type">Vector</span>[<span class="type">Double</span>]): <span class="type">Double</span> = &#123;</span><br><span class="line">  ((xs zip ys) map &#123; <span class="keyword">case</span> (x, y) =&gt; x * y &#125;).sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><p>Scala 支持变长参数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(bar: (<span class="type">Int</span>, <span class="type">Boolean</span>)*) = &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- bar <span class="keyword">if</span> i._2) <span class="keyword">yield</span> println(i)</span><br><span class="line">  <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo((<span class="number">3</span>, <span class="literal">true</span>), (<span class="number">2</span>, <span class="literal">false</span>), (<span class="number">1</span>, <span class="literal">true</span>), (<span class="number">0</span>, <span class="literal">true</span>), (<span class="number">-1</span>, <span class="literal">false</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Functional Programming Principles in Scala 笔记 5 Lists</title>
      <link href="/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-5-Lists/"/>
      <url>/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-5-Lists/</url>
      
        <content type="html"><![CDATA[<h2 id="List-上的其它操作"><a href="#List-上的其它操作" class="headerlink" title="List 上的其它操作"></a><code>List</code> 上的其它操作</h2><h3 id="普通操作"><a href="#普通操作" class="headerlink" title="普通操作"></a>普通操作</h3><ul><li><code>length</code>，<code>last</code>，<code>init</code>，<code>take</code>，<code>drop</code> 和字面意思一致。</li><li><code>xs(n)</code> 可以取出 <code>xs</code> 的第 n 个元素。</li><li><code>++</code> 连接列表。</li><li><code>reverse</code> 翻转列表。</li><li>用 <code>updated</code>：更新某个位置上的元素，返回一个新的列表。</li><li>用 <code>indexOf</code> 和 <code>contains</code> 寻找元素。</li></ul><h3 id="高阶函数操作"><a href="#高阶函数操作" class="headerlink" title="高阶函数操作"></a>高阶函数操作</h3><p>除了常见的 <code>map</code>、<code>filter</code> 外：</p><ul><li>和 <code>filter</code> 相反的 <code>filterNot</code>。</li><li><code>partition</code> 可以根据谓词将列表分成两部分。</li><li><code>takeWhile</code> 和 <code>dropWhile</code>。</li><li><code>span</code> 结合了 <code>takeWhile</code> 和 <code>dropWhile</code>，但是效率更高，只要一遍遍历。</li></ul><hr><p>列表的 reduction 可以通过 <code>reduceLeft</code> 和 <code>reduceRight</code> 实现。这里可能可以用到 Scala 中的一个 <a href="#匿名函数语法糖">语法糖</a>。</p><p>Reduce 操作不需要初始累加器，而 fold 操作需要。Fold 比 reduce 泛化抽象程度更高，因为 reduce 的累加器和列表的元素类型要相同。</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>Scala 中的元组用小括号进行构造。元组可以作为模式被匹配：<code>val (x, y) = (3, true)</code>。</p><p>Scala 中的元组本质上是 <code>Tuplen[T1, T2, ..., Tn]</code> 的实例，表达式和模式也是类似的。它的实现可能是</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2</span>[<span class="type">T1</span>, <span class="type">T2</span>](<span class="params">_1: +<span class="type">T1</span>, _2: +<span class="type">T2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">"("</span> + _1 + <span class="string">","</span> + _2 + <span class="string">")"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此索引使用的是 <code>_1</code> 和 <code>_2</code> 这种别扭的方式。可以看作是语法盐。</p><h2 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h2><p><strong>这是其它语言中基本没有的规则。</strong>假如我们要写一个通用的 <code>max</code> 函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>[<span class="type">T</span>](x: <span class="type">T</span>, y: <span class="type">T</span>) = <span class="keyword">if</span> (x &gt; y) x <span class="keyword">else</span> y</span><br></pre></td></tr></table></figure><p>但这么做无法通过编译，因为 <code>&gt;</code> 不一定是 <code>x</code> 的成员（<code>x</code> 类型为 <code>T</code>）。也就是说 <code>T</code> 不一定是可比较的。为此我们要引入某种比较 <code>T</code> 的策略，标准库中的 <code>Ordering</code> trait 提供了这么一个功能：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>[<span class="type">T</span>](x: <span class="type">T</span>, y: <span class="type">T</span>)(ord: <span class="type">Ordering</span>[<span class="type">T</span>]) = <span class="keyword">if</span> (ord.gt(x, y)) x <span class="keyword">else</span> y</span><br></pre></td></tr></table></figure><p>现在可以通过编译了。如果想取整数的较大值，只要执行 <code>max(2, 3)(Ordering.Int)</code>；取字符串的较大值只要 <code>max(&quot;foo&quot;, &quot;bar&quot;)(Ordering.String)</code>。其中 <code>Ordering.Int</code> 是 <code>Ordering[Int]</code> 的实例，由标准库自带。</p><p>但是这么做还是太麻烦了。通过使用 <em>隐式参数</em> 可以避免掉 <code>max</code> 的 <code>ord</code> 参数，只要改成：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>[<span class="type">T</span>](x: <span class="type">T</span>, y: <span class="type">T</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]) = <span class="keyword">if</span> (ord.gt(x, y)) x <span class="keyword">else</span> y</span><br></pre></td></tr></table></figure><p>在调用 <code>max</code> 时，Scala 会自己找一个合适的参数送进去。规则是：</p><ul><li>对应的参数也应该被标记为 <code>implicit</code></li><li>二者类型兼容</li><li>在调用 <code>max</code> 时对 <code>max</code> 是可见的</li></ul><p>如果找到了唯一的参数，则正常编译。如果没有找到或者有多个符合规则，则报错。</p><a id="more"></a><h2 id="程序的正确性证明"><a href="#程序的正确性证明" class="headerlink" title="程序的正确性证明"></a>程序的正确性证明</h2><p>证明一般是要证明一些性质。和数学归纳法类似，程序的正确性证明要对数据的结构做某种规约。</p><p>如果要证明某个操作在列表上会保持某些性质，一般要证明在空列表上保持（Base step），并且在列表 prepend 操作上保持（Inductive step）。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="匿名函数语法糖"><a href="#匿名函数语法糖" class="headerlink" title="匿名函数语法糖"></a>匿名函数语法糖</h3><p><code>((x, y, z) =&gt; x * y + z)</code> 可以简写为 <code>(_ * _ + _)</code>，规则是，每次遇到 <code>_</code> 都会引入新的参数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Functional Programming Principles in Scala 笔记 3 Data and Abstraction</title>
      <link href="/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-3-Data-and-Abstraction/"/>
      <url>/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-3-Data-and-Abstraction/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类使用 <code>abstract</code> 修饰，无须对方法进行定义，无法被实例化。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x: <span class="type">Int</span>): <span class="type">Boolean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">include</span></span>(x: <span class="type">Int</span>): <span class="type">IntSet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承与实现"><a href="#继承与实现" class="headerlink" title="继承与实现"></a>继承与实现</h2><p>使用 <code>extends</code> 继承其它类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonEmpty</span>(<span class="params">elem: <span class="type">Int</span>, left: <span class="type">IntSet</span>, right: <span class="type">IntSet</span></span>) <span class="keyword">extends</span> <span class="title">IntSet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x: <span class="type">Int</span>) =</span><br><span class="line">    <span class="keyword">if</span> (x &lt; elem) left contains x</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; elem) right contains x</span><br><span class="line">    <span class="keyword">else</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">include</span></span>(x: <span class="type">Int</span>) =</span><br><span class="line">    <span class="keyword">if</span> (x &lt; elem) <span class="keyword">new</span> <span class="type">NonEmpty</span>(elem, left include x, right)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; elem) <span class="keyword">new</span> <span class="type">NonEmpty</span>(elem, left, right include x)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">IntSet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x: <span class="type">Int</span>) = <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">include</span></span>(x: <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">NonEmpty</span>(x, <span class="keyword">new</span> <span class="type">Empty</span>, <span class="keyword">new</span> <span class="type">Empty</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有指定继承哪个类，则继承自 <code>Object</code> 类。</p><p>如果在子类中要定义的东西已经在父类中被定义了，则必须加上 <code>override</code> 修饰：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">IntSet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x: <span class="type">Int</span>) = <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">include</span></span>(x: <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">NonEmpty</span>(x, <span class="keyword">new</span> <span class="type">Empty</span>, <span class="keyword">new</span> <span class="type">Empty</span>)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">"&#123;&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要定义的东西在父类中是抽象的，那么加不加 <code>override</code> 都可以。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Scala 提供了 object 这种抽象，可以认为是在语言层面上直接提供了单例。比如上例中实际上只要全局有一个 <code>Empty</code> 就可以了。只要将 <code>class</code> 换成 <code>object</code>；此外，<code>object</code> 不支持 <code>new</code>，只要使用类型名就可以访问唯一的实例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">IntSet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x: <span class="type">Int</span>) = <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">include</span></span>(x: <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">NonEmpty</span>(x, <span class="type">Empty</span>, <span class="type">Empty</span>)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">"&#123;&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>如果建立了一个带有以下方法的 <code>object</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后可以直接使用 <code>scala Foo</code> 来将对应的 <code>main</code> 方法作为程序入口点。</p><h2 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h2><p>使用 <code>package</code> 来声明一个包。</p><p>外部要使用这个包中的内容时要写出类的完整路径。可以通过 <code>import</code> 语句避免掉这种麻烦。</p><p><code>import</code> 时可以使用通配符 <code>_</code>，或者使用 <code>{..., ...}</code> 的语法一次导入多个类。</p><p>Scala 程序中有些东西是自动导入的，包括：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala._</span><br><span class="line"><span class="keyword">import</span> java.lang._</span><br><span class="line"><span class="keyword">import</span> scala.<span class="type">Predef</span>._</span><br></pre></td></tr></table></figure><p>这些包中包括 <code>require</code>，<code>assert</code> 等。</p><h2 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h2><p>Scala 是单继承的。Scala 中的类只能继承自一个类，但是可以使用 <code>with</code> 继承多个 traits。相当于 Ruby 中的 mixin。</p><p>实际上：</p><blockquote><p>If you have multiple classes or traits to inherit, the first one is always <code>extends</code>, and the following &gt;=0 <code>class</code>/<code>trait</code> to be <code>with</code>s.</p></blockquote><p>Java 中的接口和 Scala 中的 trait 类似，区别在于 trait 可以含有自己的状态以及具体的方法。Trait 比类弱的地方在于它本身不能单独被构造，没有构造参数。</p><a id="more"></a><h2 id="特殊的类型"><a href="#特殊的类型" class="headerlink" title="特殊的类型"></a>特殊的类型</h2><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>Scala 中的几种基础类型：</p><ul><li><code>Any</code> 是所有类型的子类型。</li><li><code>AnyRef</code> 所有引用类型的子类型。</li><li><code>AnyVal</code> 所有值类型的子类型。</li></ul><p>和 Java 不同，Java 中的 <code>int</code> 已经是最底层的类型了，但是 Scala 中它还能被 <code>AnyVal</code> 甚至 <code>Any</code> 替代，因此 <code>List(1, true, null)</code> 是合法的（类型为 <code>List[Any]</code>）。</p><h3 id="Bottom-Type-和-Null-Type"><a href="#Bottom-Type-和-Null-Type" class="headerlink" title="Bottom Type 和 Null Type"></a>Bottom Type 和 Null Type</h3><p><code>Nothing</code> 类型不包含任何值，常用来表示不终止的计算。例如 <code>throw exception</code> 这个表达式的类型就是 <code>Nothing</code>。</p><p><code>Null</code> 类型是所有引用类型的子类型。它具有一个值 <code>null</code>。任何能够出现 <code>AnyRef</code> 的地方都可以出现 <code>Null</code>，但是所有能够出现 <code>AnyVal</code> 的地方都不能出现 <code>Null</code>。</p><hr><p>Scala 中有个叫 <code>Unit</code> 的值类型，所谓的 <code>Unit</code> 类型指的是只能取一个值的类型（类似 <code>Null</code>），它无法承载任何信息。<code>Unit</code> 和 <code>Nothing</code> 的区别有些微妙，它们一般用来作为函数的返回类型，区别在于：</p><ul><li>如果函数的返回类型是 <code>Unit</code>，表示 <strong>逻辑上这个函数不返回有意义的值</strong>，可以看作是一个过程。</li><li>如果函数的返回类型是 <code>Nothing</code>，表示 <strong>这个函数无法终止</strong>，唯一退出这个函数的方法是抛出异常。</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>Scala 中的泛型参数用中括号扩起，下面是一个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">List</span>[<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Cons</span>[<span class="type">T</span>](<span class="params">val head: <span class="type">T</span>, val tail: <span class="type">List</span>[<span class="type">T</span>]</span>) <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Nil</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">T</span>]</span></span><br></pre></td></tr></table></figure><p>上面用到了一个语法糖，见 <a href="#类构造的语法糖">笔记末尾</a>。</p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>同样使用中括号。定义和调用的时候都要加上：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span></span>[<span class="type">T</span>](elem: <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">Cons</span>[<span class="type">T</span>](elem, <span class="keyword">new</span> <span class="type">Nil</span>[<span class="type">T</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> a = singleton[<span class="type">Int</span>](<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>不过大部分情况下 Scala 会进行类型推到，调用时的类型声明是可以省掉的。</p><h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p>Polymorphism 在 Scala 中的表现有两种，一个是 OOP 中的继承带来的 <em>子类型</em>，还有一个就是泛型。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="类构造的语法糖"><a href="#类构造的语法糖" class="headerlink" title="类构造的语法糖"></a>类构造的语法糖</h3><p>Scala 中，类的构造有个语法糖：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">_a: <span class="type">Int</span>, _b: <span class="type">Int</span>, _c: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> a = _a</span><br><span class="line">  <span class="keyword">val</span> b = _b</span><br><span class="line">  <span class="keyword">val</span> c = _c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做太无聊了，因此可以写成</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">val a: <span class="type">Int</span>, val b: <span class="type">Int</span>, val c: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Functional Programming Principles in Scala 笔记 2 Higher Order Functions</title>
      <link href="/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-2-Higher-Order-Functions/"/>
      <url>/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-2-Higher-Order-Functions/</url>
      
        <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数是参数或者返回值是函数的函数。语法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>, a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> f(a) + sum(f, a + <span class="number">1</span>, b)</span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>Scala 中的匿名函数的语法为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y</span><br></pre></td></tr></table></figure><p>如果参数的类型可以被编译器推断，那么它们也是可以省略的。</p><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>Scala 中定义柯里化的函数只需要在定义和使用时在函数名后面用多个括号：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapInt</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>)(xs: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">Int</span>] =</span><br><span class="line">  <span class="keyword">if</span> (xs.isEmpty) <span class="type">List</span>() <span class="keyword">else</span> f(xs.head) :: mapInt(f)(xs.tail)</span><br></pre></td></tr></table></figure><p>出于某些我现在不知道的原因，把偏函数赋给变量时要在不带参数的部分写上 <code>_</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> doubler = mapInt(x =&gt; <span class="number">2</span> * x) _</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>仿照如下的例子定义一个类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure><p>此时会得到类型 <code>Rational</code> 和对应的构造函数 <code>Rational</code>。二者名字相同，但是 Scala 会自己加以区分。</p><p>使用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>来构造类的 object。</p><p>不过，无法通过 <code>a.x</code> 来访问构造时传入的参数。</p><h3 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h3><p>扩展上面的例子，加入两个成员：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以使用这些成员了，它们实际上是不带参数的函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(a.numer)</span><br><span class="line">print(a.denom)</span><br></pre></td></tr></table></figure><p>实际上将前面定义中的 <code>def</code> 换成 <code>val</code> 也是可以的。</p><p>自然，类里面是可以定义带参数的方法的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(that: <span class="type">Rational</span>) = <span class="keyword">new</span> <span class="type">Rational</span>(</span><br><span class="line">    numer * that.denom + that.numer * denom, denom * that.denom</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中可以通过访问 <code>this</code> 来获取当前实例。</p><a id="more"></a><h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>类在初始化时可以放置一些前置条件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  require(y != <span class="number">0</span>, <span class="string">"denominator must be nonzero"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>在代码中使用 <code>assert</code> 进行断言。</p><p>断言用来检查代码本身，而前置条件用来约束代码的使用者。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>对于每个类，Scala 会自动生成一个 primary constructor。它的参数是类的参数，执行该构造函数时会顺次执行类的定义中的语句，这就是为什么 <code>require</code> 会被执行。</p><p>也可以自定义一些构造函数。关键字是 <code>this</code>。构造函数本身还可以调用其它构造函数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(x: <span class="type">Int</span>) = <span class="keyword">this</span>(x, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>对于只有一个参数的函数，<code>.</code> 和括号都可以省略，看起来就会像中缀运算符。也就是说你可以把 <code>a.add(b)</code> 直接写成 <code>a add b</code>。</p><p>Scala 中的标识符的规则和其它语言不一样，它是可以含有符号的。一个标识符可以：</p><ul><li>像其他语言一样，字母（或下划线）开头，然后是字母（或下划线）和数字的序列；</li><li>完全由符号构成的序列，例如 <code>+?%&amp;</code>；</li><li>由第一条规则构造出的序列，接一个下划线，再接一个由第二条规则构成的序列。</li></ul><p>合理应用上述规则，会得到：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(that: <span class="type">Rational</span>) = <span class="keyword">new</span> <span class="type">Rational</span>(</span><br><span class="line">    numer * that.denom + that.numer * denom, denom * that.denom</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> a = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> b = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> c = a + b</span><br></pre></td></tr></table></figure><p>单目操作符也是可以搞的。按照 Scala 的规则，其命名应该为 <code>unary_</code> 后面跟着实际的名称：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unary_-</span> </span>= <span class="keyword">new</span> <span class="type">Rational</span>(-numer, denom)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> a = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> b = -a</span><br></pre></td></tr></table></figure><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>对于自己定义的这些操作符，优先级是如何确定的？每个操作符的第一个字符反映了该操作符的优先级。Scala 对不同字符定义了不同优先级。例如 <code>*</code> 的优先级比 <code>+</code> 高，因此 <code>a *$% b +@#$ c *@#$ d</code> 的实际顺序是 <code>(a *$% b) +@#$ (c *@#$ d)</code>。</p><p><code>a + b ^? c ?^ d less a ==&gt; b | c</code> 的求值顺序是 <code>((a + b) ^? (c ?^ d)) less ((a ==&gt; b) | c)</code>。特殊符号的优先级最高，字母的优先级最低。中间的那些字符的优先级和其他语言中常使用的惯例相同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Functional Programming Principles in Scala 笔记 1 Functions &amp; Evaluation</title>
      <link href="/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-1-Functions-Evaluation/"/>
      <url>/2019/04/17/Functional-Programming-Principles-in-Scala-%E7%AC%94%E8%AE%B0-1-Functions-Evaluation/</url>
      
        <content type="html"><![CDATA[<p>课程来源 <a href="https://www.coursera.org/learn/progfun1/" target="_blank" rel="noopener">Coursera</a>。</p><h2 id="求值策略"><a href="#求值策略" class="headerlink" title="求值策略"></a>求值策略</h2><h3 id="Call-by-Value-与-Call-by-Name"><a href="#Call-by-Value-与-Call-by-Name" class="headerlink" title="Call by Value 与 Call by Name"></a>Call by Value 与 Call by Name</h3><p>程序对函数调用的求值策略有 call by value 和 call by name 两种。</p><ul><li>前者在函数调用前先对参数求值，然后将参数的值代入函数体中。</li><li>后者直接将参数的表达式代入到函数体中，然后对函数体求值。</li></ul><p>两种方式各有优点。前者不会对参数重复求值，后者不会对不被使用的参数求值。根据 lambda 运算理论，只要整个求值过程中没有副作用，并且两个过程都能终止，那么最后的结果总是相同的。</p><hr><p>另一个常被提及的是 call by reference。然而这是一种传递参数的策略，而不是求值策略。为了防止混淆，我把按值传递和按引用传递叫做 pass by value 与 pass by reference。</p><h3 id="不同求值策略的终止性"><a href="#不同求值策略的终止性" class="headerlink" title="不同求值策略的终止性"></a>不同求值策略的终止性</h3><p>根据相关理论，如果 call by value 可以终止，那么 call by name 也可以终止，反之不成立。但是一般的语言（包括 Scala）总是默认 call by value，因为这样效率更高。</p><p>Scala 允许让函数对某个参数运用 call by name 的策略，只要在函数签名中参数的类型声明前加上箭头：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constOne</span></span>(x: <span class="type">Int</span>, y: =&gt; <span class="type">Int</span>) = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面的函数省略了返回类型，Scala 会自己推导；不过它推导不出自递归函数的返回类型。语法上看胖箭头也是函数类型的一部分，我感觉这么做实际上是对 <code>y</code> 传了一个函数进去。</p><p>它可以让你用函数实现逻辑表达式的短路求值效果：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">and</span></span>(x: <span class="type">Boolean</span>, y: =&gt; <span class="type">Boolean</span>) = <span class="keyword">if</span> (x) y <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">or</span></span>(x: <span class="type">Boolean</span>, y: =&gt; <span class="type">Boolean</span>) = <span class="keyword">if</span> (x) <span class="literal">true</span> <span class="keyword">else</span> y</span><br></pre></td></tr></table></figure><p>现在，即使对 <code>y</code> 的求值无法终止，<code>and</code> 和 <code>or</code> 在某些情况下也可以终止。</p><h2 id="def-与-val"><a href="#def-与-val" class="headerlink" title="def 与 val"></a><code>def</code> 与 <code>val</code></h2><p><code>def</code> 用来定义变量（以及函数），而 <code>val</code> 用来求值。它们可以分别看做是 call by name 和 call by value 的声明版本。</p><p>首先定义一个无法终止的函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>: <span class="type">Int</span> = loop</span><br></pre></td></tr></table></figure><p>对于</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span> </span>= loop</span><br><span class="line"><span class="keyword">val</span> b = loop</span><br></pre></td></tr></table></figure><p>两条语句，前者可以终止，而后者会将 <code>loop</code> 的值求出后再赋给 <code>b</code>，因此无法终止。</p><a id="more"></a><h2 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h2><p>Scala 中可以使用 blocks 来构建语句或者表达式的序列：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(y: <span class="type">Int</span>) = y +<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = &#123;</span><br><span class="line">  <span class="keyword">val</span> x = f(<span class="number">3</span>);</span><br><span class="line">  x * x</span><br><span class="line">&#125; + x</span><br></pre></td></tr></table></figure><p>Block 中定义的东西只有该 block 可见；并且会 shadow 掉外面的定义。</p><p>Block 中定义的函数的函数体可以直接访问 block 中的变量：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(x: <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span></span>(y: <span class="type">Int</span>) = x + y</span><br><span class="line">    g(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>Scala 中只有自己调用自己的尾调用被自动优化了。可以在函数定义前加上 <code>@tailrec</code> 来表示这个函数是尾递归的。这相当于作了一个 assertion，如果函数实际上不是尾递归的则会触发错误。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式化验证课程笔记 8</title>
      <link href="/2019/04/15/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-8/"/>
      <url>/2019/04/15/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-8/</url>
      
        <content type="html"><![CDATA[<h1 id="第八周"><a href="#第八周" class="headerlink" title="第八周"></a>第八周</h1><h2 id="程序语义描述方法"><a href="#程序语义描述方法" class="headerlink" title="程序语义描述方法"></a>程序语义描述方法</h2><ul><li><strong>操作语义</strong>：描述程序执行过程中状态的改变，与语言的实现联系紧密。</li><li><strong>指称语义</strong>：只关心执行效果，不关心实现。</li><li><strong>公理语义</strong>：使用相关方法进行对语义建模，使用数学方法进行研究。</li></ul><h2 id="一个示例语言"><a href="#一个示例语言" class="headerlink" title="一个示例语言"></a>一个示例语言</h2><p>这个语言称为 while 语言，包括：</p><ul><li>来自数字集合 Num 的数字 n</li><li>来自变量集合 Var 的变量 v</li><li>来自算术表达式集合 Aexp 的算术表达式 a</li><li>来自布尔表达式集合 Bexp 的布尔表达式 b</li><li>来自语句集合 Stm 的语句 S（这个是大写）</li></ul><p>注意 <strong>程序可以看作是语句的序列</strong>。</p><p>语法：</p><script type="math/tex; mode=display">\begin{aligned}a &::= n | v | a_1 + a_2 | a_1 \ast a_2|a_1 - a_2 \\b &::= \text{true} | \text{false} | a_1 = a_2 | a_1 \le a_2 | \lnot b | b_1\land b_2 \\S &::= v:= a | \text{skip} | S_1; S_2 | \text{if }b\text{ then } S_1\text{ else } S_2 | \text{while }b\text{ do }S\end{aligned}</script><h2 id="表达式的语义"><a href="#表达式的语义" class="headerlink" title="表达式的语义"></a>表达式的语义</h2><h3 id="数字的语义"><a href="#数字的语义" class="headerlink" title="数字的语义"></a>数字的语义</h3><p>假设 while 语言中数字使用二进制进行表示，那么数字的语义实际上是一个 Num 到 $\displaystyle{\mathcal Z}$ 的映射 $\displaystyle{\mathcal N:\text{Num}\to\mathcal Z}$。其定义省略。</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>状态指的是一个变量集合到整数集合的映射。可以将其看作是对某个变量集合的 assignment。</p><p>例如一个可能的状态是 $s=[x\mapsto 5, y\mapsto 7]$。一个状态可以在另一个状态的基础上进行修改：$s&#39;=s[x\mapsto 9]$，这仅会改变 $x$ 的值。</p><h3 id="算术表达式的语义"><a href="#算术表达式的语义" class="headerlink" title="算术表达式的语义"></a>算术表达式的语义</h3><p>算术表达式的语义被语义函数 $\mathcal A$ 定义，该函数接受一个算术表达式和一个状态，返回该状态下对表达式求值的结果（不严谨，还要弄一下柯里化）：$\displaystyle{\mathcal A: \text{Aexp}\to (\text{State}\to \mathcal Z)}$。</p><p>一个性质：</p><script type="math/tex; mode=display">\begin{aligned}\mathcal A [\![ a[y\mapsto a_0] ]\!] s = \mathcal A [\![ a ]\!] (s[y\mapsto \mathcal A [\![ a_0 ]\!] s])\end{aligned}</script><p>其中 $a[y\mapsto a_0]$ 表示将表达式 $\displaystyle{a}$ 中的所有 $\displaystyle{y}$ 全部替换为表达式 $\displaystyle{a_0}$。$\displaystyle{\mathcal A [![ \cdot ]!] \cdot}$ 表示使用语义函数的结果对某表达式求值。</p><h3 id="布尔表达式的语义"><a href="#布尔表达式的语义" class="headerlink" title="布尔表达式的语义"></a>布尔表达式的语义</h3><p>与算术表达式类似，语义函数为 $\mathcal B:\text{Bexp}\to(\text{State}\to \mathcal T)$，其中 $\displaystyle{\mathcal T = \{\text{true}, \text{false}\}}$。</p><h3 id="表达式语义的性质"><a href="#表达式语义的性质" class="headerlink" title="表达式语义的性质"></a>表达式语义的性质</h3><p>算数表达式 $a$ 中出现的变量 $v$ 称为 $a$ 的自由变量；算数表达式的所有自由变量记作 $FV(a)$。对于布尔表达式可以作类似的定义。</p><a id="more"></a><h2 id="操作语义"><a href="#操作语义" class="headerlink" title="操作语义"></a>操作语义</h2><p>操作语义分为 <em>自然语义</em> 和 <em>结构操作语义</em>，其中自然语义描述的是语句操作完成时的结果，而结构操作语义描述的是各步计算过程如何发生。结构操作语义的粒度比自然语义要细很多。因此自然语义又称 <em>大步语义</em>，结构操作语义又称 <em>小步语义</em>。</p><p>使用 $\displaystyle{\langle S, s \rangle \to s&#39;}$ 来表示语句的执行。语句 $S$ 在初始状态 $\displaystyle{s}$ 下执行，执行后转移到状态 $\displaystyle{s&#39;}$。</p><h3 id="while-语言中的自然语义"><a href="#while-语言中的自然语义" class="headerlink" title="while 语言中的自然语义"></a>while 语言中的自然语义</h3><p>一些例子：</p><ul><li><strong>赋值语句的自然语义</strong>：$\displaystyle{\langle x:=a, s \rangle \to s[x\mapsto \mathcal A [![ a ]!] s]}$。</li><li><strong>skip 语句的自然语义</strong>：$\displaystyle{\langle \text{skip}, s \rangle \to s}$。</li><li><strong>复合语句的自然语义</strong>：如果 $\displaystyle{\langle S_1, s \rangle\to s&#39;, \langle S_2, s&#39; \rangle\to s&#39;&#39;}$，那么 $\displaystyle{\langle S_1; S_2 \rangle s \to s&#39;&#39;}$。</li><li><strong>循环语句</strong>：如果 $\displaystyle{\langle S, s \rangle \to s&#39;, \langle \text{while }b\text{ do }S , s&#39;\rangle \to s&#39;&#39;}$，那么当 $\displaystyle{\mathcal B [![ b ]!] s}$ 为真时，$\displaystyle{\langle \text{while }b\text{ do }S, s\rangle\to s&#39;&#39;}$，否则 $\displaystyle{\langle \text{while }b\text{ do }S, s\rangle\to s}$。</li></ul><h3 id="终止与循环"><a href="#终止与循环" class="headerlink" title="终止与循环"></a>终止与循环</h3><p>如果存在状态 $\displaystyle{s&#39;}$ 使得 $\displaystyle{\langle S, s \rangle \to s&#39;}$，则称 $\displaystyle{\langle S, s \rangle }$ 是终止的，否则是循环的。如果 $\displaystyle{S}$ 从所有的状态开始都是终止的，则称 $\displaystyle{S}$ 总是终止的。类似可以定义 <em>总是循环的</em>。</p><h3 id="语义等价"><a href="#语义等价" class="headerlink" title="语义等价"></a>语义等价</h3><p>如果对于任意状态 $\displaystyle{s}$ 和 $\displaystyle{s&#39;}$，总有 $\displaystyle{\langle S_1, s \rangle \to s&#39;}$ 当且仅当 $\displaystyle{\langle S_2, s \rangle \to s&#39;}$，那么 $S_1$ 和 $S_2$ 是语义等价的。</p><p>即使语句是循环的，也可以定义语义等价性。只要在相同状态下两个语句都是循环的，或者终止于相同的状态即可。</p><h3 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h3><p>如果对任意的语句和初始状态，$\displaystyle{\langle S, s \rangle \to s&#39;, \langle S, s \rangle \to s&#39;&#39;}$ 蕴含 $s&#39; = s&#39;&#39;$，则称自然语义具有确定性。</p><p>自然语义具有确定性。</p><h2 id="语义函数"><a href="#语义函数" class="headerlink" title="语义函数"></a>语义函数</h2><p>可以将语句的意义概括为从 State 到 State 的部分函数。</p><p>语义函数 $\displaystyle{S_{ns}:\text{Stm}\to (\text{State}\to\text{State})}$。</p><h2 id="结构操作语义"><a href="#结构操作语义" class="headerlink" title="结构操作语义"></a>结构操作语义</h2><p>结构操作语义的粒度更细。它使用 $\displaystyle{\langle S, s \rangle \Rightarrow \langle S&#39;, s&#39; \rangle }$ 来表示语句 $S$ 在初始状态 $s$ 下执行到某个中间状态 $s&#39;$，而下一条要执行的语句是 $S&#39;$。如果 $S$ 执行完后到了状态 $\displaystyle{s&#39;&#39;}$，也可以沿用自然语义中的符号 $\displaystyle{\langle S, s \rangle \Rightarrow s&#39;&#39;}$。</p><p>使用结构操作语义可以更加细致地描述语句的执行过程。例如当 $\displaystyle{\mathcal B [![ b ]!] s}$ 为真时，$\displaystyle{\langle\text{if }b \text{ then }S_1\text{ else} S_2, s\rangle\Rightarrow \langle S_1, s \rangle}$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 形式化验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Z3 学习笔记</title>
      <link href="/2019/04/09/Z3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/04/09/Z3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Z3-学习笔记"><a href="#Z3-学习笔记" class="headerlink" title="Z3 学习笔记"></a>Z3 学习笔记</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Z3 is a theorem prover which can be used to check the satisfiability of logical formulas over theories.</p><h2 id="Basic-Commands"><a href="#Basic-Commands" class="headerlink" title="Basic Commands"></a>Basic Commands</h2><p>A Z3 script is a sequence of commands defined by SMT-LIB 2.0 standard.</p><p>The syntax is like Racket.</p><ul><li><code>echo</code> to print something.</li><li><code>declare-const</code> to declare a constant. (No value needed.)</li><li><code>declare-fun</code> to declare a function. (No definition needed.)</li><li><code>assert</code> to make assertions, which will be used to check satisfiability.</li><li><code>check-sat</code> to check the satisfiability of all assertions.</li><li><code>get-model</code> to get the assignment if all assertions are satisfiable.</li></ul><p>The result of <code>get-model</code> uses <code>define-fun</code> to define functions.</p><p>An <code>ite</code> expression stands for an if-then-else branch.</p><h3 id="Using-Scopes"><a href="#Using-Scopes" class="headerlink" title="Using Scopes"></a>Using Scopes</h3><p>Z3 uses a global stack to store all declarations. This is useful if you want to prove multiple independent theories using some common declarations.</p><p>Use <code>push</code> to enter a new stack frame and use <code>pop</code> to exit the current stack frame.</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>Use <code>set-option</code> to configure Z3. Use <code>reset</code> to remove all configurations and assertions.</p><p>Some parameters for <code>set-option</code>:</p><ul><li><code>:print-success</code> will toggle printing <code>success</code> for commands.</li><li><code>:produce-unsat-cores</code> will toggle generation of unsat cores.</li><li><code>:produce-models</code> will toggle model generation.</li><li><code>:produce-proofs</code> will toggle proof generation.</li></ul><h3 id="Additional-Commands"><a href="#Additional-Commands" class="headerlink" title="Additional Commands"></a>Additional Commands</h3><ul><li><code>display</code> to pretty print an expression.</li><li><code>simplify</code> to simplify an expression. Many options are available.</li><li><code>define-sort</code> to define a new type. The type can be parameterized.</li></ul><p>You may need <code>as</code> as something like type annotations when dealing with parameterized types.</p><h2 id="Propositional-Logic"><a href="#Propositional-Logic" class="headerlink" title="Propositional Logic"></a>Propositional Logic</h2><p>Use <code>and</code>, <code>or</code>, <code>xor</code>, <code>not</code>, <code>=&gt;</code> (for $\rightarrow$) and <code>=</code> (for $\leftrightarrow$) for logical connectives.</p><h3 id="Satisfiability-and-Validity"><a href="#Satisfiability-and-Validity" class="headerlink" title="Satisfiability and Validity"></a>Satisfiability and Validity</h3><p>If you want to prove $F$ is valid, you can ask Z3 to prove $\lnot F$ is unsatisfiable.</p><h2 id="Uninterpreted-Functions-and-Constants"><a href="#Uninterpreted-Functions-and-Constants" class="headerlink" title="Uninterpreted Functions and Constants"></a>Uninterpreted Functions and Constants</h2><p><strong>Constants are function taking no parameters, so everything are functions.</strong></p><p>Functions in first-order logic should be pure and total.</p><p>Use <code>declare-sort</code> to declare a unspecified type.</p><h2 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h2><p>Z3 supports integers and real numbers.</p><h3 id="Nonlinear-Arithmetic"><a href="#Nonlinear-Arithmetic" class="headerlink" title="Nonlinear Arithmetic"></a>Nonlinear Arithmetic</h3><p>A formula with expression <code>* m n</code> where <code>m</code> and <code>n</code> are neither numbers is called <strong><em>nonlinear</em></strong>. Nonlinear integer arithmetic is <strong>undecidable</strong>.</p><p>Z3 can only solve some of the nonlinear arithmetic problems.</p><h3 id="Division"><a href="#Division" class="headerlink" title="Division"></a>Division</h3><p>Z3 support real number division <code>/</code>, integer division <code>div</code>, modulo <code>mod</code> and remainder <code>rem</code>.</p><p>The result of division by zero is not specified due to all functions need to be total. It can be any result if Z3 wants. You may need a wrapper to avoid this.</p><a id="more"></a><h2 id="Bitvectors"><a href="#Bitvectors" class="headerlink" title="Bitvectors"></a>Bitvectors</h2><p>Bitvector theory is a theory for modeling the semantics of unsigned and signed arithmetic in the computer.</p><p>The type of bitvector with length $n$ is <code>(_ BitVec n)</code>.</p><p>Supported operations:</p><p><strong>Arithmetic</strong>:</p><ul><li><code>bvadd</code> addition</li><li><code>bvsub</code> subtraction</li><li><code>bvneg</code> negation</li><li><code>bvmul</code> multiplication</li><li><code>bvurem</code> unsigned remainder</li><li><code>bvsrem</code> signed remainder</li><li><code>bvsmod</code> signed modulo</li><li><code>bvshl</code> shift left</li><li><code>bvlshr</code> logical shift right</li><li><code>bvashr</code> arithmetic shift right</li></ul><p><strong>Bitwise</strong>:</p><ul><li><code>bvor</code></li><li><code>bvand</code></li><li><code>bvnot</code></li><li><code>bvnand</code></li><li><code>bvnor</code></li><li><code>bvxor</code></li></ul><p><strong>Predicate</strong>:</p><p><code>u</code> means unsigned while <code>s</code> means signed. <code>le</code> means less than or equal to, others are similar.</p><ul><li><code>bvule</code></li><li><code>bvult</code></li><li><code>bvuge</code></li><li><code>bvugt</code></li><li><code>bvsle</code></li><li><code>bvslt</code></li><li><code>bvsge</code></li><li><code>bvsgt</code></li></ul><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Z3 supports array select (array read), array store (array write). It also supports array equality.</p><h3 id="Select-and-Store"><a href="#Select-and-Store" class="headerlink" title="Select and Store"></a>Select and Store</h3><p>Use <code>select</code> for array read and <code>store</code> for array write.</p><p>Array write will return a new array with the certain element is replaced.</p><h3 id="Constant-Arrays"><a href="#Constant-Arrays" class="headerlink" title="Constant Arrays"></a>Constant Arrays</h3><p>A constant array is an array of which all elements are the same constant.</p><p>It can be created as <code>(as const (Array Int Int)) 1</code>.</p><h3 id="Array-Models"><a href="#Array-Models" class="headerlink" title="Array Models"></a>Array Models</h3><p>Z3 uses constructor <code>(_ as-array f)</code> to give an interpretation for an array.</p><h3 id="Mapping-Functions-on-Arrays"><a href="#Mapping-Functions-on-Arrays" class="headerlink" title="Mapping Functions on Arrays"></a>Mapping Functions on Arrays</h3><p>You can do <code>map</code> operation on arrays.</p><h3 id="Bags-as-Arrays"><a href="#Bags-as-Arrays" class="headerlink" title="Bags as Arrays"></a>Bags as Arrays</h3><p>A bag is a data structure like multisets. It keeps the number of each element.</p><p>Bags can be implemented in Z3 with arrays.</p><h2 id="Datatypes"><a href="#Datatypes" class="headerlink" title="Datatypes"></a>Datatypes</h2><p>Use <code>declare-datatypes</code> for datatype declaration.</p><h3 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h3><p>Z3 supports records like:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">declare-datatypes</span> (<span class="name">T1</span> T2) ((<span class="name">Pair</span> (<span class="name">mk-pair</span> (<span class="name">first</span> T1) (<span class="name">second</span> T2)))))</span><br></pre></td></tr></table></figure><p>You can use <code>mk-pair</code> as the constructor, <code>first</code> and <code>second</code> as the accessors.</p><h3 id="Scalars-Enumeration"><a href="#Scalars-Enumeration" class="headerlink" title="Scalars (Enumeration)"></a>Scalars (Enumeration)</h3><p>Z3 supports enumerations like:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">declare-datatypes</span> () ((<span class="name">S</span> A B C)))</span><br></pre></td></tr></table></figure><p>Now <code>S</code> is a type having possible value <code>A</code>, <code>B</code> and <code>C</code>.</p><h3 id="Recursive-Datatypes"><a href="#Recursive-Datatypes" class="headerlink" title="Recursive Datatypes"></a>Recursive Datatypes</h3><p>Z3 supports recursive datatype, like list:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">declare-datatypes</span> (<span class="name">T</span>) ((<span class="name">Lst</span> nil (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">hd</span> T) (<span class="name">tl</span> Lst)))))</span><br></pre></td></tr></table></figure><p><code>List</code> is built-in supported by Z3. Possible operations are <code>nil</code> (for empty list), <code>head</code> and <code>tail</code>, and <code>insert</code> to insert values into the list.</p><h3 id="Mutually-Recursive-Datatypes"><a href="#Mutually-Recursive-Datatypes" class="headerlink" title="Mutually Recursive Datatypes"></a>Mutually Recursive Datatypes</h3><p>Z3 supports mutually recursive datatypes like</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">declare-datatypes</span> (<span class="name">T</span>) ((<span class="name">Tree</span> leaf (<span class="name">node</span> (<span class="name">value</span> T) (<span class="name">children</span> TreeList)))</span><br><span class="line">                        (<span class="name">TreeList</span> nil (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">car</span></span> Tree) (<span class="name"><span class="builtin-name">cdr</span></span> TreeList)))))</span><br></pre></td></tr></table></figure><p>In this example, you can use <code>is-leaf</code> to check whether a <code>Tree</code> instance is a <code>leaf</code> or a <code>node</code>.</p><h2 id="Quantifiers"><a href="#Quantifiers" class="headerlink" title="Quantifiers"></a>Quantifiers</h2><h3 id="Modeling-with-Quantifiers"><a href="#Modeling-with-Quantifiers" class="headerlink" title="Modeling with Quantifiers"></a>Modeling with Quantifiers</h3><p>Use <code>forall</code> for a universal quantifier statement.</p><h3 id="Patterns"><a href="#Patterns" class="headerlink" title="Patterns"></a>Patterns</h3><p>A pattern is an expression which contains variables bound by a quantifier. During the searching, the quantifier will be instantiated whenever the pattern is created.</p><blockquote><p><strong>This section is skipped.</strong></p></blockquote><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Z3 is usually used from programmatic APIs.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>形式化验证课程笔记 7</title>
      <link href="/2019/04/08/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-7/"/>
      <url>/2019/04/08/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-7/</url>
      
        <content type="html"><![CDATA[<h1 id="第七周"><a href="#第七周" class="headerlink" title="第七周"></a>第七周</h1><h2 id="Decision-Procedure-for-Array-Property-Fragment"><a href="#Decision-Procedure-for-Array-Property-Fragment" class="headerlink" title="Decision Procedure for Array Property Fragment"></a>Decision Procedure for Array Property Fragment</h2><p>Firstly, we need to do some conversions.</p><h3 id="Step-1-Put-F-in-NNF"><a href="#Step-1-Put-F-in-NNF" class="headerlink" title="Step 1. Put $F$ in NNF"></a>Step 1. Put $F$ in NNF</h3><p>For any formula $F$ of array property fragments, it should be converted into NNF form. In NNF, negation can only appear in literals, and logical connectives can only be $\land$ and $\lor$. <strong>Here, literals can be array properties.</strong></p><h3 id="Step-2-Remove-All-Write-Terms"><a href="#Step-2-Remove-All-Write-Terms" class="headerlink" title="Step 2. Remove All Write Terms"></a>Step 2. Remove All Write Terms</h3><p>For any write term $a\langle i\triangleleft v\rangle$ in $F$, convert it to a fresh new array $a&#39;$ with the following condition conjoined to $F$:</p><script type="math/tex; mode=display">a'[i] = v \land (\forall j::j\ne i\rightarrow a[j]  = a'[j])</script><h3 id="Step-3-Remove-Existential-Quantifiers"><a href="#Step-3-Remove-Existential-Quantifiers" class="headerlink" title="Step 3. Remove Existential Quantifiers"></a>Step 3. Remove Existential Quantifiers</h3><p>For any existential quantifier term $\exists i::G[i]$, replace it with $G[j]$ where $j$ is a fresh new variable.</p><p>When talking about satisfiability, the two expressions above are equal.</p><h3 id="Step-4-Select-the-Index-Terms"><a href="#Step-4-Select-the-Index-Terms" class="headerlink" title="Step 4. Select the Index Terms"></a>Step 4. Select the Index Terms</h3><p>In this step we want to remove universal quantifiers where the variable is used for array read.</p><p>This can be done by considering all possible values of the variable.</p><p>The following finite set should be considered (check all elements of the set):</p><p>$\{\lambda\}\cup\{i | i \text{ is in a index guard and is a free variable}\}\cup\{i | i \text{ appears in an array read and is a free variable}\}$</p><p>Where $\lambda$ stands for &quot;all values that are not special&quot;, and it is used for ensure completeness.</p><p>The set defined above is annotated as index set $I$.</p><h3 id="Step-5-Transform-forall-into-land"><a href="#Step-5-Transform-forall-into-land" class="headerlink" title="Step 5. Transform $\forall $ into $\land$"></a>Step 5. Transform $\forall $ into $\land$</h3><p>For any universal quantifier term $\forall i::G[i]\rightarrow H[i]$, replace it with $\bigwedge\limits_{i\in I}G[i]\rightarrow H[i]$.</p><h3 id="Step-6-Ensure-the-Uniqueness-of-lambda"><a href="#Step-6-Ensure-the-Uniqueness-of-lambda" class="headerlink" title="Step 6. Ensure the Uniqueness of $\lambda$"></a>Step 6. Ensure the Uniqueness of $\lambda$</h3><p>After step 5, we need to conjoin the following formula with $F$ to ensure $\lambda$ is not the same with other elements in the index set:</p><script type="math/tex; mode=display">\bigwedge_{i\in I-\{\lambda\}}\lambda \ne i</script><h3 id="Step-7-Decide-the-Formula"><a href="#Step-7-Decide-the-Formula" class="headerlink" title="Step 7. Decide the Formula"></a>Step 7. Decide the Formula</h3><p>Now the formula is not an array property anymore. It can be decided by $T_A\cup T_E$.</p><p>The formula from those steps are <strong>equisatisfiable</strong> with the original formula.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>We want to know the satisfiability of:</p><script type="math/tex; mode=display">(\forall i:: i\ne j \rightarrow a[i]=b[j])\land (\forall i::i\ne k\rightarrow a[i]\ne b[i])</script><ol><li><p>Step 1, 2 and 3 are skipped.</p></li><li><p>The index set is $\{\lambda, j, k\}$.</p></li><li><p>After removing universal quantifiers, we get:</p><script type="math/tex; mode=display">(\lambda \ne j \rightarrow a[\lambda]= b[\lambda]) \land (k \ne j \rightarrow a[k]= b[k]) \land\\(\lambda \ne k \rightarrow a[\lambda]\ne b[\lambda]) \land (j \ne k \rightarrow a[j]\ne b[j]) \land\\(\lambda \ne j) \land (\lambda \ne k)</script><p>Which can be decided by $T_A\cup T_E$.</p></li></ol><a id="more"></a><h2 id="Integer-Indexed-Arrays"><a href="#Integer-Indexed-Arrays" class="headerlink" title="Integer-Indexed Arrays"></a>Integer-Indexed Arrays</h2><p>Arrays don&#39;t need to be indexed by integers, they can also be indexed by any objects, such as real numbers.</p><p>However, the deciding procedure can be simplified where indexes are integers.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><ul><li><strong>Bounded array equality</strong>: $\forall i:: l \le i \le u\rightarrow a[i] = b[i]$.</li><li><strong>Bounded sorted array</strong>: $\forall i, j :: l \le i\le j\le u\rightarrow a[i] &lt; a[j]$.</li></ul><h2 id="Satisfiability-Modulo-Theories-SMT"><a href="#Satisfiability-Modulo-Theories-SMT" class="headerlink" title="Satisfiability Modulo Theories (SMT)"></a>Satisfiability Modulo Theories (SMT)</h2><p>All we have talked about can only handle conjunctive formulas. For disjunctions, we can convert these formulas into DNF, however this is expensive.</p><p>SMT is a decision problem for formulas in some combination of <strong>first-order</strong> background theories with arbitrary boolean structure.</p><p>SMT problems can be decomposed into two parts which can be solved efficiently:</p><ul><li>Use SAT-Solver to check boolean strcutrues</li><li>Use dedicated theories to check formulas (literals)</li></ul><h2 id="Boolean-Structure"><a href="#Boolean-Structure" class="headerlink" title="Boolean Structure"></a>Boolean Structure</h2><p>We can get the <strong><em>boolean abstraction</em></strong> of any formula recursively. For any formula we can get its boolean structure using boolean abstraction.</p><p>For every literal, we should introduce a fresh new variable.</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>For formula $g(a) = c \land (f(g(a)) \ne f(c)\lor g(a) = d)\land c\ne d$, it&#39;s <em>boolean abstraction</em> is $P_1\land (P_2\lor P_3)\land P_4$, where $P_1$ to $P_4$ stand for corresponding literals.</p><p>The boolean abstraction of $F$ is denoted as $\mathcal B(F)$, and the reversed procedure is $\mathcal {B}^{-1}$.</p><h3 id="Properties-of-Boolean-Abstraction"><a href="#Properties-of-Boolean-Abstraction" class="headerlink" title="Properties of Boolean Abstraction"></a>Properties of Boolean Abstraction</h3><p>If $F$ is satisfiable, then $\mathcal B(F)$ is also satisfiable. Not vice versa.</p><p>If $\mathcal B(F)$ is not satisfiable, then $F$ is not satisfiable. (Contrapositive.)</p><p>$\mathcal B(F)$ is called the <strong><em>overapproximation</em></strong> of $F$.</p><h2 id="Combining-T-and-SAT-Solvers"><a href="#Combining-T-and-SAT-Solvers" class="headerlink" title="Combining $T$ and SAT Solvers"></a>Combining $T$ and SAT Solvers</h2><p>Given $F$:</p><ol><li>Get $F_\mathcal B = \mathcal B(F)$.</li><li>If $F_\mathcal B$ is unsatisfiable, so is $F$.</li><li>Otherwise, let $\alpha$ be an assignment for $F_\mathcal B$. ($\alpha$ maps constants to boolean value.)</li><li>Construct $C = \bigwedge\limits_{i = 1}^n P_i\leftrightarrow \alpha(P_i)$. ($\leftrightarrow$ doesn&#39;t need to appear in $C$, and $C$ can be a simple conjunctive propositional conjunctive formula.)</li><li>Construct $F&#39; = \mathcal B^{-1}(C)$. Now $F&#39;$ is in quantifier-free conjunctive form (if every literal is quantifier-free).</li><li>Send $F&#39;$ to $T$-solver. If the solver reports satisfiable, then the original formula is satisfiable.</li><li>Otherwise, since we only select one possible assignment in step 3, we need to update $F_\mathcal B := F_\mathcal B\land \lnot C$, then repeat steps above.</li></ol><p>In step 2 we use a SAT solver, and in step 6 we use a $T$-solver depending on which theory we used.</p><h2 id="Enhancement-1-Integrating-with-DPLL-DPLL-T"><a href="#Enhancement-1-Integrating-with-DPLL-DPLL-T" class="headerlink" title="Enhancement 1: Integrating with DPLL: DPLL($T$)"></a>Enhancement 1: Integrating with DPLL: DPLL($T$)</h2><p>Sometimes using SAT solver can cause efficiency issue. This can be alleviated by using DPLL as the solver.</p><p>The idea is to query $T$-solver incrementally. After constructing $C$ in step 4, use DPLL and <strong>unit propagation</strong> to get the value of some variables. Then construct $F&#39;$ on known literals, and query $T$-solver to get some conclusions. This is called <strong><em>theory propagation</em></strong>. Those conclusions can fix the value of some other variables (or cause a backjump for DPLL), and accelerate the decision procedure for the boolean abstraction.</p><p>Theory propagation can speed up the decision of $C$. However, theory propagation is slow.</p><h2 id="Enhancement-2-Unsat-Core"><a href="#Enhancement-2-Unsat-Core" class="headerlink" title="Enhancement 2: Unsat Core"></a>Enhancement 2: Unsat Core</h2><p>An unsat core $C^\ast$ is a subset of $C$ where $C^\ast$ is unsatisfiable, but dropping any element of $C^\ast$ will make it satisfiable. Whether $C^\ast$ is satisfiable needs to query $T$-solver.</p><p>A naive algorithm to compute $C^\ast$ can be by deleting elements from $C$ repeatedly. This can get a unsat core, but it can&#39;t be guaranteed the unsat core is optimal.</p><p>When in step 7, we added $\lnot C$ into the $F_\mathcal B$. After getting the unsat core $C^\ast$, we can add $\lnot C^\ast$ instead of $\lnot C$. This can shrink the searching space of DPLL tighter then adding $\lnot C$ as $C^\ast$ is more &quot;general&quot;, hence it can speed up the searching procedure of DPLL too.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 形式化验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式化验证课程笔记 6</title>
      <link href="/2019/04/01/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-6/"/>
      <url>/2019/04/01/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-6/</url>
      
        <content type="html"><![CDATA[<h1 id="第六周"><a href="#第六周" class="headerlink" title="第六周"></a>第六周</h1><h2 id="Combination-Theories"><a href="#Combination-Theories" class="headerlink" title="Combination Theories"></a>Combination Theories</h2><h3 id="Combined-Theory"><a href="#Combined-Theory" class="headerlink" title="Combined Theory"></a>Combined Theory</h3><p>For theory $T_1, T_2$, if $T_1\cap T_2 = \{=\}$, then the combined theory $T_1\cup T_2$ has signature $\Sigma_1\cup\Sigma_2$ and axioms $A_1\cup A_2$.</p><h3 id="Nelson-Oppen-Combination-Method"><a href="#Nelson-Oppen-Combination-Method" class="headerlink" title="Nelson-Oppen Combination Method"></a>Nelson-Oppen Combination Method</h3><p>$T_1\cup T_2$ is decidable if both $T_1$ and $T_2$ are <strong>quantifier-free</strong>, <strong>conjunctive</strong> fragments which are <strong>decidable</strong> and <strong>stably-infinite</strong> (see below).</p><h2 id="Stably-Infinite-Theories"><a href="#Stably-Infinite-Theories" class="headerlink" title="Stably-Infinite Theories"></a>Stably-Infinite Theories</h2><p>A theory $T$ with signature $\Sigma$ is <strong>stably infinite</strong> if for every quantifier-free $T$-satisfiable $\Sigma$-formula $F$, there is a satisfiable $T$-interpretation with domain of infinite cardinality.</p><p>$T_E$, $T_A$ and $T_Z$ are stably infinite.</p><h2 id="Nelson-Oppen-Procedure"><a href="#Nelson-Oppen-Procedure" class="headerlink" title="Nelson-Oppen Procedure"></a>Nelson-Oppen Procedure</h2><p>This procedure takes a formula $F$ in combined theory $T_1\cup T_2$, and returns an equisatisfiable formula $F_1\land F_2$ where $F_1$ is a $T_1$-formula and $F_2$ is a $T_2$-formula.</p><p><em>In short, the procedure can separate a formula in a combined theory into two formulas in each theory.</em></p><h3 id="Step-1-Variable-Abstraction"><a href="#Step-1-Variable-Abstraction" class="headerlink" title="Step 1. Variable Abstraction"></a>Step 1. Variable Abstraction</h3><h4 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h4><p>In this step, our goal is to make every literal in $F$ belongs to either $T_1$ or $T_2$.</p><p>A function or a predict is a literal, so:</p><ul><li>If function $f(\dots, t, \dots)$ is in $F$, where $f$ in $\Sigma_1$ but $t$ in $\Sigma_2$, then we introduce a new variable $w$ and replace $t$ with w, then conjoin $t = w$.</li><li>If predicate $p(\dots, t, \dots)$ is in $F$, where $p$ in $\Sigma_1$ but $t$ in $\Sigma_2$, we introduce a new variable $w$ and replace $t$ with w, then conjoin $t = w$.</li></ul><p><em>Note that a variable is a logic symbol</em>. When finished, every literal in $F$ belows to either $T_1$ or $T_2$. Note the $=$ cannot be viewed as a predicate here.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>The following formula is in $T_\mathbb Z\cup T_E$:</p><script type="math/tex; mode=display">1 \le x \land x\le 2 \land f(x)\ne f(1) \land f(x)\ne f(2)</script><p>Also the formula can be thought as only in $T_E​$, we introduce axioms in $T_\mathbb Z​$ here. Therefore the formula is not only in $T_E​$.</p><ol><li><p>All symbols are $1$, $2$, $f(\cdot)$, $x$, $\le$, $=$, $\lnot$, $\land$, where $x$, $\lnot$ and $\land$ are logical symbols.</p></li><li><p>For non-logical symbols, $f(\cdot)$ and $=$ are in $T_E$, while $1$, $2$, $=$ and $\le$ are in $T_\mathbb Z$.</p></li><li><p>For literal $f(1)$, $f$ is in $T_E$ but $1$ is in $T_\mathbb Z$, so we introduce variable $m$ to replace $1$ in $f(1)$, then conjoin it to the formula. Do this for $f(2)$ too. Then we get</p><script type="math/tex; mode=display">1 \le x \land x\le 2 \land f(x)\ne f(m) \land f(x)\ne f(n)\land m=1 \land n = 2</script></li><li><p>Now $f(x)\ne f(m)\land f(x)\ne f(n)​$ is in $T_E​$, while $1\le x \land x \le 2 \land m = 1\land n = 2​$ is in $T_\mathbb Z​$.</p></li></ol><h3 id="Step-2-Guess-And-Check"><a href="#Step-2-Guess-And-Check" class="headerlink" title="Step 2. Guess And Check"></a>Step 2. Guess And Check</h3><h4 id="Procedure-1"><a href="#Procedure-1" class="headerlink" title="Procedure"></a>Procedure</h4><p>In this step, our goal is to decide whether the original formula is satisfiable.</p><ol><li><p>For given formula $F_1$ and $F_2$, we can find their <strong>shared variables</strong> $V = free(F_1)\cap free(F_2)$, where $free(F)$ means all free variables in $F​$.</p></li><li><p>Build an equivalence relation $E$ on $V$, and build a formula $\alpha(V, E)$ which depends on $V$ and $E$:</p><script type="math/tex; mode=display">\alpha(V, E) = \bigwedge\limits_{u, v\in V.uEv} u=v\land \bigwedge\limits_{u, v\in V.\lnot(uEv)}u\ne v</script></li><li><p>$F_1\cup F_2$ is $T_1\cup T_2$-satisfiable if and only if there exists an $\alpha(V, E)$ and:</p><ul><li>$F_1\land \alpha(V, E)$ is $T_1$-satisfiable.</li><li>$F_2\land \alpha(V, E)$ is $T_2$-satisfiable.</li></ul></li></ol><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>(Follows the example in step 1.)</p><ol><li>$F_1$ (which in $T_E$) is $f(x)\ne f(m)\land f(x)\ne f(n)$, and $F_2$ (which in $T_\mathbb Z$) is $1\le x \land x \le 2 \land m = 1\land n = 2$.</li><li>Shared variables are $V = \{x, m, n\}$.</li><li>For every possible partition on $V$, we can construct an equivalence relation. There are five possibilities.<ul><li>$\{\{x\}, \{m\}, \{n\}\}$: No, because $F_2\land x\ne m \land x \ne n$ is not $T_\mathbb Z$-satisfiable. (Some items are omitted.)</li><li>$\{\{x\}, \{m =n\}\}$: No, because $F_2\land m=n$ is not $T_\mathbb Z$-satisfiable.</li><li>$\{\{x, m\}, \{n\}\}$: No, because $F_1\land x  = m$ is not $T_E$-satisfiable.</li><li>Same for the remaining two possibilities.</li></ul></li><li>As all possibilities cannot ensure $F_1\land \alpha(V, E)$ is $T_E$-satisfiable and $F_2 \land \alpha(V, E)$ is $T_\mathbb Z$-satisfiable, the original formula $F$ is not $T_E\cup T_\mathbb Z$-satisfiable.</li></ol><h4 id="Efficiency-Issue"><a href="#Efficiency-Issue" class="headerlink" title="Efficiency Issue"></a>Efficiency Issue</h4><p>The method above is impractical as we need to construct too many partitions.</p><a id="more"></a><h2 id="Convex-Theory"><a href="#Convex-Theory" class="headerlink" title="Convex Theory"></a>Convex Theory</h2><p>A theory is <strong>convex</strong> if for any quantifier-free, conjunctive formula $F$:</p><script type="math/tex; mode=display">F\rightarrow \bigvee\limits_{i =1}^n u_i = v_i \Rightarrow F\rightarrow u_i= v_i \text{ for some } i\in \{1, \dots, n\}</script><ul><li>$T_A$ and $T_\mathbb Z$ are not convex.</li><li>$T_E$ and $T_\mathbb Q$ are convex.</li></ul><hr><p>$T_\mathbb Z$ is not convex, for example, for formula $F:1 \le x\le 2 \land u=1 \land v = 2 $, we have $F\rightarrow x=u\lor x=v$ is true, but both $F\rightarrow x=u$ and $F\rightarrow x = v$ are false.</p><h2 id="Optimized-Step-2-Equality-Propagation"><a href="#Optimized-Step-2-Equality-Propagation" class="headerlink" title="Optimized Step 2: Equality Propagation"></a>Optimized Step 2: Equality Propagation</h2><h3 id="Procedure-2"><a href="#Procedure-2" class="headerlink" title="Procedure"></a>Procedure</h3><p>In this step, our goal is to decide whether the original formula is satisfiable, but with a more efficient algorithm than the step 2 above.</p><ol><li>For given formula $F_1$ and $F_2$, we can find their <strong>shared variables</strong> $V = free(F_1)\cap free(F_2)$, where $free(F)$ means all free variables in $F$.</li><li>Construct a set $E$ containing all equations shared between $T_1$ and $T_2$. Initially the set is empty.</li><li>Ask the decision procedure of $T_1$ to report newly implied equalities between shared variables. If $T_1$ is convex, you will get one equality, and you should add this equality to $E$; if $T_1$ is not convex, you will get a disjunction of equalities, and you should split the search procedure into multiple branches and add each equality into one branch.</li><li>Repeat step 3, but replace $T_1$ with $T_2$ and use information stores in $E$.</li><li>Repeat step 3 and step 4, until<ul><li>If any branch of the search ends with a full arrangement, the original formula is <strong>satisfiable</strong>.</li><li>If all branches end with contradiction, the original formula is <strong>unsatisfiable</strong>.</li><li>If all branches cannot discover new equalities, the original formula is <strong>satisfiable</strong>.</li></ul></li></ol><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><p>Formula $F$ is in $T_E\cup T_\mathbb Q$:</p><script type="math/tex; mode=display">f(f(x) - f(y))\ne f(z) \land x \le y \land y + z \le x \land 0 \le z</script><p>Divide it into two formulas:</p><ul><li>$F_E: f(w) \ne f(z) \land u=f(x)\land v =f(y)$</li><li>$F_\mathbb Q: x\le y \land y + z \le x \land 0 \le z \land w = u - v$</li><li>$V = \{x, y, z, u, v, w\}$</li></ul><p><em>If we use the procedure in the above section by constructing $E$ on all partitions of $V$, it is impractical.</em></p><p><em>Note that both $T_E$ and $T_\mathbb Q$ are convex.</em></p><ol><li>Construct known equivalence relation $E​$ on $V​$, but initially the set is empty.</li><li>With $F_\mathbb Q$ and $E=\{\}$, we now know $x = y$. Add this equation to $E$. (Although we know $z=0$, $0$ is not in $T_E$, so we cannot add this equation to $E$. We only concern about the equality on shared variables.)</li><li>With $F_E$ and $E=\{x = y\}$, we now know $u=v$. Add this equation to $E$.</li><li>With $F_\mathbb Q$ and $E = \{x = y, u = v\}$, we now know $z = w$. Add this equation to $E$.</li><li>With $F_E$ and $E$ we get a contradiction, hence the original formula is $T_E\cup T_\mathbb Q$-unsatisfiable.</li></ol><p><strong>How to construct an assignment</strong>: if the formula is satisfiable, you can construct an assignment by defining equivalence relations on $V$: if two variables are equal according to $E$, they are equal; otherwise they are not equal.</p><h3 id="Another-Example"><a href="#Another-Example" class="headerlink" title="Another Example"></a>Another Example</h3><p>Formula $F$ is in $T_E\cup T_\mathbb Z$:</p><script type="math/tex; mode=display">1 \le x\land x \le 2\land f(x)\ne f(1)\land f(x)\ne f(2)</script><p>Divide $F$ into two formulas:</p><ul><li>$F_E: f(x)\ne f(w_1)\land f(x)\ne f(w_2)$</li><li>$F_\mathbb Z: 1\le x \land x \le 2 \land w_1 = 1 \land w_2 = 2$</li><li>$V = \{x, w_1, w_2\}$</li></ul><p><em>Note that $T_\mathbb Z​$ is not convex.</em></p><ol><li>Construct known equivalence relation $E$ on $V$, but initially the set is empty.</li><li>With $F_\mathbb Z$ and $E = \{\}$, we now know $x  = w_1\lor x = w_2$, and we have two path here: $E_1 = \{x =  w_1\}$ and $E_2 = \{x = w_2\}$.</li><li>With $F_E​$ and $E_1 = \{x = w_1\}​$ we get a contradiction, hence this path is not satisfiable.</li><li>With $F_E​$ and $E_2 = \{x = w_2\}​$ we get a contradiction, hence this path is not satisfiable.</li><li>Therefore the original formula is not $T_E\cup T_\mathbb Z$-satisfiable.</li></ol><hr><h2 id="Bring-Back-Quantifiers"><a href="#Bring-Back-Quantifiers" class="headerlink" title="Bring Back Quantifiers"></a>Bring Back Quantifiers</h2><p>Quantifier-free fragments are not expressive, for example, we cannot say two arrays are equal in $T_{A}$.</p><h2 id="Array-Properties"><a href="#Array-Properties" class="headerlink" title="Array Properties"></a>Array Properties</h2><p>Introduce quantifiers into $T_A$, but limit the variable to array indices.</p><p>An <strong>array property</strong> is a $\Sigma_A$-formula of the form $\forall i::F[i]\rightarrow G[i]$, where $F[i]$ is <strong>index guard</strong>, $G[i]$ is <strong>value constraint</strong>.</p><h3 id="Syntax-of-Index-Guard"><a href="#Syntax-of-Index-Guard" class="headerlink" title="Syntax of Index Guard"></a>Syntax of Index Guard</h3><img src="/2019/04/01/形式化验证课程笔记-6/DeepinScreenshot_select-area_20190402134523.png"><h3 id="Syntax-of-Value-Constraint"><a href="#Syntax-of-Value-Constraint" class="headerlink" title="Syntax of Value Constraint"></a>Syntax of Value Constraint</h3><img src="/2019/04/01/形式化验证课程笔记-6/DeepinScreenshot_select-area_20190402134538.png"><h2 id="Array-Property-Fragment"><a href="#Array-Property-Fragment" class="headerlink" title="Array Property Fragment"></a>Array Property Fragment</h2><p>The <strong>array property fragment</strong> is a logical combination of <strong>quantifier-free $\Sigma_A$-formulas</strong> and <strong>array properties</strong>.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><ul><li>$\forall i::a[i] = b[i]$</li><li>$\forall j::i\ne j\rightarrow a\langle i\triangleleft v\rangle[j] = a[j]$</li></ul><h2 id="Deciding-Array-Property-Fragment"><a href="#Deciding-Array-Property-Fragment" class="headerlink" title="Deciding Array Property Fragment"></a>Deciding Array Property Fragment</h2><p>Semantically, $\forall i::F[i]$ is equal to $\bigwedge\limits_\beta \beta (F)$ where $\beta$ ranges over all substitutions of $i$.</p><p>The idea is to replace $\forall i::F[i]$ with a <strong>finite</strong> conjunction $\bigwedge\limits_{i = 1}^n F[t_i]$. In this conjunctive, $t_i$ are called the <strong>index terms</strong>, and all index terms necessary should be considered.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 形式化验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式化验证课程笔记 5</title>
      <link href="/2019/03/25/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-5/"/>
      <url>/2019/03/25/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-5/</url>
      
        <content type="html"><![CDATA[<h1 id="第五周"><a href="#第五周" class="headerlink" title="第五周"></a>第五周</h1><h2 id="Theory-of-Equality-and-Uninterpreted-Functions"><a href="#Theory-of-Equality-and-Uninterpreted-Functions" class="headerlink" title="Theory of Equality and Uninterpreted Functions"></a>Theory of Equality and Uninterpreted Functions</h2><p>In $T_E$，$=$ is a predicate. Formulas in $T_E$ may contain other predicates, but they can be converted to $=$ using <strong>Theory of Equality and Uninterpreted Functions</strong> (EUF).</p><p>Any predicate $p(x_1, x_2, \dots, x_n)$ other than $=$ can be converted to a function and the predicate $=$, where $f_p$ is a introduced function by $p$ and $\bullet$ is a constant.</p><p>In EUF:</p><ul><li>$=$ is the only predicate.</li><li>All atomic formulas are either equalities or inequalities.</li></ul><p><strong>Example:</strong></p><script type="math/tex; mode=display">p(x)\land q(x, y)\land q(y, z) \rightarrow \lnot q(x, z)</script><p>can be converted to:</p><script type="math/tex; mode=display">(f_p(x) = \bullet)\land (f_q(x, y)=\bullet)\land (f_q(y, z)=\bullet)\rightarrow f_q(x, z)\neq\bullet</script><h2 id="Relations"><a href="#Relations" class="headerlink" title="Relations"></a>Relations</h2><ul><li><p>A relation on $S$ is a subset of $S\times S$.</p></li><li><p>An <strong>equivalence relation</strong> should be reflexive, symmetric and transitive.</p></li><li><p>An <strong>congruence relation</strong> $R$ should be a equivalence relation, and obey the property that $\forall \mathbf s, \mathbf t\in S^n::(\land^n_{i = 1} \mathbf s_iR\mathbf t_i)\rightarrow f(\mathbf s)Rf(\mathbf t)$, where $f:S^n\mapsto S$ is <strong>not arbitrary</strong>. (A relation is a congruence relation relies on the function $f$.)</p></li></ul><a id="more"></a><h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><ul><li>A <strong>equivalence class</strong> for equivalence relation $R$ for element $e$ is $[e]_R = \{s| s\in S \land s R e\}$.</li><li>If the relation is also a congruence relation, the equivalence class is also a <strong>congruence relation</strong>.</li></ul><h2 id="Partitions"><a href="#Partitions" class="headerlink" title="Partitions"></a>Partitions</h2><ul><li><p>A partition $P$ of a set $S$ is a set of subsets of $S$ with total property and disjoint property.</p></li><li><p>All equivalence classes for relation $R$ on $S$ form a partition, called the <strong>quotient</strong> of $S$ by $R$: $S/R$.</p></li></ul><h2 id="Relation-Refinements"><a href="#Relation-Refinements" class="headerlink" title="Relation Refinements"></a>Relation Refinements</h2><ul><li><strong>Refinement</strong>: $R_1 \prec R_2$ if $\forall s_1, s_2 \in S:: s_1 R_1 s_2 \rightarrow s_1 R_2 s_2$, called $R_1$ refines $R_2$.</li><li><strong>Refinements and subsets</strong>: $R_1\prec R_2$ if and only if $R_1 \subseteq R_2$.</li></ul><p><strong>Example:</strong></p><p>Define $a\equiv_n b$ if $(a\text{ mod } n = (b \text{ mod } n))$, then we have $\equiv_4 \prec \equiv_2$.</p><h2 id="Equivalence-Closure-and-Congruence-Closure"><a href="#Equivalence-Closure-and-Congruence-Closure" class="headerlink" title="Equivalence Closure and Congruence Closure"></a>Equivalence Closure and Congruence Closure</h2><p>The <strong>equivalence closure</strong> for any relation $R$ is the smallest equivalence relation $R_E$ including $R$.</p><p>Formally, $R_E$ is the equivalence closure of $R$ if:</p><ul><li>$R\prec R_E$.</li><li>For any equivalence relation $R&#39;$, $R\prec R&#39;\rightarrow R&#39;=R_E \lor R_E\prec R&#39;$.</li></ul><p><strong>Congruence closures</strong> can be defined similarly.</p><h2 id="Deciding-Quantifier-free-Conjunctive-Segment-of-T-E"><a href="#Deciding-Quantifier-free-Conjunctive-Segment-of-T-E" class="headerlink" title="Deciding Quantifier-free Conjunctive Segment of $T_E$"></a>Deciding Quantifier-free Conjunctive Segment of $T_E$</h2><h3 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h3><p>For any quantifier-free conjunctive $T_E$ formula $F:(s_1=t_1)\land (s_2=t_2)\land\dots\land(s_m=t_m)\land(s_{m + 1}\ne t_{m + 1})\land\dots\land(s_n\ne t_n)$, $F$ is $T_E$-satisfiable if and only if there is a congruence relation $\sim$ such that:</p><ul><li>$s_i\sim t_i$ for all $i\in\{1,\dots, m\}$</li><li>$s_i\nsim t_i$ for all $i \in \{m + 1, \dots, n\}$</li></ul><h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><ol><li>Construct a relation $R$ based on $F$ over the subterm set $S_F$(variables) : $\{s_1 = t_1, \dots ,s_m=t_m\}$.</li><li>Construct the congruence closure $\sim$ of $R$.</li><li>If for any $i\in \{m + 1, \dots, n\}$, $s_i\sim s_t$, then $F$ is $T_E$-unsatisfiable.</li><li>Otherwise it&#39;s $T_E$-satisfiable.</li></ol><h2 id="Congruence-Closure-Algorithm"><a href="#Congruence-Closure-Algorithm" class="headerlink" title="Congruence Closure Algorithm"></a>Congruence Closure Algorithm</h2><h3 id="Algorithm-1"><a href="#Algorithm-1" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>The congruence closure over $S_F$ can be constructed as:</p><ol><li>Construct a trivial congruence closure $\sim_0 = \{\{s\}|s\in S_F\}$.</li><li>For any $i \in \{1, \dots, m\}$, we have $s_i = t_i$, so build $\sim_{i}$ by merging $[s_i]_{\sim_{i - 1}}$ and $[t_i]_{\sim_{i - 1}}$ and then propagate until you can&#39;t perform any more merging or propagating.</li></ol><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>For formula $F: f(a,b) = a\land f(f(a, b), b)\ne a$:</p><ol><li>Get $S_F = \{a, b, f(a, b), f(f(a, b), b)\}​$.</li><li>$\sim_0 = \{\{a\}, \{b\}, \{f(a, b)\}, \{f(f(a, b), b)\}\}$.</li><li>Based on $f(a, b) = a$ we have $\sim_{0}&#39; = \{\{a, f(a, b)\}, \{b\}, \{f(f(a, b), b)\}\}$.</li><li>With axiom of $T_E$, we have $f(a, b)\sim a\land b\sim b \rightarrow f(f(a, b), b)\sim f(a, b)$, hence $\sim_0&#39;$ can be propagated as $\sim_1 = \{\{a, f(a, b), f(f(a, b), b)\}, \{b\}\}$.</li><li>We have $a\sim f(f(a, b), b)$ but $F$ says $f(f(a, b), b) \ne a$, so $F$ is not $T$-satisfiable.</li></ol><h3 id="Property-of-the-Algorithm-for-Deciding-Satisfactory-of-T-E"><a href="#Property-of-the-Algorithm-for-Deciding-Satisfactory-of-T-E" class="headerlink" title="Property of the Algorithm for Deciding Satisfactory of $T_E$"></a>Property of the Algorithm for Deciding Satisfactory of $T_E$</h3><h4 id="Soundness-and-Completeness"><a href="#Soundness-and-Completeness" class="headerlink" title="Soundness and Completeness"></a>Soundness and Completeness</h4><p>Quantifier-free conjunctive $\Sigma_E$ formula $F$ is $T$-satisfiable if and only if the algorithm returns satisfiable.</p><h4 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h4><p>The time complexity is $O(e^2)$ where $e$ is the number of edges in the initial graph of the graph representing the congruence relation.</p><h2 id="Deciding-Quantifier-free-Conjunctive-Segment-of-T-A"><a href="#Deciding-Quantifier-free-Conjunctive-Segment-of-T-A" class="headerlink" title="Deciding Quantifier-free Conjunctive Segment of $T_A$"></a>Deciding Quantifier-free Conjunctive Segment of $T_A$</h2><h3 id="Basic-Idea-1"><a href="#Basic-Idea-1" class="headerlink" title="Basic Idea"></a>Basic Idea</h3><p>The problem can be reduced to deciding quantifier-free conjunctive segment of $T_E$.</p><h3 id="Case-1-Formulas-with-No-Write-Terms"><a href="#Case-1-Formulas-with-No-Write-Terms" class="headerlink" title="Case 1: Formulas with No Write Terms"></a>Case 1: Formulas with No Write Terms</h3><p>In this case, all terms are reading of array. For each array $a$, we can introduce a function $f_a$. For the reading term $a[i]$, it can be rewritten into a function $f_a(i)$. Now the formula is converted to a formula in $T_A$.</p><h3 id="Case-2-Formulas-with-Write-Terms"><a href="#Case-2-Formulas-with-Write-Terms" class="headerlink" title="Case 2: Formulas with Write Terms"></a>Case 2: Formulas with Write Terms</h3><p>Case 2 can be reduced to case 1.</p><p>Select one write term from the formula $F$, then convert it as following:</p><ol><li>(Case $i = j$) Replace $F[a\langle i\lhd v\rangle[j]]$ with $F_1: F[v] \land i = j$.</li><li>(Case $i\ne j$) Replace $F[a\langle i\lhd v\rangle [j]]$ with $F_2: F[a[j]]\land i\ne j$.</li></ol><p>Now we have two branches and reduce one write term. Do this recursively on each branch until there is no write terms in the formula, then every formula has been transformed into case 1. If any branch is satisfiable, then the original formula is satisfiable. Otherwise, the original formula is unsatisfiable.</p><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>This algorithm is sound and complete. The time complexity is $O(2^n)$.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 形式化验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sequence Models 笔记 3 Sequence models &amp; Attention mechanism</title>
      <link href="/2019/03/23/Sequence-Models-%E7%AC%94%E8%AE%B0-3-Sequence-models-Attention-mechanism/"/>
      <url>/2019/03/23/Sequence-Models-%E7%AC%94%E8%AE%B0-3-Sequence-models-Attention-mechanism/</url>
      
        <content type="html"><![CDATA[<h1 id="Sequence-models-amp-Attention-mechanism"><a href="#Sequence-models-amp-Attention-mechanism" class="headerlink" title="Sequence models &amp; Attention mechanism"></a>Sequence models &amp; Attention mechanism</h1><h2 id="Various-sequence-to-sequence-architectures"><a href="#Various-sequence-to-sequence-architectures" class="headerlink" title="Various sequence to sequence architectures"></a>Various sequence to sequence architectures</h2><h3 id="Basic-Models"><a href="#Basic-Models" class="headerlink" title="Basic Models"></a>Basic Models</h3><p>Sequence to Sequence 结构可以将一个序列转换到另一个序列。一个简单的模型是使用 many-to-one 的 RNN 作为 encoder 提取出序列的特征，然后使用 one-to-many 的 RNN 作为 decoder 将特征再次变换到序列。</p><p>另一个应用是 image captioning，即给定一张图片要求网络输出对这张图片的描述。此时可以先使用一个 CNN 提取特征，然后使用 RNN 产生文本。</p><h3 id="Picking-the-most-likely-sentence"><a href="#Picking-the-most-likely-sentence" class="headerlink" title="Picking the most likely sentence"></a>Picking the most likely sentence</h3><p>以 Sequence to Sequence 中的机器翻译为例。机器翻译可以看作是带有条件的 <strong>语言模型</strong>，语言模型可以对给定的句子估计出它出现在语言中的概率，也可以用来产生一些句子，而机器翻译则可以看作是其对应的“条件概率”版本——给定源句子作为条件，机器翻译模型可以对任意的目标语言的句子的概率进行评估，也可以用来生成源语言对应的目标语言。语言模型的初始输入是一个全零的向量，而机器翻译中完成翻译的 decoder 部分的初始输入是 encoder 得到的特征。</p><p>在生成的过程中，我们希望能够直接得到最优的句子。因此不像语言模型中每次选词的时候按照概率进行选择，机器翻译要求选出的词的序列尽可能好，这就需要某种搜索策略。</p><p>较简单的搜索策略就是贪心搜索，每次都选取概率最高的那个词。但是这种策略工作得并不好，通过使用 <em>beam search</em> （中文为 <em>集束搜索</em>）可以获得更好的结果。</p><h3 id="Beam-Search"><a href="#Beam-Search" class="headerlink" title="Beam Search"></a>Beam Search</h3><p>集束搜索是贪心搜索的泛化版本。它有一个参数用来控制搜索的宽度 $B$。</p><p>在使用集束搜索进行目标语言的生成时，首先选定第一个词。Decoder 会给出第一个词的概率分布，选出概率最大的 $B$ 个词，记录下来。然后生成第二个词，对于之前记录下的 $B$ 个词，每个都进入网络作为输入再生成 $B$ 个词，此时一共有 $B^2$ 个短序列，每个序列有两个词，同时关联了自己的概率。此时从这 $B^2$ 个短序列中选出 $B$ 个最优的即可。然后选择第三个词。依此类推。</p><p>可以看到集束搜索本质上还是一种贪心算法，不过它在每一步时考虑了一定的分支情况。它得到的结果一般会比普通的贪心算法好很多。</p><p>当 $B = 1$ 时，集束搜索会退化到贪心算法。</p><h3 id="Refinements-to-Beam-Search"><a href="#Refinements-to-Beam-Search" class="headerlink" title="Refinements to Beam Search"></a>Refinements to Beam Search</h3><h4 id="Avoid-underflow"><a href="#Avoid-underflow" class="headerlink" title="Avoid underflow"></a>Avoid underflow</h4><p>按照贝叶斯公式，集束搜索中需要求的是 $\displaystyle{\arg\max\limits_y\prod\limits_{t = 1}^{T_y}P(y^{\langle t \rangle} |x , y^{\langle 1 \rangle}, \dots, y^{\langle t - 1 \rangle })}$。但是，随着序列的增长，这个值可能很小以至于下溢出，因此常常通过取对数解决这个问题：$\displaystyle{\arg\max\limits_y\sum\limits_{t = 1}^{T_y}\log P(y^{\langle t \rangle} |x , y^{\langle 1 \rangle}, \dots, y^{\langle t - 1 \rangle })}$。</p><h4 id="Length-normalization"><a href="#Length-normalization" class="headerlink" title="Length normalization"></a>Length normalization</h4><p>如果按照上述公式进行计算，那么较短的句子出现在语言中的概率要比那些更长的句子要高。因为每增加一个词，整体的概率就会乘以一个在 0 到 1 之间的值。在使用语言模型进行文本生成时，结束生产的条件是得到了 <code>&lt;EOS&gt;</code>，因此这个问题是无所谓的。但是在集束搜索中因为要使用这个概率来选择“较好”的那些句子，所以会产生问题，算法会倾向于选择那些更短的句子。</p><p>这可以通过对句子的长度进行归一化来缓解，使用修正后的概率对句子出现的可能性进行度量：</p><script type="math/tex; mode=display">\begin{aligned}\arg\max\limits_y\frac{1}{|T_y|^\alpha}\sum\limits_{t = 1}^{T_y}\log P(y^{\langle t \rangle} |x , y^{\langle 1 \rangle}, \dots, y^{\langle t - 1 \rangle })\end{aligned}</script><p>其中 $\displaystyle{\alpha}$ 是超参数，一般选择 0.7。</p><h4 id="Choose-parameters"><a href="#Choose-parameters" class="headerlink" title="Choose parameters"></a>Choose parameters</h4><p>在集束搜索中，$B$ 的选择会导致算法在结果和性能上的差异。$B$ 越高，结果越好，但是计算时间越长。</p><p>通常使用 10 到 50 之间的 $B$ 值。随着 $B$ 的增长，计算时间是线性增长的，但是效果变好的趋势会越来越缓慢。</p><h3 id="Error-analysis-in-beam-search"><a href="#Error-analysis-in-beam-search" class="headerlink" title="Error analysis in beam search"></a>Error analysis in beam search</h3><p>当机器翻译的模型效果较差时，这种情况可能是集束搜索造成的，也可能是 RNN 本身的问题。前者可以通过增加搜索宽度解决，后者可以通过增加网络的复杂程度解决。如何知道到底是什么造成的问题？</p><p>对于单条训练数据，设源文本是 $x$，人工翻译的文本是 $y^\ast$（一个相当好的结果），机器翻译得到的结果是 $\hat y$。在机器翻译中，RNN 可以对给定了 $x$ 后的任意目标语言序列进行概率评估，而集束搜索则找到了其中概率较高（但不一定是最高）的一个序列。现在，只要让 RNN 在给定 $\displaystyle{x}$ 的情况下对 $\displaystyle{y^\ast}$ 和 $\displaystyle{\hat y}$ 求概率。如果发现 $\displaystyle{P(y^\ast|x)&gt; P(\hat y|x)}$，说明集束搜索没有找出最好的翻译，因此是集束搜索的问题；如果发现 $\displaystyle{P(y^\ast|x) &lt; P(\hat y|x)}$，说明 RNN 认为人工翻译的结果较差，因此是 RNN 的问题。</p><p>单条数据就可以确定导致这个数据差的是搜索的问题还是 RNN 的问题。对所有数据全部执行一遍就能知道主要是搜索的问题还是 RNN 的问题，然后针对性优化。</p><h3 id="Bleu-Score"><a href="#Bleu-Score" class="headerlink" title="Bleu Score"></a>Bleu Score</h3><p>Bleu Score 可以给翻译结果打分。</p><p>对于一个句子的翻译结果，假设已经有了若干个人工翻译结果作为参考，可以通过以下方式计算 $p_n$，其中角标 $n$ 表示考虑的序列（n-gram）的长度，例如 $p_2$ 表示考虑的都是连续两个词的 bigram。$p_n$ 是一个商，其中分母是机器翻译结果中 n-gram 的个数，分子是每个独特的 n-gram 在每个标准翻译中出现的最大次数的和。 $p_n$ 的值介于 0 到 1 之间，分数越高，翻译质量越高。</p><p>最后，Bleu Score 是 $B_P\exp(p_1 + p_2 + p_3 + p_4)$，其中 $B_P$ 是一个惩罚项（翻译结果短的话 $p_n$ 会比较高），如果翻译结果比参考翻译长，$B_P = 1$，否则，设参考翻译结果长度为 $l_0$，机器翻译结果长度 $l_1$，则 $BP = \exp(1 - l_1/l_0)$。</p><a id="more"></a><h3 id="Attention-Model-Intuition"><a href="#Attention-Model-Intuition" class="headerlink" title="Attention Model Intuition"></a>Attention Model Intuition</h3><p>如果要对一个很长的句子进行机器翻译，上面的方法表现会比较差，引入注意力机制可以较好地解决这一问题。</p><p>人类在对语句进行翻译时，每次只会注意到源语言语句中的一小部分，然后翻译出目标语言的一小部分。使用了注意力机制的机器翻译系统会模仿这一行为。具体算法见下一节。</p><h3 id="Attention-Model"><a href="#Attention-Model" class="headerlink" title="Attention Model"></a>Attention Model</h3><p>在 Attention model 中，对源语言使用 RNN（典型是 LSTM BRNN）提取特征。不同于之前使用的 many-to-one 结构，此处保留 RNN 的所有时间步上的输出，因此得到的是 $a^{\langle 1 \rangle}, a^{\langle 2 \rangle }, \dots, a^{\langle T_x \rangle }$。</p><p>使用一组参数 $\displaystyle{\alpha^{\langle t, t&#39; \rangle }}$ 表示“注意力”大小，先假设这个值已经得到了，它实际上是在计算 $\displaystyle{y^{\langle t \rangle }}$ 的过程中应当在多大程度上考虑 $\displaystyle{a^{\langle t&#39; \rangle }}$ 的权重。Attention Model 生成序列时使用的是一个 RNN，其每个时间步 $\displaystyle{t}$ 上的输入一部分来自上个时间步的输出 $\displaystyle{y^{\langle t - 1 \rangle }}$，一部分来自源语言的特征被注意力加权后的值 $\displaystyle{a^{\langle 1 \rangle }\alpha^{\langle t, 1\rangle} + a^{\langle 2 \rangle }\alpha^{\langle t, 2\rangle}+\dots+a^{\langle T_x \rangle }\alpha^{\langle t, T_x\rangle}}$。需要保证 $\displaystyle{\sum\limits_{t&#39;}\alpha^{\langle t, t&#39; \rangle } = 1}$。</p><p>$\displaystyle{\alpha^{\langle t, t&#39; \rangle }}$ 的计算过程如下。因为要保证 $\displaystyle{\sum\limits_{t&#39;}\alpha^{\langle t, t&#39; \rangle } = 1}$，$\displaystyle{\alpha^{\langle t, t&#39; \rangle }}$ 实际上是某个东西的 softmax 结果（计算时 $\displaystyle{t}$ 是固定的，$\displaystyle{t&#39;}$ 是可变的。softmax 是对 $\displaystyle{t&#39;}$ 而言的）。设 $\displaystyle{\alpha^{\langle t, t&#39; \rangle } = \text{softmax}(e^{\langle t, t&#39; \rangle })}$，而 $\displaystyle{e^{\langle t, t&#39; \rangle }}$ 是由 $\displaystyle{s^{\langle t - 1 \rangle }}$（负责产生序列的那个 RNN 的中间状态）以及 $\displaystyle{a^{\langle t&#39; \rangle }}$ 共同计算得出的，计算方法是通过一个小型的神经网络。</p><hr><p>现在假设已经翻译了一部分词，正要翻译出第 $\displaystyle{t}$ 个词。目前有的是 $s^{\langle t - 1 \rangle }$ 以及对所有的 $\displaystyle{t&#39;}$ 都有 $\displaystyle{a^{\langle t&#39; \rangle}}$。由于负责产生 $\displaystyle{e^{\langle t, t&#39; \rangle }}$ 的网络是共享的，因此可以计算出对所有的 $\displaystyle{t&#39;}$ 的 $\displaystyle{e^{\langle t, t&#39; \rangle }}$，再计算出 $\displaystyle{\alpha^{\langle t, t&#39; \rangle }}$。然后根据 $\displaystyle{\alpha^{\langle t, t&#39; \rangle }}$ 对 $\displaystyle{a^{\langle t, t&#39; \rangle }}$ 进行加权，得到的结果与 $\displaystyle{y^{\langle  t-1 \rangle }}$ 融合后产生 $\displaystyle{y^{\langle t \rangle}}$ 即可。</p><h2 id="Speech-recognition-Audio-data"><a href="#Speech-recognition-Audio-data" class="headerlink" title="Speech recognition - Audio data"></a>Speech recognition - Audio data</h2><h3 id="Speech-recognition"><a href="#Speech-recognition" class="headerlink" title="Speech recognition"></a>Speech recognition</h3><p>通过使用端到端的学习，RNN 可以直接从音频输入处理得到文本结果。</p><p>语音识别中，输入序列的长度往往很长（音频文件），而输出却很短（可能只是一个句子）。通过使用 CTC cost 的方法可以解决这个问题。它的思路是首先识别出一个序列，这个序列中的元素允许大量相邻的重复，然后再去掉这些重复得到符合人类习惯的输出。</p><h3 id="Trigger-Word-Detection"><a href="#Trigger-Word-Detection" class="headerlink" title="Trigger Word Detection"></a>Trigger Word Detection</h3><p>所谓的 trigger word 指的是能够唤醒设备的一句话，比如 Hey Google 这样的。</p><p>识别 trigger word 的算法比较简单。假设有个 many-to-many 的 RNN，只要这样设定标签序列即可：首先将标签序列的所有值全部设为 0，然后对于音频输入序列中，一旦有 trigger word 被说出了，就将说完后对应的一小段时间内对应的标签序列设为 1。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><h3 id="Conclusion-and-thank-you"><a href="#Conclusion-and-thank-you" class="headerlink" title="Conclusion and thank you"></a>Conclusion and thank you</h3><blockquote><p><strong>本节无笔记。</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sequence Models 笔记 2 Natural Language Processing &amp; Word Embeddings</title>
      <link href="/2019/03/23/Sequence-Models-%E7%AC%94%E8%AE%B0-2-Natural-Language-Processing-Word-Embeddings/"/>
      <url>/2019/03/23/Sequence-Models-%E7%AC%94%E8%AE%B0-2-Natural-Language-Processing-Word-Embeddings/</url>
      
        <content type="html"><![CDATA[<h1 id="Natural-Language-Processing-amp-Word-Embeddings"><a href="#Natural-Language-Processing-amp-Word-Embeddings" class="headerlink" title="Natural Language Processing &amp; Word Embeddings"></a>Natural Language Processing &amp; Word Embeddings</h1><h2 id="Introduction-to-Word-Embeddings"><a href="#Introduction-to-Word-Embeddings" class="headerlink" title="Introduction to Word Embeddings"></a>Introduction to Word Embeddings</h2><h3 id="Word-Representation"><a href="#Word-Representation" class="headerlink" title="Word Representation"></a>Word Representation</h3><p>在上一讲中使用了 one-hot 向量对单词进行编码。这样做的弊端是任意两个词之间的距离都是一样的，所有的词都是平权的，实际上并不好。解决的方法是使用高维向量来表示一个词（称为 <em>嵌入</em>），每个分量的取值都可以是一个实数。<strong>语义上</strong> 接近的单词应当在高维空间中的距离较短。这种嵌入方式可以使用相对于 one-hot 向量更低的维数进行编码，因此被称作是 dense 的。</p><p>在理想的情况下，用来表示单词的高维向量的分量应该是具有意义的。例如，第一个分量可以用来指明这个单词是名词的程度，第二个分量可以用来指明这个单词表示一个人类的程度。不过，一般使用高维向量表示单词时每个分量的含义没有这么明确，而是难以解释的。</p><p>如果使用了合适的表示手段将词 <em>嵌入</em> 到了高维空间中，然后使用一些降维算法（例如 t-SNE）将其可视化，就可以发现语义上相近的词的分布会更加集中。</p><h3 id="Using-word-embeddings"><a href="#Using-word-embeddings" class="headerlink" title="Using word embeddings"></a>Using word embeddings</h3><p>词嵌入经常和迁移学习结合起来使用。</p><p>一般的应用流程是从网上下载已经训练好的词嵌入结果（也可以自己训练），然后将这个嵌入方案应用到新的任务上。此后还可以对嵌入方案进行微调。</p><p>词嵌入和将图像编码为向量的思路很类似。区别在于图像的编码对任意图像都可以进行，但是词嵌入只能对词典中存在的词进行。</p><h3 id="Properties-of-word-embeddings"><a href="#Properties-of-word-embeddings" class="headerlink" title="Properties of word embeddings"></a>Properties of word embeddings</h3><p>词嵌入的一个应用是 analogy reasoning，这和词嵌入的属性有关。</p><p>在训练得到词的嵌入方案的过程中可以让词嵌入具有一定的性质。假设要构建这样的一个应用，它可以回答诸如“man 相对于 women 相当于 king 相对于什么”这样的问题。下面使用 $\displaystyle{e_{w}}$ 来表示单词 $\displaystyle{w}$ 的嵌入。要构建的应用相当于找出一个词 d，使得 a 相对于 b 相当于 c 相对于 d，只要让嵌入方案大致满足 $\displaystyle{e_a - e_b \approx e_c - e_d}$ 即可。这样，在给出了 a，b 和 c 后只要求出 $\displaystyle{\arg\max\limits_d\text{similarity}(e_d, e_c + e_b - e_a)}$。</p><p>相似性的度量最常用的是使用余弦相似度。度量时应当在进行嵌入的空间中进行度量。使用了 t-SNE 进行降维后的空间中再进行度量时会出问题，因为这种降维破坏了线性性。</p><h3 id="Embedding-matrix"><a href="#Embedding-matrix" class="headerlink" title="Embedding matrix"></a>Embedding matrix</h3><p>词嵌入学习到的结果可以表示为一个矩阵 $\displaystyle{\mathbf E}$，行数为嵌入的向量长度，列数为词典大小。每一列是对应词的嵌入结果。</p><p>可以使用某个词对应的 one hot 向量 $\displaystyle{\vec o}$ 来取出这个词的嵌入结果，只要计算 $\displaystyle{\mathbf E \vec o}$ 即可。尽管实现上这么做不是高效的。</p><a id="more"></a><h2 id="Learning-Word-Embeddings-Word2vec-amp-GloVe"><a href="#Learning-Word-Embeddings-Word2vec-amp-GloVe" class="headerlink" title="Learning Word Embeddings: Word2vec &amp; GloVe"></a>Learning Word Embeddings: Word2vec &amp; GloVe</h2><h3 id="Learning-word-embeddings"><a href="#Learning-word-embeddings" class="headerlink" title="Learning word embeddings"></a>Learning word embeddings</h3><p>如何学习嵌入方案？</p><h4 id="一个稍微复杂的算法"><a href="#一个稍微复杂的算法" class="headerlink" title="一个稍微复杂的算法"></a>一个稍微复杂的算法</h4><p>对于给定的句子 &quot;I want a glass of orange juice&quot;，首先假定最后一个词不知道。现在的问题是在已知输入为 &quot;I want a glass of orange&quot; 的情况下预测出最后一个词，正确答案是 juice。使用这个方法可以训练嵌入方案。</p><p>首先确定一个窗口大小，例如是 4。这是一个超参数，决定了考虑要预测的词前面的词的数量（这些词称为 context）这个例子中将只使用 &quot;a glass of orange&quot; 来预测下一个词。首先随机化嵌入矩阵 $\displaystyle{\mathbf E}$，然后取出这四个词对应的嵌入，送入一个全连接网络。网络输出结果是和词典大小一致的 softmax，作为下一个词的预测结果。在最大化这个网络的预测准确率的过程中，作为网络参数的 $\displaystyle{\mathbf E}$ 是在不断变化的，这就是一个学习嵌入方案的过程。</p><p>在这个例子中，嵌入方案会自动将 orange 和 apple 的嵌入放得比较接近，因为它们后面都可以跟 juice。</p><h4 id="关于-context-的选取"><a href="#关于-context-的选取" class="headerlink" title="关于 context 的选取"></a>关于 context 的选取</h4><p>在上一小节中的 context 的选取方式是取要预测的词前面若干个词。对于构建语言模型来说这样做是合理的，不过为了学习嵌入方案还有其它 context 的选取策略。包括同时选取左边和右边的若干词、选取左边的第一个词、随机选取附近的某个词等。</p><h3 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>Word2Vec 是一个学习嵌入方案的算法。</p><p>对于给定的句子，例如 &quot;I want a glass of orange juice&quot;，word2Vec 会首先选择一个词作为 context（假设选择了 &quot;orange&quot;），这个选择是顺次进行的，没什么策略。然后 word2Vec 会在 context 附近随机选择一个词作为 target（比如选择了 &quot;juice&quot;）。</p><p>对于词典中的每个词，都有一个对应的参数 $\displaystyle{\theta_i}$ 与之对应。该参数是一个向量，长度和嵌入得到的向量长度相同。嵌入矩阵 $\displaystyle{\mathbf E}$ 同样使用随机进行初始化。</p><p>训练时，对于给定的 context 和 target，首先从 $\displaystyle{\mathbf E}$ 中计算出 context 的嵌入 $\displaystyle{e_{\text{context}}}$，然后计算产生 target 的概率大小。这个概率使用 softmax 得出，具体为 $\displaystyle{p(\text{target}|\text{context}) = \frac{e^{\theta_{\text{target}}^T e_{\text{context}}}}{\sum\limits_j e^{\theta_j^Te_{\text{context}}}}}$。损失函数的定义和多分类任务一致。在最大化概率的过程中，$\displaystyle{\mathbf E}$ 会逐渐变化，这就是学到的嵌入方案。</p><h4 id="一些优化的点"><a href="#一些优化的点" class="headerlink" title="一些优化的点"></a>一些优化的点</h4><p>在计算概率时，如果词典很大的话计算过程会很长，为此可以使用层次化的分类器。这种策略使用多个分类器并将其组织成树状。第一层的分类器决定样本被分到第二层的哪个分类器中，依此类推。树不一定要是对称的，为了效率考虑可以像哈夫曼树一样将更高频的分类放在更浅的地方。</p><p>在选择 target 时，会有一个范围（比如距离在 10 个词以内），是可以调整的。此外，有些高频词（a、the）会比其它语义更加具体的词出现得更频繁，因此可以考虑除了均匀选取之外的一些策略来平衡这种问题。</p><h3 id="Negative-Sampling"><a href="#Negative-Sampling" class="headerlink" title="Negative Sampling"></a>Negative Sampling</h3><p>在前述算法中要计算 softmax，当词典很大的时候计算量较大。另一个优化方法是使用 negative sampling 将多分类的任务转化为多个二分类的任务。</p><p>首先按照 word2Vec 的算法选择出 context 和 target。这里的 target 是 positive 的，我们希望在给出 context 的情况下能够预测出 target。然后随机选出 $k$ 个 negative targets，选取方法见后。和 word2Vec 一样，词典中的每个单词都有一个和嵌入长度相同的参数 $\displaystyle{\theta_i}$。</p><p>随机初始化嵌入矩阵 $\displaystyle{\mathbf E}$，计算 $\displaystyle{\sigma(\theta_i^Te_{\text{context}})}$。如果对应的 target 是 positive 的，这个值应当接近 1，否则应当接近 0。可以看到对于单个的 target，这仅仅是一个二分类任务。而我们只选取了 1 个 positive target 和 k 个 negative targets，因此一共只有 $\displaystyle{k + 1}$ 个二分类任务。和原来的 softmax 分类相比计算量大大降低了。</p><h4 id="k-的典型值"><a href="#k-的典型值" class="headerlink" title="k 的典型值"></a>k 的典型值</h4><p>数据集较小时 k 较大，一般为 5 到 20；数据集较大时 k 较小，一般为 2 到 5。</p><h4 id="negative-targets-的选取"><a href="#negative-targets-的选取" class="headerlink" title="negative targets 的选取"></a>negative targets 的选取</h4><p>一种方式是在词典中均匀选取。另一种方式是在词典中按照词在语言中出现的频率对概率加权。</p><p>原始 word2Vec 中使用的方法介于二者之间，每个词的概率为 $\displaystyle{\frac{f(w_i)^{\frac{3}{4}}}{\sum\limits_jf(w_j)^{\frac{3}{4}}}}$。</p><p>这个算法中选出的 negative target 可能位于句子中 context 附近，也就是说它可能的确是 context 的 positive target。此时不用做任何处理，因为这种概率毕竟较小，而且网络一般很鲁棒。</p><h3 id="GloVe-word-vectors"><a href="#GloVe-word-vectors" class="headerlink" title="GloVe word vectors"></a>GloVe word vectors</h3><p>GloVe 是另一个嵌入方案的学习算法。</p><p>首先需要计算出一个方阵 $\displaystyle{\mathbf X}$，这个方阵的规模是词典大小。$\displaystyle{\mathbf X_{ij}}$ 表示语料中单词 i 出现在单词 j 的 context 中的次数。对于一些特定的 context 选区方案（例如一个单词的 context 是左右 10 个单词），得到的 $\displaystyle{\mathbf X}$ 是对称的。</p><p>随机初始化嵌入矩阵。为每个单词关联参数 $\displaystyle{\theta_i}$。GloVe 中的目标函数为</p><script type="math/tex; mode=display">\sum\limits_i\sum\limits_jf(\mathbf X_{ij})(\theta_i^Te_j - \log \mathbf X_{ij})^2</script><p>如果 $\mathbf X_{ij}$ 较大，那么 $\displaystyle{\theta_i}$ 和 $\displaystyle{e_j}$ 就会更加接近。反之不会很近。上式中的 $\displaystyle{f(\cdot)}$ 用来对右边进行权值的调整。例如当 $\mathbf X_{ij}$ 为 0 时，为了保证结果有意义，$\displaystyle{f(\mathbf X_{ij})}$ 就会为 0。这个调整也可以用来平衡高频词和低频词的权重。</p><p>因为我们要学习的是 $\displaystyle{e_j}$，但是这里使用到的 $\displaystyle{\theta_i}$ 也是有意义的，而二者在目标函数中的地位相同，因此最后会让嵌入 $\displaystyle{e_j^{(\text{final})} = \frac{e_j + \theta_j}{2}}。</p><h4 id="关于非人工嵌入的一些性质"><a href="#关于非人工嵌入的一些性质" class="headerlink" title="关于非人工嵌入的一些性质"></a>关于非人工嵌入的一些性质</h4><p>如果嵌入方案不是手工完成的话，那么学习到的嵌入方案的每个分量很难给出语义上的解释。尽管它们可能通过一些线性变换变换到每个分量都可以解释的空间中。不管，在诸如 analogy reasoning 之类的算法中，这种嵌入还是很有用的。</p><h2 id="Applications-using-Word-Embeddings"><a href="#Applications-using-Word-Embeddings" class="headerlink" title="Applications using Word Embeddings"></a>Applications using Word Embeddings</h2><h3 id="Sentiment-Classification"><a href="#Sentiment-Classification" class="headerlink" title="Sentiment Classification"></a>Sentiment Classification</h3><p>情感分类用来从一个句子中得出作者是否喜欢他谈论的事物。更加复杂的任务是对喜爱程度进行离散的打分。下面要谈论的算法都是进行打分，因此可以使用多分类来进行。</p><p>一个简单的算法是，取出句子中每个词的嵌入，然后进行平均，然后进行多分类任务。但是这种算法没有考虑到词的顺序。</p><p>稍微复杂但是更可靠的算法是使用 many-to-one 结构的 RNN，将嵌入的序列作为输入，输出一个特征，然后进行多分类。</p><h3 id="Debiasing-word-embeddings"><a href="#Debiasing-word-embeddings" class="headerlink" title="Debiasing word embeddings"></a>Debiasing word embeddings</h3><p>在语料中可能存在一些“偏见”，例如男性和医生的关联程度要比女性和医生的关联程度高，女性和护士的关联程度要比男性和护士的关联程度高。可以通过一定手段在学习到的嵌入方案中消除这种偏见。</p><ol><li>首先需要找到能够产生偏见的那些词，比如 father/mother, male/female, boy/girl 等。对于同一个 topic（这里是性别），将这些词找到之后算出它们的嵌入，然后逐对相减，然后求平均。这样就得到了一个向量，它表示的是性别这个 topic 在整个嵌入空间中的方向。（实际中这个方向不一定是一维的，这里进行了简化）。</li><li>由于剩下的词都和性别无关，但是语料中却不可避免地和性别进行了一定程度的关联，因此可以通过将其它所有词的嵌入都投射到和性别方向正交的某个超平面上。这个超平面的具体位置无所谓，只要它和性别的方向正交就可以了。</li><li>在上一步中即使进行了投射，但是超平面的位置是随便选的，因此 father 和 mother 这两个词距离 doctor 的距离不一定相同。在第三步中需要逐对调整这些和性别高度关联的词的位置，调整方法略去，是一些数学上的变换。最终的结果应当满足两个词的差的方向和性别的方向平行，并且中点位于刚刚选取的超平面上。</li></ol><p>第 3 步中的示意图（来自作业）：</p><img src="/2019/03/23/Sequence-Models-笔记-2-Natural-Language-Processing-Word-Embeddings/equalize10.png"><p>因为需要消除偏见的 topic 较少，而且大部分单词和偏见无关，因此选择 topic 以及选出和 topic 有关的单词的任务可以手工完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sequence Models 笔记 1 Recurrent Neural Networks</title>
      <link href="/2019/03/23/Sequence-Models-%E7%AC%94%E8%AE%B0-1-Recurrent-Neural-Networks/"/>
      <url>/2019/03/23/Sequence-Models-%E7%AC%94%E8%AE%B0-1-Recurrent-Neural-Networks/</url>
      
        <content type="html"><![CDATA[<h1 id="Recurrent-Neural-Networks"><a href="#Recurrent-Neural-Networks" class="headerlink" title="Recurrent Neural Networks"></a>Recurrent Neural Networks</h1><p>来源 <a href="https://www.coursera.org/learn/nlp-sequence-models" target="_blank" rel="noopener">Coursera-Sequence Models</a>.</p><h2 id="Recurrent-Neural-Networks-1"><a href="#Recurrent-Neural-Networks-1" class="headerlink" title="Recurrent Neural Networks"></a>Recurrent Neural Networks</h2><h3 id="Why-sequence-models"><a href="#Why-sequence-models" class="headerlink" title="Why sequence models"></a>Why sequence models</h3><p>一些序列模型的应用：</p><ul><li>Speech recognition</li><li>Music generation</li><li>Sentiment classfication</li><li>DNA Sequence analysis</li><li>Machine translation</li><li>Video activity recognition</li><li>Name entity recognition（从文本序列中标记出表示名称的单词，例如人名）</li></ul><h3 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h3><h4 id="序列相关的记号"><a href="#序列相关的记号" class="headerlink" title="序列相关的记号"></a>序列相关的记号</h4><p>因为小括号、中括号和大括号都被占用了，这里使用尖括号对序列中的元素进行索引。如果 $x$ 是一个样本，它是一个序列，那么它的第 $t$ 个元素是 $x^{\langle k\rangle }$。</p><p>使用 $T_x$ 表示 $x$ 的长度。</p><h4 id="序列的表示"><a href="#序列的表示" class="headerlink" title="序列的表示"></a>序列的表示</h4><p>以文本序列为例，首先准备一个词典，其中包含 <code>&lt;UNK&gt;</code> 表示不在词典中的所有词。每个词都有自己的唯一序号。对于一个序列 $x$，将其中的每个单词都编码为一个 one hot 的向量，其中只有单词在词典中的序号对应的位置是 1，其余位置是零。这样就把一个单词序列编码为了 one hot 向量的序列。</p><h3 id="Recurrent-Neural-Network-Model"><a href="#Recurrent-Neural-Network-Model" class="headerlink" title="Recurrent Neural Network Model"></a>Recurrent Neural Network Model</h3><h4 id="为何不使用普通网络"><a href="#为何不使用普通网络" class="headerlink" title="为何不使用普通网络"></a>为何不使用普通网络</h4><ul><li>普通神经网络在处理序列问题时无法考虑到时间上的局部信息，序列中的每个元素在其看来是平权的。</li><li>出于和引入 CNN 一样的原因，使用 RNN 可以学习到如何对临近的元素提取信息，并可以减小参数数目。</li><li>序列的长度不是固定的，普通神经网络无法处理这个问题。</li></ul><h4 id="递归神经网络"><a href="#递归神经网络" class="headerlink" title="递归神经网络"></a>递归神经网络</h4><p>RNN 可以将一个序列映射到另一个序列。<strong>在整个序列映射过程中，网络参数保持不变。</strong></p><p>对于元素 $x^{\langle t\rangle }$，它对应的 $\hat y^{\langle t\rangle }$ 既取决于输入 $x^{\langle t\rangle }$ 也取决于上次的激活值 $a^{\langle t- 1\rangle }$。在计算过程中，$x^{\langle t\rangle }$ 既产生预测值 $\hat y^{\langle t\rangle }$ 也产生激活值 $a^{\langle t\rangle }$。初始时的 $a^{\langle 0\rangle }$ 可以是零向量，也可以是某个随机值。</p><h4 id="简单递归神经网络的问题"><a href="#简单递归神经网络的问题" class="headerlink" title="简单递归神经网络的问题"></a>简单递归神经网络的问题</h4><p>上述 RNN 的问题在于对于序列中的某个元素只能利用序列中该元素前的信息，而不能利用后续信息。这在一些应用中是不利的，但是有解决方案。</p><h4 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h4><p>RNN 中的一个模块需要维护三个权值和两个偏置：$W_{aa}, W_{ax}, W_{ya}, b_a, b_y$。<em>命名方式：第一个角标指示用来计算什么，第二个角标如果存在依据什么计算。</em></p><p>对于上次的激活值 $a^{\langle t - 1\rangle }$ 以及这次的输入 $x^{\langle t\rangle }$，有</p><script type="math/tex; mode=display">\begin{aligned}a^{\langle t\rangle } &= g_1(W_{aa}a^{\langle t-1\rangle } + W_{ax}x^{\langle t\rangle } + b_a) \\y^{\langle t\rangle } &= g_2(W_{ya}a^{\langle t\rangle } + b_y)\end{aligned}</script><p>可以进一步简化这个符号。如果将 $W_{aa}$ 和 $W_{ax}$ 横向拼接起来得到 $W_a$，将 $W_{ya}$ 记作 $W_y$，将 $a^{\langle t - 1\rangle }$ 和 $x^{\langle t\rangle }$ 纵向拼接起来得到 $[a^{\langle t - 1\rangle }, x^{\langle t\rangle }]$，那么有</p><script type="math/tex; mode=display">\begin{aligned}a^{\langle t\rangle } &= g_1(W_{a}[a^{\langle t-1\rangle }, x^{\langle t\rangle }] + b_a) \\y^{\langle t\rangle } &= g_2(W_{y}a^{\langle t\rangle } + b_y)\end{aligned}</script><p>现在只要维护两个权值和偏置即可。<strong>再次注意对同一个序列而言，各元素计算时使用的参数是相同且共享的。</strong></p><a id="more"></a><h3 id="Backpropagation-through-time"><a href="#Backpropagation-through-time" class="headerlink" title="Backpropagation through time"></a>Backpropagation through time</h3><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>对于序列中的每个元素的输出可以定义损失函数 $\mathcal L(\hat y^{\langle t\rangle }, y^{\langle t\rangle })​$，将每个元素的损失函数加起来就得到了序列的损失函数 $\mathcal L(\hat y, y) = \sum\limits_{t = 1}^{T_y}\mathcal L(\hat y^{\langle t\rangle }, y^{\langle t\rangle })​$。</p><h4 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h4><p>对于一个序列，如果将计算过程中各个值的依赖关系有有向图表示出来，会得到一张 DAG。其中输入包括 $a^{\langle 0\rangle }, W_a, b_a, W_y, b_y, x^{\langle 1\rangle }, x^{\langle 2\rangle }, \dots, x^{\langle T_x\rangle }$，输出只有 $\mathcal L(\hat y, y)$。理论上，只要是 DAG 就可以对变量 $W_a, b_a, W_y, b_y$（或者包括 $a^{\langle 0\rangle }$）求导，然后梯度下降更新；实现上也没太大难度。</p><h3 id="Different-types-of-RNNs"><a href="#Different-types-of-RNNs" class="headerlink" title="Different types of RNNs"></a>Different types of RNNs</h3><p>有多种输入输出规模不同的 RNN。</p><h4 id="Many-to-many"><a href="#Many-to-many" class="headerlink" title="Many-to-many"></a>Many-to-many</h4><p>这种 RNN 就是上面写的。接受输入序列 $x​$ 返回输出序列 $\hat y$，并且满足 $T_x = T_y​$。</p><h4 id="Many-to-one"><a href="#Many-to-one" class="headerlink" title="Many-to-one"></a>Many-to-one</h4><p>接受输入序列 $x​$，但是只生成一个元素 $\hat y​$。典型的应用例如将文本评价转换为打分。结构上，可以认为和 many-to-many 的 RNN 类似，但是输出序列中除了 $\hat y^{\langle T_y\rangle }​$ 以外的元素都被忽略掉了。</p><h4 id="One-to-one"><a href="#One-to-one" class="headerlink" title="One-to-one"></a>One-to-one</h4><p>这种是 RNN 的退化情况，实际上就是简单的全连接网络。</p><h4 id="One-to-many"><a href="#One-to-many" class="headerlink" title="One-to-many"></a>One-to-many</h4><p>这种可以用来做序列生成，接受一个可以看做是种子的元素 $x​$ 生成序列 $\hat y​$。和普通的 RNN 类似，但是在后面的计算中因为缺失除了 $x^{\langle 1\rangle }​$ 以外的输入 ，于是使用 $\hat y^{\langle t - 1\rangle }​$ 当做 $x^{\langle t\rangle }​$。</p><h4 id="Many-to-many-with-different-length"><a href="#Many-to-many-with-different-length" class="headerlink" title="Many-to-many with different length"></a>Many-to-many with different length</h4><p>很多应用中，输入序列的长度和输出序列的长度不是相等的，例如机器翻译。为了实现这一点，可以将一个 many-to-one 当做 encoder，将一个 one-to-many 当做 decoder，然后将二者连接起来，就实现了输入输出不等长的 many-to-many。</p><h3 id="Language-model-and-sequence-generation"><a href="#Language-model-and-sequence-generation" class="headerlink" title="Language model and sequence generation"></a>Language model and sequence generation</h3><h4 id="什么是语言建模"><a href="#什么是语言建模" class="headerlink" title="什么是语言建模"></a>什么是语言建模</h4><p>对语言建模后，语言模型可以对一个句子（单词的序列）给出这个句子在该语言下出现的概率。如果得分较高，表明这个句子是合理的，反之是不合理的。</p><h4 id="如何对语言建模"><a href="#如何对语言建模" class="headerlink" title="如何对语言建模"></a>如何对语言建模</h4><p>首先准备很多句子的语料库用来进行训练。对于任意一个句子，它是单词的序列，记作 $x$。首先对句子拆分为 token。现在序列中要么是表示词典中已有单词的 token，要么是表示单词未知的 <code>&lt;UNK&gt;</code>，要么是表示句子结束的 <code>&lt;EOS&gt;</code>。然后对 token 进行 one-hot 编码。现在 $x$ 应当是 one-hot 向量的序列。</p><p>使用 RNN 进行训练。根据 $x$ 构建这样的输入序列 $x&#39;$：$x&#39;^{\langle 1\rangle } =  \vec 0$，$x&#39;^{\langle t\rangle } = x^{\langle t - 1\rangle }$，使得 $x&#39;$ 有 $T_x$ 个元素。如此一来 $x&#39;$ 中没有 <code>&lt;EOS&gt;</code>。然后让 $x$ 作为目标序列。训练这个 RNN 即可。</p><p><strong>有效的原因：</strong>考虑序列中的第一个元素，输入为 $x&#39;^{\langle 1\rangle } = \vec 0$，输出为 $\hat y^{\langle 1\rangle }$，这个输出是一个经过了 softmax 的表示句子中第一个单词是 $x^{\langle 1\rangle }$ 对应单词的概率，即 $P(x^{\langle 1\rangle })$。考虑第二个元素，输入为 $x&#39;^{\langle 2\rangle } = x^{\langle 1\rangle }$，输出表示的是在已知第一个单词是 $x^{\langle 1\rangle }$ 的情况下，句子的第二个单词是 $x^{\langle 2\rangle }$ 的概率，即 $P(x^{\langle 2\rangle }|x^{\langle 1\rangle })$。依此类推。最后一个输出是句子在这个地方结束的概率。</p><p>现在对于一个句子，它出现在语言中的概率可以根据将句子送进这个网络中产生的输出计算。比如句子是 this is a dog，则送入网络，第一次没有输入，第一个输出将给出语言中所有句子的第一个单词的概率分布，自然就知道单词是 this 的概率；第二次输入 this，第二次的输出给出了在已知了第一个单词是 this 的情况下，第二个单词的概率分布，自然就知道了单词是 is 的概率。类推即可。最后按照贝叶斯公式全部乘起来就得到了句子出现在语言中的概率。</p><h3 id="Sampling-novel-sequences"><a href="#Sampling-novel-sequences" class="headerlink" title="Sampling novel sequences"></a>Sampling novel sequences</h3><h4 id="生成文本"><a href="#生成文本" class="headerlink" title="生成文本"></a>生成文本</h4><p>使用建好模型的语言可以生成文本。还是用上面那个 RNN。第一步提供空输入，网络会返回第一个单词的概率分布。按照这个概率分布随机选择一个单词，将这个词作为生成的文本的第一个单词。然后构建这个词的 one-hot 向量后作为输入的第二个元素送入网络，则网络会给出在第一个单词正是该单词的情况下，第二个单词的概率分布。不断这样做下去。</p><p><strong>何时终止</strong>：如果 <code>&lt;EOS&gt;</code> 在字典中，可以在生成该 token 时终止，或者提前选好句子长度。</p><p>如果遇见了 <code>&lt;UNK&gt;</code>，可以不作处理或者重新选取单词。</p><h4 id="使用字符作为-token"><a href="#使用字符作为-token" class="headerlink" title="使用字符作为 token"></a>使用字符作为 token</h4><p>除了将单词作为 token 构建序列外也可以将字符作为 token 构建序列。</p><p><strong>好处</strong>：不用操心 <code>&lt;UNK&gt;</code>，因为可能出现的字符必然是有限的。</p><p><strong>坏处</strong>：序列的长度很长，计算量大。</p><h3 id="Vanishing-gradients-with-RNNs"><a href="#Vanishing-gradients-with-RNNs" class="headerlink" title="Vanishing gradients with RNNs"></a>Vanishing gradients with RNNs</h3><h4 id="简单-RNN-的问题"><a href="#简单-RNN-的问题" class="headerlink" title="简单 RNN 的问题"></a>简单 RNN 的问题</h4><p>因为序列的每个元素都会走一遍网络，所以网络可以在序列上“展开”。展开后会发现一层 RNN 变成了序列元素那么多层，如果序列很长的话，展开后的网络就会很深，这会带来梯度消失或者爆炸的问题。这将导致网络在调整权重时主要靠的是最后几个元素的影响，前面的若干元素的影响难以考虑到。</p><p>此外，直观上可以看到，对于很长的序列而言，生成的序列中的每个元素都主要依赖于它前面的几个元素，而更加前面的信息则容易丢失。这表明简单的 RNN 无法很好地处理对长距离的依赖。</p><h4 id="梯度爆炸的解决方案"><a href="#梯度爆炸的解决方案" class="headerlink" title="梯度爆炸的解决方案"></a>梯度爆炸的解决方案</h4><p>对于梯度爆炸有个简单的解决方案，就是预先设定一个阈值。如果梯度绝对值大于该阈值就在此将其截断，使得梯度绝对值总是不会超过阈值。</p><h3 id="Gated-Recurrent-Unit-GRU"><a href="#Gated-Recurrent-Unit-GRU" class="headerlink" title="Gated Recurrent Unit (GRU)"></a>Gated Recurrent Unit (GRU)</h3><p>GRU 通过在网络中引入负责记忆的单元来解决长距离的依赖问题。想法是在计算 $a^{\langle t \rangle}$ 的过程中，有时候适当保存 $a^{\langle t \rangle}$ 中的若干分量，在处理接下来的一些元素时保持这些分量不变，直到某个特定的时刻再允许其变动。此时的 $a^{\langle t \rangle}$ 在处理同一个序列的不同元素的过程中变成了某种像寄存器一样的东西，因此使用新的记号 $c^{\langle t \rangle}$ 来表示它（c 代表 cell）。此外，还需要引入一个量控制 $c^{\langle t \rangle}$ 是否不变，这个量为 $\Gamma_u$（u 代表 update）。</p><h4 id="简化版-GRU"><a href="#简化版-GRU" class="headerlink" title="简化版 GRU"></a>简化版 GRU</h4><p>在简单的 RNN 中，有：</p><script type="math/tex; mode=display">\begin{aligned}a^{\langle t\rangle } &= g_1(W_{a}[a^{\langle t-1\rangle }, x^{\langle t\rangle }] + b_a) \\y^{\langle t\rangle } &= g_2(W_{y}a^{\langle t\rangle } + b_y)\end{aligned}</script><p>进行如下的改造：</p><ul><li>用 $c^{\langle t \rangle}$ 替换 $a^{\langle t \rangle}$。</li><li>在计算 $c^{\langle t \rangle}$ 时，首先计算出候选值 $\tilde{c}^{\langle t \rangle}$，同时更新 $\Gamma_u$ 的值。</li><li>使用 $\Gamma_u$ 决定 $c^{\langle t \rangle}$ 是被保持还是被候选值替代。</li></ul><p>公式变成：</p><script type="math/tex; mode=display">\begin{aligned}\tilde c^{\langle t\rangle } &= g_1(W_{c}[c^{\langle t-1\rangle }, x^{\langle t\rangle }] + b_c) \\\Gamma_u &= \sigma(W_{u}[c^{\langle t-1\rangle }, x^{\langle t\rangle }] + b_u) \\c^{\langle t\rangle } &= \Gamma_u\ast \tilde{ c}^{\langle t \rangle} + (1 - \Gamma_u)\ast c^{\langle t - 1 \rangle} \\y^{\langle t\rangle } &= g_2(W_{y}c^{\langle t\rangle } + b_y)\end{aligned}</script><p>因为 $\Gamma_u$ 是经过 sigmoid 后得到的，因此大部分元素都接近 0 或者 1。$\Gamma_u$ 的大小和 $c^{\langle t \rangle}$ 是相同的，在第三个式子中，$\ast$ 进行的是逐元素乘法。考虑到 $\Gamma_u$ 的性质，它表示的意思就是让 $c^{\langle t - 1 \rangle}$ 中一部分元素更新为新的值，一部分元素保持原有值不变。从第二个式子可以看到每次计算 $\Gamma_u$ 时，只取决于上次的记忆单元的值和正在处理的元素，还比较合理。</p><p>这样建模的话，网络在处理序列中元素的过程中，每个序列中的元素都会更新一下 $c^{\langle t \rangle}$，但是因为 GRU 的机制，并非 $c^{\langle t \rangle}$ 的所有分量都被更新了，一个分量是否更新取决于它自己的值和读入的序列元素。这样一来，$c^{\langle t \rangle}$ 的某些分量就有可能在长序列中始终保持不变从而实现将信息存储起来，在经过了长序列后，这段序列前的一些重要信息依然得以保留，便实现了在长距离上的依赖关系。$\Gamma_u$ 可以看作是是否更新的“门”。$c^{\langle t \rangle}$ 中的每个分量可以看作是一个能够存储一个标量的寄存器，什么时候打开，什么时候关闭取决于 $c^{\langle t \rangle}$ 的内容和输入内容。</p><h4 id="完整版-GRU"><a href="#完整版-GRU" class="headerlink" title="完整版 GRU"></a>完整版 GRU</h4><p>上述 GRU 是一个简化版本。实际在计算候选值 $\tilde{c}^{\langle t \rangle}$ 时，我们还引入了一个控制 $c^{\langle t - 1 \rangle}$ 中的哪些分量会影响 $\tilde{c}^{\langle t \rangle}$ 的门 $\Gamma_r$（r 表示 relevance）。完整的 GRU 的公式为：</p><script type="math/tex; mode=display">\begin{aligned}\Gamma_r &= \sigma(W_{r}[c^{\langle t-1\rangle }, x^{\langle t\rangle }] + b_r) \\\tilde c^{\langle t\rangle } &= g_1(W_{c}[\Gamma_r \ast c^{\langle t-1\rangle }, x^{\langle t\rangle }] + b_c) \\\Gamma_u &= \sigma(W_{u}[c^{\langle t-1\rangle }, x^{\langle t\rangle }] + b_u) \\c^{\langle t\rangle } &= \Gamma_u\ast \tilde{ c}^{\langle t \rangle} + (1 - \Gamma_u)\ast c^{\langle t - 1 \rangle} \\y^{\langle t\rangle } &= g_2(W_{y}c^{\langle t\rangle } + b_y)\end{aligned}</script><p>这样一来，一个完整的 GRU 单元需要维护 4 个权值和 4 个偏置。</p><h3 id="Long-Short-Term-Memory-LSTM"><a href="#Long-Short-Term-Memory-LSTM" class="headerlink" title="Long Short Term Memory (LSTM)"></a>Long Short Term Memory (LSTM)</h3><h4 id="常见版-LSTM"><a href="#常见版-LSTM" class="headerlink" title="常见版 LSTM"></a>常见版 LSTM</h4><p>常见版本的 LSTM 在 GRU 基础上的改动：</p><ul><li>GRU 中的记忆单元 $c^{\langle t \rangle}$ 和激活值是同一个量，但是 LSTM 将它们分开了。现在激活值就是激活值，不再负责存储；$c^{\langle t \rangle}$ 专门负责存储。</li><li>移除了负责关联的 $\Gamma_r$。</li><li>引入了两个新的门 $\Gamma_f$（forget）和 $\Gamma_o$（output）。</li></ul><p>公式如下：</p><script type="math/tex; mode=display">\begin{aligned}\tilde c^{\langle t\rangle } &= g_1(W_{c}[a^{\langle t-1\rangle }, x^{\langle t\rangle }] + b_c) \\\Gamma_u &= \sigma(W_{u}[a^{\langle t-1\rangle }, x^{\langle t\rangle }] + b_u) \\\Gamma_f &= \sigma(W_{f}[a^{\langle t-1\rangle }, x^{\langle t\rangle }] + b_f) \\\Gamma_o &= \sigma(W_{o}[a^{\langle t-1\rangle }, x^{\langle t\rangle }] + b_o) \\c^{\langle t\rangle } &= \Gamma_u\ast \tilde{ c}^{\langle t \rangle} + \Gamma_f\ast c^{\langle t - 1 \rangle} \\a^{\langle t \rangle} &= \Gamma_o\ast g_2(c^{\langle t \rangle}) \\y^{\langle t\rangle } &= g_3(W_{y}a^{\langle t\rangle } + b_y)\end{aligned}</script><p>逐行解释：</p><ul><li>根据上次的激活输出、这次的序列输入决定候选的记忆单元值。</li><li>根绝上次的激活输出、这次的序列输入决定 $\Gamma_u, \Gamma_f, \Gamma_o$。</li><li>根据 $\Gamma_u, \Gamma_f$ 决定记忆单元如何更新。其中 $\Gamma_u$ 负责更新，如果某个分量为零就表示不更新；$\Gamma_f$ 表示遗忘，如果某个分量为零就表示忘掉记忆单元原来的值。这是 $c^{\langle t - 1 \rangle}$ 和 $c^{\langle t \rangle}$ 的唯一联系。</li><li>根据当前记忆单元的值算出这次的激活输出。</li><li>根据这次的激活输出算出这次的序列输出。</li></ul><p>和 GRU 一样，$c^{\langle t \rangle}$ 可以看作是一组寄存器。LSTM 比 GRU 更加复杂，毕竟门更多。代价是 GRU 的运算更加简单。</p><h4 id="带-Peephole-connection-的-LSTM"><a href="#带-Peephole-connection-的-LSTM" class="headerlink" title="带 Peephole connection 的 LSTM"></a>带 Peephole connection 的 LSTM</h4><p>LSTM 最常见的一个变种是带有 peephole connection 的 LSTM。在上面的公式中，$\Gamma_u, \Gamma_f, \Gamma_o$ 只取决于上次的激活输出和这次的序列输入，而使用 peephole connection 后，它们还取决于上次的记忆单元的值。</p><p>注意在使用 peephole connection 时，$\Gamma_u, \Gamma_f, \Gamma_o$ 虽然会受到记忆单元的影响，但是记忆单元的一个分量只会影响到 $\Gamma_u, \Gamma_f, \Gamma_o$ 中对应位置的分量的值。换言之，记忆单元对 $\Gamma_u, \Gamma_f, \Gamma_o$ 在分量上是一对一的。</p><h3 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN"></a>Bidirectional RNN</h3><p>上面的所有内容都是单向的 RNN。这种 RNN 在处理序列中的元素时，无法利用后面的元素的信息。使用双向的 RNN 可以解决这个问题。</p><p>想法：如果序列不是一个无限长的流，那么它总是有限的。用 RNN 正向处理一遍这个序列，会生成一个序列；如果反向处理一遍这个序列又可以生成一个序列。这两个序列结合起来得到的序列就是最终生成的序列。在最终的序列中，每个元素即受到了序列中在它前面的元素的影响，也受到了在它后面的元素的影响。</p><p>直观来看：</p><img src="/2019/03/23/Sequence-Models-笔记-1-Recurrent-Neural-Networks/DeepinScreenshot_select-area_20190328210024.png"><p>注意即使正向反向都搞了一遍，整个图还是无环的。生成 $\hat y^{\langle t \rangle}$ 的方法可以使用 $\hat y^{\langle t \rangle} = W_y[\overrightarrow a^{\langle t \rangle}, \overleftarrow a^{\langle t \rangle}] + b_y$来计算。</p><p>在 NLP 任务中常用的套路是双向 LSTM。</p><h3 id="Deep-RNNs"><a href="#Deep-RNNs" class="headerlink" title="Deep RNNs"></a>Deep RNNs</h3><p>一层 RNN 可以将一个序列映射到另一个序列，得到的序列可以继续通过新的 RNN。这样做就可以将多层 RNN 叠起来得到一个复杂的网络。</p><p>因为 RNN 可以在序列上展开，所以一层 RNN 的计算量就比较大了，这也是为什么三层的 RNN 就算比较深的 RNN 网络了。</p><p>一种常用的架构是让序列通过多层 RNN 后得到的序列中的每个元素都再通过一个独立的小神经网络。注意每个元素都是一个向量，通过神经网络后得到的还是一个向量。例如最开始的输入序列长度为 n，经过 RNN 后得到的序列长度为 m，让这 m 个元素（每个是一个向量）独立地经过 m 个不同的神经网络，就可以再次得到长度为 m 的向量序列。这个序列可以作为最后的输出（并且每个元素不一定等长/平权）。</p><h2 id="关于-RNN-的反向传播"><a href="#关于-RNN-的反向传播" class="headerlink" title="关于 RNN 的反向传播"></a>关于 RNN 的反向传播</h2><p>此处内容来自于作业。推导中一些细节被略去了。</p><h3 id="普通-RNN-的反向传播"><a href="#普通-RNN-的反向传播" class="headerlink" title="普通 RNN 的反向传播"></a>普通 RNN 的反向传播</h3><h4 id="一个时间步上的反向传播"><a href="#一个时间步上的反向传播" class="headerlink" title="一个时间步上的反向传播"></a>一个时间步上的反向传播</h4><p>首先考虑一个时间步上的情况。假设我们已经知道了 $\displaystyle{\frac{\partial J}{\partial a^{\langle t\rangle}}}$。</p><p>假设使用的激活函数是 $\tanh$，那么有 $\displaystyle{a^{\langle t \rangle} = \tanh(W_{aa} a^{\langle t - 1 \rangle} + W_{ax} x^{\langle t \rangle} + b_a)}$。我们知道：</p><ul><li>$\displaystyle{\frac{\partial \tanh x}{\partial x}=1 - \tanh^2(x)}$</li><li>$\displaystyle{\mathbf Z = \mathbf {XY}, \frac{\partial J}{\partial \mathbf Z} = \mathbf M \Rightarrow \frac{\partial J}{\partial \mathbf X} = \mathbf M\mathbf Y^T, \frac{\partial J}{\partial \mathbf Y}=\mathbf X^T \mathbf M}$</li></ul><p>于是有：</p><ul><li>$\displaystyle{\frac{\partial J}{\partial W_{aa}} = (1 - \tanh^2(W_{aa} a^{\langle t - 1 \rangle} + W_{ax} x^{\langle t \rangle} + b_a)){a^{\langle t - 1 \rangle}}^T}$</li><li>$\displaystyle{\frac{\partial J}{\partial a ^{\langle t - 1 \rangle}} = W_{aa}^T(1 - \tanh^2(W_{aa} a^{\langle t - 1 \rangle} + W_{ax} x^{\langle t \rangle} + b_a))}$</li><li>$\displaystyle{\frac{\partial J}{\partial W_{ax}} = (1 - \tanh^2(W_{aa} a^{\langle t - 1 \rangle} + W_{ax} x^{\langle t \rangle} + b_a)){x^{\langle t \rangle}}^T}$</li><li>$\displaystyle{\frac{\partial J}{\partial x ^{\langle t \rangle}} = W_{ax}^T(1 - \tanh^2(W_{aa} a^{\langle t - 1 \rangle} + W_{ax} x^{\langle t \rangle} + b_a))}$</li><li>$\displaystyle{\frac{\partial J}{\partial b_a} = 1 - \tanh^2(W_{aa} a^{\langle t - 1 \rangle} + W_{ax} x^{\langle t \rangle} + b_a)}$</li></ul><p><em>计算时触发了 boardcast，所以在计算 $\displaystyle{\frac{\partial J}{\partial b_a}}$ 时应当注意缩减一下维度。</em></p><p>一个问题是 $\displaystyle{\frac{\partial J}{\partial a^{\langle t\rangle}}}$ 是怎么知道的。不严谨地，因为 $\displaystyle{a ^{\langle t \rangle}}$ 会参与计算 $\displaystyle{y ^{\langle t \rangle}}$，而 $\displaystyle{y ^{\langle t \rangle}}$ 会参与计算损失函数。</p><h4 id="一个序列上的反向传播"><a href="#一个序列上的反向传播" class="headerlink" title="一个序列上的反向传播"></a>一个序列上的反向传播</h4><blockquote><p>$\displaystyle{a ^{\langle t \rangle}}$ 会参与计算 $\displaystyle{y ^{\langle t \rangle}}$，而 $\displaystyle{y ^{\langle t \rangle}}$ 会参与计算损失函数。</p></blockquote><p>似乎从这里可以知道对于一个序列而言，我们就已经知道了对每个元素的 $\displaystyle{\frac{\partial J}{\partial a^{\langle t\rangle}}}$。但是实际情况并非如此，因为除了最后一个元素 $\displaystyle{a ^{\langle T_x \rangle}}$ 以外，其它的 $\displaystyle{a ^{\langle t \rangle}}$ 还会影响后续的 $\displaystyle{a ^{\langle t \rangle}}$。所以我们只知道 $\displaystyle{\frac{\partial J}{\partial a^{\langle T_x\rangle}}}$，要反着往回进行计算。</p><p>首先对序列中的最后一个元素套用上一节的过程，可以得到 $\displaystyle{\frac{\partial J}{\partial x ^{\langle T_x \rangle}}, \frac{\partial J}{\partial a ^{\langle T_x - 1 \rangle}}, \frac{\partial J}{\partial W_{ax}}, \frac{\partial J}{\partial W_{aa}}, \frac{\partial J}{\partial b_a}}$。</p><p>然后按照序列的顺序倒着操作，对每个元素套用上一节的过程。不过，在给定输入 $\displaystyle{\frac{\partial J}{\partial a^{\langle t\rangle}}}$ 时，它是由两部分组成的，一个是来自后一个序列得到的 $\displaystyle{\left(\frac{\partial J}{\partial a ^{\langle (t + 1) - 1 \rangle}}\right)_1}$，一个是从计算 $\displaystyle{y ^{\langle t \rangle}}$ 这条路径得到的 $\displaystyle{\left(\frac{\partial J}{\partial a ^{\langle t - 1 \rangle}}\right)_2}$。按照计算图求导的搞法，这两个量要加起来才能作为真实的输入。</p><p>当对整个序列全部执行了上述过程后，会得到多个不同的 $\displaystyle{\frac{\partial J}{\partial W_{ax}}, \frac{\partial J}{\partial W_{aa}}, \frac{\partial J}{\partial b_a}}$。还是按照计算图的搞法，不同的 $\displaystyle{\frac{\partial J}{\partial W_{ax}}}$ 加起来才是最后真实的 $\displaystyle{\frac{\partial J}{\partial W_{ax}}}$（因为在计算过程中一共走了 $\displaystyle{T_x}$ 条影响最终结果的路径）。$\displaystyle{W_{aa}, b_a}$ 相同。</p><p>此外还会得到对整个序列的 $\displaystyle{\frac{\partial J}{\partial x ^{\langle t \rangle}}}$，由于可能是多层 RNN 的复合，所以这个量是有意义的。将它们放在一个张量中作为对输入的导数。</p><h3 id="LSTM-的反向传播"><a href="#LSTM-的反向传播" class="headerlink" title="LSTM 的反向传播"></a>LSTM 的反向传播</h3><p>实在是推不动，还是算了吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式化验证课程笔记 4</title>
      <link href="/2019/03/18/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-4/"/>
      <url>/2019/03/18/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-4/</url>
      
        <content type="html"><![CDATA[<h1 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h1><h2 id="Review-FOL"><a href="#Review-FOL" class="headerlink" title="Review FOL"></a>Review FOL</h2><h3 id="Logical-Symbols-and-Non-logical-Symbols"><a href="#Logical-Symbols-and-Non-logical-Symbols" class="headerlink" title="Logical Symbols and Non-logical Symbols"></a>Logical Symbols and Non-logical Symbols</h3><ul><li>Logical symbols: propositional connectives, variables, quantifiers.</li><li>Non-logical symbols: constant symbols, function symbols, predicate symbols.</li></ul><h3 id="Interpretation-and-Assignment"><a href="#Interpretation-and-Assignment" class="headerlink" title="Interpretation and Assignment"></a>Interpretation and Assignment</h3><ul><li>Interpretation fixes values for constants.</li><li>Assignment fixes values for variables.</li></ul><h2 id="First-Order-Theory-Motivation"><a href="#First-Order-Theory-Motivation" class="headerlink" title="First-Order Theory: Motivation"></a>First-Order Theory: Motivation</h2><p>First-order logic is very general but undecidable. By limiting the non-logical symbols, we can have something stronger then propositional logic but still decidable, which is first-order theory. First-order theory is weaker then FOL.</p><h2 id="Defining-a-First-Order-Theory"><a href="#Defining-a-First-Order-Theory" class="headerlink" title="Defining a First-Order Theory"></a>Defining a First-Order Theory</h2><p>A first-order logic contains:</p><ul><li><strong>Signature</strong> $\Sigma$,  a set of non-logic symbols</li><li><strong>Axioms</strong> $\mathcal{A}$, a set of closed formulas over $\Sigma$</li></ul><p><strong>$\Sigma$ limits the symbols and $\mathcal A$ gives them semantics.</strong></p><p>Formula only containing symbols from $\Sigma$ is called $\Sigma​$-formula.</p><h2 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h2><ul><li><strong>T-interpretation/T-model</strong>: A tuple of domain and interpretation $(D, I)$ satisfying $\forall A\in \mathcal A, (D, I)\vDash A$. (Domain and interpretation satisfying all axioms.)</li><li><strong>T-satisfaction</strong>: $F$ is T-satisfiable if you can find a T-model $T$ and an assignment $\alpha$ such that $T, \alpha\vDash F$.</li><li><strong>T-validity</strong>: Similar as above, but asks for all T-models and assignments. Written as $T\vDash F$. <strong>A theory is the set of all closed formulas that are T-valid.</strong></li><li><strong>T-entailment</strong>: $F_1$ T-entails $F_2$ if $T\vDash F_1\rightarrow F_2$.</li><li><strong>T-equivalence</strong>: Similar as above but asks for $F_1\leftrightarrow F_2$.</li></ul><a id="more"></a><p>Copying from materials:</p><img src="/2019/03/18/形式化验证课程笔记-4/DeepinScreenshot_select-area_20190321204753.png"><hr><p>Below are some examples of first-order theories.</p><h2 id="Proving"><a href="#Proving" class="headerlink" title="Proving"></a>Proving</h2><p>If you want to prove validity of some formula of a first-order theory, you can use FOL rules and axioms from the theory.</p><h2 id="Theory-of-Equality-T-E"><a href="#Theory-of-Equality-T-E" class="headerlink" title="Theory of Equality $T_E$"></a>Theory of Equality $T_E$</h2><ul><li>Signature: $\Sigma_E = \{=, a, b, \dots, p, q, r, \dots\}​$</li><li>Axioms:<ul><li><strong>Reflexivity</strong>: $\forall x :: x = x​$</li><li><strong>Symmetry</strong>: $\forall x, y::x = y\rightarrow y = x​$</li><li><strong>Transitivity</strong>: $\forall x, y, z:: x= y\land y - z\rightarrow x = z​$</li><li><strong>Function congruence</strong>:$\forall \vec x, \vec y::\vec x_i =\vec y_i \rightarrow f(\vec x) = f(\vec y)​$</li><li><strong>Predicate congruence</strong>:$\forall \vec x, \vec y::\vec x_i =\vec y_i \rightarrow (p(\vec x) \leftrightarrow p(\vec y))$</li></ul></li><li><p><strong>Not decidable.</strong> FOL is not weaker than $T_E$.</p></li><li><p>Quantifier free fragment of $T_E$ is decidable.</p></li></ul><h2 id="Peano-Arithmetic-T-PA"><a href="#Peano-Arithmetic-T-PA" class="headerlink" title="Peano Arithmetic $T_{PA}$"></a>Peano Arithmetic $T_{PA}$</h2><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><img src="/2019/03/18/形式化验证课程笔记-4/DeepinScreenshot_select-area_20190321205853.png"><h3 id="Axioms"><a href="#Axioms" class="headerlink" title="Axioms"></a>Axioms</h3><img src="/2019/03/18/形式化验证课程笔记-4/DeepinScreenshot_select-area_20190321205918.png"><img src="/2019/03/18/形式化验证课程笔记-4/DeepinScreenshot_select-area_20190321210026.png"><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>Satisfiability and validity are undecidable. Also incomplete. Quantifier-free fragment undecidable.</p><h2 id="Presburger-Arithmetic-T-mathbb-N"><a href="#Presburger-Arithmetic-T-mathbb-N" class="headerlink" title="Presburger Arithmetic $T_\mathbb{N}$"></a>Presburger Arithmetic $T_\mathbb{N}$</h2><h3 id="Signature-and-Axioms"><a href="#Signature-and-Axioms" class="headerlink" title="Signature and Axioms"></a>Signature and Axioms</h3><p>Almost the same with $T_{PA}$ but removes all things about multiplication.</p><h3 id="Properties-1"><a href="#Properties-1" class="headerlink" title="Properties"></a>Properties</h3><p>Decidable and complete.</p><h2 id="Linear-Integer-Arithmetic-T-mathbb-Z"><a href="#Linear-Integer-Arithmetic-T-mathbb-Z" class="headerlink" title="Linear-Integer Arithmetic $T_\mathbb{Z}$"></a>Linear-Integer Arithmetic $T_\mathbb{Z}$</h2><img src="/2019/03/18/形式化验证课程笔记-4/DeepinScreenshot_select-area_20190321211100.png"><img src="/2019/03/18/形式化验证课程笔记-4/DeepinScreenshot_select-area_20190321211108.png"><p><strong>$T_\mathbb{Z}$ only support multiplying a variable with a constant number!</strong></p><h2 id="Theory-of-Arrays-T-A"><a href="#Theory-of-Arrays-T-A" class="headerlink" title="Theory of Arrays $T_A$"></a>Theory of Arrays $T_A$</h2><h3 id="Signature-1"><a href="#Signature-1" class="headerlink" title="Signature"></a>Signature</h3><img src="/2019/03/18/形式化验证课程笔记-4/DeepinScreenshot_select-area_20190321211435.png"><p><strong>Logic is static, so read and write won&#39;t modifies the array, but create a modified copy version of the array.</strong></p><h3 id="Axioms-1"><a href="#Axioms-1" class="headerlink" title="Axioms"></a>Axioms</h3><img src="/2019/03/18/形式化验证课程笔记-4/DeepinScreenshot_select-area_20190321211609.png"><p><strong>We didn&#39;t define equality over arrays, only over array elements.</strong></p><h3 id="Properties-2"><a href="#Properties-2" class="headerlink" title="Properties"></a>Properties</h3><p>Undecidable. Quantifier-free fragment decidable.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 形式化验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convolutional Neural Networks 笔记 3 Object detection</title>
      <link href="/2019/03/14/Convolutional-Neural-Networks-%E7%AC%94%E8%AE%B0-3-Object-detection/"/>
      <url>/2019/03/14/Convolutional-Neural-Networks-%E7%AC%94%E8%AE%B0-3-Object-detection/</url>
      
        <content type="html"><![CDATA[<h1 id="Object-detection"><a href="#Object-detection" class="headerlink" title="Object detection"></a>Object detection</h1><h2 id="Detection-algorithms"><a href="#Detection-algorithms" class="headerlink" title="Detection algorithms"></a>Detection algorithms</h2><h3 id="Object-Localization"><a href="#Object-Localization" class="headerlink" title="Object Localization"></a>Object Localization</h3><h4 id="图像输入的任务"><a href="#图像输入的任务" class="headerlink" title="图像输入的任务"></a>图像输入的任务</h4><p>对于图像输入，常见的任务有以下几种：</p><ul><li>Image classification（分类）：对图像进行分类。</li><li>Classification with localization（带定位的分类）：对图像进行分类并且给出目标的 bounding box。</li><li>Detection（目标检测）：对图像中的目标给出 bounding box。</li></ul><p>其中分类和带定位的分类都只有一个目标对象，而目标检测可能有多个目标对象。</p><h4 id="输出的定义"><a href="#输出的定义" class="headerlink" title="输出的定义"></a>输出的定义</h4><p>对于带定位的分类，处理手段一般是将图片通过 CNN 然后提取出一个特征，该特征的构成如下：第一个分量 $\displaystyle{p_c}​$ 指示了图片中存在目标的概率（因为这种任务中输入可能是什么目标都没有）；随后的四个分量分别指出了目标在图片中的位置和 bounding box 大小；随后的若干个分量来自于一个 softmax 的输出，指示了目标的分类。因此，如果分类有 $n​$ 个，特征就有 $\displaystyle{n + 5}​$ 个分量。</p><ul><li>对于第一个分量，如果接近零表示无目标，此时后续分量没有意义。计算损失函数时记得考虑。</li><li>对于后面的四个分量 $\displaystyle{b_x, b_y, b_h, b_w}$，它们的值介于 0 到 1 之间。其中 $\displaystyle{b_x, b_y}$ 指示目标中心点的位置；$\displaystyle{b_h, b_w}$ 指示目标的高度和宽度。位置和长度都是以图片作为基准单位的，图片左上角坐标为 $\displaystyle{(0, 0)}$，右下角为 $\displaystyle{(1, 1)}$；图片的长和宽都定为 1。</li></ul><p>在计算损失函数时，一般在 $\displaystyle{p_c = 1}$ 时采用均方误差，$\displaystyle{p_c = 0}$ 时只看算法是否预测对了图像中没有目标。也可以将代表分类的那几个分量单独取出做交叉熵。</p><a id="more"></a><h3 id="Landmark-Detection"><a href="#Landmark-Detection" class="headerlink" title="Landmark Detection"></a>Landmark Detection</h3><p>Landmark detection 可以用来识别图片中的关键点，例如人脸的眼角、身躯的骨骼等。在 AR 领域有应用。它和上一节的不同之处在于 landmark detection 只用给出点的位置，而不需要大小。</p><p>对于一类图片可以给出多个 landmark，每个 landmark 占用两个分量来表示坐标。此外，还需要一个额外的分量来表示给定的图片到底是不是存在可以判定的对象（实际上就是二分类 CNN 的输出）。如果要给出多个 landmark，那么一个网络的输出中每个 landmark 的顺序必须是固定的：例如要识别身躯的头部，头部是第一个 landmark，那么网络给出的所有输出中，第一组坐标对应的都是头部。</p><h3 id="Object-Detection"><a href="#Object-Detection" class="headerlink" title="Object Detection"></a>Object Detection</h3><p>现在考虑目标检测任务，可以搞出下面这个非常垃圾的实现。</p><ol><li>首先准备一些训练样本图片，这些样本图片要么是几乎完全被目标占据的，要么就是没有目标的。然后训练出一个 CNN 让它能够将这两类样本分开。</li><li>随后就可以开始进行目标检测了。这里使用滑窗算法，选择窗口大小和步长，在要进行目标检测的图片上滑动。滑动的结果送入 CNN 中判定是否是目标，如果是的话就标记为一个 bounding box。不断改变滑窗算法的参数即可。</li></ol><p>这么做的话，计算成本巨大。如果要减小成本就要使用更加粗糙的参数，导致性能较差。不过可以通过卷积的方式减小计算成本。</p><h3 id="Convolutional-Implementation-of-Sliding-Windows"><a href="#Convolutional-Implementation-of-Sliding-Windows" class="headerlink" title="Convolutional Implementation of Sliding Windows"></a>Convolutional Implementation of Sliding Windows</h3><h4 id="使用卷积实现全连接"><a href="#使用卷积实现全连接" class="headerlink" title="使用卷积实现全连接"></a>使用卷积实现全连接</h4><p>全连接层可以使用卷积核大小为输入大小的卷积层实现。</p><p>例如需要将 $\displaystyle{h\times w \times c}$ 的输入映射到 $\displaystyle{n}$ 维的输出。全连接的做法是向对原来的输入进行 reshape，变成 $\displaystyle{hwc}$ 维的向量，然后做线性变换到 $\displaystyle{n}$ 维后施加激活函数。而通过使用 $\displaystyle{n}$ 个卷积核大小为 $\displaystyle{h\times w}$ 的卷积操作（按照前面所讲，卷积操作将会在所有通道上用不同参数卷积），每个卷积核得到的是一个大小为 $\displaystyle{1\times 1\times 1}$ 的输出，加上偏置后施加激活函数。这样一来经过这种卷积得到的就是 $\displaystyle{1\times 1\times n}$ 的输出了。<strong>因此在数学上，使用卷积可以实现全连接。</strong></p><h4 id="使用卷积实现滑窗算法"><a href="#使用卷积实现滑窗算法" class="headerlink" title="使用卷积实现滑窗算法"></a>使用卷积实现滑窗算法</h4><p>在上一节提出了一个垃圾实现，这里可以使用卷积优化运算量。</p><ol><li>首先，对于之前建立的那个进行二分类的 CNN，需要将其中的全连接层使用卷积层替换掉。根据上一小节的笔记，二者还是等价的。</li><li>因为卷积操作的参数是不依赖于输入的规模的（如果输入变大的话输出也会跟着变大），直接将原来的算法应用于整个图像上，而不是窗口上。这么操作之后，整个算法的最终输出就发生了变化。如果原来的滑窗算法中，横向会取 $\displaystyle{n_1}$ 个窗口，纵向会取 $\displaystyle{n_2}$ 个窗口，那么如果原来的算法最终输出是 $\displaystyle{n}$ 维的，现在的算法的最终输出就是 $\displaystyle{n_1 \times n_2\times n}$ 维的，其中 $\displaystyle{n_1}$ 和 $\displaystyle{n_2}$ 所在的维度对应的那个 $\displaystyle{n}$ 维特征正好是原来对应窗口的特征。</li></ol><img src="/2019/03/14/Convolutional-Neural-Networks-笔记-3-Object-detection/snipaste_20190323_161336.png"><p>如上图中，上一行是原始算法，下一行是卷积实现的滑窗。要处理的图片大小是 $\displaystyle{16\times 16}$ 的，窗口大小是 $\displaystyle{14\times 14}$，步长为 2。最后得到的 4 个输出分别对应原来的四个窗口。</p><hr><p>优化在于，原来的算法每次只能得到一个窗口对应的特征，现在一次就能得到多个窗口对应的特征，有很多计算结果都被重用了，因此效率提高了。不过，这么做不能依然给出精确的边界。</p><h3 id="Bounding-Box-Predictions"><a href="#Bounding-Box-Predictions" class="headerlink" title="Bounding Box Predictions"></a>Bounding Box Predictions</h3><p>为了对多个目标进行检测，同时给出 bounding box，需要结合滑窗算法和带定位分类中使用到的输出。</p><p>具体来说，首先对图片进行横向和纵向的切分，现在得到的是一个网格，格子之间没有重叠。每个格子都是一个窗口的取值，使用上一节的方法，将滑窗算法转化为一个单独的 CNN。至于输出，则使用带定位的分类中使用到的 $\displaystyle{n + 5}$ 风格的那种输出。</p><p>对于图像中的每个目标，它都只会有唯一一个中心点，而这个中心点只会处于一个格子中。现在先不考虑一个格子中出现了多个目标的中心点的情况。</p><ul><li>对于这个格子，我们希望算法输出的特征是 $\displaystyle{p_c = 1}$，负责分类的向量给出了正确的分类，负责定位的分量给出了正确的定位，其中定位位置的分量位于 0 到 1 之间，给出的位置是相对这个格子的位置；负责高度和宽度的分量大于 0 即可，度量时以一个格子作为一个单位，长度可能大于一个单位（这里没想清楚算法是怎么知道除了自己负责的这个格子以外的情况的）。</li><li>对于其它不含任何中心点的格子，我们希望算法输出的特征是 $\displaystyle{p_c = 0}$，这样就不必考虑后面的分量了（尽管这一般难以实现）。</li></ul><p>按照上面的规则，如果一个目标确实比较大而占据了多个格子，我们也只取它中心点所在的格子。至于其它格子的输出将 $\displaystyle{p_c}$ 输出为 1 会在后面进行修正。如此一来，只要格子划分得足够细密，就可以得到足够多的目标的精确边界。</p><p>上面的算法是 YOLO 模型使用的算法的高度简化版本。</p><hr><p><em>存在的一个问题是，对单个格子进行处理的时候到底是怎么知道中心点位于这个格子内部的那个目标的长度和宽度的？</em></p><h3 id="Intersection-Over-Union"><a href="#Intersection-Over-Union" class="headerlink" title="Intersection Over Union"></a>Intersection Over Union</h3><p>Intersection Over Union 简称 IoU，可以用来衡量两个矩形在位置和大小上的相似程度。IoU 的值等于这两个矩形的交的面积比上并的面积，越接近 1 表示相似度越大。</p><p>可以使用 IoU 对 bounding box 的正确性进行度量。例如将阈值设置为 0.5，当算法确定的 bounding box 和真实数据 IoU 大于该阈值时，即可认为算法在这个输出上是正确的。</p><h3 id="Non-max-Suppression"><a href="#Non-max-Suppression" class="headerlink" title="Non-max Suppression"></a>Non-max Suppression</h3><p>前面提到了，我们只希望一个格子中具有中心点，但是运行算法后往往有多个格子都认为自己有中心点。处理方法是这样的：</p><ol><li>找到 $\displaystyle{p_c}$ 最大的那个格子（$\displaystyle{p_c}$ 实际上是这个格子包含中心点的概率，不一定非 0 则 1）。</li><li>找到这个格子对应的 bounding box，记作 $\displaystyle{b_1}$。</li><li>对于其它格子预测出的 bounding box，如果这些 bounding box 和 $\displaystyle{b_1}$ 的 IoU 大于某个给定阈值，则认为两个实际上是同一个对象，忽略掉对应的 bounding box。</li></ol><p>重复这个算法，直到没有任何两个 bounding box 的 IoU 大于给定阈值。剩下来的 bounding box 每个对应一个目标。</p><h3 id="Anchor-Boxes"><a href="#Anchor-Boxes" class="headerlink" title="Anchor Boxes"></a>Anchor Boxes</h3><p>前述算法依然可以改进的地方是，每个格子只能检测一个对象。通过引入锚框的概念，现在一个格子可以检测有限多个对象。</p><p>锚框指的应该是固定高宽比的一个框。例如人的 bounding box 一般是高度大于宽度，而车的 bounding box 一般是宽度大于高度。因此可以确定针对人的锚框和针对车的锚框，它们的高宽比不一样。不过锚框只是一些矩形，它们和分类没有必然联系。在提取特征时，之前提取的是 $\displaystyle{n + 5}$ 维的特征，如果希望每个格子中最多可以包括两个对象的话，就将之前的方案重复两遍，得到 $\displaystyle{2\times (n + 5)}$ 的特征。</p><p>现在运行算法。在训练时，$\displaystyle{2\times (n + 5)}$ 的特征中两组分别负责两个不同的锚框。它们之间的顺序是确定的；例如在设计标签时，可以将高度大于宽度的对象分配到第一组 $\displaystyle{n + 5}$ 维中，而宽度大于高度的分配到第二组中。在预测时，目标不仅会被分配到一个格子，还会被分配到一个锚框类型，这就提高了一个格子中可以检测的目标数量。例如，如果一个人和一辆车的中心点都位于某个格子中，而人被分到了高度大于宽度的锚框，车被分到了另一个，那么就成功在一个格子中检测到了两个对象。</p><hr><p>不过，这个算法并不能处理一个格子中的多个目标高宽比相同，以及一个格子中的目标数超过锚框数的情况。</p><h3 id="YOLO-Algorithm"><a href="#YOLO-Algorithm" class="headerlink" title="YOLO Algorithm"></a>YOLO Algorithm</h3><p>这一节是对上面几节的综合。值得记录的一点是，在使用 non-max suppression 的时候，每个类别应该单独进行 non-max suppression。例如需要在图像中识别出行人和车辆两个类别，而算法得到了很多 bounding box，各个 bounding box 具有不同的种类，而同一个对象可能有多个 bounding box。此时要做的是，取出对应地被识别为行人的那些 bounding box 执行 non-max suppression，然后取出对应地被识别为车辆的那些 bounding box 执行 non-max suppression。</p><h3 id="Region-Proposals"><a href="#Region-Proposals" class="headerlink" title="Region Proposals"></a>Region Proposals</h3><p>候选区域是目标检测的一种策略。在上述算法中，很多窗口中的内容应用传统的视觉处理手段就可以判定它基本上没有目标，但是使用 CNN 还是要提取特征，这比较浪费。一个处理手段是先对图像进行 segmentation 得到那些可能具有目标的区域，对这些区域的 bounding box 直接运行识别和分类的 CNN。这个算法称为 R-CNN。</p><p>Fast R-CNN 对 R-CNN 作了改进，它使用卷积实现的滑窗操作对每个 bounding box 进行分类，在速度上有所改进。Faster R-CNN 在此基础上，使用 CNN 而非传统算法进行 segmentation。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convolutional Neural Networks 笔记 4 Special applications: Face recognition &amp; Neural style transfer</title>
      <link href="/2019/03/14/Convolutional-Neural-Networks-%E7%AC%94%E8%AE%B0-4-Special-applications-Face-recognition-Neural-style-transfer/"/>
      <url>/2019/03/14/Convolutional-Neural-Networks-%E7%AC%94%E8%AE%B0-4-Special-applications-Face-recognition-Neural-style-transfer/</url>
      
        <content type="html"><![CDATA[<h1 id="Face-recognition-amp-Neural-style-transfer"><a href="#Face-recognition-amp-Neural-style-transfer" class="headerlink" title="Face recognition &amp; Neural style transfer"></a>Face recognition &amp; Neural style transfer</h1><h2 id="Face-Recognition"><a href="#Face-Recognition" class="headerlink" title="Face Recognition"></a>Face Recognition</h2><h3 id="What-is-face-recognition"><a href="#What-is-face-recognition" class="headerlink" title="What is face recognition?"></a>What is face recognition?</h3><p>两个不同任务：</p><ul><li>Face verification：给定一张图片，判定这张图片是否是某个人</li><li>Face recognition：给定一张图片和具有很多个人的数据库，判定这张图片是否属于任意一个人并给出是哪个人</li></ul><p>显然 recognition 比 verification 要难。</p><h3 id="One-Shot-Learning"><a href="#One-Shot-Learning" class="headerlink" title="One Shot Learning"></a>One Shot Learning</h3><p>实际系统的 face recognition 的主要挑战在于每个人的照片很少，没法像用来分类的网络那样在很多样本上进行训练。这个问题被称为 one shot learning problem。很多时候每类的样本可能只有一个。此外，如果使用普通的 CNN 分类网络，要向数据库中增加一个人就要重新训练整个 CNN，这是不可接受的。</p><p>为了解决这个问题需要网络学习一个 similarity function。这个函数接受两张图片并返回它们的相似程度（越低表示越相似）。低于某个阈值时即可认为两张图片上是同一个人。</p><h3 id="Siamese-Network"><a href="#Siamese-Network" class="headerlink" title="Siamese Network"></a>Siamese Network</h3><p>一种定义相似函数的方式是使用 Siamese 网络架构。首先构建一个 CNN 网络，它将一张图片转换到一个向量表示的特征上。将输入记作 $\vec x$，输出记作 $f(\vec x)​$，相似函数可以定义为</p><script type="math/tex; mode=display">d(\vec x^{(1)}, \vec x^{(2)}) = ||f(\vec x^{(1)}) - f(\vec x^{(2)})||^2</script><p>现在，只要对于相似的输入，$d(\vec x^{(1)}, \vec x^{(2)})$ 较小而对于不相似的输入，该值较大即可。</p><a id="more"></a><h3 id="Triplet-Loss"><a href="#Triplet-Loss" class="headerlink" title="Triplet Loss"></a>Triplet Loss</h3><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>选取三个样本，记作 $A, P, N​$，分别表示 anchor、positive、negative，anchor 表示参照图片，positive 和参照图片同类，negative 和 anchor 不是同类。希望 $d(A, P)\leq d(A, N)​$，但是这还不够，因为网络可能会学习到将所有的图片映射到 0 这样的“技巧”导致应用失败，因此还要引入大于零的 margin $\alpha​$ 使得 $d(A, P) - d(A, N) + \alpha \leq 0​$。</p><p>现在可以定义损失函数 triplet loss，它是相对于三个样本而言的：</p><script type="math/tex; mode=display">L(A, P, N) = \text{max}(||f(A) - f(P)||^2 - ||f(A) - f(N)||^2 + \alpha, 0)</script><p>之所以要加上 $\text{max}$ 是因为我们只要 $d(A, P) - d(A, N) + \alpha \leq 0$ 就可以了，不需要网络把它们的差距拉得很大。</p><h4 id="样本选取"><a href="#样本选取" class="headerlink" title="样本选取"></a>样本选取</h4><p>训练时需要选取样本，但是如果随机选取的话效率很低。这是因为大部分随机选出的图片都会满足 negative 比 positive 要离 anchor 远得多，所以大部分情况下网络并没有什么可以优化的，而计算特征耗费了时间。好的选取策略是只选取那些 $d(A, P)\approx d(A, N)$ 的三元组。</p><h3 id="Face-Verification-and-Binary-Classification"><a href="#Face-Verification-and-Binary-Classification" class="headerlink" title="Face Verification and Binary Classification"></a>Face Verification and Binary Classification</h3><p>Siamese 架构的一种替代形式是使用二分类来进行 face verification。</p><p>对于两张图片，将它们送入 CNN 中得到两个特征 $f(\vec x_1)$ 和 $f(\vec x_2)$，然后逐元素作差得到 $f(\vec x_1) - f(\vec x_2)$，然后使用一个激活函数。最后得到的输出为</p><script type="math/tex; mode=display">\hat y = \sigma(\sum\limits_{i = 1}^kw_i|f(\vec x_1)_i - f(\vec x_2)_i| + b)</script><p>实际上就是将这个差进行线性变换然后送入激活函数。如果这个值接近 1 就表示两张图片是同一个人，接近 0 表示是不同人。</p><p>除了使用 1-范数之外，还可以使用 chi square form：</p><script type="math/tex; mode=display">\hat y = \sigma(\sum\limits_{i = 1}^kw_i\frac{(f(\vec x^{(1)})_i - f(\vec x^{(2)})_i)^2}{f(\vec x^{(1)})_i + f(\vec x^{(2)})_i} + b)</script><hr><p>在实际的系统中，数据库中的人脸的特征可以提前计算好后存起来，这样在运行时就不用计算数据库中的人的特征了。</p><h2 id="Neural-Style-Transfer"><a href="#Neural-Style-Transfer" class="headerlink" title="Neural Style Transfer"></a>Neural Style Transfer</h2><h3 id="What-is-neural-style-transfer"><a href="#What-is-neural-style-transfer" class="headerlink" title="What is neural style transfer?"></a>What is neural style transfer?</h3><p>给定图片 C（Content），图片 S（Style），网络会生成一张图片 G（Generated）。G 的内容是 C 的内容，但是画面风格是 S 的风格。</p><h3 id="What-are-deep-ConvNets-learning"><a href="#What-are-deep-ConvNets-learning" class="headerlink" title="What are deep ConvNets learning?"></a>What are deep ConvNets learning?</h3><p>为了实现 neural style transfer 我们需要知道一个 CNN 中每层的每个神经元到底学到了什么。这可以通过可视化 <strong>能够使这个神经元的输出最大化</strong> 的输入来实现。在训练集中找到一些图片，卷积操作使得每个神经元只会将其中的一部分作为输入。对于某层的某个神经元，将那些能够最大化该神经元输出的部分显示出来。以下是一个例子（从浅层到深层，来自 <em>Visualizing and Understanding Convolutional Networks</em>）：</p><ul><li><p>第一层</p><img src="/2019/03/14/Convolutional-Neural-Networks-笔记-4-Special-applications-Face-recognition-Neural-style-transfer/DeepinScreenshot_select-area_20190323205156.png"></li><li><p>第二层</p><img src="/2019/03/14/Convolutional-Neural-Networks-笔记-4-Special-applications-Face-recognition-Neural-style-transfer/DeepinScreenshot_select-area_20190323205203.png"></li><li><p>第三层</p><img src="/2019/03/14/Convolutional-Neural-Networks-笔记-4-Special-applications-Face-recognition-Neural-style-transfer/DeepinScreenshot_select-area_20190323205217.png"></li><li><p>第四层</p><img src="/2019/03/14/Convolutional-Neural-Networks-笔记-4-Special-applications-Face-recognition-Neural-style-transfer/DeepinScreenshot_select-area_20190323205226.png"></li><li><p>第五层</p><img src="/2019/03/14/Convolutional-Neural-Networks-笔记-4-Special-applications-Face-recognition-Neural-style-transfer/DeepinScreenshot_select-area_20190323205238.png"></li></ul><hr><p>可以看到最初学习到的特征是局部的，后面则逐渐呈现全局的特征，并且能够最大化一个神经元的那些部分都具有很多相似的性质。</p><h3 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h3><p>风格迁移中使用到的损失函数也接受一个三元组，就是前面提到的 $C, S, G$，有</p><script type="math/tex; mode=display">J(C, S, G) = \alpha J_{content}(C, G) + \beta J_{style}(S, G)</script><p>其中 $\alpha$ 和 $\beta$ 两个超参数控制内容和风格两个损失函数的比重（实际上一个超参数就可以了）。</p><p>首先随机生成一个和要生成的图片同规模的张量 $G$（比如 $1024\times 768\times 3$），将这个张量作为网络的参数的一部分。同时，将 $C$ 和 $S$ 作为网络的常量。现在损失函数就只和 $G$ 有关了。现在最小化损失函数就可以将 $G$ 向着某个特定的方向变化，收敛后可视化 $G$ 就得到了希望生成的图片。</p><h3 id="Content-Cost-Function"><a href="#Content-Cost-Function" class="headerlink" title="Content Cost Function"></a>Content Cost Function</h3><p>$J_{content}$ 的定义相对简单。</p><p>首先选择一个预训练好的 CNN，以及一个合适的层数 $l$（不能太浅也不能太深）。将 $G$ 和 $C$ 作为 CNN 的输入传入。使用它们在 $l$ 层激活后的输出即可定义</p><script type="math/tex; mode=display">J_{content}(C, G) = \frac{1}{2}||\mathbf a^{[l](C)} - \mathbf a^{[l](G)}||^2</script><h3 id="Style-Cost-Function"><a href="#Style-Cost-Function" class="headerlink" title="Style Cost Function"></a>Style Cost Function</h3><p>$J_{style}$ 的定义相对复杂。</p><p>首先选择一个预训练好的 CNN，以及一个合适的层数 $l​$。将 $G​$ 和 $S​$ 作为 CNN 的输入传入。考虑它们在第 $l​$ 层的激活后的输出 $\mathbf a^{[l]{}(S)}​$ 和 $\mathbf a^{[l]{}(G)}​$。每个输出都有若干个通道，不同通道之间的相关性可以用来衡量“风格”的相近程度。假设第 $l​$ 层的输出规模是 $n_h^{[l]}\times n_w^{[l]}\times n_c^{[l]}​$ 的，对于每个激活输出 $\mathbf a​$，可以定义风格矩阵 $\mathbf G​$：</p><script type="math/tex; mode=display">\mathbf G_{rs} = \sum\limits_{i = 1}^{n_h^{[l]}}\sum\limits_{j = 1}^{n_w^{[l]}}\mathbf a_{ijr}\mathbf a_{ijs}</script><p>其中 $r,s$ 是 $\mathbf G$ 的下标。如果两个通道相关性很高，那么这个分量就比较大，否则接近 0。从 CNN 中间层的可视化结果可以看到使用这种度量是相对合理的。如果两张图片的 $\mathbf G$ 接近的话，就表明它们在风格上接近。</p><p>对于第 $l$ 层，可以定义这一层的 $J_{style}$ 为</p><script type="math/tex; mode=display">J_{style}^{[l]}(S, G) = \frac{1}{(2n^{[l]}_hn^{[l]}_wn^{[l]}_c)^2}\sum\limits_{i = 1}^{n^{[l]}_C}\sum\limits_{j = 1}^{n^{[l]}_C}(\mathbf G_{ij}^{[l](S)} - \mathbf G_{ij}^{[l](G)})^2</script><p>实际上多取几层的最终效果会更好，而不是像 $J_{content}$ 那样只取一层。因此最后的 $J_{style}$ 为：</p><script type="math/tex; mode=display">J_{style}(S, G) = \sum\limits_{l} J_{style}^{[l]}(S, G)</script><h3 id="1D-and-3D-Generalizations"><a href="#1D-and-3D-Generalizations" class="headerlink" title="1D and 3D Generalizations"></a>1D and 3D Generalizations</h3><p>这一节和人脸识别与风格迁移都没关系，是将卷积推广到了一维数据和三维数据中。</p><p>推广后的一些共性特点：</p><ul><li>卷积核的维度总是和数据的维度相同，如果数据是三维的，卷积核也是三维的。</li><li>如果数据有多个通道，那么每个卷积核都会独立学习所有通道。即卷积核的通道维度的大小和数据的通道维度的大小是一致的。</li><li>如果有多个卷积核，每个卷积核会在输出中产生一个新的通道。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convolutional Neural Networks 笔记 2 Deep convolutional models: case studies</title>
      <link href="/2019/03/14/Convolutional-Neural-Networks-%E7%AC%94%E8%AE%B0-2-Deep-convolutional-models-case-studies/"/>
      <url>/2019/03/14/Convolutional-Neural-Networks-%E7%AC%94%E8%AE%B0-2-Deep-convolutional-models-case-studies/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-convolutional-models-case-studies"><a href="#Deep-convolutional-models-case-studies" class="headerlink" title="Deep convolutional models: case studies"></a>Deep convolutional models: case studies</h1><h2 id="Case-studies"><a href="#Case-studies" class="headerlink" title="Case studies"></a>Case studies</h2><h3 id="Why-look-at-case-studies"><a href="#Why-look-at-case-studies" class="headerlink" title="Why look at case studies?"></a>Why look at case studies?</h3><p>CNN 中很多东西都是模块化的，学习一些 case 有助于自己写出能用的网络。</p><p>本讲会学习到 LeNet-5、AlexNet、VGG、ResNet 和 Inception。</p><h3 id="Classic-Networks"><a href="#Classic-Networks" class="headerlink" title="Classic Networks"></a>Classic Networks</h3><p>LeNet-5 使用小卷积核（$\displaystyle{3\times 3}$），卷积层后面跟着平均池化层（当时流行平均池化）。卷积层后面跟着池化层是一个常见的模式，重复几次后变被压平，然后进入几层全连接的网络。</p><p>AlexNet 比 LeNet-5 要大，但是整体结构基本相似。不同之处在于 AlexNet 中使用了较大的卷积核（$\displaystyle{11\times 11}$），但是随后几层中卷积核大小又慢慢变小了。</p><p>VGG 又称 VGG-16，通过小卷积核（全部是 $\displaystyle{3\times3}$，使用 same 填充策略）和窗口大小与步长都为 2 的最大池化提取特征。每层会将高宽缩小一半，通道增加一倍；最后通过几个全连接层。VGG 是一个相对较大的网络，但是结构简单。一个变种是 VGG-19，它是一个更大的网络。</p><a id="more"></a><h3 id="ResNets"><a href="#ResNets" class="headerlink" title="ResNets"></a>ResNets</h3><p>深层的网络一般难以训练，因为有梯度消失/爆炸的问题。ResNet 是一个很深的网络，由所谓的 Residual Block 组成。Residual Block 使用了 skip connection 技术，这项技术使得深层网络的训练变得简单。</p><p>考虑两层全连接的网络，等会会把它转换成一个 residual block：</p><script type="math/tex; mode=display">\begin{aligned}z^{[l]} &= w^{[l]}a^{[l - 1]} + b^{[l]} \\a^{[l]} &= g^{[l]}(z^{[l]}) \\z^{[l + 1]} &= w^{[l + 1]}a^{[l]} + b^{[l + 1]} \\a^{[l + 1]} &= g^{[l + 1]}(z^{[l + 1]}) \\\end{aligned}</script><p>进行如下的修改：在计算第二个激活函数前，将 $\displaystyle{z^{[l + 1]}}$ 和 $\displaystyle{a^{[l - 1]}}$ 相加。修改后的方程变为：</p><script type="math/tex; mode=display">\begin{aligned}z^{[l]} &= w^{[l]}a^{[l - 1]} + b^{[l]} \\a^{[l]} &= g^{[l]}(z^{[l]}) \\z^{[l + 1]} &= w^{[l + 1]}a^{[l]} + b^{[l + 1]} \\a^{[l + 1]} &= g^{[l + 1]}(z^{[l + 1]} + a^{[l - 1]}) \\\end{aligned}</script><p>这样形成了一个“短路”的结构，故名 skip connection。这样的结构就叫 residual block。这项技术使得前层的特征能够直接到后面几层中，使得更深的网络能够更加容易训练。</p><h3 id="Why-ResNets-Work"><a href="#Why-ResNets-Work" class="headerlink" title="Why ResNets Work"></a>Why ResNets Work</h3><p>为何 ResNet 能够工作？如果检查一下某个 residual block：</p><script type="math/tex; mode=display">\begin{aligned}z^{[l]} &= w^{[l]}a^{[l - 1]} + b^{[l]} \\a^{[l]} &= g^{[l]}(z^{[l]}) \\z^{[l + 1]} &= w^{[l + 1]}a^{[l]} + b^{[l + 1]} \\a^{[l + 1]} &= g^{[l + 1]}(z^{[l + 1]} + a^{[l - 1]}) \\\end{aligned}</script><p>将最后一个式子展开，得到：$\displaystyle{a^{[l + 1]} = g^{[l + 1]}( w^{[l + 1]}a^{[l]} + b^{[l + 1]} + a^{[l - 1]})}$。如果 $\displaystyle{w^{[l + 1]}}$ 和 $b^{[l + 1]}$ 都正好为零的话，整个 residual block 做的事情实际上就是对 $a^{[l - 1]}$ 激活。如果各层使用的激活函数都是 ReLU 的话，$a^{[l - 1]}$ 是正的，激活后值不变。因此整个 residual block 实际上学习到了一个 identity 的函数。</p><p>在网络层数较深时，如果一个 residual block 被调整到了接近 identity 函数的情况的话，就相当于这两层不存在。因此一个 residual block 不会比两层网络的表现更差。</p><hr><p>一般来说，residual block 中要求 $z^{[l + 1]}$ 和 $a^{[l - 1]}$ 的规模是一致的，这通过使用 same padding 就可以实现。如果不一致的话也可以解决，只需要对 $a^{[l - 1]}$ 施加一个线性变换：$a^{[l + 1]} = g^{[l + 1]}(z^{[l + 1]} + \mathbf Wa^{[l - 1]})$，其中 $\mathbf W$ 的值可以被学习到，也可以直接手工构造。</p><h3 id="Networks-in-Networks-and-1x1-Convolutions"><a href="#Networks-in-Networks-and-1x1-Convolutions" class="headerlink" title="Networks in Networks and 1x1 Convolutions"></a>Networks in Networks and 1x1 Convolutions</h3><p>大小为 $\displaystyle{1\times1}$ 的卷积核做的事情是什么？对于每个这样的卷积核，它对数据卷积的结果是与原来的长和宽相同的、结果是原始矩阵的的各个通道的线性组合。如果有多个 $\displaystyle{1\times1}$ 的卷积核，就可以有多个这样的线性组合。一般来说进行完卷积后有一个激活函数，因此还是有点用的。</p><p>$\displaystyle{1\times1}$ 的卷积核可以用来改变输入的通道数。例如使用池化可以减小长和宽，而使用 $\displaystyle{1\times1}$ 的卷积核则可以减小通道数。</p><h3 id="Inception-Network-Motivation"><a href="#Inception-Network-Motivation" class="headerlink" title="Inception Network Motivation"></a>Inception Network Motivation</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>Inception 模型中，每层都使用不同大小的卷积核。例如，使用 $\displaystyle{1\times1}$ 的卷积核得到部分通道的结果，再使用 $\displaystyle{3\times3}$ 的卷积核得到一部分，使用 $\displaystyle{5\times5}$ 的卷积核得到一部分，使用最大池化得到一部分。卷积时全部使用 same padding，所以得到的特征的长宽和原始输入一致，可以将它们作为不同的通道叠起来从而得到新的特征。（池化操作也做 same padding。）新的特征中有各种大小的卷积核得到的特征。</p><h4 id="减小计算量"><a href="#减小计算量" class="headerlink" title="减小计算量"></a>减小计算量</h4><p>在上述操作中 $\displaystyle{5\times 5}$ 的卷积操作非常耗时。一个减小计算量的方法是先通过 $\displaystyle{1\times1}$ 的卷积核减少通道数，然后再使用 $\displaystyle{5\times5}$ 的卷积核得到和原来通道数一样多的特征。这么搞不会明显影响最终的效果，但是可以明显减少计算量。</p><h3 id="Inception-Network"><a href="#Inception-Network" class="headerlink" title="Inception Network"></a>Inception Network</h3><p>几个要点：</p><ul><li>使用 $\displaystyle{1\times1}$ 卷积核变换通道数</li><li>在上一节中我们得到的是一个 inception module。将多个 inception module 顺次连接起来就可以得到 inception network</li><li>Inception network 中，网络也会从中间部分引出部分旁路对中间特征进行分类，这保证了中间特征在分类上效果还可以，是一种正则化手段</li><li>Inception 网络的后续版本使用了 skip connection</li></ul><h2 id="Practical-advices-for-using-ConvNets"><a href="#Practical-advices-for-using-ConvNets" class="headerlink" title="Practical advices for using ConvNets"></a>Practical advices for using ConvNets</h2><h3 id="Using-Open-Source-Implementation"><a href="#Using-Open-Source-Implementation" class="headerlink" title="Using Open-Source Implementation"></a>Using Open-Source Implementation</h3><p>因为实验复现困难，作者建议使用的时候直接找开源实现，尽量不要从头开始，手造轮子。</p><p>这节居然讲怎么用 GitHub。</p><h3 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h3><p>在使用开源实现时注意可以下载已经训练好的权值，这样可以使用迁移学习减少自己训练的计算量。在自己样本很少的时候很有用。</p><p>如果需要将前面的几层冻住的话，可以考虑对样本经过冻住的模型后的特征保存下来，这样训练时就可以只计算没被冻住的那些而不用重复计算相同的特征。</p><p>如果样本较多的话，可以少固定住几层，多训练几层。甚至可以仅将提供的权值作为初始值开始进行训练。</p><h3 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h3><p>做 data augmentation 可以提高样本的数量。简单的 augmentation 方法有镜像、裁剪、旋转等。复杂一些的有 color shifting（对不同颜色通道做一些偏移）、PCA color augmentation。</p><p>Data augmentation 也有超参数，也可以考虑直接使用开源实现。</p><h3 id="State-of-Computer-Vision"><a href="#State-of-Computer-Vision" class="headerlink" title="State of Computer Vision"></a>State of Computer Vision</h3><ul><li><p>数据越多，算法越简单。数据越少，需要手工设计的特征就越复杂。</p></li><li><p>Ensmbling 是一种提高准确率的方法：独立地训练多个完成相同任务的网络，对同一个输入，取它们输出的平均值。可能可以提高一点点准确率。</p></li><li>Multi-corp 是一种提高准确率的方法，它对测试数据进行多种 augmentation，然后将多个 augmentation 送进网络后的结果进行平均作为最终结果。</li></ul><p>上述两种方法一般在竞赛中使用而不在实际系统中使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convolutional Neural Networks 笔记 1 Foundations of Convolutional Neural Networks</title>
      <link href="/2019/03/14/Convolutional-Neural-Networks-%E7%AC%94%E8%AE%B0-1-Foundations-of-Convolutional-Neural-Networks/"/>
      <url>/2019/03/14/Convolutional-Neural-Networks-%E7%AC%94%E8%AE%B0-1-Foundations-of-Convolutional-Neural-Networks/</url>
      
        <content type="html"><![CDATA[<h1 id="Foundations-of-Convolutional-Neural"><a href="#Foundations-of-Convolutional-Neural" class="headerlink" title="Foundations of Convolutional Neural"></a>Foundations of Convolutional Neural</h1><p>来源 <a href="https://www.coursera.org/learn/convolutional-neural-networks" target="_blank" rel="noopener">Coursera</a>。</p><h2 id="Convolutional-Neural-Networks"><a href="#Convolutional-Neural-Networks" class="headerlink" title="Convolutional Neural Networks"></a>Convolutional Neural Networks</h2><h3 id="Computer-Vision"><a href="#Computer-Vision" class="headerlink" title="Computer Vision"></a>Computer Vision</h3><p>一些应用：</p><ul><li>Image classfication</li><li>Object detection</li><li>Neural style transfer</li></ul><p>Computer vision 的一大挑战在与每个输入样本都非常大。例如一张图片就可能有数百万的输入特征。</p><h3 id="Edge-Detection-Example"><a href="#Edge-Detection-Example" class="headerlink" title="Edge Detection Example"></a>Edge Detection Example</h3><p>这节讲的是卷积操作如何工作。对于给定的代表图像的矩阵 $\displaystyle{\mathbf{A}}$，以及一个卷积核（filter 或者 kernel）$\displaystyle{\mathbf B}$，二者的卷积是一个新的矩阵 $\displaystyle{\mathbf C}$。若 $\displaystyle{\mathbf A\in\mathbb{R}^{m_A\times n_A}, \mathbf{B}\in \mathbb{R}^{m_B\times n_B}}$，一般有 $\displaystyle{m_B &lt; m_A, n_B &lt; n_A}$。则 $\displaystyle{\mathbf{C}\in\mathbb{R}^{(m_A - m_B + 1)\times(n_A - n_B + 1)}}$ 且</p><script type="math/tex; mode=display">\mathbf{C}[i, j] = \sum\left((\mathbf{A}[i:i + m_B][j:j + n_B])\odot\mathbf{B}\right)</script><p>可以想成 $\mathbf{B}$ 在 $\displaystyle{\mathbf A}$ 上滑动，每次滑动一步，并且不断做着 Hadamard 乘积来得到矩阵 $\displaystyle{\mathbf C}$。</p><p>矩阵卷积一般记作 $\displaystyle{\mathbf C = \mathbf A\ast\mathbf B}$。</p><hr><p>卷积在图像处理中有实际应用，例如</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & -1 \\1 & 0 & -1 \\1 & 0 & -1 \\\end{bmatrix}</script><p>这个卷积核可以用来识别图像中的竖直方向的明暗边界。</p><a id="more"></a><h3 id="More-Edge-Detection"><a href="#More-Edge-Detection" class="headerlink" title="More Edge Detection"></a>More Edge Detection</h3><p>卷积核有很多选择，例如将上述检测竖直方向图像边缘的卷积核旋转一下就能得到检测水平边缘的卷积核，而通过合理设置各个元素的值又能得到不同的效果。手动构造卷积核非常灵活。</p><p>在深度学习中我们希望神经网络能够自己学习到合适的卷积核，这样就不用手动进行构造了，而且学习到的卷积核能够更好地针对任务提取特征。</p><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>在上述卷积的例子中可以发现 $\displaystyle{\mathbf A}$ 在被卷积后变小了。如果网络有多层的话，卷积几次就会让输入变小。此外，在边缘上的元素比在内部的元素参与卷积运算的次数更少，这说明对编原的信息利用不够。为了解决这个问题，需要对 $\displaystyle{\mathbf A}$ 进行 padding，即在它的周围加上一些假的数据来扩大它的规模。</p><p>例如，假设卷积核的大小是 $\displaystyle{3\times 3}$ 的，如果对 $\displaystyle{\mathbf A}$ 周围加上一圈 $\displaystyle{0}$ 的话，就可以让卷积完成后规模保持不变。</p><p>常用的 padding 策略有两种：</p><ul><li><strong>Valid</strong>：其实就是不进行 padding。</li><li><strong>Same</strong>：选择 padding 的规模让卷积完成后得到的 $\displaystyle{\mathbf C}$ 和原来的 $\displaystyle{\mathbf A}$ 除了通道数外，在考虑步长（见下一节）的情况下规模一致。（例如选择步长为 2 的话，$\mathbf{C}$ 的长宽应该刚好是 $\mathbf A$ 的一半。）特殊地，在步长为 1 的情况下，$\mathbf C$ 和 $\mathbf A$ 的长宽应当相同。</li></ul><p>当然其它策略也是可以的。</p><hr><p>为了在 padding 的时候让 $\displaystyle{\mathbf C}$ 和原来的 $\displaystyle{\mathbf A}$ 规模一致并且进行对称的 padding，卷积核的边长一般是奇数。实际上传统的计算机视觉中卷积核也一般是奇数，这样可以让卷积核有一个中心，能够更好地说明它的方位。常用的卷积核规模一般就是 $\displaystyle{3\times 3}$ 和 $\displaystyle{5\times 5}$ 的，也有边长为 $\displaystyle{1}$ 的。</p><h3 id="Strided-Convolutions"><a href="#Strided-Convolutions" class="headerlink" title="Strided Convolutions"></a>Strided Convolutions</h3><p>前面提到的卷积操作中，$\displaystyle{\mathbf B}$ 每次移动的步长（stride）都是 $\displaystyle{1}$，但这实际上不是必要的，也可以是其它的步长。在这种情况下：</p><script type="math/tex; mode=display">\mathbf{C}[i, j] = \sum\left((\mathbf{A}[i\times s:i\times s + m_B][j\times s:j\times s + n_B])\odot\mathbf{B}\right)</script><p>其中 $\displaystyle{s}$ 是步长大小。在步长不为 $\displaystyle{1}$ 的卷积中，如果卷积核移动后没有完全落在原矩阵内，就认为这次卷积操作无法继续进行。在这个约束下，对于以下规模设置：原矩阵 $\displaystyle{n\times n}$、卷积核 $\displaystyle{f\times f}$、各向填充大小 $\displaystyle{p}$，各向步长为 $\displaystyle{s}$ 时卷积出来的矩阵的边长应为 $\displaystyle{\lfloor \frac{n + 2p - f}{s} + 1\rfloor}$。</p><hr><p>严格来说上述卷积在数学上应当叫做 cross-correlation，真正的卷积应该将卷积核横向翻转然后纵向翻转后，再做上述移动和 Hadamard 积。但是在深度学历领域人们直接将 cross-correlation 叫做卷积，虽然实现上和数学定义不一致，但是效果是一样的。</p><h3 id="Convolutions-Over-Volume"><a href="#Convolutions-Over-Volume" class="headerlink" title="Convolutions Over Volume"></a>Convolutions Over Volume</h3><p>实际的图像并不总是刚好使用一个矩阵就能够表示的。例如若图像使用 RGB 格式的话，一个像素需要 3 个 <strong>通道</strong> 进行表示。</p><p>如果图像的规模是 $\displaystyle{h\times w}$ 的话，在 3 个通道的情况下我们需要 $\displaystyle{h\times w\times 3}$ 的张量表示一张图片。这种情况下的 $\displaystyle{3}$ 这个维度称为 <strong>通道</strong> 或者 <strong>深度</strong>。一般需要使用同样通道数的卷积核对这个张量进行卷积，例如可以选择规模为 $\displaystyle{f\times f\times 3}$ 的卷积核。如果卷积核的通道数和原始张量的通道数相同的话，卷积出来的结构就应该是一个矩阵（深度为 1）。</p><p>如果我们希望对同一个张量能在不同方面提取特征的话，就会用到多个卷积核（大小相同）。每个卷积核都和张量的深度相同，因此会单独得到一个矩阵。多个卷积核会得到多个矩阵，将这些矩阵摞起来的话就又得到了一个张量，作为卷积提取出来的特征。该张量的通道数与卷积核数目相同，可以在后面的网络中进一步被处理。</p><p>每个不同的通道是对同一图片在不同方面的特征的描述，不论是输入中的 RGB 还是卷积中不同卷积核得到的特征。</p><h3 id="One-Layer-of-a-Convolutional-Network"><a href="#One-Layer-of-a-Convolutional-Network" class="headerlink" title="One Layer of a Convolutional Network"></a>One Layer of a Convolutional Network</h3><h4 id="卷积的偏置与激活函数"><a href="#卷积的偏置与激活函数" class="headerlink" title="卷积的偏置与激活函数"></a>卷积的偏置与激活函数</h4><p>在一层卷积操作中可以同样可以引入偏置的概念。每个卷积核有一个实数的偏置 $\displaystyle{b}$。在完成卷积后，每个卷积核对应得到自己的矩阵，然后和自己相应的偏置 $\displaystyle{b}$ 会被加到这个矩阵上（每个元素加的量都是一样的）。如果一层有 $\displaystyle{n_c}$ 个卷积核，就对应 $\displaystyle{n_c}$ 个实数。<strong>当加上了偏置之后，整个矩阵会逐元素经过一个非线性激活函数。</strong></p><p>卷积操作的一个优势在于只要确定了卷积核的大小和数量，那么这一层的参数数量不会随着输入的规模变大而变大，它会维持在一个固定的值上。</p><h4 id="记号说明"><a href="#记号说明" class="headerlink" title="记号说明"></a>记号说明</h4><ul><li>使用 $\displaystyle{n_H^{[l - 1]}, n_W^{[l - 1]}, n_C^{[l - 1]}}$ 表示上一层传入的图片的高、宽、通道数</li><li>使用 $\displaystyle{n_H^{[l ]}, n_W^{[l ]}, n_C^{[l ]}}$ 表示经过卷积后得到的图片的高、宽、通道数；</li><li>使用 $\displaystyle{f^{[l]}, p^{[l]}, s^{[l]}}$ 分别表示这一层卷积的卷积核大小、填充大小和步长。</li></ul><p>可以知道 $\displaystyle{n^{[l]}_H = \lfloor\frac{n^{[l - 1]}_H + 2p^{[l]} - f^{[l]}}{s^{[l]}}  + 1\rfloor}$。一共有 $n^{[l]}_C$个卷积核，每个的大小是 $f^{[l]}\times f^{[l]}\times n_C^{[l - 1]}$。每个卷积核的参数数量是 $f^{[l]}\times f^{[l]} + 1$，其中 1 是偏置。</p><h3 id="Simple-Convolutional-Network-Example"><a href="#Simple-Convolutional-Network-Example" class="headerlink" title="Simple Convolutional Network Example"></a>Simple Convolutional Network Example</h3><p>常用的卷积神经网络的套路是使用多层卷积层提取出特征，然后对于每个样本将其压成一个一维向量，然后接入常规的神经网络中。</p><p>一般来说，在卷积神经网络中，连续多层的卷积将会呈现边长逐渐变小，通道数逐渐变大的趋势。</p><h3 id="Pooling-Layers"><a href="#Pooling-Layers" class="headerlink" title="Pooling Layers"></a>Pooling Layers</h3><p>池化操作可以看作是一种特殊的卷积操作。在池化操作中同样是一个固定大小的窗口在原始矩阵上滑动，原始矩阵在窗口中的值会产出一个实数，进而产生新的矩阵。滑动同样有卷积核大小、步长和填充大小的概念。</p><p>在池化中几乎不会使用到填充，因此这里不考虑。池化一般使用的是最大池化和平均池化，其中最大池化使用得更多。最大池化指的是将窗口中的最大值作为“卷积”操作得到的值；而平均池化则是将窗口中各值的平均值作为“卷积”操作得到的值。池化过程没有参数需要学习。池化完毕后矩阵规模一般会减小。如果原始的输入有多个通道，则应在各个通道上独立地进行池化，因此池化完成后通道数不变。</p><p>池化的窗口大小一般选为 2，步长也一般选为 2，这样可以将输入的长和宽减小为原来的一半。池化操作主要是在保留特征大部分信息的情况下减小特征的规模，从而加速计算。</p><h3 id="CNN-Example"><a href="#CNN-Example" class="headerlink" title="CNN Example"></a>CNN Example</h3><p>常用 Conv 表示卷积层，Pool 表示池化层，FC 表示全连接层。一个典型的图像分类网络的架构是 Conv-Pool-Conv-Pool-Conv-Pool-FC-FC-FC-Softmax。</p><p>在计算网络层数的时候，有人习惯将一组 Conv-Pool 记作一层，有人习惯记作两层。</p><p>这类网络大部分的参数都在全连接部分。如果将各层每个样本的特征全部压缩成一维向量的话，正常情况下它们的规模应该是缓慢减小的。如果某层减小很快的话说明这层的超参数设置可能存在问题。</p><h3 id="Why-Convolutions"><a href="#Why-Convolutions" class="headerlink" title="Why Convolutions?"></a>Why Convolutions?</h3><p>使用卷积层相较于普通全连接层的好处：</p><ul><li>Parameter sharing：一个卷积核一般可以用来提取某种特征。这是某种共性的提取特征的手段，它应当能在图像的不同区域发挥作用。因此使用卷积可以得到这种相对普适的特征提取过程，在样本的各个位置共享卷积参数。</li><li>Sparsity of connections：卷积得到的矩阵中，每个元素只取决于原始矩阵中的一小部分（窗口大小的一部分）。这造成了卷积得到的矩阵和原始矩阵是稀疏连接的，使得它在一定程度上比较鲁棒。另外，卷积操作可以学习到 translation invariance，即使原始矩阵存在平移，卷积操作也能够得到和不平移情况下相似的特征。</li></ul><hr><h2 id="关于-CNN-的反向传播"><a href="#关于-CNN-的反向传播" class="headerlink" title="关于 CNN 的反向传播"></a>关于 CNN 的反向传播</h2><p>这一节的内容来自作业。反向传播的公式没有给出推导，只有结论。另外这里的公式都只是示意，很多细节（比如关于通道的）被省去了。</p><h3 id="卷积操作的反向传播"><a href="#卷积操作的反向传播" class="headerlink" title="卷积操作的反向传播"></a>卷积操作的反向传播</h3><p>假设输入是 $A​$，经过卷积后得到的是 $Z​$。损失函数是 $J​$。则</p><ul><li>对于给定的卷积核 $W_c​$，计算损失函数对 $A​$ 的的导数：$\displaystyle{\frac{\partial J}{\partial A} = \sum\limits_{h = 0}^{n_H}\sum\limits_{w = 0}^{n_W}}W_c\times \frac{\partial J}{\partial Z_{hw}}​$。符号上这个式子不是很严谨。可以想成在计算 $\displaystyle{\frac{\partial J}{\partial A}}​$ 时，先初始化一个和 $A​$ 等大的矩阵 $X​$；然后对于 $Z​$ 中的每个元素 $Z_{hw}​$，找到 $A​$ 中参与计算 $Z_{hw}​$ 的那个子矩阵的位置，将 $W_c​$ 乘以 $\displaystyle{ \frac{\partial J}{\partial Z_{hw}}}​$ 后加到 $X​$ 对应的位置上。遍历了 $Z​$ 的每个元素后就计算出了 $\displaystyle{\frac{\partial J}{\partial A}}​$。</li><li>对于给定的卷积核 $W_c$，计算损失函数对该卷积核的导数：$\displaystyle{\frac{\partial J}{\partial W_c} = \sum\limits_{h = 0}^{n_H}\sum\limits_{w = 0}^{n_W}S_{hw}\times\frac{\partial J}{\partial Z_{hw}}}$。其中 $S_{hw}$ 是一个和卷积核大小相等的 $A$ 的一部分，它正是产生 $Z_{hw}$ 的那个子矩阵。</li><li>对于给定的卷积核，损失函数对其偏置的导数满足 $\displaystyle{\frac{\partial J}{\partial b} = \sum_h\sum_w\frac{\partial J}{\partial Z_{hw}}}$。</li></ul><h3 id="池化操作的反向传播"><a href="#池化操作的反向传播" class="headerlink" title="池化操作的反向传播"></a>池化操作的反向传播</h3><p>池化可以看作是特殊的卷积。它没有偏置，并且计算损失函数对卷积核的导数是没有意义的，因此只用考虑在知道对 $Z$ 的导数的情况下如何计算对 $A$ 的导数：</p><ul><li><strong>最大池化</strong>：$\displaystyle{\frac{\partial J}{\partial A} = \sum\limits_{h = 0}^{n_H}\sum\limits_{w = 0}^{n_W}}W_{hw}\times \frac{\partial J}{\partial Z_{hw}}​$，其中 $W_{hw}​$ 是一个 mask 矩阵，它只有一个元素是 1，其余元素是 0。该矩阵对应的是产生 $Z_{hw}​$ 的 $A​$ 的子矩阵，其中 1 的位置对应的是子矩阵最大值所在位置。</li><li><strong>平均池化</strong>：$\displaystyle{\frac{\partial J}{\partial A} = \sum\limits_{h = 0}^{n_H}\sum\limits_{w = 0}^{n_W}}W\times \frac{\partial J}{\partial Z_{hw}}$，其中 $W$ 大小和卷积核相同，所有元素都相等并且加起来为 1。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dafny 学习笔记</title>
      <link href="/2019/03/12/Dafny-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/12/Dafny-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Dafny-学习笔记"><a href="#Dafny-学习笔记" class="headerlink" title="Dafny 学习笔记"></a>Dafny 学习笔记</h1><h2 id="Guide"><a href="#Guide" class="headerlink" title="Guide"></a>Guide</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Dafny use annotations to write programs with no bugs. The annotation below means all elements in <code>a</code> are positive:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forall k: int :: 0 &lt;= k &lt; a.Length ==&gt; 0 &lt; a[k]</span><br></pre></td></tr></table></figure><p>Now you turn the task of <strong><em>writing bug-free programs</em></strong> into <strong><em>writing bug-free annotations</em></strong>.</p><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><p>Use <code>method</code> to declare a method. Methods are different from functions in Dafny. <strong>Syntax example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">method MultipleReturns(x: int, y: int) returns (more: int, less: int)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A method can return multiple values, and each value has a name. They can be assigned inside the method body. Use <code>return</code> with no argument to return early from the method. <strong>Parameters are read-only.</strong></p><hr><ul><li>Use <code>:=</code> for variable assignments.</li><li>Braces are required in <code>if</code> <strong>statements</strong> even if the branch has only one statement. Otherwise it will be an <strong>expression</strong>.</li></ul><a id="more"></a><h3 id="Pre-and-Postconditions"><a href="#Pre-and-Postconditions" class="headerlink" title="Pre- and Postconditions"></a>Pre- and Postconditions</h3><h4 id="Simple-Usage"><a href="#Simple-Usage" class="headerlink" title="Simple Usage"></a>Simple Usage</h4><p>Use <code>requires</code> for preconditions and <code>ensures</code> for postconditions. Preconditions must be held before calling the method, and postconditions will be held after the method returns from any points. <strong>Syntax example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method MultipleReturns(x: int, y: int) returns (more: int, less: int)</span><br><span class="line">   requires 0 &lt; y</span><br><span class="line">   ensures less &lt; x &lt; more</span><br><span class="line">&#123;</span><br><span class="line">   more := x + y;</span><br><span class="line">   less := x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>One method can have multiple preconditions and/or postconditions.</p><h4 id="With-Conditions"><a href="#With-Conditions" class="headerlink" title="With Conditions"></a>With Conditions</h4><p>pre- and postconditions can have conditions with implication operator <code>==&gt;</code>, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method Abs(x: int) returns (y: int)</span><br><span class="line">   ensures 0 &lt;= y</span><br><span class="line">   ensures 0 &lt;= x ==&gt; x == y</span><br><span class="line">   ensures x &lt; 0 ==&gt; y == -x</span><br><span class="line">&#123;</span><br><span class="line">   // body as before</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dafny won&#39;t see the method body except for the current one when making proofs, it only uses method annotations. However the behavior is described both in the postconditions and the method body, <strong><em>that&#39;s why Dafny has functions</em></strong>.</p><hr><ul><li>Dafny supports chain operator syntax: <code>less &lt; x &lt; more</code>.</li></ul><h3 id="Assertions"><a href="#Assertions" class="headerlink" title="Assertions"></a>Assertions</h3><p>Use <code>assert</code> to make assertions in the method body. <strong>Syntax example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">method Testing()</span><br><span class="line">&#123;</span><br><span class="line">   var v := Abs(3);</span><br><span class="line">   assert 0 &lt;= v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>Use <code>var</code> with optional type declaration to declare local variables: <code>var v := 3;</code> or <code>var v: int := 3;</code>. Types will be inferred when omitted.</li></ul><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><h4 id="What-are-Functions"><a href="#What-are-Functions" class="headerlink" title="What are Functions"></a>What are Functions</h4><p>Use <code>function</code> to define a function. The syntax is almost the same as method definition, except for the keyword.</p><p><strong>Function must contain only one expression</strong>, for example, the <code>fib</code> function below uses an <code>if</code> expression:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fib(n: nat): nat</span><br><span class="line">&#123;</span><br><span class="line">   if n == 0 then 0 else</span><br><span class="line">   if n == 1 then 1 else</span><br><span class="line">                  fib(n - 1) + fib(n - 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When Dafny make proofs, functions will be expanded, so you can write <code>assert 2 == fib(3)</code> directly without annotations in <code>fib</code>. However, <strong>functions can not be called from methods</strong>, they are only used for verification.</p><blockquote><p><code>nat</code> is a type for natural numbers.</p></blockquote><h4 id="Function-Method"><a href="#Function-Method" class="headerlink" title="Function Method"></a>Function Method</h4><p>Use <code>function method</code> to declare a function method. A function method is a function, and it can be called from methods.</p><h3 id="Loop-Invariants"><a href="#Loop-Invariants" class="headerlink" title="Loop Invariants"></a>Loop Invariants</h3><p>Use <code>invariant</code> to declare loop invariants in <code>while</code> loops. <strong>Syntax example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">method ComputeFib(n: nat) returns (b: nat)</span><br><span class="line">   ensures b == fib(n)</span><br><span class="line">&#123;</span><br><span class="line">   if n == 0 &#123; return 0; &#125;</span><br><span class="line">   var i: int := 1;</span><br><span class="line">   var a := 0;</span><br><span class="line">       b := 1;</span><br><span class="line">   while i &lt; n</span><br><span class="line">      invariant 0 &lt; i &lt;= n</span><br><span class="line">      invariant a == fib(i - 1)</span><br><span class="line">      invariant b == fib(i)</span><br><span class="line">   &#123;</span><br><span class="line">      a, b := b, a + b;</span><br><span class="line">      i := i + 1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Loop invariants must be held <strong>before</strong> and <strong>after</strong> the loop body. Therefore, before the first execution and after the last execution of the loop body, those invariants are held.</p><p><strong><em>Loop invariants are necessary because Dafny doesn&#39;t know how many times a loop will be executed.</em></strong></p><hr><ul><li>Dafny has parallel assignments: <code>a, b = b, a</code>.</li></ul><h3 id="Termination"><a href="#Termination" class="headerlink" title="Termination"></a>Termination</h3><p>There are circumstances where we want Dafny to proof the program will terminate: <strong>loops</strong> and <strong>recursive calls</strong>. In both cases, use <code>decreases</code> to annotate an expression will get lower and is bounded by zero after each execution. <strong>Syntax example for loops:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while 0 &lt; i</span><br><span class="line">   invariant 0 &lt;= i</span><br><span class="line">   decreases i</span><br><span class="line">&#123;</span><br><span class="line">   i := i - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Quantifiers"><a href="#Quantifiers" class="headerlink" title="Quantifiers"></a>Quantifiers</h3><p>Use <code>forall</code> to make conditions on a set. The set can be infinite:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert forall k :: k &lt; k + 1;</span><br></pre></td></tr></table></figure><p>But typically finite. <code>forall</code> usually appears in <code>requires</code>, <code>ensures</code> and <code>assert</code>s. A full example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">method Find(a: array&lt;int&gt;, key: int) returns (index: int)</span><br><span class="line">   ensures 0 &lt;= index ==&gt; index &lt; a.Length &amp;&amp; a[index] == key</span><br><span class="line">   ensures index &lt; 0 ==&gt; forall k :: 0 &lt;= k &lt; a.Length ==&gt; a[k] != key</span><br><span class="line">&#123;</span><br><span class="line">   index := 0;</span><br><span class="line">   while index &lt; a.Length</span><br><span class="line">      invariant 0 &lt;= index &lt;= a.Length</span><br><span class="line">      invariant forall k :: 0 &lt;= k &lt; index ==&gt; a[k] != key</span><br><span class="line">   &#123;</span><br><span class="line">      if a[index] == key &#123; return; &#125;</span><br><span class="line">      index := index + 1;</span><br><span class="line">   &#125;</span><br><span class="line">   index := -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h3><p>Predicates are only syntactical sugar for functions returning booleans. Use <code>predicate</code> to define them. <strong>Syntax example (indication only):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predicate sorted(a: array&lt;int&gt;)</span><br><span class="line">   requires a != null</span><br><span class="line">&#123;</span><br><span class="line">   forall j, k :: 0 &lt;= j &lt; k &lt; a.Length ==&gt; a[j] &lt;= a[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There is no return type because the type is always a boolean. <strong><em>Recall that functions can not be called, so the <code>forall</code> statement is also inside a condition.</em></strong></p><h3 id="Framing"><a href="#Framing" class="headerlink" title="Framing"></a>Framing</h3><p>For some reasons, if a function needs to access some data on the <strong>heap</strong> (e.g. arrays), a <code>read</code> annotation is required:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">predicate sorted(a: array&lt;int&gt;)</span><br><span class="line">   requires a != null</span><br><span class="line">   read a</span><br><span class="line">&#123;</span><br><span class="line">   forall j, k :: 0 &lt;= j &lt; k &lt; a.Length ==&gt; a[j] &lt;= a[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And a <code>modifies</code> annotation is required for modify data.</p><h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><p>Combining all we have learned, we have a <code>BinarySearch</code> method:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">predicate sorted(a: array&lt;int&gt;)</span><br><span class="line">   requires a != null</span><br><span class="line">   reads a</span><br><span class="line">&#123;</span><br><span class="line">   forall j, k :: 0 &lt;= j &lt; k &lt; a.Length ==&gt; a[j] &lt;= a[k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method BinarySearch(a: array&lt;int&gt;, value: int) returns (index: int)</span><br><span class="line">   requires a != null &amp;&amp; 0 &lt;= a.Length &amp;&amp; sorted(a)</span><br><span class="line">   ensures 0 &lt;= index ==&gt; index &lt; a.Length &amp;&amp; a[index] == value</span><br><span class="line">   ensures index &lt; 0 ==&gt; forall k :: 0 &lt;= k &lt; a.Length ==&gt; a[k] != value</span><br><span class="line">&#123;</span><br><span class="line">   var low, high := 0, a.Length;</span><br><span class="line">   while low &lt; high</span><br><span class="line">      invariant 0 &lt;= low &lt;= high &lt;= a.Length</span><br><span class="line">      invariant forall i ::</span><br><span class="line">         0 &lt;= i &lt; a.Length &amp;&amp; !(low &lt;= i &lt; high) ==&gt; a[i] != value</span><br><span class="line">   &#123;</span><br><span class="line">      var mid := (low + high) / 2;</span><br><span class="line">      if a[mid] &lt; value</span><br><span class="line">      &#123;</span><br><span class="line">         low := mid + 1;</span><br><span class="line">      &#125;</span><br><span class="line">      else if value &lt; a[mid]</span><br><span class="line">      &#123;</span><br><span class="line">         high := mid;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">         return mid;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><blockquote><p>Nothing to note for this section.</p></blockquote><h2 id="Termination-1"><a href="#Termination-1" class="headerlink" title="Termination"></a>Termination</h2><p>Use <code>decreases</code> to annotate a loop or recursive function/method will terminates. Sometimes Dafny will guess a termination annotation and these annotations can be omitted.</p><p><code>decreases</code> are often followed by an expression which evaluates to an integer, but they can also be followed by arrays (length in this case) or sets (subset relation in this case).</p><h3 id="Loop-Forever"><a href="#Loop-Forever" class="headerlink" title="Loop Forever"></a>Loop Forever</h3><p>If you want a loop to execute forever intentionally, use <code>decreases *</code>. The method containing the loop should also be annotated <code>decreases *</code>. Here is an example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">method hail(N: nat)</span><br><span class="line">   decreases *</span><br><span class="line">&#123;</span><br><span class="line">   var n := N;</span><br><span class="line">   while 1 &lt; n</span><br><span class="line">      decreases *</span><br><span class="line">   &#123; </span><br><span class="line">      n := if n % 2 == 0 then n / 2 else n * 3 + 1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Multiple-Decreases-Expressions"><a href="#Multiple-Decreases-Expressions" class="headerlink" title="Multiple Decreases Expressions"></a>Multiple Decreases Expressions</h3><p>If multiple expressions are in the <code>decreases</code> annotation, they should decrease lexicographically. For example, for <code>decreases m, n</code>:</p><ul><li>If <code>m</code> decreases, then <code>n</code> can change whatever it likes.</li><li>If <code>m</code> doesn&#39;t change, then <code>n</code> should decrease.</li><li><code>m</code> shouldn&#39;t increase in any iteration.</li></ul><h3 id="Mutual-Recursive-Methods"><a href="#Mutual-Recursive-Methods" class="headerlink" title="Mutual Recursive Methods"></a>Mutual Recursive Methods</h3><p>Dafny can proof termination for mutual recursive methods too:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">predicate even(n: nat)</span><br><span class="line">   ensures even(n) &lt;==&gt; n % 2 == 0</span><br><span class="line">&#123;</span><br><span class="line">   if n == 0 then true else odd(n-1)</span><br><span class="line">&#125;</span><br><span class="line">predicate odd(n: nat)</span><br><span class="line">   ensures odd(n) &lt;==&gt; n % 2 != 0</span><br><span class="line">&#123;</span><br><span class="line">   if n == 0 then false else even(n-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h2><p>Sets are orderless, <strong>immutable</strong> and can be used in annotations. <strong>Infinite sets are not allowed.</strong></p><h3 id="Sets-Operations"><a href="#Sets-Operations" class="headerlink" title="Sets Operations"></a>Sets Operations</h3><ul><li><code>+</code> for set union.</li><li><code>*</code> for set intersection.</li><li><code>-</code> for set difference.</li><li><code>&lt;=</code> for subset relation.</li><li><code>&lt;</code> for strict subset relation.</li><li><code>==</code> and <code>!=</code> for equality and inequality.</li><li><code>in</code> and <code>!in</code> for testing element membership.</li></ul><h3 id="Sets-Comprehension"><a href="#Sets-Comprehension" class="headerlink" title="Sets Comprehension"></a>Sets Comprehension</h3><p><strong>Syntax</strong>: <code>set x: T | p(x) :: f(x)</code>, where <code>T</code> is an optional type annotation, <code>p(x)</code> is a predicate, <code>f(x)</code> is a mapper function (identity if omitted). For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (set x | x in &#123;0,1,2&#125; :: x + 1) == &#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure><h2 id="Sequences"><a href="#Sequences" class="headerlink" title="Sequences"></a>Sequences</h2><p>Sequences are ordered, <strong>immutable</strong> and can be used in annotations.</p><h3 id="Sequences-Operations"><a href="#Sequences-Operations" class="headerlink" title="Sequences Operations"></a>Sequences Operations</h3><ul><li>Use <code>|s|</code> for sequences length.</li><li>Use <code>[s]</code> for sequences indexing.</li><li>Use <code>[a .. b]</code> for sequences slicing (<code>a</code> and <code>b</code> can be omitted).</li><li>Use <code>+</code> for sequences concatenation.</li><li>Use <code>in</code> and <code>!in</code> for testing element membership.</li></ul><h3 id="Sequences-Construction"><a href="#Sequences-Construction" class="headerlink" title="Sequences Construction"></a>Sequences Construction</h3><ul><li>Constructing from existing sequence with the element at position <code>i</code> modified to <code>v</code>: <code>s[i := v]</code>.</li><li>Constructing from existing array: <code>var s := a[..]</code>.</li></ul><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Data structures stored on the stack is called <strong>value types</strong>. They can not be modified.</p><p>Dafny has four value types: sets, sequences, multisets and maps.</p><h3 id="Multisets"><a href="#Multisets" class="headerlink" title="Multisets"></a>Multisets</h3><p>Multisets is like sets, except that it allows an element to occur multiple times.</p><p>Operations on multisets are almost the same as sets. Use <code>!!</code> for multisets disjoint (no common elements).</p><p>You can construct multisets by:</p><ul><li>Literally: <code>multiset{1, 2, 3, 4, 3, 2, 1}</code>.</li><li>From existing sets or sequences: <code>assert multiset({1, 1, 1, 2, 2}) == multiset{1, 2}</code>.</li></ul><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p>Maps are associative arrays.</p><h4 id="Maps-Operations"><a href="#Maps-Operations" class="headerlink" title="Maps Operations"></a>Maps Operations</h4><ul><li>Use <code>m[k]</code> for indexing.</li><li><p>Use <code>in</code> and <code>!in</code> to test <strong>key</strong> membership.</p></li><li><p>Use <code>!!</code> to test maps domain disjoint. A domain is the set of keys.</p></li></ul><h4 id="Maps-Constructions"><a href="#Maps-Constructions" class="headerlink" title="Maps Constructions"></a>Maps Constructions</h4><ul><li>Literally: <code>map[4 := 5, 5 := 6]</code>.</li><li>Modify from existing maps: <code>m[i := j]</code>.</li><li>Maps comprehension: <code>map i | i in m &amp;&amp; i != 3 :: m[i]</code>, which remove the key-value pair with key 3 from <code>m</code>.</li></ul><h2 id="Lemmas"><a href="#Lemmas" class="headerlink" title="Lemmas"></a>Lemmas</h2><p>Lemmas are used to provide intermediate steps for Dafny to make proofs. Dafny will prove the lemma, and use it to prove other things.</p><p>Lemmas are in fact methods. They can also be viewed as heavyweight assertions.</p><p>Use <code>lemma</code> for define a lemma. No modification is allowed in lemma body. Lemmas have preconditions and postconditions, and they also have parameters. Dafny will prove a lemma individually, and ensure that if the parameters meet preconditions, they will meet postconditions. After the lemma is proved, it can be called from other code to help Dafny make other proofs.</p><p>Check the example below:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">lemma SkippingLemma(a : array&lt;int&gt;, j : int)</span><br><span class="line">   requires a != null</span><br><span class="line">   requires forall i :: 0 &lt;= i &lt; a.Length ==&gt; 0 &lt;= a[i]</span><br><span class="line">   requires forall i :: 0 &lt; i &lt; a.Length ==&gt; a[i-1]-1 &lt;= a[i]</span><br><span class="line">   requires 0 &lt;= j &lt; a.Length</span><br><span class="line">   ensures forall k :: j &lt;= k &lt; j + a[j] &amp;&amp; k &lt; a.Length ==&gt; a[k] != 0</span><br><span class="line">&#123;</span><br><span class="line">   var i := j;</span><br><span class="line">   while i &lt; j + a[j] &amp;&amp; i &lt; a.Length</span><br><span class="line">      invariant i &lt; a.Length ==&gt; a[j] - (i-j) &lt;= a[i]</span><br><span class="line">      invariant forall k :: j &lt;= k &lt; i &amp;&amp; k &lt; a.Length ==&gt; a[k] != 0</span><br><span class="line">   &#123;</span><br><span class="line">      i := i + 1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">method FindZero(a: array&lt;int&gt;) returns (index: int)</span><br><span class="line">   requires a != null</span><br><span class="line">   requires forall i :: 0 &lt;= i &lt; a.Length ==&gt; 0 &lt;= a[i]</span><br><span class="line">   requires forall i :: 0 &lt; i &lt; a.Length ==&gt; a[i-1]-1 &lt;= a[i]</span><br><span class="line">   ensures index &lt; 0  ==&gt; forall i :: 0 &lt;= i &lt; a.Length ==&gt; a[i] != 0</span><br><span class="line">   ensures 0 &lt;= index ==&gt; index &lt; a.Length &amp;&amp; a[index] == 0</span><br><span class="line">&#123;</span><br><span class="line">   index := 0;</span><br><span class="line">   while index &lt; a.Length</span><br><span class="line">      invariant 0 &lt;= index</span><br><span class="line">      invariant forall k :: 0 &lt;= k &lt; index &amp;&amp; k &lt; a.Length ==&gt; a[k] != 0</span><br><span class="line">   &#123;</span><br><span class="line">      if a[index] == 0 &#123; return; &#125;</span><br><span class="line">      SkippingLemma(a, index);</span><br><span class="line">      index := index + a[index];</span><br><span class="line">   &#125;</span><br><span class="line">   index := -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><blockquote><p>Read the document when needed: <a href="https://rise4fun.com/Dafny/tutorial/Modules" target="_blank" rel="noopener">https://rise4fun.com/Dafny/tutorial/Modules</a>.</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://rise4fun.com/Dafny/tutorial" target="_blank" rel="noopener">https://rise4fun.com/Dafny/tutorial</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 形式化验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式化验证课程笔记 3</title>
      <link href="/2019/03/11/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-3/"/>
      <url>/2019/03/11/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<h1 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h1><p>主题：一阶逻辑。</p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>命题逻辑表达能力有限。一阶逻辑可以表达无穷大的集合、对象之间的关系和各种量化关系。</p><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><ul><li><p>一阶逻辑的语法分为两部分——逻辑部分和非逻辑部分。逻辑部分包含逻辑连接词、变量和谓词。通过限制除了逻辑部分之外的部分即非逻辑部分，可以限制一阶逻辑的表达能力。</p></li><li><p>非逻辑中包括 <strong>函数</strong> 和 <strong>谓词</strong>，区别在于函数将对象映射到对象，谓词将对象映射到布尔值。常数可以看做零元常函数；变量可以看做零元谓词。</p></li><li><p>一阶逻辑中的对象称为 <strong>项</strong>，包括对象常量、变量和函数。</p></li><li>一阶逻辑中的求值为真值的东西称为 <strong>原子 </strong>，包括真值常量、变量和谓词。</li><li>原子和它的反合称 <strong>文字</strong>。</li><li><p>文字称为 <strong>公式</strong>；公式使用逻辑连接词连接后，或者被量词结合起来使用后也是公式。</p></li><li><p>在形如 $\forall x.F(x,y)$ 的公式中，$x$ 是 <strong>bound</strong> 的（被量词修饰），$y$ 是 <strong>free</strong> 的。$F(x, y)$ 是 $x$ 的 <strong>辖域</strong>（相当于作用域）。<br>没有 free 变量的公式是 <strong>closed</strong> 的，否则是 <strong>open</strong> 的；不包含变量的公式是 <strong>ground</strong> 的。</p></li></ul><a id="more"></a><h2 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h2><p>类似命题逻辑的解释，一阶逻辑也有解释，但更加复杂：</p><ul><li><strong>论域</strong>：一个非空集合。</li><li>一阶逻辑的解释包括：<ul><li>每个对象常量被赋值为论域中的对象。每个真值常量被赋值为一个真值。</li><li>每个函数都给出了确定而完备的定义 $D^n\mapsto D$。完备表示对所有可能的输入都应该有定义。</li><li>每个谓词都给出了确定而完备的定义 $D^n\mapsto \{\top, \bot\}$。（不过在符号上经常将谓词写成一个元组的集合，集合中的元组解包后作为参数传入谓词会得到真，否则得到假。）</li></ul></li></ul><p>和命题逻辑的解释不同，当完成了解释之后，真值是不确定的！<strong>因为只给常量赋了值，没有给变量赋值。</strong>对变量赋值的过程称为 <strong>assignment</strong>（指派，记作 $\alpha$）。指派完成后才能得到最后的真值。</p><p>从这个角度上，命题逻辑中的原子可以看成是一阶逻辑中的常量，但不能看作是变量。</p><p><del><em>什么是常量？什么是变量？我也不知道。形如 $x + y &gt; z\rightarrow x &gt;z - y$ 中，$x, y, z$ 都是常量而不是变量。</em></del></p><p><em>常量指的应该是不被量词修饰的“字母”，而变量指的是被量词修饰的“字母”。</em></p><h2 id="Evaluating-Terms"><a href="#Evaluating-Terms" class="headerlink" title="Evaluating Terms"></a>Evaluating Terms</h2><p>给定解释 $I$ 和指派 $\alpha$，可以对任意的项 $a$ 进行求值。</p><ul><li>$a$ 为常量：$\langle I, \alpha\rangle(a) = I(a)$</li><li>$a$ 为变量：$\langle I, \alpha\rangle(a) = \alpha(a)$</li><li>$a$ 为函数：$\langle I, \alpha\rangle(f(x_1, x_2)) = (I(f))(\langle I, \alpha\rangle(x_1), \langle I, \alpha\rangle(x_2))$</li></ul><p>项的求值结果是对象。</p><h2 id="Evaluating-Formulas"><a href="#Evaluating-Formulas" class="headerlink" title="Evaluating Formulas"></a>Evaluating Formulas</h2><p>给定解释、指派和论域三者后可以对公式进行求值。公式求值的结果是布尔值。</p><h2 id="Evaluating-Quantifiers"><a href="#Evaluating-Quantifiers" class="headerlink" title="Evaluating Quantifiers"></a>Evaluating Quantifiers</h2><p><strong>对指派的变更（variant）</strong>：对于指派 $\alpha​$，如果修改其中变量 $x​$ 的值为 $c​$，新的指派记作 $\alpha[x\mapsto c]​$。</p><p>使用对指派的变更这一概念可以对量词子句进行求值。求值结果为布尔值。</p><p>例如 $\forall x.P(x)​$ 在 $I, \alpha, D​$ 下求值结果为真当且仅当对于 $D​$ 中的任意 $c​$，$P(x)​$ 在 $I, \alpha[x\mapsto c],D​$ 的结果都为真。</p><h2 id="Satisfiability-amp-Validity"><a href="#Satisfiability-amp-Validity" class="headerlink" title="Satisfiability &amp; Validity"></a>Satisfiability &amp; Validity</h2><p>如果存在一组 $D, I, \alpha​$ 使得 $D, I, \alpha\vDash F​$，$F​$ 是可满足的。</p><p>如果对所有的 $D, I, \alpha​$  都满足 $F​$，则 $F​$ 是永真的。这个条件很强，它要三个东西都是任取的。</p><p>同命题逻辑一样，二者可以相互实现。$F$ 是可满足的等价于其反面不是永真的。</p><h2 id="Proof-Validity"><a href="#Proof-Validity" class="headerlink" title="Proof Validity"></a>Proof Validity</h2><p>同命题逻辑一样，如果希望证明永真性，就假设其反面可满足。<strong><em>证明中使用的规则和命题逻辑一致。</em></strong></p><p>额外的规则用来消除量词：</p><script type="math/tex; mode=display">\begin{aligned}&D, I, \alpha\vDash \forall x.F \\\Rightarrow& D, I, \alpha[x\mapsto c] \vDash F \text{ for all } c \text{ in } D\\&D, I, \alpha\nvDash \forall x.F \\\Rightarrow& D, I, \alpha[x\mapsto c] \nvDash F \text{ for some } c \text{ in } D\\&D, I, \alpha\vDash \exists x.F \\\Rightarrow& D, I, \alpha[x\mapsto c] \vDash F \text{ for some } c \text{ in } D\\&D, I, \alpha\nvDash \exists x.F \\\Rightarrow& D, I, \alpha[x\mapsto c] \nvDash F \text{ for any } c \text{ in } D\\\end{aligned}</script><p>证明时在以下情况可以推出矛盾：同一个谓词在相同参数情况下返回了不同结果。例如 $D, I, \alpha[x\mapsto a] \vDash p(x)$ 和 $D, I, \alpha[y\mapsto a]\nvDash p(y)$ 是矛盾的。</p><h2 id="Soundness-amp-Completeness"><a href="#Soundness-amp-Completeness" class="headerlink" title="Soundness &amp; Completeness"></a>Soundness &amp; Completeness</h2><p>命题逻辑的永真性证明和一阶逻辑的永真性证明都应说明证明过程是可靠且完备的。</p><ul><li><strong>可靠性</strong>：只要所有的证明分支都导出了矛盾，那么公式必然是不可满足的。不会发生错误的接受。</li><li><strong>完备性</strong>：如果公式是不可满足的，则必然在有限步内能够在所有分支上都导出矛盾。不会发生错误的拒绝。</li></ul><h2 id="Decidability"><a href="#Decidability" class="headerlink" title="Decidability"></a>Decidability</h2><ul><li><p><strong>决定性问题</strong>：要求回答是或者否的问题。</p></li><li><p><strong>可决定的（decidable）</strong>：一个问题是可决定的，等价于存在一个程序，对于任意的问题输入，当结果应该为真时它会停机并输出真，当结果应该为假时它会停机并输出假。</p></li><li><strong>半可决定的（semidecidable）</strong>：一个问题是可决定的，等价于存在一个程序，对于任意的问题输入，当结果应该为真时它会停机并输出真，当结果应该为假时它要么会停机并输出假要么不会停机。</li></ul><p>给定一个一阶逻辑公式问它是否是永真的，这个问题是不可决定的，但是是半可决定的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 形式化验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式化验证课程笔记 2</title>
      <link href="/2019/03/11/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2019/03/11/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><p>主要内容：SAT 问题求解。</p><p>约定 $F$ 表示公式，$C$ 表示从句。</p><h2 id="Satisfiability-Problem"><a href="#Satisfiability-Problem" class="headerlink" title="Satisfiability Problem"></a>Satisfiability Problem</h2><ul><li><strong>SAT 问题</strong>：给定命题，问是否存在一个解释使得命题成立。</li><li><strong>2-SAT 问题</strong>：给定 CNF 形式的命题，每个从句最多只有两个文字的 SAT 问题，可在多项式时间内求解。</li><li><strong>3-SAT 问题</strong>：给定 CNF 形式的命题，每个从句最多只有三个文字的 SAT 问题。NPC 难度。</li></ul><h2 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a>Resolution</h2><p>对于一个 CNF，可以将它写成集合的集合的形式，例如：</p><script type="math/tex; mode=display">(P\lor Q)\land(Q\to \lnot P)</script><p>相当于</p><script type="math/tex; mode=display">\{\{P, Q\}, \{\lnot Q, \lnot P\}\}</script><p>用 $C[P]$ 表示文字 $P$ 在从句 $C$ 中出现，用 $C\{P\mapsto Q\}$ 表示在从句 $C$ 中使用 $Q$ 替换掉 $P$。</p><a id="more"></a><p><strong>Single inference rule</strong>：如果两个从句中各自出现了一个变量和它的反，那么可以将变量消去，然后将两个从句合并。</p><img src="/2019/03/11/形式化验证课程笔记-2/DeepinScreenshot_select-area_20190311120330.png"><p>如果两个从句中分别只包含这个变量和它的反，那么显然它是不可满足的。可以得到 SAT 问题的一个算法：</p><img src="/2019/03/11/形式化验证课程笔记-2/DeepinScreenshot_select-area_20190311120451.png"><hr><h3 id="Partial-Interpretations"><a href="#Partial-Interpretations" class="headerlink" title="Partial Interpretations"></a>Partial Interpretations</h3><p><strong>部分解释</strong> 是不完全覆盖所有变量的解释。</p><p>文字在给定部分解释下有三种结果：true、false、undef（没有出现在部分解释中）。</p><p>从句也包含上述三种结果，还有一种 undef 的特殊形式 unit，指的是在部分解释下，从句的真值只取决于一个没有被解释的变量。</p><h2 id="Decision-Procedure-as-a-Transition-System"><a href="#Decision-Procedure-as-a-Transition-System" class="headerlink" title="Decision Procedure as a Transition System"></a>Decision Procedure as a Transition System</h2><p>对 SAT 问题的求解可以看作是一个以所有部分解释为状态的状态机上的搜索。从空的部分解释开始，每次选择一个变量对其进行解释，如此下去，直到尝试完所有可能或者找到 SAT 状态。</p><p>首先考虑一个 naive 的算法。初始状态下部分解释为空，然后可以做两件事情：decision 或者 backtrack。实际上做的事就是一个启发式的深搜。</p><img src="/2019/03/11/形式化验证课程笔记-2/DeepinScreenshot_select-area_20190311121912.png"><p>在考虑 unit 的情况下，一旦给定了一个部分解释，那么为了使整个命题为真，有些在该部分解释下为 unit 的从句依赖的那个变量就可以直接确定出值，而不用被尝试。加上这个优化后，能做的事情除了 decision、backtrack 外就是这个 unit propagation 了。</p><p>最后给一个例子（上标小圆圈表示尝试将真值赋给变量；上划线表示尝试将假值赋给变量；否则就是 unit propagation 确定的）。</p><img src="/2019/03/11/形式化验证课程笔记-2/DeepinScreenshot_select-area_20190311122224.png"><h2 id="Backjump"><a href="#Backjump" class="headerlink" title="Backjump"></a>Backjump</h2><p>可以对上面的算法进一步优化。考虑如下的例子：</p><img src="/2019/03/11/形式化验证课程笔记-2/DeepinScreenshot_select-area_20190311201154.png"><ol><li>如果先将 $P_1$ 设为 True，那么 $P_2$ 就必须为 False（unit propagation）。</li><li>如果再将 $P_3$ 设为 True，那么 $P_4$ 就必须为 False。</li><li>如果再将 $P_5$ 设为 True，那么从 $C_4$ 知道 $P_6$ 必须为 True，从 $C_3$ 和已经为 True 的 $P_2$ 知道 $P_6$ 必须为 False，产生矛盾。</li></ol><p>如果将上述决策过程做成一张 DAG 会得到：</p><img src="/2019/03/11/形式化验证课程笔记-2/DeepinScreenshot_select-area_20190311201533.png"><p>从这张图中我们可以知道，只要 $P_1$ 和 $P_5$  同时为 True 就会有矛盾，而不用管 $P_3$ 的取值。</p><p>这张图称作 <strong>Implication Graph</strong>，其中 @ 表示在第几步做的决策，箭头上表示从第几个从句得到结论，$\Lambda$ 表示矛盾。</p><p>Implication graph 中含有 $\Lambda$ 结点的最大联通分量称为 <strong>Conflict Graph</strong>。</p><p>从 Confilict graph 中可以得到一系列 <strong>冲突子句</strong>，就像 $P_1$ 和 $P_5$ 不能同时为 True 一样，还能找到其它不能同时满足的取值情况。现在的问题是：</p><ul><li>如何找到这样的不可同时满足的取值情况</li><li>如何使用该信息</li></ul><h3 id="如何找到这样的不可同时满足的取值情况"><a href="#如何找到这样的不可同时满足的取值情况" class="headerlink" title="如何找到这样的不可同时满足的取值情况"></a>如何找到这样的不可同时满足的取值情况</h3><p>将 Confilict graph 中的结点切分成两个集合，使得所有的决策结点落在一个集合中，矛盾结点在另一个集合中，且矛盾结点所在的集合的任何一点都不是决策结点所在一个集合中任何一点的前驱：</p><img src="/2019/03/11/形式化验证课程笔记-2/DeepinScreenshot_select-area_20190311202437.png"><p>如上图，一共可以找到三种切分方法。对应可以获得三组不可同时满足的取值情况。它们可以作为新的条件，像从句一样加入到已知的公式中。</p><h3 id="如何使用该信息"><a href="#如何使用该信息" class="headerlink" title="如何使用该信息"></a>如何使用该信息</h3><p>在搜索的过程中维护 Implication graph。当出现了矛盾时，得到 confilict graph，此时可以分析出是哪些决定导致了矛盾，哪些决定与矛盾无关，并且可以得到一系列冲突子句。将所有的冲突子句加入到公式中，并有限修改那些导致矛盾的变量的取值即可。</p><p>因为记住了是哪些变量导致的矛盾并优先处理了，在搜索时搜索树的表现情况像是往上跳了很多，所以叫 backjump。</p><h2 id="Pratical-Algorithms"><a href="#Pratical-Algorithms" class="headerlink" title="Pratical Algorithms"></a>Pratical Algorithms</h2><p>以上是 SAT 求解器设计的一些策略。解决 SAT 问题的一些实用算法：</p><ul><li>（DPLL）Davis-Putnam-Logemann-Loveland</li><li>（CDCL）Conflict-Driven Clause Learning</li><li>Dynamic Largest Individual Sum</li><li>Variable State Independent Decaying Sum</li></ul><p>不使用冲突子句的算法是简易的 DPLL 算法，使用冲突子句的算法是简易的 CDCL 算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 形式化验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（中）：建模与设计 笔记 2 数据建模：工程化方法及案例分析</title>
      <link href="/2019/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-2-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%9A%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%96%B9%E6%B3%95%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
      <url>/2019/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-2-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%9A%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%96%B9%E6%B3%95%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="数据建模：工程化方法及案例分析"><a href="#数据建模：工程化方法及案例分析" class="headerlink" title="数据建模：工程化方法及案例分析"></a>数据建模：工程化方法及案例分析</h1><h2 id="什么是IDEF1X"><a href="#什么是IDEF1X" class="headerlink" title="什么是IDEF1X"></a>什么是IDEF1X</h2><p>IDEF1X 是 E-R 图的一种细化。例如实体被细分为独立实体、从属实体；其它概念也有所细化。</p><p>可以将 IDEF1X 看作是除了 Chen 和 Crow&#39;s foot 之外的第三种表达方法。</p><h2 id="独立实体和从属实体"><a href="#独立实体和从属实体" class="headerlink" title="独立实体和从属实体"></a>独立实体和从属实体</h2><p>独立实体又称 <strong>强实体</strong>，从属实体又称 <strong>弱实体</strong>。</p><ul><li><strong>独立实体</strong> 的实例的唯一标识不依赖于它与其它实体的联系。主关键字没有外键。</li><li><strong>从属实体</strong> 的实例的唯一标识依赖于这个实体与其它实体的联系。从属实体的主关键字继承自其它实体的属性。主关键字有外键。从属实体的实例的存在依赖于其它实体的存在。</li></ul><p>IDEF1X 中还有其它各种限制和要求，这里略去。</p><h2 id="标定联系和非标定联系"><a href="#标定联系和非标定联系" class="headerlink" title="标定联系和非标定联系"></a>标定联系和非标定联系</h2><ul><li><strong>标定联系</strong>：父实体的主关键字是子实体的主关键字的一部分时，子实体和父实体之间的联系为 <strong>标定联系</strong>。此时子实体是从属实体。</li><li><strong>非标定联系</strong>：不是标定联系的联系。尽管父实体的主关键字可能是子实体的某个属性，但是子实体的唯一标识不需要靠这个属性。</li></ul><h2 id="非确定联系与相交实体"><a href="#非确定联系与相交实体" class="headerlink" title="非确定联系与相交实体"></a>非确定联系与相交实体</h2><p><strong>非确定联系</strong>：实体之间多对多的联系。</p><p>非确定联系需要分解为若干个多对一的联系进行表达。非确定联系的表达需要引入 <strong>相交实体</strong> 作为中介进行表达，例如两个实体之间的多对多的联系可以通过引入相交实体变成两个多对一的联系。</p><hr><p>确定性联系通过属性继承实现实体之间的联系；非确定性联系通过引入相交实体实现实体之间的联系。</p><h2 id="分类联系与分类实体"><a href="#分类联系与分类实体" class="headerlink" title="分类联系与分类实体"></a>分类联系与分类实体</h2><p>分类实体的概念类似于 OOP 中的继承。在 IDEF1X 中“超类”实体称为 <strong>一般实体</strong>，“子类”实体称为 <strong>分类实体</strong>。从一般实体到分类实体的过程称为 <strong>特化</strong>，反之称为 <strong>泛化</strong>。</p><p>分类实体和一般实体具有相同的主关键字。</p><p>分类实体和一般实体之间的联系称为 <strong>分类联系</strong>。<strong>完全分类联系</strong> 指的是一般实体的实例必然是某个分类实体的实例，反之为 <strong>非完全分类联系</strong>，即存在不是任意分类实体实例的一般实体的实例（一般实体的范围比分类实体的范围的并集要更大）。</p><a id="more"></a><h2 id="IDEF1X案例讲解之一-四个建模小例子"><a href="#IDEF1X案例讲解之一-四个建模小例子" class="headerlink" title="IDEF1X案例讲解之一-四个建模小例子"></a>IDEF1X案例讲解之一-四个建模小例子</h2><blockquote><p>本节无笔记。</p></blockquote><h2 id="IDEF1X案例讲解之二-仓储系统建模"><a href="#IDEF1X案例讲解之二-仓储系统建模" class="headerlink" title="IDEF1X案例讲解之二-仓储系统建模"></a>IDEF1X案例讲解之二-仓储系统建模</h2><blockquote><p>本节无笔记。</p></blockquote><h2 id="IDEF1X案例讲解之三-物料系统建模"><a href="#IDEF1X案例讲解之三-物料系统建模" class="headerlink" title="IDEF1X案例讲解之三-物料系统建模"></a>IDEF1X案例讲解之三-物料系统建模</h2><blockquote><p>本节无笔记。</p></blockquote><h2 id="IDEF1X案例讲解之四-六个模型示例点评"><a href="#IDEF1X案例讲解之四-六个模型示例点评" class="headerlink" title="IDEF1X案例讲解之四-六个模型示例点评"></a>IDEF1X案例讲解之四-六个模型示例点评</h2><blockquote><p>本节无笔记。</p></blockquote><h2 id="IDEF1X案例讲解之五-联赛管理系统建模"><a href="#IDEF1X案例讲解之五-联赛管理系统建模" class="headerlink" title="IDEF1X案例讲解之五-联赛管理系统建模"></a>IDEF1X案例讲解之五-联赛管理系统建模</h2><blockquote><p>本节无笔记。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Happy 与 Parsec 学习笔记</title>
      <link href="/2019/03/05/Happy-%E4%B8%8E-Parsec-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/05/Happy-%E4%B8%8E-Parsec-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Happy-与-Parsec-学习笔记"><a href="#Happy-与-Parsec-学习笔记" class="headerlink" title="Happy 与 Parsec 学习笔记"></a>Happy 与 Parsec 学习笔记</h1><h2 id="Parser-Generator-与-Parser-Combinator"><a href="#Parser-Generator-与-Parser-Combinator" class="headerlink" title="Parser Generator 与 Parser Combinator"></a>Parser Generator 与 Parser Combinator</h2><p>Parser 有两种——Generator 和 combinator。</p><ul><li><p>Generator 接受语法规则，然后生成语法分析程序。例如 ANTLR 就是典型的 parser generator。</p></li><li><p>Combinator 将一些小的语法分析函数组合起来，形成功能更复杂的语法分析函数。</p></li></ul><p>Happy 和 Parsec 是 Haskell 的两个包，前者是 parser generator，后者是 parser combinator。</p><p>作为例子，这篇文章会使用两种不同的策略对 json 文件进行语法分析。</p><a id="more"></a><h2 id="Happy-Parser-Generator"><a href="#Happy-Parser-Generator" class="headerlink" title="Happy - Parser Generator"></a>Happy - Parser Generator</h2><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>Happy 是用来进行进行语法分析的，没有词法分析的功能（但是可以模拟出来）。Happy 和 yacc 的用法类似。</p><p>这里应用了 Happy 官方文档第二章中的一部分，对于简单的语法分析任务应该够用了。</p><p>首先定义要解析的语言的 Token：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- token definition for lexer</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Token</span></span></span><br><span class="line">    = <span class="type">TokenString</span> <span class="type">String</span></span><br><span class="line">    | <span class="type">TokenNumber</span> <span class="type">String</span></span><br><span class="line">    | <span class="type">TokenNull</span></span><br><span class="line">    | <span class="type">TokenTrue</span></span><br><span class="line">    | <span class="type">TokenFalse</span></span><br><span class="line">    | <span class="type">TokenLBrace</span></span><br><span class="line">    | <span class="type">TokenRBrace</span></span><br><span class="line">    | <span class="type">TokenLBracket</span></span><br><span class="line">    | <span class="type">TokenRBracket</span></span><br><span class="line">    | <span class="type">TokenColon</span></span><br><span class="line">    | <span class="type">TokenComma</span></span><br><span class="line">    <span class="keyword">deriving</span> <span class="type">Show</span></span><br></pre></td></tr></table></figure><p>然后瞎写一个词法分析函数（基本上是对的）：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lexer program</span></span><br><span class="line"><span class="title">lexer</span> :: <span class="type">String</span> -&gt; [<span class="type">Token</span>]</span><br><span class="line"><span class="title">lexer</span> <span class="string">""</span> = []</span><br><span class="line"><span class="title">lexer</span> ccs @ (c : cs)</span><br><span class="line">    | isSpace c = lexer cs</span><br><span class="line">    | c == '&#123;' = <span class="type">TokenLBrace</span> : lexer cs</span><br><span class="line">    | c == '&#125;' = <span class="type">TokenRBrace</span> : lexer cs</span><br><span class="line">    | c == '[' = <span class="type">TokenLBracket</span> : lexer cs</span><br><span class="line">    | c == ']' = <span class="type">TokenRBracket</span> : lexer cs</span><br><span class="line">    | c == ':' = <span class="type">TokenColon</span> : lexer cs</span><br><span class="line">    | c == ',' = <span class="type">TokenComma</span> : lexer cs</span><br><span class="line">    | length cs &gt;= <span class="number">3</span> &amp;&amp; (c : take <span class="number">3</span> cs == <span class="string">"null"</span>) = <span class="type">TokenNull</span> : lexer (drop <span class="number">3</span> cs)</span><br><span class="line">    | length cs &gt;= <span class="number">3</span> &amp;&amp; (c : take <span class="number">3</span> cs == <span class="string">"true"</span>) = <span class="type">TokenTrue</span> : lexer (drop <span class="number">3</span> cs)</span><br><span class="line">    | length cs &gt;= <span class="number">4</span> &amp;&amp; (c : take <span class="number">4</span> cs == <span class="string">"false"</span>) = <span class="type">TokenFalse</span> : lexer (drop <span class="number">4</span> cs)</span><br><span class="line">    | c == '<span class="string">"' = let (s, remain) = lexString ccs in TokenString s : lexer remain</span></span><br><span class="line"><span class="string">    | c == '-' || isDigit c = let (s, remain) = lexNumber ccs in TokenNumber s : lexer remain</span></span><br><span class="line"><span class="string">    | otherwise = error "</span><span class="type">Lexer</span> error - unexpected character.<span class="string">"</span></span><br><span class="line"><span class="string">    where</span></span><br><span class="line"><span class="string">        firstChar s = case s of</span></span><br><span class="line"><span class="string">            "</span><span class="string">" -&gt; ("</span><span class="string">", "</span><span class="string">")</span></span><br><span class="line"><span class="string">            '\\' : '\\' : remain -&gt; ("</span>\\\\<span class="string">", remain)</span></span><br><span class="line"><span class="string">            '\\' : '\"' : remain -&gt; ("</span>\\\<span class="string">""</span>, remain)</span><br><span class="line">            '\\' : 'b' : remain -&gt; (<span class="string">"\\b"</span>, remain)</span><br><span class="line">            '\\' : 'f' : remain -&gt; (<span class="string">"\\f"</span>, remain)</span><br><span class="line">            '\\' : 'n' : remain -&gt; (<span class="string">"\\n"</span>, remain)</span><br><span class="line">            '\\' : 'r' : remain -&gt; (<span class="string">"\\r"</span>, remain)</span><br><span class="line">            '\\' : 't' : remain -&gt; (<span class="string">"\\t"</span>, remain)</span><br><span class="line">            '\\' : '/' : remain -&gt; (<span class="string">"\\/"</span>, remain)</span><br><span class="line">            '\\' : 'u' : c1 : c2 : c3 : c4 : remain -&gt;</span><br><span class="line">                <span class="keyword">if</span> all (\x -&gt; isLower x &amp;&amp; isHexDigit x) [c1, c2, c3, c4]</span><br><span class="line">                <span class="keyword">then</span> (['\\', 'u', c1, c2, c3, c4], remain)</span><br><span class="line">                <span class="keyword">else</span> error <span class="string">"Lexer error - unrecognized escaped unicode."</span></span><br><span class="line">            c : cs -&gt; ([c], cs)</span><br><span class="line">        lexUntilQuote s = <span class="keyword">case</span> s <span class="keyword">of</span></span><br><span class="line">            <span class="string">""</span> -&gt; error <span class="string">"Lexer error - unmatched quote."</span></span><br><span class="line">            otherwise -&gt; <span class="keyword">let</span> (fc, r) = firstChar s <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> fc == <span class="string">"\""</span></span><br><span class="line">                <span class="keyword">then</span> (fc, r)</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">let</span> (ans, rr) = lexUntilQuote r <span class="keyword">in</span> (fc ++ ans, rr)</span><br><span class="line">        lexString s = <span class="keyword">let</span> (ans, remain) = lexUntilQuote (tail s) <span class="keyword">in</span> (head s : ans, remain)</span><br><span class="line">        getNumber :: <span class="type">String</span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">        getNumber s = s =~ <span class="string">"-?(0|[1-9][0-9]*)(\\.[0-9]+)?([eE][+-]?[0-9]+)?"</span></span><br><span class="line">        lexNumber s = <span class="keyword">let</span> (off, len) = getNumber s <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> off /= <span class="number">0</span></span><br><span class="line">            <span class="keyword">then</span> error <span class="string">"Lexer error - not a number."</span></span><br><span class="line">            <span class="keyword">else</span> (take len s, drop len s)</span><br></pre></td></tr></table></figure><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>和 Yacc 类似，Happy 需要一个语法文件。</p><p>语法文件中需要定义用到的 <strong>语法中用到的</strong> token，小写字母开头或者单字符（名称可以任意）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- token definition for parser</span><br><span class="line">%token</span><br><span class="line">    string  &#123; TokenString $$ &#125;</span><br><span class="line">    number  &#123; TokenNumber $$ &#125;</span><br><span class="line">    null    &#123; TokenNull &#125;</span><br><span class="line">    true    &#123; TokenTrue &#125;</span><br><span class="line">    false   &#123; TokenFalse &#125;</span><br><span class="line">    &apos;&#123;&apos;     &#123; TokenLBrace &#125;</span><br><span class="line">    &apos;&#125;&apos;     &#123; TokenRBrace &#125;</span><br><span class="line">    &apos;[&apos;     &#123; TokenLBracket &#125;</span><br><span class="line">    &apos;]&apos;     &#123; TokenRBracket &#125;</span><br><span class="line">    &apos;:&apos;     &#123; TokenColon &#125;</span><br><span class="line">    &apos;,&apos;     &#123; TokenComma &#125;</span><br></pre></td></tr></table></figure><p>一共两列，左边是语法定义中使用的 token，相当于终结符，右边是词法分析得到的 token。Happy 进行词法分析时希望得到的是一个 token 流，<strong>Happy 在这里会进行一个匹配</strong>，将右边的 token 对应到左边后进行语法分析。词法分析得到的 token 可以带有属性，使用 $$$$ 表示即可。</p><p>然后写语法定义（右边一些 <code>J</code> 开头的后面会写）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* grammar definition */</span><br><span class="line"></span><br><span class="line">Json</span><br><span class="line">    : Value                         &#123; Json $1 &#125;</span><br><span class="line"></span><br><span class="line">Value</span><br><span class="line">    : string                        &#123; JString $1 &#125;</span><br><span class="line">    | number                        &#123; JNumber $1 &#125;</span><br><span class="line">    | true                          &#123; JTrue &#125;</span><br><span class="line">    | false                         &#123; JFalse &#125;</span><br><span class="line">    | null                          &#123; JNull &#125;</span><br><span class="line">    | Object                        &#123; JObject $1 &#125;</span><br><span class="line">    | Array                         &#123; JArray $1 &#125;</span><br><span class="line"></span><br><span class="line">Object</span><br><span class="line">    : &apos;&#123;&apos; &apos;&#125;&apos;                       &#123; [] &#125;</span><br><span class="line">    | &apos;&#123;&apos; Pairs &apos;&#125;&apos;                 &#123; $2 &#125;</span><br><span class="line"></span><br><span class="line">Pairs</span><br><span class="line">    : string &apos;:&apos; Value              &#123; [($1, $3)] &#125;</span><br><span class="line">    | string &apos;:&apos; Value &apos;,&apos; Pairs    &#123; ($1, $3) : $5 &#125;</span><br><span class="line"></span><br><span class="line">Array</span><br><span class="line">    : &apos;[&apos; &apos;]&apos;                       &#123; [] &#125;</span><br><span class="line">    | &apos;[&apos; Values &apos;]&apos;                &#123; $2 &#125;</span><br><span class="line"></span><br><span class="line">Values</span><br><span class="line">    : Value                         &#123; [$1] &#125;</span><br><span class="line">    | Value &apos;,&apos; Values              &#123; $1 : $3 &#125;</span><br></pre></td></tr></table></figure><p>Happy 最后会把语法分析的结果转换为 Haskell 中的一个 datatype（我称之为 target datatype）。因此还需要定义对应的 datatype。语法规则的声明可以看做有两列：左边是对文法的描述，是终结符和非终结符构成的模式；右边是一个 Haskell 表达式（甚至可以是一个函数），表示应当将对应的模式转换到 Haskell 中的什么值。使用形如 <code>$1</code> 这样的符号来对产生式右部的符号进行索引。</p><p>这个例子中对应的 datatype 的定义是：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- target datatype</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Json</span> = <span class="type">Json</span> <span class="type">JValue</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">JValue</span></span></span><br><span class="line">    = <span class="type">JString</span> <span class="type">String</span></span><br><span class="line">    | <span class="type">JNumber</span> <span class="type">String</span></span><br><span class="line">    | <span class="type">JTrue</span></span><br><span class="line">    | <span class="type">JFalse</span></span><br><span class="line">    | <span class="type">JNull</span></span><br><span class="line">    | <span class="type">JObject</span> [(<span class="type">String</span>, <span class="type">JValue</span>)]</span><br><span class="line">    | <span class="type">JArray</span> [<span class="type">JValue</span>]</span><br><span class="line">    <span class="keyword">deriving</span> <span class="type">Show</span></span><br></pre></td></tr></table></figure><p>整个 json 文件会被 parse 成一个 <code>Json</code> 对象。</p><p>例如，在语法定义中</p><ul><li><code>true { JTrue }</code> 表示 <code>true</code> 这个 token 会被映射到 <code>JTrue</code></li><li><code>string &#39;:&#39; Value { [($1, $3)] }</code> 表示整个模式会被映射到一个只有一个元素的列表，唯一的元素是一个二元组，第二个分量是 <code>Value</code> 将会被映射得到的量，而第一个分量是 <code>string</code> 这个 token 的值（在 <strong>语法中用到的</strong> token 中 <code>string</code> 这个 token 是带有值的），整个的类型是 <code>[(String, JValue)]</code>，和 target datatype 定义一致。</li></ul><p><strong>总结</strong>：源语言按照语法规则被映射到 Haskell 中使用 target datatype 表示的值。</p><h3 id="完整的语法文件"><a href="#完整的语法文件" class="headerlink" title="完整的语法文件"></a>完整的语法文件</h3><p>语法文件使用 <code>.y</code> 作为后缀。完整的语法文件的格式为（将注释中以 <code>EXPAND</code> 开头的替换为前面对应的代码片段）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">module HappyJsonParser where</span><br><span class="line"></span><br><span class="line">import Data.Char</span><br><span class="line">import Text.Regex.Posix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%name happyJsonParser</span><br><span class="line">%tokentype &#123; Token &#125;</span><br><span class="line">%error &#123; parseError &#125;</span><br><span class="line"></span><br><span class="line">/* EXPAND token definition for parser */</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">/* EXPAND grammar definition */</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">parseError :: [Token] -&gt; a</span><br><span class="line">parseError _ = error &quot;Parse Error&quot;</span><br><span class="line"></span><br><span class="line">-- EXPAND target datatype</span><br><span class="line">-- EXPAND token definition for lexer</span><br><span class="line">-- EXPAND lexer program</span><br><span class="line"></span><br><span class="line">lexAndParse :: String -&gt; Json</span><br><span class="line">lexAndParse = happyJsonParser . lexer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>{</code> 和 <code>}</code> 扩起的是在生成 hs 文件时会原封不动复制过去的代码片段，因此里面应当是 Haskell 代码，包括：模块声明、引入声明、错误处理程序、target datatype、token datatype 和词法分析器等。</p><ul><li><code>%name</code> 后面跟一个函数名，Happy 会生成相同名称的签名为 <code>[Token] -&gt; Exp</code> 的函数，其中 <code>Token</code> 是 token datatype，<code>Exp</code> 是语法规则第一条会被翻译到的 datatype 即 target datatype。</li><li><code>%tokentype</code> 指定 token datatype。</li><li><p><code>%error</code> 制定错误处理函数，可以就像上面那样写个没有任何功能的函数。</p></li><li><p>注意定义完了词法单元后再定义文法时要用 <code>%%</code> 进行分割。</p></li></ul><p>在最后可以搞一个将词法分析与语法分析结合起来的函数 <code>lexAndParse</code>，其中用到的 <code>happyJsonParser</code> 就是 Happy 生成的函数。</p><p>随后执行 <code>happy this_file.y</code> 即可生成对应的 hs 文件，然后使用其中定义的函数即可（一般就是 <code>happyJsonParser</code> 和 <code>lexAndParse</code> 了）。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>对于以下 json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"widget"</span>: &#123;</span><br><span class="line">    <span class="attr">"debug"</span>: <span class="string">"on"</span>,</span><br><span class="line">    <span class="attr">"window"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"Sample Konfabulator Widget"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"main_window"</span>,</span><br><span class="line">      <span class="attr">"width"</span>: <span class="number">500</span>,</span><br><span class="line">      <span class="attr">"height"</span>: <span class="number">500</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"image"</span>: &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"Images/Sun.png"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"sun1"</span>,</span><br><span class="line">      <span class="attr">"hOffset"</span>: <span class="number">250</span>,</span><br><span class="line">      <span class="attr">"vOffset"</span>: <span class="number">250</span>,</span><br><span class="line">      <span class="attr">"alignment"</span>: <span class="string">"center"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"text"</span>: &#123;</span><br><span class="line">      <span class="attr">"data"</span>: <span class="string">"Click Here"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">36</span>,</span><br><span class="line">      <span class="attr">"style"</span>: <span class="string">"bold"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"text1"</span>,</span><br><span class="line">      <span class="attr">"hOffset"</span>: <span class="number">250</span>,</span><br><span class="line">      <span class="attr">"vOffset"</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="attr">"alignment"</span>: <span class="string">"center"</span>,</span><br><span class="line">      <span class="attr">"onMouseUp"</span>: <span class="string">"sun1.opacity = (sun1.opacity / 100) * 90;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会得到：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Json</span> (<span class="type">JObject</span> [(<span class="string">"\"widget\""</span>,<span class="type">JObject</span> [(<span class="string">"\"debug\""</span>,<span class="type">JString</span> <span class="string">"\"on\""</span>),(<span class="string">"\"window\""</span>,<span class="type">JObject</span> [(<span class="string">"\"title\""</span>,<span class="type">JString</span> <span class="string">"\"Sample Konfabulator Widget\""</span>),(<span class="string">"\"name\""</span>,<span class="type">JString</span> <span class="string">"\"main_window\""</span>),(<span class="string">"\"width\""</span>,<span class="type">JNumber</span> <span class="string">"500"</span>),(<span class="string">"\"height\""</span>,<span class="type">JNumber</span> <span class="string">"500"</span>)]),(<span class="string">"\"image\""</span>,<span class="type">JObject</span> [(<span class="string">"\"src\""</span>,<span class="type">JString</span> <span class="string">"\"Images/Sun.png\""</span>),(<span class="string">"\"name\""</span>,<span class="type">JString</span> <span class="string">"\"sun1\""</span>),(<span class="string">"\"hOffset\""</span>,<span class="type">JNumber</span> <span class="string">"250"</span>),(<span class="string">"\"vOffset\""</span>,<span class="type">JNumber</span> <span class="string">"250"</span>),(<span class="string">"\"alignment\""</span>,<span class="type">JString</span> <span class="string">"\"center\""</span>)]),(<span class="string">"\"text\""</span>,<span class="type">JObject</span> [(<span class="string">"\"data\""</span>,<span class="type">JString</span> <span class="string">"\"Click Here\""</span>),(<span class="string">"\"size\""</span>,<span class="type">JNumber</span> <span class="string">"36"</span>),(<span class="string">"\"style\""</span>,<span class="type">JString</span> <span class="string">"\"bold\""</span>),(<span class="string">"\"name\""</span>,<span class="type">JString</span> <span class="string">"\"text1\""</span>),(<span class="string">"\"hOffset\""</span>,<span class="type">JNumber</span> <span class="string">"250"</span>),(<span class="string">"\"vOffset\""</span>,<span class="type">JNumber</span> <span class="string">"100"</span>),(<span class="string">"\"alignment\""</span>,<span class="type">JString</span> <span class="string">"\"center\""</span>),(<span class="string">"\"onMouseUp\""</span>,<span class="type">JString</span> <span class="string">"\"sun1.opacity = (sun1.opacity / 100) * 90;\""</span>)])])])</span><br></pre></td></tr></table></figure><h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><p>Happy 还支持：</p><ul><li>定义优先级和结合性</li><li>对产生式进行类型标注</li><li>使用 Monadic Parser（并没有仔细看）</li><li>错误处理</li><li>其它</li></ul><h2 id="Parsec-Parser-Combinator"><a href="#Parsec-Parser-Combinator" class="headerlink" title="Parsec - Parser Combinator"></a>Parsec - Parser Combinator</h2><p>Parsec 使用 parser combinator 的策略：每个函数处理一件小事，然后通过函数组合让它的功能更加复杂。</p><p>Parsec 最低可以到字符粒度的控制，因此既可以进行词法分析也可以进行语法分析。Parsec 库中提供了大量可以直接使用的函数，只需要将这些函数组合起来即可，并且这些函数的语义比较明确。</p><h3 id="Target-datatype"><a href="#Target-datatype" class="headerlink" title="Target datatype"></a>Target datatype</h3><p>和使用 Happy 时一致：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- target datatype</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Json</span> = <span class="type">Json</span> <span class="type">JValue</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">JValue</span></span></span><br><span class="line">    = <span class="type">JString</span> <span class="type">String</span></span><br><span class="line">    | <span class="type">JNumber</span> <span class="type">String</span></span><br><span class="line">    | <span class="type">JTrue</span></span><br><span class="line">    | <span class="type">JFalse</span></span><br><span class="line">    | <span class="type">JNull</span></span><br><span class="line">    | <span class="type">JObject</span> [(<span class="type">String</span>, <span class="type">JValue</span>)]</span><br><span class="line">    | <span class="type">JArray</span> [<span class="type">JValue</span>]</span><br><span class="line">    <span class="keyword">deriving</span> <span class="type">Show</span></span><br></pre></td></tr></table></figure><h3 id="处理数字"><a href="#处理数字" class="headerlink" title="处理数字"></a>处理数字</h3><p>使用 Parsec 时，所有的做解析的函数的签名都应为 <code>GenParser Char st X</code>，其中 <code>X</code> 按照自己需要决定。</p><p>Json 中数字的正则表达式是 <code>-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?</code>。下面首先使用 <code>integer</code>、<code>fraction</code> 和 <code>exponential</code> 分别处理整数部分、小数部分和指数部分，它们处理的结果都“返回”字符串。然后使用 <code>number</code> 将它们结合起来最终返回一个 <code>JValue</code>。</p><p>以 <code>integer</code> 为例，首先 <code>string &quot;0&quot;</code> 会尝试从字符串流中匹配 <code>&quot;0&quot;</code>，一旦成功，立即返回；否则会开始匹配 <code>&lt;|&gt;</code> 后的内容（<code>&lt;|&gt;</code> 是 <code>Alternative</code> 的一个运算符）。<code>oneOf</code> 会从给定的多个字符中进行匹配，<code>digit</code> 会尝试匹配一个数字，<code>many</code> 会进行多次匹配（可以是 0 次，而 <code>many1</code> 不允许是 0 次）。</p><p><strong>需要注意对于 <code>&lt;|&gt;</code> 来说，如果前面已经匹配了一部分然后失败了，那么匹配后面时前面已匹配部分已经被消耗了。可使用 <code>try</code> 解决这个问题。</strong></p><p><code>choice</code> 会从一个列表的匹配函数中依次选择直到成功，option 会在不成功时返回一个 fallback 值。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- number</span></span><br><span class="line"><span class="title">integer</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">String</span></span><br><span class="line"><span class="title">integer</span> = (string <span class="string">"0"</span>) &lt;|&gt; (<span class="keyword">do</span> l &lt;- oneOf ['<span class="number">1</span>' .. '<span class="number">9</span>']; r &lt;- many digit; return (l : r))</span><br><span class="line"></span><br><span class="line"><span class="title">fraction</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">String</span></span><br><span class="line"><span class="title">fraction</span> = <span class="keyword">do</span> char '.'; r &lt;- many1 digit; return ('.' : r)</span><br><span class="line"></span><br><span class="line"><span class="title">exponential</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">String</span></span><br><span class="line"><span class="title">exponential</span> = <span class="keyword">do</span></span><br><span class="line">    e &lt;- oneOf ['e', '<span class="type">E'</span>]</span><br><span class="line">    s &lt;- option <span class="string">""</span> (choice [string <span class="string">"-"</span>, string <span class="string">"+"</span>])</span><br><span class="line">    d &lt;- many1 digit</span><br><span class="line">    return ((e : s) ++ d)</span><br><span class="line"></span><br><span class="line"><span class="title">number</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">JValue</span></span><br><span class="line"><span class="title">number</span> = <span class="keyword">do</span></span><br><span class="line">    s &lt;- option <span class="string">""</span> (string <span class="string">"-"</span>)</span><br><span class="line">    i &lt;- integer</span><br><span class="line">    f &lt;- option <span class="string">""</span> fraction</span><br><span class="line">    e &lt;- option <span class="string">""</span> exponential</span><br><span class="line">    return $ <span class="type">JNumber</span> (s ++ i ++ f ++ e)</span><br></pre></td></tr></table></figure><h3 id="处理字符串"><a href="#处理字符串" class="headerlink" title="处理字符串"></a>处理字符串</h3><p><code>count</code> 可以指定匹配次数；<code>noneOf</code> 相当于反向的 <code>oneOf</code>。</p><p>使用 <code>choice</code> 时，也会出现匹配一部分后失败导致字符被消耗的问题，因此这里用 <code>map try</code> 来解决。应该有更好的办法。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- string</span></span><br><span class="line"><span class="title">lowerHex</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">Char</span></span><br><span class="line"><span class="title">lowerHex</span> = oneOf (['<span class="number">0</span>' .. '<span class="number">9</span>'] ++ ['a' .. 'f'])</span><br><span class="line"></span><br><span class="line"><span class="title">legalEscape</span> = map try [</span><br><span class="line">    string <span class="string">"\\\\"</span>, string <span class="string">"\\\""</span>, string <span class="string">"\\b"</span>, string <span class="string">"\\f"</span>,</span><br><span class="line">    string <span class="string">"\\n"</span>, string <span class="string">"\\r"</span>, string <span class="string">"\\t"</span>, string <span class="string">"\\/"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="title">stringChar</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">String</span></span><br><span class="line"><span class="title">stringChar</span> =</span><br><span class="line">    choice legalEscape</span><br><span class="line">    &lt;|&gt; (<span class="keyword">do</span> string <span class="string">"\\u"</span>; esc &lt;- count <span class="number">4</span> lowerHex; return (<span class="string">"\\u"</span> ++ esc))</span><br><span class="line">    &lt;|&gt; count <span class="number">1</span> (noneOf ['\<span class="string">"'])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">quotedString :: GenParser Char st JValue</span></span><br><span class="line"><span class="string">quotedString = do char '\"'; s &lt;- many stringChar; char '\"'; return $ JString (concat (["</span>\<span class="string">""</span>] ++ s ++ [<span class="string">"\""</span>]))</span><br></pre></td></tr></table></figure><h3 id="核心的处理"><a href="#核心的处理" class="headerlink" title="核心的处理"></a>核心的处理</h3><p><code>space</code> 可以匹配空白字符（因为没有 tokenize 的过程，所以即使是语法解析阶段也要手动处理空白字符）；<code>sepBy</code> 可以匹配模式 A 被模式 B 分割的模式（<code>endBy</code> 则匹配模式 A 总以模式 B 结尾的模式）。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- parser</span></span><br><span class="line"><span class="title">true</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">JValue</span></span><br><span class="line"><span class="title">true</span> = string <span class="string">"true"</span> &gt;&gt; return <span class="type">JTrue</span></span><br><span class="line"></span><br><span class="line"><span class="title">false</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">JValue</span></span><br><span class="line"><span class="title">false</span> = string <span class="string">"false"</span> &gt;&gt; return <span class="type">JFalse</span></span><br><span class="line"></span><br><span class="line"><span class="title">nullVal</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">JValue</span></span><br><span class="line"><span class="title">nullVal</span> = string <span class="string">"null"</span> &gt;&gt; return <span class="type">JNull</span></span><br><span class="line"></span><br><span class="line"><span class="title">pair</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st (<span class="type">String</span>, <span class="type">JValue</span>)</span><br><span class="line"><span class="title">pair</span> = <span class="keyword">do</span></span><br><span class="line">    many space</span><br><span class="line">    (<span class="type">JString</span> s) &lt;- quotedString</span><br><span class="line">    many space</span><br><span class="line">    char ':'</span><br><span class="line">    v &lt;- value</span><br><span class="line">    return (s, v)</span><br><span class="line"></span><br><span class="line"><span class="title">object</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">JValue</span></span><br><span class="line"><span class="title">object</span> = <span class="keyword">do</span></span><br><span class="line">    char '&#123;'</span><br><span class="line">    kvs &lt;- sepBy pair (char ',')</span><br><span class="line">    char '&#125;'</span><br><span class="line">    return $ <span class="type">JObject</span> kvs</span><br><span class="line"></span><br><span class="line"><span class="title">array</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">JValue</span></span><br><span class="line"><span class="title">array</span> = <span class="keyword">do</span></span><br><span class="line">    char '['</span><br><span class="line">    vs &lt;- sepBy value (char ',')</span><br><span class="line">    char ']'</span><br><span class="line">    return $ <span class="type">JArray</span> vs</span><br><span class="line"></span><br><span class="line"><span class="title">value</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">JValue</span></span><br><span class="line"><span class="title">value</span> = <span class="keyword">do</span></span><br><span class="line">    many space</span><br><span class="line">    v &lt;- choice (map try [quotedString, number, true, false, nullVal, object, array])</span><br><span class="line">    many space</span><br><span class="line">    return v</span><br><span class="line"></span><br><span class="line"><span class="title">json</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">Json</span></span><br><span class="line"><span class="title">json</span> = <span class="type">Json</span> &lt;$&gt; value</span><br></pre></td></tr></table></figure><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- main</span></span><br><span class="line"><span class="title">parseJson</span> :: <span class="type">String</span> -&gt; <span class="type">Json</span></span><br><span class="line"><span class="title">parseJson</span> s = <span class="keyword">case</span> parse json <span class="string">""</span> s <span class="keyword">of</span></span><br><span class="line">    <span class="type">Right</span> x -&gt; x</span><br><span class="line">    <span class="type">Left</span> _ -&gt; error <span class="string">"Parse error."</span></span><br></pre></td></tr></table></figure><hr><p>可以看到，Parsec 的语义性很好。</p><p>Parsec 还能和 Applicative Functor 结合使用，应该能进一步简化代码，但是我没有细看。</p><h2 id="Parser-Combinator-与-Parser-Generator-的比较"><a href="#Parser-Combinator-与-Parser-Generator-的比较" class="headerlink" title="Parser Combinator 与 Parser Generator 的比较"></a>Parser Combinator 与 Parser Generator 的比较</h2><p>来自 <a href="https://gist.github.com/ChShersh/27844477752359735dfa41ac184d3bf2" target="_blank" rel="noopener">https://gist.github.com/ChShersh/27844477752359735dfa41ac184d3bf2</a>。</p><img src="/2019/03/05/Happy-与-Parsec-学习笔记/DeepinScreenshot_select-area_20190307164636.png"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://gist.github.com/ChShersh/27844477752359735dfa41ac184d3bf2" target="_blank" rel="noopener">https://gist.github.com/ChShersh/27844477752359735dfa41ac184d3bf2</a></li><li><a href="https://www.haskell.org/happy/doc/html/index.html" target="_blank" rel="noopener">https://www.haskell.org/happy/doc/html/index.html</a></li><li><a href="http://book.realworldhaskell.org/read/using-parsec.html" target="_blank" rel="noopener">http://book.realworldhaskell.org/read/using-parsec.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> Parser </tag>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式化验证课程笔记 1</title>
      <link href="/2019/03/04/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2019/03/04/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><p>这些笔记是对课程 <em>软件系统建模与验证（1）</em>的记录。</p><p>这周讲的主要是命题逻辑。</p><h2 id="Propositional-Logic"><a href="#Propositional-Logic" class="headerlink" title="Propositional Logic"></a>Propositional Logic</h2><ul><li><strong>原子</strong>：取值为真或假的不可分割的断言。</li><li><strong>文字</strong>：原子或者它的反。</li><li><strong>公式</strong>：使用逻辑联结词连接的文字。</li><li><strong>解释</strong>：将公式中的每个原子映射到一个真值上的映射。确定了解释之后，公式的真值就知道了。</li><li><strong>满足</strong>：解释 $I$ 使公式 $F$ 为真，记作 $I\vDash F$。不满足记作 $I \nvDash F$。</li><li><strong>从句</strong>：合取范式和析取范式中由文字和逻辑连接词构成的语法单元。</li></ul><p>解释在记号上可以看做词典，原子 $P$ 在解释 $I$ 下的真值为 $I[P]$。</p><a id="more"></a><h2 id="Inductive-Semantics"><a href="#Inductive-Semantics" class="headerlink" title="Inductive Semantics"></a>Inductive Semantics</h2><p>Inductive semantics 用来得到一个解释下公式是否是被该解释满足的：</p><img src="/2019/03/04/形式化验证课程笔记-1/DeepinScreenshot_select-area_20190304175910.png"><h2 id="Satisfiability-amp-Validity"><a href="#Satisfiability-amp-Validity" class="headerlink" title="Satisfiability &amp; Validity"></a>Satisfiability &amp; Validity</h2><p>Satisfiable 指的是公式可被满足；Valid 指的是公式在任意解释下都被满足（<strong>永真式</strong>）。</p><p>二者是对偶的——永真的公式的反是不可满足的，因此可以用一个判定另一个。</p><p>证明可满足性或永真性的两种办法——<strong>搜索</strong> 和 <strong>推理</strong>。搜索可以用到上面的 inductive semantics。</p><h2 id="Semantic-Argument"><a href="#Semantic-Argument" class="headerlink" title="Semantic Argument"></a>Semantic Argument</h2><p>Semantic argument 是使用推理证明可满足性或永真性的办法之一。</p><p>证明框架：</p><ol><li>假设 $F$ 不是永真的，则存在解释 $I$ 使得 $I\nvDash F$。</li><li>应用 <strong>证明规则</strong>。</li><li>在不断应用证明规则的过程中可能出现多分支的情况，最后的情形必然是以下二者之一：<ul><li>证明到最后存在没有出现矛盾并且无法继续进行下去的分支，表示 $F$ 确实不是永真的。</li><li><strong>每个分支</strong> 都在不能进行下去前碰到了矛盾，表明 $F$ 是永真的。</li></ul></li></ol><p>证明规则见下一节。</p><h2 id="Proof-Rules"><a href="#Proof-Rules" class="headerlink" title="Proof Rules"></a>Proof Rules</h2><p>按照 negation、conjunction、disjunction、implication、equivalence（实际上就是五个逻辑运算符）可以分成五类规则。</p><p>短竖线表示 <strong>或</strong>，此时证明发生分叉。</p><img src="/2019/03/04/形式化验证课程笔记-1/DeepinScreenshot_select-area_20190304181140.png"><h2 id="Semantic-Judgements"><a href="#Semantic-Judgements" class="headerlink" title="Semantic Judgements"></a>Semantic Judgements</h2><p>如果 $F_1 \to F_2$ 永真，记作 $F_1\Rightarrow F_2$。</p><p>如果 $F_1 \leftrightarrow F_2$ 永真，记作 $F_1\Leftrightarrow F_2$。</p><p>这两个符号是用来表示公式之间的语义关系的，不是逻辑运算符。</p><h2 id="Normal-Forms"><a href="#Normal-Forms" class="headerlink" title="Normal Forms"></a>Normal Forms</h2><h3 id="Negation-Normal-Form-NNF"><a href="#Negation-Normal-Form-NNF" class="headerlink" title="Negation Normal Form (NNF)"></a>Negation Normal Form (NNF)</h3><p>这种范式中，所有的 negation 必须出现在原子前面。除此之外没有其它要求。</p><h3 id="Disjunctive-Normal-Form-DNF"><a href="#Disjunctive-Normal-Form-DNF" class="headerlink" title="Disjunctive Normal Form (DNF)"></a>Disjunctive Normal Form (DNF)</h3><p>析取范式。文字使用合取构成从句，从句使用析取构成公式。</p><p>析取范式的可满足性判定是显然的，但是它的从句数量可能很多。将普通公式变换到 DNF 可能导致 DNF 规模随原始公式规模指数级增大。</p><h3 id="Conjunctive-Normal-Form-CNF"><a href="#Conjunctive-Normal-Form-CNF" class="headerlink" title="Conjunctive Normal Form (CNF)"></a>Conjunctive Normal Form (CNF)</h3><p>合取范式。文字使用析取构成从句，从句使用合取构成公式。</p><p>合取范式的可满足性判定不是显然的，但是一般可满足性判定器使用合取范式作为输入，因为将一个公式变换为<br>CNF 形式是相对容易的。</p><h2 id="Equisatisfiability"><a href="#Equisatisfiability" class="headerlink" title="Equisatisfiability"></a>Equisatisfiability</h2><p>如果两个公式在可满足性上等价，这两个公式称为 <strong>可满足性等价</strong>。</p><p>可满足性等价比普通的等价要弱一些。可满足性等价不一定是等价的，但是反过来，等价的公式在可满足性上一定等价。</p><h2 id="Tseitin-39-s-Transformation"><a href="#Tseitin-39-s-Transformation" class="headerlink" title="Tseitin&#39;s Transformation"></a>Tseitin&#39;s Transformation</h2><p>这是一个将任意公式变换为 CNF 的算法，优点在于 CNF 的规模和原有的公式的规模是线性关系。</p><p>Tseitin 变换的思路是对于公式中的每个子表达式都引入新的变量。见维基上的这个例子：</p><img src="/2019/03/04/形式化验证课程笔记-1/DeepinScreenshot_select-area_20190304183135.png"><p>使用 Tseitin 变换可以变换到紫色箭头所示的那一步，随后将各项继续写为析取的形式即可。这一步是 trivial 的，因为每个要变换的子公式都最多只有两个运算符。</p><p>例子中对 $\neg s$ 单独引入变量的原因，我猜测是 $\neg$ 可能会出现在某个子公式左边，因此不能简单地认为 $\neg$ 及其运算数一定构成的是文字，这里只是一种退化的情况。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 形式化验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（下）：管理与技术 笔记 7 数据库事务处理技术之故障恢复</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（下）：管理与技术 笔记 6 数据库事务处理技术之并发控制</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-6-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-6-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（下）：管理与技术 笔记 5 数据库查询优化技术</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（下）：管理与技术 笔记 4 数据库查询实现算法之两趟扫描算法</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%A4%E8%B6%9F%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%A4%E8%B6%9F%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（下）：管理与技术 笔记 3 数据库查询实现算法之一趟扫描算法</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%80%E8%B6%9F%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%80%E8%B6%9F%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（下）：管理与技术 笔记 2 数据库索引技术</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库索引技术"><a href="#数据库索引技术" class="headerlink" title="数据库索引技术"></a>数据库索引技术</h1><h2 id="索引的概念和作用"><a href="#索引的概念和作用" class="headerlink" title="索引的概念和作用"></a>索引的概念和作用</h2><h2 id="SQL-中索引的创建和使用"><a href="#SQL-中索引的创建和使用" class="headerlink" title="SQL 中索引的创建和使用"></a>SQL 中索引的创建和使用</h2><h2 id="稀疏索引与稠密索引"><a href="#稀疏索引与稠密索引" class="headerlink" title="稀疏索引与稠密索引"></a>稀疏索引与稠密索引</h2><h2 id="主索引与辅助索引"><a href="#主索引与辅助索引" class="headerlink" title="主索引与辅助索引"></a>主索引与辅助索引</h2><h2 id="聚簇索引与倒排索引"><a href="#聚簇索引与倒排索引" class="headerlink" title="聚簇索引与倒排索引"></a>聚簇索引与倒排索引</h2><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h2><h2 id="B-树键值插入与删除-结点分裂与合并操作示例"><a href="#B-树键值插入与删除-结点分裂与合并操作示例" class="headerlink" title="B+ 树键值插入与删除-结点分裂与合并操作示例"></a>B+ 树键值插入与删除-结点分裂与合并操作示例</h2><h2 id="散列索引"><a href="#散列索引" class="headerlink" title="散列索引"></a>散列索引</h2><h2 id="可扩展散列索引和线性散列索引"><a href="#可扩展散列索引和线性散列索引" class="headerlink" title="可扩展散列索引和线性散列索引"></a>可扩展散列索引和线性散列索引</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（下）：管理与技术 笔记 1 数据库物理存储</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库物理存储"><a href="#数据库物理存储" class="headerlink" title="数据库物理存储"></a>数据库物理存储</h1><h2 id="存储体系回顾"><a href="#存储体系回顾" class="headerlink" title="存储体系回顾"></a>存储体系回顾</h2><p>数据库一般存放在磁盘上（也有内存数据库），然后将内存作为缓冲区。这样可以兼顾大容量和高速度两个方面。</p><p><strong>磁盘管理</strong>：操作系统将磁盘分成若干个块。一个文件的存储可能涉及到多个块。块之间按照类似单链表的方式进行组织。第一个块的位置信息存储在目录文件中。</p><p><strong>内存管理</strong>：操作系统将内存分成若干个页。内存中只维护了一部分页面，如果要使用的页面不在内存中就要使用到页面交换。</p><h2 id="磁盘的结构与特性"><a href="#磁盘的结构与特性" class="headerlink" title="磁盘的结构与特性"></a>磁盘的结构与特性</h2><p>扇区是物理概念，块是逻辑概念。一个块是由多个 <strong>连续的</strong> 扇区实现的。</p><p>物理上优化读写效率的一些考虑：</p><ul><li>降低 IO 次数。</li><li>降低排队等待时间。</li><li>降低寻道或旋转延迟时间，这可以通过将文件在连续的块上进行存储、在同一个柱面的不同磁道上进行存储、在多个磁盘上并行存储实现。</li></ul><p>RAID 技术是用来处理多个磁盘并行存储的技术。主要是要考虑到 <strong>并行处理</strong> 和 <strong>可靠性</strong> 两个方面。</p><h2 id="查询实现的基本思想"><a href="#查询实现的基本思想" class="headerlink" title="查询实现的基本思想"></a>查询实现的基本思想</h2><h3 id="数据存储的映射关系"><a href="#数据存储的映射关系" class="headerlink" title="数据存储的映射关系"></a>数据存储的映射关系</h3><p>在文件系统中，OS 对于每个文件都维护了一个起始块的地址。在 DBMS 中，数据库也为每条记录记录了对应块的地址。如果记录已经在内存中被缓存起来，那么 DBMS 还会维护每条记录对应的内存地址。</p><h3 id="数据存储与查询实现的基本框架"><a href="#数据存储与查询实现的基本框架" class="headerlink" title="数据存储与查询实现的基本框架"></a>数据存储与查询实现的基本框架</h3><p>存储管理器管理磁盘；缓冲区管理器管理内存；内存作为磁盘的缓冲区。数据库将数据、数据格式和数据控制信息三者分开存储，使用索引/文件和记录管理器进行管理，并且分别由外界的 DML、DDL 和 DCL 进行控制。</p><h2 id="记录与表在磁盘上的存储"><a href="#记录与表在磁盘上的存储" class="headerlink" title="记录与表在磁盘上的存储"></a>记录与表在磁盘上的存储</h2><p>逻辑上，数据是按照 <strong>表-记录-属性值</strong> 进行存储的；物理上，数据存储在磁盘块中。</p><p>记录在磁盘上的存储可以使用两种策略：</p><ul><li><strong>定长记录</strong>：为每个记录统一规定长度。</li><li><strong>变长记录</strong>：每条记录的长度不固定，通过分隔符进行分隔，或者使用类似目录的东西存偏置。</li></ul><p>根据一条记录是否能够跨越块进行存储可以分为 <em>跨块存储</em> 和 <em>不跨块存储</em>。在跨块存储时，需要使用指针连接各块。这更加节省磁盘空间，但是读取效率存在问题。</p><p>后面的笔记中 <em>磁盘块</em> 表示的就是 OS 管理文件的单位；<em>数据块</em> 是存放数据的磁盘块；<em>索引块</em> 是存放索引的磁盘块。</p><p>关于一张表占用的磁盘块的分配方法有：</p><ul><li><strong>连续分配</strong>：分配连续的磁盘块以存储这张表（扩展上会有困难）。</li><li><strong>链接分配</strong>：每个块中存放指向下一个块的指针（访问速度上会有问题）。</li><li><strong>按簇分配</strong>：一簇是若干连续的磁盘块。簇之间使用指针连接。</li><li><strong>索引分配</strong>：索引块中存放指向实际数据块的指针。</li></ul><a id="more"></a><h2 id="四种文件组织方法"><a href="#四种文件组织方法" class="headerlink" title="四种文件组织方法"></a>四种文件组织方法</h2><h3 id="数据组织与存取方法"><a href="#数据组织与存取方法" class="headerlink" title="数据组织与存取方法"></a>数据组织与存取方法</h3><p>数据组织要考虑到 <strong>数据更新</strong> 和 <strong>数据检索</strong> 的需求。<em>文件组织</em> 包括如何将数据存储在磁盘上，如和将各部分联系起来。<em>存取方法</em> 指的是对文件存取的方法。</p><h3 id="无序记录文件"><a href="#无序记录文件" class="headerlink" title="无序记录文件"></a>无序记录文件</h3><p>又称堆文件。要插入新数据的时候总是插入到文件的尾部；要删除记录时删除对应位置上的记录，然后移动整个表直到文件中没有中空的记录（称为 <em>数据库重组</em>）。也可以将要删除的记录进行标记，然后定期手动进行数据库存储。</p><p>无序记录的检索效率很低，但是更新效率很高。</p><h3 id="有序记录文件"><a href="#有序记录文件" class="headerlink" title="有序记录文件"></a>有序记录文件</h3><p>又称排序文件。和无需记录文件类似，但是记录是有序的。排序的依据是 <em>排序字段</em>，这个字段一般是主键。有序记录文件的检索效率很高，但是更新效率很低，因为为了保持有序性，需要大规模移动数据。</p><p>一个改进措施是使用 <em>溢出文件</em>，溢出文件中存放的是无序的位于主文件之外的记录。当插入新记录时直接加到溢出文件中，当检索记录时两个文件都要进行检索。定期重组，将溢出文件合并到主文件中去即可。</p><h3 id="散列文件"><a href="#散列文件" class="headerlink" title="散列文件"></a>散列文件</h3><p>将记录散列到不同的桶文件当中。细节略去。</p><h3 id="聚簇文件"><a href="#聚簇文件" class="headerlink" title="聚簇文件"></a>聚簇文件</h3><p><em>聚簇</em> 指的是将具有相似属性值的记录存放在连续的磁盘块中。</p><p><em>多表聚簇</em> 指的是将若干个相互关联的表存储在一个文件中。有时候这么做可以提高多表查询的效率。</p><h2 id="Oracle-数据库物理存储简介"><a href="#Oracle-数据库物理存储简介" class="headerlink" title="Oracle 数据库物理存储简介"></a>Oracle 数据库物理存储简介</h2><blockquote><p>本节无笔记。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（中）：建模与设计 笔记 6 模式分解存在什么问题</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-6-%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-6-%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="模式分解存在什么问题"><a href="#模式分解存在什么问题" class="headerlink" title="模式分解存在什么问题"></a>模式分解存在什么问题</h1><p>当关系模式不满足前面提到的若干范式的时候就应当进行分解。</p><h2 id="模式分解存在的问题"><a href="#模式分解存在的问题" class="headerlink" title="模式分解存在的问题"></a>模式分解存在的问题</h2><h3 id="什么是模式分解"><a href="#什么是模式分解" class="headerlink" title="什么是模式分解"></a>什么是模式分解</h3><p>一个关系模式可以分解为几个更小的关系模式。这几个更小的关系模式的属性集的并应当是原来的关系模式的属性集，并且彼此之间互相不包含。</p><p>给定了一个关系模式的分解 $\displaystyle{\rho}$。对于一个关系 R，将它按照方案分解后得到的多个子关系自然连接起来，会得到另一个关系 $\displaystyle{m_\rho(R)}$，这个关系和 R 不一定相等。它们之间的差异正是要研究的。</p><ul><li>如果 $\displaystyle{m_\rho(R)}$ 中多出来了一些错误的记录，这种分解称为是 <em>有损的</em>。</li><li>如果 $\displaystyle{m_\rho(R)}$ 相对于 R 丢失了某些函数依赖，这种分解不是 <em>保持依赖</em> 的。</li></ul><hr><p>关于 $\displaystyle{m_\rho(R)}$ 的一些性质：</p><ul><li>R 中的记录必然出出现在 $\displaystyle{m_\rho(R)}$ 中。</li><li>$\displaystyle{m_\rho(R) = m_\rho(m_\rho(R))}$</li><li>将 $\displaystyle{m_\rho(R)}$ 投影到各个小关系模式上的结果和将 R 投影上去的结果一致。</li></ul><h2 id="无损连接分解及其检验算法"><a href="#无损连接分解及其检验算法" class="headerlink" title="无损连接分解及其检验算法"></a>无损连接分解及其检验算法</h2><h3 id="什么是无损连接分解"><a href="#什么是无损连接分解" class="headerlink" title="什么是无损连接分解"></a>什么是无损连接分解</h3><p>对于关系模式 R 的任意关系 r，以及给定的分解方案 $\displaystyle{\rho}$，如果  $\displaystyle{m_\rho(r) = r}$，则称分解是无损连接分解。</p><h3 id="无损连接分解的判定"><a href="#无损连接分解的判定" class="headerlink" title="无损连接分解的判定"></a>无损连接分解的判定</h3><p>直接 copy 课件上的算法：</p><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-6-模式分解存在什么问题/DeepinScreenshot_select-area_20190403143255.png"><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-6-模式分解存在什么问题/DeepinScreenshot_select-area_20190403143247.png"><p>例子：</p><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-6-模式分解存在什么问题/DeepinScreenshot_select-area_20190403143316.png"><p>下面这张图中的步骤可以继续进行下去</p><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-6-模式分解存在什么问题/DeepinScreenshot_select-area_20190403143527.png"><p>如果在进行过程中发现某一行全部为 a，则表明分解是无损连接分解；否则是有损连接分解。</p><a id="more"></a><h3 id="简单版无损连接分解的判定"><a href="#简单版无损连接分解的判定" class="headerlink" title="简单版无损连接分解的判定"></a>简单版无损连接分解的判定</h3><p>很多时候只要将一个关系模式拆分成两个关系模式，此时判定会很简单。如果将 R 分解为 $\displaystyle{R_1}$ 和 $\displaystyle{R_2}$，则分解是无损的当且仅当 $\displaystyle{R_1\cap R_2\rightarrow R_1 - R_2\lor R_1\cap R_2\rightarrow R_2 - R_1}$。</p><p>根据这个容易得到如果分解出的两个小关系模式没有任何公共属性的话，必然不是无损连接分解。</p><h3 id="无损连接分解的性质"><a href="#无损连接分解的性质" class="headerlink" title="无损连接分解的性质"></a>无损连接分解的性质</h3><ul><li>将一个关系模式 R 无损连接分解为若干个小关系模式后，小关系模式可以进一步进行无损连接分解。如果用小关系模式无损连接分解的方案替换掉 R 的分解方案中被分解的那个小关系模式，得到的分解方案对于 R 而言还是无损的。</li><li>关系模式 R 的无损连接分解方案 $\displaystyle{\rho}$ 是一个属性集的集合，任何包含这个集合的集合也是 R 的无损连接分解。</li></ul><h2 id="保持依赖分解及其检验算法"><a href="#保持依赖分解及其检验算法" class="headerlink" title="保持依赖分解及其检验算法"></a>保持依赖分解及其检验算法</h2><h3 id="什么是保持依赖分解"><a href="#什么是保持依赖分解" class="headerlink" title="什么是保持依赖分解"></a>什么是保持依赖分解</h3><p>首先定义依赖关系集在关系模式上的投影。对于关系模式 R 上的依赖关系集 F 和 R 的小关系模式 P，如果 F 中的依赖关系 $\displaystyle{X\rightarrow Y}$ 中的 X 和 Y 都在 P 中，则这条依赖关系也在 F 在 P 的投影中。</p><p>对于 R，给定了分解方案后可以得到多个小关系模式。将 F 逐一对这些小关系模式进行投影，会得到多个依赖关系集。将这些依赖关系集并起来，如果得到的依赖关系集和 F 等价，则分解方案是保持依赖的。否则就说明分解方案丢失了某些依赖关系。</p><p>需要注意：</p><ul><li><strong>保持依赖的分解不一定是无损连接分解。</strong></li><li><strong>无损连接分解不一定是保持依赖的分解。</strong></li></ul><h3 id="判定分解是否保持依赖"><a href="#判定分解是否保持依赖" class="headerlink" title="判定分解是否保持依赖"></a>判定分解是否保持依赖</h3><p>直接按照上述定义进行判断即可。在将依赖关系集的投影并起来后，记作 G。现在只要判定 G 是否和 F 等价。为此，就转化为了判定两个依赖关系集是否等价的问题。</p><p>对于 F 中的每个依赖关系 $\displaystyle{X\rightarrow Y}$，求出 X 在 G 下的属性闭包，检查是否包含 Y 即可。但是在求这个属性闭包的时候应当在分解后的小关系模式中进行。课件上的算法表述如下：</p><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-6-模式分解存在什么问题/DeepinScreenshot_select-area_20190403150301.png"><h2 id="模式分解成-BCNF-及第三范式的算法"><a href="#模式分解成-BCNF-及第三范式的算法" class="headerlink" title="模式分解成 BCNF 及第三范式的算法"></a>模式分解成 BCNF 及第三范式的算法</h2><p>BCNF 指的就是 Boyce-Codd 范式。</p><h3 id="将关系模式分解为-BCNF"><a href="#将关系模式分解为-BCNF" class="headerlink" title="将关系模式分解为 BCNF"></a>将关系模式分解为 BCNF</h3><p><strong>注意</strong>：这个算法不能保证分解保持依赖。</p><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-6-模式分解存在什么问题/DeepinScreenshot_select-area_20190403151528.png"><h3 id="将关系模式分解为第三范式"><a href="#将关系模式分解为第三范式" class="headerlink" title="将关系模式分解为第三范式"></a>将关系模式分解为第三范式</h3><p>由于第三范式比 BCNF 更弱，所以这个分解可以同时做到无损连接以及保持依赖。</p><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-6-模式分解存在什么问题/DeepinScreenshot_select-area_20190403151820.png"><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-6-模式分解存在什么问题/DeepinScreenshot_select-area_20190403152723.png"><hr><p>课程上这里还介绍了如何将关系模式分解至满足第四范式，这里略去。</p><h2 id="连接依赖与第五范式"><a href="#连接依赖与第五范式" class="headerlink" title="连接依赖与第五范式"></a>连接依赖与第五范式</h2><h3 id="连接依赖"><a href="#连接依赖" class="headerlink" title="连接依赖"></a>连接依赖</h3><p>连接依赖是形式最一般的依赖。多值依赖是连接依赖的特例。</p><p>看起来很复杂，我不打算弄清楚了。</p><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-6-模式分解存在什么问题/DeepinScreenshot_select-area_20190403154219.png"><h3 id="第五范式"><a href="#第五范式" class="headerlink" title="第五范式"></a>第五范式</h3><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-6-模式分解存在什么问题/DeepinScreenshot_select-area_20190403154258.png"><h2 id="数据库设计需要知道的"><a href="#数据库设计需要知道的" class="headerlink" title="数据库设计需要知道的"></a>数据库设计需要知道的</h2><p>整理一下包含这一讲在内的三讲，内容依次是 <em>数据依赖理论</em>、<em>关系范式理论</em> 和 <em>模式分解理论</em>。</p><p>数据依赖理论用来发现关系中的函数依赖（这一讲主要在玩定义），进而可以判断是否满足某种范式；关系范式理论给出了一些范式（1NF、2NF、3NF、BCNF 等）；模式分解理论给出了在不满足关系范式的情况下如何对关系进行分解，并且保证正确性（无损连接、保持依赖）。</p><p>范式要求的严格程度按照 1NF、2NF、3NF、BCNF、4NF、5NF 递增。但是 4NF 和 5NF 实在是太严格了，一般分解到满足 3NF 或者 BCNF 就可以了。</p><hr><p>分不分解需要进行折中。按照上面这些理论会得到一些小关系模式，它们不会存在冗余、插入和删除异常。但是查询时需要大量的连接操作。</p><p>实际操作中设计的关系模式符合 BCNF 一般就够了（如果有依赖，依赖的属性组必须包含候选键）。</p><hr><p>至此已经结束了逻辑数据库的设计。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（中）：建模与设计 笔记 4 函数依赖及其公理/定理</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-4-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%8F%8A%E5%85%B6%E5%85%AC%E7%90%86-%E5%AE%9A%E7%90%86/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-4-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%8F%8A%E5%85%B6%E5%85%AC%E7%90%86-%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="函数依赖及其公理-定理"><a href="#函数依赖及其公理-定理" class="headerlink" title="函数依赖及其公理/定理"></a>函数依赖及其公理/定理</h1><h2 id="什么是函数依赖"><a href="#什么是函数依赖" class="headerlink" title="什么是函数依赖"></a>什么是函数依赖</h2><h3 id="函数依赖的定义"><a href="#函数依赖的定义" class="headerlink" title="函数依赖的定义"></a>函数依赖的定义</h3><p>对于具有多个属性的关系模式 R，如果对于属性集合中的两个子集 A 和 B 和任意的关系 r，r 中不可能出现两个记录使得 A 中的值相等而 B 中的值不等，则称 A 函数决定 B，B 函数依赖于 A，记作 $\displaystyle{A\rightarrow B}$。</p><p>另一种说法是，如果将 A 和 B 单独拿出来做一个关系，这个关系中 A 可以作为主键。</p><h3 id="函数依赖的性质"><a href="#函数依赖的性质" class="headerlink" title="函数依赖的性质"></a>函数依赖的性质</h3><ul><li>有些函数依赖关系中 $\displaystyle{B\subseteq A}$，这种称为是 <strong>平凡</strong> 的函数依赖，反之为不平凡的函数依赖。</li><li>即使两个属性之间存在函数依赖关系，即 $\displaystyle{A\rightarrow B}$，这不意味着 A 和 B 不能在关系的多条记录中出现。</li><li>两个属性子集可能相互函数依赖。</li><li>如果关系中，A 上没有相同的两个记录出现，那么任意属性子集都函数依赖于 A。</li><li>有基于 <strong>模式</strong> 的函数依赖，要求对所有可能的关系都成立；也有基于 <strong>关系</strong> 的函数依赖，只要求对这一个关系成立即可。</li></ul><h2 id="部分函数依赖与完全函数依赖"><a href="#部分函数依赖与完全函数依赖" class="headerlink" title="部分函数依赖与完全函数依赖"></a>部分函数依赖与完全函数依赖</h2><p>如果 $\displaystyle{A\rightarrow B}$，但是存在 A 的真子集 A&#39; 使得 $\displaystyle{A&#39;\rightarrow B}$，则称 B <strong>部分函数依赖</strong> 于 A。如果不存在这样的子集，此时为 <strong>完全函数依赖</strong>。</p><h2 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h2><p>函数依赖关系具有传递性：$\displaystyle{A\rightarrow B, B\rightarrow C \Rightarrow A\rightarrow C}$。</p><p>如果加上一些更强的限制：$A\rightarrow B$ 和 $B\rightarrow C$ 都是非平凡的，且 $C\nsubseteq A$，$B\nrightarrow A$，则称 C <strong>传递函数依赖</strong> 于 A。</p><h2 id="函数依赖相关的几个重要概念"><a href="#函数依赖相关的几个重要概念" class="headerlink" title="函数依赖相关的几个重要概念"></a>函数依赖相关的几个重要概念</h2><p>把数据库中的相关概念用函数依赖理论重新定义了一下：</p><ul><li><strong>候选键</strong>：能够 <strong>完全决定</strong> 关系模式中所有属性的属性组称为关系模式上的 <strong>候选键</strong>。</li><li><strong>主键</strong>：对于一个关系模式，可以选取其任意一个候选键作为 <strong>主键</strong>。</li><li><strong>主属性</strong>：包含于任意一个候选键中的属性称为 <strong>主属性</strong>，否则为 <strong>非主属性</strong>。</li><li><strong>超键</strong>：超键和候选键类似，但是移除了完全决定的限制。超键是某个候选键对应属性集的超集。</li><li><strong>外键</strong>：某个属性组不是当前关系模式的候选键，但是是另一个关系模式的候选键，称为当前关系模式的 <strong>外键</strong>。</li></ul><p>其它的一些概念：</p><ul><li><strong>逻辑蕴涵</strong>：设 F 是关系模式 R 上函数依赖关系的集合（不一定是完整的）。对于 R 的两个属性组 A 和 B，如果从 F 中能够推理出 $\displaystyle{A\rightarrow B}$，则称 F 逻辑蕴涵 $\displaystyle{A\rightarrow B}$，记作 $\displaystyle{F\vDash A\rightarrow B}$。</li><li><strong>闭包</strong>：设 F 是关系模式 R 上函数依赖关系的集合（不一定是完整的）。F 逻辑蕴涵的所有函数依赖关系构成的集合称为 F 的闭包。</li></ul><p>可以看到，函数依赖是属性集子集上的一个关系，起码它是传递、自反的。</p><a id="more"></a><h2 id="关于函数依赖的-Armstrong-公理"><a href="#关于函数依赖的-Armstrong-公理" class="headerlink" title="关于函数依赖的 Armstrong 公理"></a>关于函数依赖的 Armstrong 公理</h2><h3 id="Armstrong-公理"><a href="#Armstrong-公理" class="headerlink" title="Armstrong 公理"></a>Armstrong 公理</h3><p>Armstrong 公理一共有三条，可以用来从函数依赖关系集合中发现新的函数依赖关系。</p><p>这一小节和下一小节都使用 X、Y、Z 作为属性组；U 作为属性全集；F 作为某个函数依赖关系的集合。</p><ul><li><strong>自反律</strong>：$\displaystyle{X\subseteq Y\Rightarrow F\vDash Y\rightarrow X}$。</li><li><strong>增广律</strong>：$\displaystyle{X\rightarrow Y\in F\Rightarrow F\vDash XZ \rightarrow YZ}$。</li><li><strong>传递律</strong>：$\displaystyle{X\rightarrow Y\in F\land Y\rightarrow Z\in F\Rightarrow F\vDash X\rightarrow Z}$。</li></ul><h3 id="Armstrong-公理对应的引理"><a href="#Armstrong-公理对应的引理" class="headerlink" title="Armstrong 公理对应的引理"></a>Armstrong 公理对应的引理</h3><p>从上述公理出发可以引出下面四条定理（为了方便就不写 $\displaystyle{\in F}$ 以及 $\displaystyle{F\vDash}$ 了）：</p><ul><li><strong>合并律</strong>：$\displaystyle{X\rightarrow Y\land X\rightarrow Z \Rightarrow X\rightarrow YZ}$。</li><li><strong>伪传递律</strong>：$\displaystyle{X\rightarrow Y\land WY\rightarrow Z\Rightarrow XW\rightarrow Z}$。</li><li><strong>分解律</strong>：$\displaystyle{X\rightarrow Y\land Z\subseteq Y\Rightarrow X\rightarrow Z}$。</li><li><strong>重要引理</strong>：$\displaystyle{X\rightarrow A_1A_2\dots A_n\Leftrightarrow \bigvee_i X\rightarrow A_i}$，其中 $A_i$ 都是属性。</li></ul><p>上述公理和引理都可以通过定义加以证明。</p><h2 id="什么是属性（集）闭包"><a href="#什么是属性（集）闭包" class="headerlink" title="什么是属性（集）闭包"></a>什么是属性（集）闭包</h2><p>设 F 是函数依赖关系的集合，X 是一个属性组。能够从 F 推导出的所有依赖于 X 的属性构成的集合称为 X 关于 F 的属性闭包，记作 $\displaystyle{X^+_F}$。</p><p>换句话说，$\displaystyle{F\vDash X\rightarrow Y \Leftrightarrow Y\subseteq X^+_F}$。</p><h2 id="属性闭包的计算算法与覆盖及其证明"><a href="#属性闭包的计算算法与覆盖及其证明" class="headerlink" title="属性闭包的计算算法与覆盖及其证明"></a>属性闭包的计算算法与覆盖及其证明</h2><p>函数依赖关系的集合称为 <strong>函数依赖集</strong>。</p><h3 id="函数依赖集的等价性"><a href="#函数依赖集的等价性" class="headerlink" title="函数依赖集的等价性"></a>函数依赖集的等价性</h3><p>如果两个函数依赖集的闭包相等，则这两个函数依赖集是 <strong>等价的</strong>。此时称其中一个函数依赖集 <strong>覆盖</strong> 另一个函数依赖集。</p><h3 id="如何计算属性闭包"><a href="#如何计算属性闭包" class="headerlink" title="如何计算属性闭包"></a>如何计算属性闭包</h3><p>可以按照如下循环不断进行，直到序列稳定。假定要求的是 X 在 F 下的属性闭包：</p><script type="math/tex; mode=display">\begin{aligned}X^{(0)} &= X \\X^{(i + 1)} &= \{A | (\exists V)(\exists W)(V\rightarrow W\in F\land V\subseteq X^{(i)}\land A\subseteq W)\} \\X^{(i + 1)} &= X^{(i + 1)} \cup X^{(i)}\end{aligned}</script><p>这样可以求出 $X^+_F$。</p><h2 id="什么是最小覆盖"><a href="#什么是最小覆盖" class="headerlink" title="什么是最小覆盖"></a>什么是最小覆盖</h2><p><strong>一个引理</strong>：对于每个函数依赖集 F，总可以找到一个等价的函数依赖集 F&#39;，使得 F&#39; 中的每个依赖关系 $\displaystyle{X\rightarrow Y}$ 中，Y 只包含一个属性。</p><p>证明和构造根据 Armstrong 公理对应的引理中的“重要引理”即可得出。</p><h3 id="最小覆盖及其构造"><a href="#最小覆盖及其构造" class="headerlink" title="最小覆盖及其构造"></a>最小覆盖及其构造</h3><p>对于一个函数依赖集 F，如果和它等价的函数依赖集 F&#39; 满足下面三个条件，则称为是 F 的最小覆盖（也叫 <strong>最小依赖集</strong>）：</p><ul><li>F&#39; 中的每个依赖关系 $\displaystyle{X\rightarrow Y}$ 中，Y 只包含一个属性。</li><li>从 F&#39; 中去掉任意一个依赖关系后都会导致得到的新函数依赖集和 F&#39; 不等价（这说明其中没有多余的依赖关系）。</li><li>F&#39; 中的任意一个依赖关系 $\displaystyle{X\rightarrow Y}$ 如果被替换为 $\displaystyle{Z\rightarrow Y}$，其中 $\displaystyle{Z\subset X}$，则得到的新函数依赖集和 F&#39; 不等价（这说明每个依赖关系的左部都没有多余的属性）。</li></ul><p>所有的函数依赖集都存在和自己等价的最小依赖集。其构造过程可以通过依次确保上述三个性质来完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（中）：建模与设计 笔记 5 关系模式设计之规范形式</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-5-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%84%E8%8C%83%E5%BD%A2%E5%BC%8F/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-5-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%84%E8%8C%83%E5%BD%A2%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="关系模式设计之规范形式"><a href="#关系模式设计之规范形式" class="headerlink" title="关系模式设计之规范形式"></a>关系模式设计之规范形式</h1><p>下面的范式都是针对 <strong>关系模式</strong> 而言的。就是说你可以通过一张表来判定这张表是否符合某个范式。</p><h2 id="什么是第一范式"><a href="#什么是第一范式" class="headerlink" title="什么是第一范式"></a>什么是第一范式</h2><p>如果关系模式中关系的每个属性都是原子而不可分的，这种关系模式符合 <em>第一范式</em>。</p><p>第一范式不允许复合属性和多值属性。</p><h3 id="不符合第一范式时的处理手段"><a href="#不符合第一范式时的处理手段" class="headerlink" title="不符合第一范式时的处理手段"></a>不符合第一范式时的处理手段</h3><p>第一种办法是转换为符合第一范式的关系模式。</p><ul><li>对于多值属性，可以将该属性和主键一起新建一个关系。</li><li>对于复合属性，要么将其打包在一起得到一个属性，要么将其拆开形成多个属性。</li></ul><p>第二种办法是使用其它数据模型进行处理。</p><h2 id="什么是第二范式"><a href="#什么是第二范式" class="headerlink" title="什么是第二范式"></a>什么是第二范式</h2><p>如果关系模式是符合第一范式的，并且关系中每个 <strong>非主属性</strong> 都 <strong>完全依赖</strong> 于 <strong>候选键</strong>，则该关系模式符合 <em>第二范式</em>。</p><p>解释：候选键要求是最小的，能够决定其它所有属性的属性组。对于唯一确定关系中的一条完整的记录，候选键是必需的；但是唯一确定关系中某个属性对应的一条记录，候选键中则可能有多余的属性。</p><p>举个不满足第二范式的例子，假设关系模式是（学号，姓名，班级，课程，成绩）。根据这个关系中的函数依赖关系，可以将（学号，课程）作为一个候选键。因此姓名是非主属性，但是（姓名）这个属性是部分依赖于（学号，课程）的，实际上只要（学号）就能唯一确定（姓名）了。</p><p>不符合第二范式的关系中存在 <em>非受控冗余</em>。在上面那张表中，需要时刻维护一个学号只对应一个姓名，但是相同的（学号，姓名）二元组在关系中多次出现。</p><h3 id="不符合第二范式时的处理手段"><a href="#不符合第二范式时的处理手段" class="headerlink" title="不符合第二范式时的处理手段"></a>不符合第二范式时的处理手段</h3><p>将这个关系分解为多个小的关系即可。</p><h2 id="什么是第三范式"><a href="#什么是第三范式" class="headerlink" title="什么是第三范式"></a>什么是第三范式</h2><p>如果关系模式是符合第二范式的，并且关系中不存在传递依赖，则该关系模式符合 <em>第三范式</em>。</p><p>关于传递依赖部分，更加严谨的定义是关系模式中 <strong>不存在</strong> 这样的情况：X 是候选键，Y 是属性组，A 是非主属性，$\displaystyle{A\notin X, A\notin Y, Y\nsubseteq X, Y\nrightarrow X}$，使得 $\displaystyle{X\rightarrow Y, Y\rightarrow A}$ 成立。</p><p>一个不满足第三范式的例子：关系模式为（学生学号，系号，系主任）。它符合第二范式。此时（学生学号）是候选键，系主任是一个非主属性。这个关系模式中有传递依赖（学生序号）$\rightarrow$（系号），（系号）$\rightarrow$（系主任），因此不符合第三范式。</p><p>不符合第三范式也会导致出现非受控冗余。</p><h3 id="不满足第三范式时的处理手段"><a href="#不满足第三范式时的处理手段" class="headerlink" title="不满足第三范式时的处理手段"></a>不满足第三范式时的处理手段</h3><p>将关系拆分成多个关系。最极端的方式是只要有个函数依赖就进行拆分，直到最后的关系中每个只有一个函数依赖关系。可以在此基础上进行合并。</p><h3 id="和第二范式的比较"><a href="#和第二范式的比较" class="headerlink" title="和第二范式的比较"></a>和第二范式的比较</h3><p>我感觉第二范式不允许某个属性函数依赖于候选键的真子集，第三范式不允许某个非主属性属性函数依赖于其它的非主属性（此处不严谨）。</p><h2 id="什么是-Boyce-Codd-范式"><a href="#什么是-Boyce-Codd-范式" class="headerlink" title="什么是 Boyce-Codd 范式"></a>什么是 Boyce-Codd 范式</h2><p>如果关系是符合第一范式的，并且对于关系中的任何函数依赖 $\displaystyle{X\rightarrow Y}$，当 $\displaystyle{Y\nsubseteq X}$ 时必有 X 包含某个候选键，则称关系符合 Boyce-Codd 范式。</p><p>Boyce-Codd 范式比第三范式更加严格。如果一个关系不满足第三范式，则必不满足 Boyce—Codd 范式。</p><p>不符合 Boyce-Codd 范式的例子：对于关系模式（城市，街道，邮政编码）来说，候选键是（城市，街道），但是因为（邮政编码）可以唯一确定（城市），这是一个函数依赖，但是被依赖的属性组不包括候选键，因此不符合 Boyce-Codd 范式。</p><h3 id="不满足-Boyce-Codd-范式时的处理手段"><a href="#不满足-Boyce-Codd-范式时的处理手段" class="headerlink" title="不满足 Boyce-Codd 范式时的处理手段"></a>不满足 Boyce-Codd 范式时的处理手段</h3><p>将不包含候选键的函数依赖单独拿出来组成一个关系，将包含候选键的函数依赖组成另一个关系。</p><a id="more"></a><h2 id="什么是多值依赖"><a href="#什么是多值依赖" class="headerlink" title="什么是多值依赖"></a>什么是多值依赖</h2><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><p>设全体属性是 U。设 X 和 Y 是某个关系模式上的两个属性组。对于这个关系模式的任意一个关系 r，如果记录 $\displaystyle{t\in r, s\in r, t[X] = s[X]}$，则一定存在 $\displaystyle{u\in r, v \in r}$ 使得：</p><ul><li>$\displaystyle{u[X] = v[X] = t[X] = s[X]}$</li><li>$\displaystyle{u[Y] = t[Y] \land u[U-X-Y] = s[U - X - Y]}$</li><li>$\displaystyle{v[Y] = s[Y] \land v[U-X-Y] = t[U - X - Y]}$</li></ul><p>都成立，则称 Y <em>多值依赖于</em> X，记作 $\displaystyle{X\rightarrow\rightarrow Y}$。</p><p>直观地看，给定 X 后可能对应多个 Y 值，也有多条记录。但是在这些记录中，可以任意将 Y 属性组的值进行调换，得到的记录依然在关系中。</p><p>函数依赖是多值依赖的特殊情况。</p><p>一些多值依赖的性质：</p><ul><li>如果 $\displaystyle{X\rightarrow\rightarrow Y}$，则 $\displaystyle{X\rightarrow\rightarrow U - X - Y}$</li></ul><h3 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h3><p>符合第一范式的关系模式中，任意一组依赖 $\displaystyle{X\rightarrow\rightarrow Y}$ 中，如果 $\displaystyle{Y\ne\varnothing, Y\nsubseteq X, XY\ne U}$，能够得到 X 一定为超键，则称该关系模式满足 <em>第四范式</em>。</p><p>直观来看，满足第四范式的关系模式中，依赖不能依赖于候选键以外的属性。</p><p>满足第四范式一定满足 Boyce-Codd 范式。在只有函数依赖的情况下，满足 Boyce-Codd 方式便一定满足第四范式。</p><h2 id="关于多值依赖的-Armstrong-公理"><a href="#关于多值依赖的-Armstrong-公理" class="headerlink" title="关于多值依赖的 Armstrong 公理"></a>关于多值依赖的 Armstrong 公理</h2><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-5-关系模式设计之规范形式/DeepinScreenshot_select-area_20190403135328.png"><p>这些公理可以被证明。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（中）：建模与设计 笔记 3 数据库设计过程</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h1><p>数据库设计的过程：</p><ol><li><strong>需求分析</strong></li><li><strong>概念数据库</strong> 设计：得到概念模型，例如 E-R 图</li><li><strong>逻辑数据库</strong> 设计：建立关系模型，得到三层抽象中的外模式</li><li><strong>物理数据库</strong> 设计：依赖于具体的 DBMS 组织物理数据</li></ol><h2 id="如何做需求分析"><a href="#如何做需求分析" class="headerlink" title="如何做需求分析"></a>如何做需求分析</h2><p>需求分析最后要提交 <strong>需求分析报告</strong>。</p><h2 id="如何做概念数据库设计"><a href="#如何做概念数据库设计" class="headerlink" title="如何做概念数据库设计"></a>如何做概念数据库设计</h2><p>概念数据库设计最后要提交 <strong>概念数据库设计报告</strong>。应当清晰地包含：</p><ul><li>实体的发现、划分、定义</li><li>实体属性的发现、划分、定义</li><li>实体联系的发现、划分、定义</li><li>外部视图和概念视图的定义</li></ul><p>并且使用规范的表达方法表达出来（例如 E-R 图）。</p><h2 id="如何做逻辑数据库设计"><a href="#如何做逻辑数据库设计" class="headerlink" title="如何做逻辑数据库设计"></a>如何做逻辑数据库设计</h2><p>逻辑数据库设计最后要提交 <strong>逻辑数据库设计报告</strong>。应当包含数据库的逻辑设计。</p><h3 id="E-R-图向关系模式的转换"><a href="#E-R-图向关系模式的转换" class="headerlink" title="E-R 图向关系模式的转换"></a>E-R 图向关系模式的转换</h3><ul><li>E-R 图的实体转换为关系</li><li>E-R 图的属性转换为属性</li><li>E-R 图的关键字转换为主键</li><li>E-R 图的复合属性应当分解成多个属性或者合并车一个关系</li><li>E-R 图的多值属性应当和主键一起 <strong>形成一个新的关系</strong></li><li>一对一联系，且双方都是部分参与时，可以将联系定义为新的关系，属性为双方的主键</li><li>一对一联系，且一方是全部参与时，可以将另一方（可能是全部参与或者部分参与）作为全部参与的这一方的属性</li><li>多对一联系，将单方参与实体的主键作为多方参与实体的属性</li><li>多对多联系，应当新建一个关系，其属性为双方的主键</li><li>弱实体的主键应当包含依赖的强实体的主键</li><li>分类实体对应的关系应包含一般实体的主键</li><li>如果分类是完全的，则可以不建立一般实体对应的关系</li><li>对于多元联系（一个联系关联多个实体），可以<ul><li>引入新的关系表示这个联系，关系应继承各个实体的主键，将其作为主键</li><li>引入新的关系，并使用自己独立的 ID 作为主键，然后引入关联的各个实体的主键作为普通的属性</li><li>转换为多个二元联系</li></ul></li></ul><a id="more"></a><h2 id="逻辑数据库设计会出现什么问题"><a href="#逻辑数据库设计会出现什么问题" class="headerlink" title="逻辑数据库设计会出现什么问题"></a>逻辑数据库设计会出现什么问题</h2><ul><li>数据库中可能存在冗余。</li><li>在插入数据和删除数据时可能出现异常。</li></ul><p>通过数据库设计理论（包括数据依赖理论、关系范式理论和模式分解理论）可以在一定程度上避免掉上述问题。</p><h2 id="如何做物理数据库设计"><a href="#如何做物理数据库设计" class="headerlink" title="如何做物理数据库设计"></a>如何做物理数据库设计</h2><p>物理数据库设计最后要提交 <strong>物理数据库设计报告</strong>。应当包含：</p><ul><li>DBMS 选型</li><li>数据库的存储结构</li><li>设置触发器</li><li>设置安全性控制</li><li>其它一些设计</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（中）：建模与设计 笔记 1 数据建模：思想与方法（暨数据库设计之抽象与表达方法）</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-1-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%9A%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%EF%BC%88%E6%9A%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%8A%BD%E8%B1%A1%E4%B8%8E%E8%A1%A8%E8%BE%BE%E6%96%B9%E6%B3%95%EF%BC%89/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0-1-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%9A%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%EF%BC%88%E6%9A%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%8A%BD%E8%B1%A1%E4%B8%8E%E8%A1%A8%E8%BE%BE%E6%96%B9%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="数据建模：思想与方法"><a href="#数据建模：思想与方法" class="headerlink" title="数据建模：思想与方法"></a>数据建模：思想与方法</h1><p>来自 <a href="http://www.xuetangx.com/courses/course-v1:HITx+13SC03100710_2x+sp/about" target="_blank" rel="noopener">学堂在线</a>。</p><h2 id="为什么要数据建模与数据库设计"><a href="#为什么要数据建模与数据库设计" class="headerlink" title="为什么要数据建模与数据库设计"></a>为什么要数据建模与数据库设计</h2><p>软件之所以开发失败是很多时候是因为没有充分理解客户的需求。成功的软件开发过程应当能够在交付时超出用户的预期需求。</p><p>对需求的理解分为数据需求的理解和处理规则需求的理解。</p><h2 id="数据模型与概念模型的概念"><a href="#数据模型与概念模型的概念" class="headerlink" title="数据模型与概念模型的概念"></a>数据模型与概念模型的概念</h2><p>可以将整个建模过程中按照抽象层次分成 <strong>现实世界</strong>、<strong>信息世界</strong> 和 <strong>计算机世界</strong>。要处理的问题在现实世界中，对这些问题进行 <strong>数据建模</strong> 可以得到位于信息世界中的 <strong>概念模型</strong>，这些模型一般用 E-R 关系模型或者 O-O 关系模型来描述；随后，经过 <strong>数据库设计</strong> 可以将概念模型转化为计算机世界中的 <strong>数据模型</strong>，这些模型一般用关系、层次或者网状模型来描述。计算机世界中的数据分为逻辑层和物理层，逻辑层就是语义上的关系，而物理层是这些关系的底层实现。</p><p><strong>和三层抽象的对应</strong>：可以将信息世界看做位于外部层次当中，计算机世界看做位于概念层次和内部层次当中。</p><p>建模的过程就是逐渐将对人类友好的表示方式转换为对计算机友好的表示方式。</p><h2 id="关于抽象的八个字"><a href="#关于抽象的八个字" class="headerlink" title="关于抽象的八个字"></a>关于抽象的八个字</h2><ul><li><strong>理解</strong>：正确理解问题。</li><li><strong>区分</strong>：衡量是否理解了问题可以通过看能否区分出问题中不同概念。</li><li><strong>命名</strong>：区分的标志是对不同概念进行了不同命名。</li><li><strong>表达</strong>：用其它人能理解的方式进行表达。</li></ul><h2 id="什么是-E-R-模型"><a href="#什么是-E-R-模型" class="headerlink" title="什么是 E-R 模型"></a>什么是 E-R 模型</h2><p>E-R 模型又称 <strong>实体联系模型</strong>。它的观点是 <strong>世界是由一组称为实体的基本对象和这些对象之间的联系构成的</strong>。</p><p>E-R 模型中的一些概念包括 <strong>实体、属性、联系、关键字</strong>。</p><p>面对一个具体问题时，将 E-R 模型中的那些抽象概念予以具体的语义的过程即为建模。</p><h2 id="实体与实例"><a href="#实体与实例" class="headerlink" title="实体与实例"></a>实体与实例</h2><p><strong>实体</strong> 指的是客观存在的可区分的事物。</p><p>实体的类指的是具有相似特征的个体的集合，实体的实例指的则是具体的个体。这个定义有点类似于 class 和 instance 的区别。注意不同语境下的区分。</p><p>后面统一将实体的类称为 <strong>实体的型</strong>，实例称为 <strong>实体的值</strong>。</p><hr><p>实体使用 <strong>属性</strong> 进行刻画。</p><p>实体具有一组属性，每个不同的实例都应该在这组属性下具有具体的属性值。例如学生实体就可能有生日和姓名属性，而每个学生实例都应该有具体的生日值和姓名值。</p><p>属性中比较特殊的情况是：</p><ul><li><strong>单一属性和复合属性</strong></li><li><strong>单值属性和多值属性</strong></li><li><strong>可空属性和非空属性</strong></li><li><strong>导出属性</strong>：该属性的值只依赖于其它的若干属性</li></ul><p><em>按照第一范式，关系模型中不能有复合属性和多值属性。</em>不过这里不是第一范式。</p><hr><p>每个实体有一个特殊的属性叫做 <strong>关键字</strong>，每个实例的关键字的值不同并且是唯一的，可以和其它实例相互区分。</p><h2 id="联系与联系的元数"><a href="#联系与联系的元数" class="headerlink" title="联系与联系的元数"></a>联系与联系的元数</h2><p>联系指的是不同实体之间的关联关系。联系不一定是二元的，联系的 <strong>元数</strong> 指的就是一个联系会与几种实体相关联。</p><p>一元联系是存在的，因为在此定义下，属于同一实体的不同实例间的联系就是一元的。</p><p>如果一个联系和同一实体的不同实例有关，那么需要用 <strong>角色</strong> 对不同的实例加以区分。例如对家庭关系建模时，“人”是实体，具体的人是一个实例，在表达谁是谁的父亲时就应该引入父亲和儿子两个角色来区分不同的人。</p><h2 id="联系与联系的基数"><a href="#联系与联系的基数" class="headerlink" title="联系与联系的基数"></a>联系与联系的基数</h2><p>实体之间的联系可以分类为一对一、一对多和多对多的。</p><p>联系的 <strong>基数</strong> 指的是实体实例之间联系的数量，即一个实体可以通过这个联系和多少个实体发生关联。这涉及到联系的存储的实现，因此比较重要。一般使用最小有多少个、最大有多少个来进行描述。</p><p>如果实体的每个实例最少要参与一个联系，称为 <strong>完全参与联系</strong>，否则为 <strong>部分参与联系</strong>。</p><h2 id="Chen-方法表达-E-R-模型"><a href="#Chen-方法表达-E-R-模型" class="headerlink" title="Chen 方法表达 E-R 模型"></a>Chen 方法表达 E-R 模型</h2><p>E-R 图的三种表达方法：</p><ul><li>Chen 方法</li><li>Crow&#39;s Foot 方法</li><li>IDEF1X 方法</li></ul><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-1-数据建模：思想与方法（暨数据库设计之抽象与表达方法）/DeepinScreenshot_select-area_20190330180054.png"><p>复合关键字指的是需要多个域才能共同确定一个实体的实例。此外，一个实体可能具有不同的几组关键字。</p><p>如果实体之间存在多种联系，则需要在它们之中画多个菱形，并且每个联系可以具有不同的基数。即使是实体之间只有一种联系，也可能出现表示实体的结点和表示联系的结点之间有多条直线（考虑一元联系）。</p><p>如果存在复合属性，可以以复合属性为结点树状展开属性的层次关系。</p><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-1-数据建模：思想与方法（暨数据库设计之抽象与表达方法）/DeepinScreenshot_select-area_20190330180437.png"><p>关系基数的符号还有一种使用箭头的方案，但是统一性不如这个方案好。</p><hr><p>对于每个实体都应该给出关键字；对于联系可以给出属性，但不一定要给出关键字。</p><h2 id="Chen-方法建模案例-物资管理系统数据建模"><a href="#Chen-方法建模案例-物资管理系统数据建模" class="headerlink" title="Chen 方法建模案例-物资管理系统数据建模"></a>Chen 方法建模案例-物资管理系统数据建模</h2><p>使用 Chen 方法进行建模的步骤：</p><ol><li>理解需求，<strong>寻找实体</strong>；</li><li>使用属性刻画实体（注意不要把一个实体作为另一个实体的属性——应当用联系进行关联）；</li><li>确定每个实体的关键字；</li><li>确定实体之间的联系并命名（以及联系的属性），同时确定联系的基数；</li><li>检查是否覆盖了所有需求。</li></ol><h2 id="Crow-39-s-Foot-方法表达-E-R-模型"><a href="#Crow-39-s-Foot-方法表达-E-R-模型" class="headerlink" title="Crow&#39;s Foot 方法表达 E-R 模型"></a>Crow&#39;s Foot 方法表达 E-R 模型</h2><p>Crow&#39;s Foot 也是一种实体关联模型的表达方法。</p><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-1-数据建模：思想与方法（暨数据库设计之抽象与表达方法）/DeepinScreenshot_select-area_20190330181957.png"><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-1-数据建模：思想与方法（暨数据库设计之抽象与表达方法）/DeepinScreenshot_select-area_20190330182024.png"><img src="/2019/03/01/数据库系统（中）：建模与设计-笔记-1-数据建模：思想与方法（暨数据库设计之抽象与表达方法）/DeepinScreenshot_select-area_20190330182052.png"><h2 id="Crow-39-s-Foot-方法建模案例-物资管理系统数据建模"><a href="#Crow-39-s-Foot-方法建模案例-物资管理系统数据建模" class="headerlink" title="Crow&#39;s Foot 方法建模案例-物资管理系统数据建模"></a>Crow&#39;s Foot 方法建模案例-物资管理系统数据建模</h2><p>使用 Crow&#39;s Foot 方法进行建模时使用的步骤和 Chen 方法类似。</p><h2 id="型与值和三个世界"><a href="#型与值和三个世界" class="headerlink" title="型与值和三个世界"></a>型与值和三个世界</h2><p>抽象就是将真实世界的信息提取出来放到数据世界，然后再将信息提取出来放到计算机世界后进行实现。</p><p>型是值的抽象，在数据库学科中，关于型和值的例子有很多，例如数据模型和模式。对于一个问题，它的型可能是更高级抽象的值。抽象是一种很重要的能力。</p><h2 id="数据模型与两种抽象层次"><a href="#数据模型与两种抽象层次" class="headerlink" title="数据模型与两种抽象层次"></a>数据模型与两种抽象层次</h2><p>— 概念级抽象：将真实世界抽象到信息世界<br>— 实现级抽象：将信息世界抽象到计算机世界</p><h2 id="再看抽象层次"><a href="#再看抽象层次" class="headerlink" title="再看抽象层次"></a>再看抽象层次</h2><p>对实际问题的抽象可以将实际问题抽象为模型。对模型的抽象可以将模型抽象为元模型（比如将物流管理模型、学生管理模型抽象为实体关联模型）。对元模型的抽象可以将元模型抽象为 meta-object facility（这个层次只有概念和概念之间的关系，非常抽象）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（上）：模型与语言 笔记 10 嵌入式 SQL 语言之动态 SQL</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-10-%E5%B5%8C%E5%85%A5%E5%BC%8F-SQL-%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%8A%A8%E6%80%81-SQL/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-10-%E5%B5%8C%E5%85%A5%E5%BC%8F-SQL-%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%8A%A8%E6%80%81-SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式-SQL-语言之动态-SQL"><a href="#嵌入式-SQL-语言之动态-SQL" class="headerlink" title="嵌入式 SQL 语言之动态 SQL"></a>嵌入式 SQL 语言之动态 SQL</h1><blockquote><p>本讲内容已经过时，因此笔记粗略。</p></blockquote><h2 id="动态-SQL-的概念和作用"><a href="#动态-SQL-的概念和作用" class="headerlink" title="动态 SQL 的概念和作用"></a>动态 SQL 的概念和作用</h2><p>可以将静态 SQL 想成是硬编码在程序中的逻辑，动态 SQL 想成是很多语言中的 <code>eval</code> 对应的功能。</p><p>动态 SQL 对应的查询可以在运行时才被确定下来，这在实现让用户指定查询规则时很有用。</p><h2 id="动态-SQL-构造示例之一"><a href="#动态-SQL-构造示例之一" class="headerlink" title="动态 SQL 构造示例之一"></a>动态 SQL 构造示例之一</h2><blockquote><p>本节无笔记。</p></blockquote><p>简单来说，宿主语言可以把一个字符串当做 SQL 语句进行执行。这一节的例子通过根据输入，手动拼接这么一个字符串完成了查询。</p><h2 id="动态-SQL-构造示例之二"><a href="#动态-SQL-构造示例之二" class="headerlink" title="动态 SQL 构造示例之二"></a>动态 SQL 构造示例之二</h2><blockquote><p>本节无笔记。</p></blockquote><h2 id="动态-SQL-的两种执行方式"><a href="#动态-SQL-的两种执行方式" class="headerlink" title="动态 SQL 的两种执行方式"></a>动态 SQL 的两种执行方式</h2><p>动态 SQL 可以在运行时就地编译，然后立即执行。编译时，这条 SQL 语句应当是含义明确的、完整的。</p><p>另一种方式是提供带有参数的 SQL 语句，然后对这个语句进行编译。编译出来的语句还需要填写参数才具有完整的语义。在运行时，只需要为这些语句提供参数即可，而不用重新编译整条语句。</p><h2 id="数据字典及其作用"><a href="#数据字典及其作用" class="headerlink" title="数据字典及其作用"></a>数据字典及其作用</h2><p>数据字典是数据库的元数据。例如有哪些表、每个表有哪些域等。数据字典又叫系统目录、系统视图等。DBA 可以检索 DBMS 暴露出的部分元数据。</p><p>数据字典也是以关系的形式存储的。</p><hr><p>一般有一个存放了所有表的元信息的表。</p><a id="more"></a><h2 id="SQLDA-与数据字典的应用"><a href="#SQLDA-与数据字典的应用" class="headerlink" title="SQLDA 与数据字典的应用"></a>SQLDA 与数据字典的应用</h2><p>通过访问数据字典，可以写出语义上更加动态的嵌入式 SQL 语句。例如可以写出一个应用软件，它可以连接到任意一个数据库然后让用户进行一些操作（像 JetBrains 的 DataGrip 那样的）。</p><h2 id="什么是-ODBC"><a href="#什么是-ODBC" class="headerlink" title="什么是 ODBC"></a>什么是 ODBC</h2><p>ODBC 是不同语言的应用程序和不同数据库服务器之间通信的标准。ODBC 规定了一些接口，只要对应的 DBMS 实现了这些接口，DBAP 就可以使用这些接口和数据库进行交互。ODBC 会使用对应的 DBMS 的 driver 来完成实际的对数据库的交互。</p><h2 id="什么是-JDBC"><a href="#什么是-JDBC" class="headerlink" title="什么是 JDBC"></a>什么是 JDBC</h2><p>JDBC 是 Java 版的 ODBC。</p><h2 id="ODBC-JDBC-嵌入式之比较"><a href="#ODBC-JDBC-嵌入式之比较" class="headerlink" title="ODBC JDBC 嵌入式之比较"></a>ODBC JDBC 嵌入式之比较</h2><ul><li><p>嵌入式 SQL 是按照语句为单位进行查询操作。</p></li><li><p>ODBC 按照函数为单位进行查询操作。</p></li><li><p>JDBC 按照对象为单位进行查询操作。</p></li></ul><p>不过三者在流程上是类似的，都是声明一个可以用来迭代的对象，然后迭代查询结果，最后关闭迭代器。</p><hr><p>使用 ODBC、JDBC 时相当于对数据库再封装了一层。原来是 DBAP 直接和 DBMS 进行交互，现在是它们和 ODBC、JDBC 进行交互，后者再和 DBMS 进行交互。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（上）：模型与语言 笔记 9 嵌入式 SQL 语言之基本技巧</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-9-%E5%B5%8C%E5%85%A5%E5%BC%8F-SQL-%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-9-%E5%B5%8C%E5%85%A5%E5%BC%8F-SQL-%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式-SQL-语言之基本技巧"><a href="#嵌入式-SQL-语言之基本技巧" class="headerlink" title="嵌入式 SQL 语言之基本技巧"></a>嵌入式 SQL 语言之基本技巧</h1><blockquote><p>本讲内容已经过时，因此笔记粗略。</p></blockquote><h2 id="什么是嵌入式-SQL-语言"><a href="#什么是嵌入式-SQL-语言" class="headerlink" title="什么是嵌入式 SQL 语言"></a>什么是嵌入式 SQL 语言</h2><p>普通的 SQL 称为交互式 SQL，存在学习成本，并且过程性差。可以将交互式 SQL 嵌入到一些高级语言（称为宿主语言）中完成更加复杂的功能，这就是嵌入式 SQL。</p><p>这样做会引入很多问题，例如高级语言如何和数据库进行交互等。</p><h2 id="程序与数据库连接"><a href="#程序与数据库连接" class="headerlink" title="程序与数据库连接"></a>程序与数据库连接</h2><p>要解决的问题：</p><ul><li>宿主语言如何和数据库连接和断开。</li><li>宿主语言如何提交和撤销操作。</li><li>宿主语言如何将变量传递给 SQL（可以想成 SQL 现在是一个需要被插值的模板字符串，插值来源是数组语言的变量）。</li></ul><h2 id="为什么需要提交和撤销"><a href="#为什么需要提交和撤销" class="headerlink" title="为什么需要提交和撤销"></a>为什么需要提交和撤销</h2><p><strong>事务</strong> 在 DBMS 使用者视角上指的是多条 SQL 语句的一次执行；在 DBMS 实现者视角上指的是一组需要要么全部执行、要么全部不执行的 SQL 语句。</p><p>事务的特性：</p><ul><li><strong>原子性</strong>：要么全部执行，要么全部不执行。</li><li><strong>一致性</strong>：事务的操作状态是正确的，一致的。</li><li><strong>隔离性</strong>：多个事务的执行结果和其执行顺序无关，即使它们是并发执行的。</li><li><strong>持久性</strong>：已提交事务的影响是持久的，被撤销事务的影响是可恢复的。</li></ul><p><strong>事务处理是 DBMS 的核心技术。</strong></p><a id="more"></a><h2 id="嵌入式-SQL-程序的一个示例"><a href="#嵌入式-SQL-程序的一个示例" class="headerlink" title="嵌入式 SQL 程序的一个示例"></a>嵌入式 SQL 程序的一个示例</h2><blockquote><p>本节无笔记。</p></blockquote><h2 id="为什么需要游标"><a href="#为什么需要游标" class="headerlink" title="为什么需要游标"></a>为什么需要游标</h2><p>要解决的问题：</p><ul><li>SQL 语句如何执行。</li><li>如何将 SQL 检索到的结果返回给宿主语言。</li><li>如何将 SQL  语句中的常量改为变量。</li></ul><p>如果检索结果只有一行，那么可以直接送到宿主语言的变量中。如果检索结果有多行则需要使用 <strong>游标</strong> 来对检索结果进行逐行的访问。<strong>游标实际上就是检索结果的迭代器，每次读取一行。</strong></p><h2 id="游标应用示例"><a href="#游标应用示例" class="headerlink" title="游标应用示例"></a>游标应用示例</h2><blockquote><p>本节无笔记。</p></blockquote><h2 id="可滚动游标"><a href="#可滚动游标" class="headerlink" title="可滚动游标"></a>可滚动游标</h2><p>标准的游标是单向的，只能从检索结果开始读取到结束。一条已经遍历过的数据如果希望再次访问只能重新打开一个游标。</p><p>通过引入可滚动游标可以让游标双向移动，并可以跳转到第一条记录或最后一条记录，但是很多 DBMS 没有支持这一特性。</p><h2 id="利用游标进行数据库增删改"><a href="#利用游标进行数据库增删改" class="headerlink" title="利用游标进行数据库增删改"></a>利用游标进行数据库增删改</h2><p>对于记录的删除和更新，有两种方式。一种是和交互式 SQL 类似的 <strong>查找删除/更新</strong>，此时嵌入式 SQL 的写法和交互式 SQL 写法很类似；另一种是 <strong>定位删除/更新</strong>，此时删除或者更新的是当前游标对应的那条记录。</p><p>对于记录的增加则只能像交互式 SQL 那样做。</p><h2 id="利用游标编写的一个程序"><a href="#利用游标编写的一个程序" class="headerlink" title="利用游标编写的一个程序"></a>利用游标编写的一个程序</h2><blockquote><p>本节无笔记。</p></blockquote><h2 id="异常状态捕获机制"><a href="#异常状态捕获机制" class="headerlink" title="异常状态捕获机制"></a>异常状态捕获机制</h2><p>这节要解决的问题是宿主语言如何知道 SQL 执行过程是否发生错误。</p><p>通过使用类似异常捕获的机制即可，可以在 SQL 执行过程中出现各种错误的时候设置各种回调函数来进行处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（上）：模型与语言 笔记 8 SQL 语言与数据库完整性和安全性</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-8-SQL-%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-8-SQL-%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-语言与数据库完整性和安全性"><a href="#SQL-语言与数据库完整性和安全性" class="headerlink" title="SQL 语言与数据库完整性和安全性"></a>SQL 语言与数据库完整性和安全性</h1><p>数据库是概念，SQL 是实现。二者不是同一个抽象层上的东西，看的时候注意这一点。</p><h2 id="数据库完整性概念及完整性约束规则"><a href="#数据库完整性概念及完整性约束规则" class="headerlink" title="数据库完整性概念及完整性约束规则"></a>数据库完整性概念及完整性约束规则</h2><h3 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h3><p>DBMS 应当保证数据库始终具有某种性质，这种性质一般和正确性、有效性和一致性有关。</p><p>完整性涉及到语义上的完整性和数据库实现上的完整性。</p><h3 id="为什么会引发完整性问题"><a href="#为什么会引发完整性问题" class="headerlink" title="为什么会引发完整性问题"></a>为什么会引发完整性问题</h3><p><strong>语义相关</strong>：错误数据输入、操作失误</p><p><strong>实现相关</strong>：程序处理失误</p><p>DBMS 应当防止这些错误导致的语义不合理现象。</p><h3 id="如何保证完整性"><a href="#如何保证完整性" class="headerlink" title="如何保证完整性"></a>如何保证完整性</h3><p>DBA 会通过 DDL 定义语义完整性。用户修改数据时，DBMS 仅在通过检查后允许修改。</p><p>完整性约束条件是四元组 $(O, P, A, R)$，分量含义分别为数据集合（约束对象）、谓词条件（什么样的约束）、触发条件（何时进行检查）和响应动作（不满足时触发的动作）。</p><h2 id="数据库完整性分类"><a href="#数据库完整性分类" class="headerlink" title="数据库完整性分类"></a>数据库完整性分类</h2><h3 id="按约束对象分类"><a href="#按约束对象分类" class="headerlink" title="按约束对象分类"></a>按约束对象分类</h3><ul><li><strong>域完整性</strong>：施加于某一列的约束。只给了一列数据也能判定某记录是否符合条件。例如要求某列的值必须大于 10。</li><li><strong>关系完整性</strong>：施加于记录上的语速。例如要求某记录的某两个域的和必须大于 10。</li></ul><h3 id="按约束来源分类"><a href="#按约束来源分类" class="headerlink" title="按约束来源分类"></a>按约束来源分类</h3><ul><li><strong>结构约束</strong>：来自模型的约束，例如主键不为空、外键必须是候选键等。</li><li><strong>内容约束</strong>：用户定义的语义约束。</li></ul><h3 id="按约束状态"><a href="#按约束状态" class="headerlink" title="按约束状态"></a>按约束状态</h3><ul><li><strong>静态约束</strong>：数据在任意时刻都应该满足的约束。</li><li><strong>动态约束</strong>：数据在进行修改时应当满足的约束。例如约束某一列的值只能升不能降。</li></ul><a id="more"></a><h2 id="SQL-表完整性与列完整性"><a href="#SQL-表完整性与列完整性" class="headerlink" title="SQL 表完整性与列完整性"></a>SQL 表完整性与列完整性</h2><p>SQL 使用 schema 进行静态约束，使用触发器进行动态约束。</p><p>定义 schema 时可以对列进行约束，也可以对表进行约束。</p><ul><li>对列可以进行的约束有 <code>NOT NULL</code>、<code>UNIQUE</code>、<code>PRIMARY KEY</code>、<code>CHECK(condition)</code>、<code>REFERENCES tableName [(colName)]</code> 和 <code>ON DELETE &lt;CASCADE | SET NULL&gt;</code>。可以使用 <code>CONSTRAINT constraintName</code> 为约束命名，方便日后撤销。其中 <code>REFERENCES</code> 用来设置外键。</li><li>对表进行的约束实际上是对多列共同进行约束，可以使用的约束有 <code>UNIQUE</code>（多列构成候选键）、<code>PRIMARY KEY</code>（多列构成主键）、<code>CHECK</code>（多列共同满足条件）、<code>FOREIGN KEY (colName1, colName2, ...) REFERENCES tableName(colName1, colName2, ...)</code> 和 <code>ON DELETE CASCADE</code>。可以使用 <code>CONSTRAINT constraintName</code> 为约束命名，方便日后撤销。</li></ul><p>列约束是表约束的特例。上述 <code>CHECK</code> 后的条件和 <code>WHERE</code> 子句后的条件格式相同，可以写出复杂的条件。</p><hr><p>在修改表时可以使用 <code>ALTER TABLE</code>。可以追加列、删除列、修改列定义。如果想要追加列约束可以通过修改列定义来完成。</p><p>使用 <code>ADD CONSTRAINT constraintName</code> 来增加约束、<code>DROP CONSTRAINT constraintName</code> 来删除约束、<code>DROP PRIMARY KEY</code> 删除主键。</p><h2 id="SQL-的断言及其应用"><a href="#SQL-的断言及其应用" class="headerlink" title="SQL 的断言及其应用"></a>SQL 的断言及其应用</h2><p>可以在 SQL 中增加断言让其在每次更新数据的时候都进行检查。断言会影响数据库效率。</p><p>语法为 <code>CREATE ASSERTION assertionName CHECK condition</code>。</p><h2 id="SQL-的触发器的概念"><a href="#SQL-的触发器的概念" class="headerlink" title="SQL 的触发器的概念"></a>SQL 的触发器的概念</h2><p>在修改数据时可以触发 SQL 的某些动作，实现动态约束。触发器的语法为（瞎写的）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> triggerName &lt;<span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span>&gt;</span><br><span class="line">&lt;<span class="keyword">INSERT</span> | <span class="keyword">DELETE</span> | <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> colName1, colName2 ...]</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> tableName [<span class="keyword">REFERENCING</span> &lt;<span class="keyword">OLD</span> | <span class="keyword">NEW</span>&gt; &lt;<span class="keyword">ROW</span> | <span class="keyword">TABLE</span>&gt; <span class="keyword">as</span> fooName]</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> &lt;<span class="keyword">ROW</span> | <span class="keyword">STATEMENT</span>&gt;</span><br><span class="line">[<span class="keyword">WHEN</span> condition]</span><br><span class="line">&lt;<span class="keyword">statement</span> | <span class="keyword">BEGIN</span> ATOMIC statement1; statement2 ...; <span class="keyword">END</span>&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>FOR EACH ROW</code> 对更新的每一行进行相应动作（此时 <code>OLD ROW</code> 指代了更新前的行），<code>FOR EACH STATEMENT</code> 对表进行检查。</p><p>除了实现动态约束外，触发器还可以实现表中某些逻辑上的关系的满足。</p><h2 id="触发器应用示例之一"><a href="#触发器应用示例之一" class="headerlink" title="触发器应用示例之一"></a>触发器应用示例之一</h2><blockquote><p>本节无笔记。</p></blockquote><h2 id="触发器应用示例之二"><a href="#触发器应用示例之二" class="headerlink" title="触发器应用示例之二"></a>触发器应用示例之二</h2><blockquote><p>本节无笔记。</p></blockquote><h2 id="数据库安全性的概念"><a href="#数据库安全性的概念" class="headerlink" title="数据库安全性的概念"></a>数据库安全性的概念</h2><p><strong>前面几节记录的是数据库的 <em>完整性</em>，下面几节记录的是 <em>安全性</em>。</strong></p><p>数据库的安全性体现为防止未授权用户对数据库的访问与破坏。安全性的分类有</p><ul><li><strong>自主安全性</strong>：权限可以在用户之间传递，用户自主管理安全性。</li><li><strong>强制安全性</strong>：对数据和用户进行分类，不同用户能够访问不同数据。</li><li>推断控制机制：防止用户通过多次查询结果推断出某些个体的信息。</li><li>数据加密存储。</li></ul><p>DBA 是 DBMS 中的超级用户，可以创建其它用户并授权。</p><h2 id="自主安全性机制"><a href="#自主安全性机制" class="headerlink" title="自主安全性机制"></a>自主安全性机制</h2><p><strong>自主安全性是通常的安全性实现。</strong></p><p>DBA 会对用户授权，而用户也可以将自己的权限给别人。</p><p>权限是一个四元组，其组成：</p><ul><li><strong>请求主体</strong>：谁拥有这个权限。</li><li><strong>访问对象</strong>：可以是数据库、表、记录、域。</li><li><strong>权利</strong>：创建、插入、删除、修改、查询。</li><li><strong>谓词</strong>：拥有权利需要满足的条件（比如只能访问某个域大于 100 的记录）。</li></ul><p>若干条上述权限的记录形成了一张访问规则表（逻辑上的，实现上不一定存储了这张表），DBMS 根据这张表进行安全性检查。</p><h2 id="两种自主安全性控制"><a href="#两种自主安全性控制" class="headerlink" title="两种自主安全性控制"></a>两种自主安全性控制</h2><h3 id="存储矩阵"><a href="#存储矩阵" class="headerlink" title="存储矩阵"></a>存储矩阵</h3><p>将每个主体作为一行，可能的访问对象作为一列，使用矩阵进行存储。矩阵元素为该主体对访问对象的权利。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>通过在表上创建视图来进行安全性控制。创建时视图可以指定条件，因此可以做得比较复杂。此外还能反映权限中的谓词。</p><p>让不同主体能够访问不同的视图即可。</p><hr><p>二者不是对立的，可以同时使用。建立了视图后，视图也会作为一个访问对象。视图可以用来实现权限中的谓词，这点比较重要。</p><h2 id="SQL-安全性控制"><a href="#SQL-安全性控制" class="headerlink" title="SQL 安全性控制"></a>SQL 安全性控制</h2><h3 id="权限级别"><a href="#权限级别" class="headerlink" title="权限级别"></a>权限级别</h3><p>数据库安全性属于 DCL 范畴。</p><p>权限被分为三个层次：</p><ul><li><strong>读权限</strong>：只能读不能更新。</li><li><strong>对记录的更新</strong>：可以插入、修改、删除记录。</li><li><strong>对关系的更新</strong>：可以创建、修改、删除关系。这是对记录的集合的操作</li></ul><p>一般来说高层次会包含低层次的权限。例如一个用户创建了某个关系后就可以向关系中插入记录。</p><h3 id="授权命令"><a href="#授权命令" class="headerlink" title="授权命令"></a>授权命令</h3><p>用户可以给其它用户授权。语法为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;<span class="keyword">ALL</span> | privilege1, privilege2 ...&gt; <span class="keyword">ON</span> tableOrViewName</span><br><span class="line"><span class="keyword">TO</span> &lt;<span class="keyword">PUBLIC</span> | user1, user2 ...&gt; [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure><p>其中 <code>privilege</code> 可选 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>ALL PRIVILEDGES</code>；<code>WITH GRANT OPTION</code> 指的是允许被授权者传播权限。</p><p>收回授权使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;<span class="keyword">ALL</span> | privilege1, privilege2 ...&gt; <span class="keyword">ON</span> tableOrViewName <span class="keyword">FROM</span> &lt;<span class="keyword">PUBLIC</span> | user1, user2 ...&gt;</span><br></pre></td></tr></table></figure><h2 id="自主安全性控制的问题"><a href="#自主安全性控制的问题" class="headerlink" title="自主安全性控制的问题"></a>自主安全性控制的问题</h2><h3 id="授权传播范围"><a href="#授权传播范围" class="headerlink" title="授权传播范围"></a>授权传播范围</h3><p>有些 SQL 实现控制了权限传播时的范围。权限的传播会构成一张以用户为结点的有向图，每次授权都会增加一条从授权者指向被授权者的边，范围指的是图上任意一条路径的长度（授权深度）和任意一个结点的出度（授权广度）。通过限制这两个量才能保证被授权者数量被控制在一个可控的范围内。</p><h3 id="被多个人授权"><a href="#被多个人授权" class="headerlink" title="被多个人授权"></a>被多个人授权</h3><p>如果一个用户被多个用户授予了相同权限，当其中一个用户收回权限时，该用户仍然具有相应权限，因为其他人也授予了他这个权限。</p><p>除非所有人都要将对应的权限收回，否则这个用户就一直有这个权限。</p><h2 id="强制安全性机制"><a href="#强制安全性机制" class="headerlink" title="强制安全性机制"></a>强制安全性机制</h2><p>强制安全性通过将数据分级，同时将用户分级来强制性地实现不同用户对不同数据的访问。</p><p>访问规则：</p><ul><li>用户不能读取分级比自己高的数据。</li><li>用户不能修改分级比自己低的数据。</li></ul><p>其中第二条是因为，一旦用户修改了这些数据，这些数据的安全性级别就会上升，导致原来可以读取这些数据的用户现在不能读取了，这是我们不希望发生的。</p><hr><p>在采用这种机制时，定义 schema 时就要指定关系、属性和元组的分级。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（上）：模型与语言 笔记 7 SQL 语言之复杂查询与视图</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-7-SQL-%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-7-SQL-%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-语言之复杂查询与视图"><a href="#SQL-语言之复杂查询与视图" class="headerlink" title="SQL 语言之复杂查询与视图"></a>SQL 语言之复杂查询与视图</h1><h2 id="In-子查询"><a href="#In-子查询" class="headerlink" title="In 子查询"></a>In 子查询</h2><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询存在是为了应对查询中和集合有关的查询，例如元素是否属于某集合、集合是否为空等。</p><p>子查询返回的是一个集合。</p><h3 id="In-子查询-1"><a href="#In-子查询-1" class="headerlink" title="In 子查询"></a>In 子查询</h3><p>判断一个集合是否在给定子查询中：<code>$$Expression [not] in $$SubQuery</code>。一般在 <code>where</code> 子句中出现。</p><p>在有子查询的情况下，查询可以分为外层查询和内层查询。如果内层查询不依赖外层查询（不使用外层查询的信息），称为 <strong>非相关子查询</strong>，否则是相关的。<strong>相关子查询中，信息只能从外层向内层传递，不能反过来。</strong></p><h2 id="Theta-Some-All-子查询"><a href="#Theta-Some-All-子查询" class="headerlink" title="Theta Some/All 子查询"></a>Theta Some/All 子查询</h2><p>这个查询主要判断集合之间的包含关系。假设 θ 表示一个二元比较关系，例如等于、大于、小于等于等。那么有两种 theta 查询：<code>$$Expression θ some $$SubQuery</code> 和 <code>$$Expression θ all $$SubQuery</code>。前者在子查询中某个值满足 θ 关系时就能成立，后者需要在子查询的所有值都满足关系的时候才成立。一般在 <code>where</code> 子句中出现。</p><ul><li><code>$$Expression in $$SubQuery</code> 可以看做是 <code>$$Expression = some $$SubQuery</code>。</li><li><code>$$Expression not in $$SubQuery</code> 可以看作是 <code>$$Expression &lt;&gt; all $$SubQuery</code>。</li></ul><a id="more"></a><h2 id="Exists-子查询"><a href="#Exists-子查询" class="headerlink" title="Exists 子查询"></a>Exists 子查询</h2><p>这个查询主要判断集合是否为空。语法是 <code>[not] exists $$SubQuery</code>。它一般出现在 <code>where</code> 中。一般的使用方式是使用相关子查询，这样子查询就会包括外层的信息，于是 exists 查询就有用了。例如下面例子中的 <code>S#</code> 来自外层查询：</p><img src="/2019/03/01/数据库系统（上）：模型与语言-笔记-7-SQL-语言之复杂查询与视图/DeepinScreenshot_select-area_20190314145407.png"><p>有时候将一个查询转换为等价的两个“不存在”的查询可能是有用的。</p><h2 id="结果计算与聚集计算"><a href="#结果计算与聚集计算" class="headerlink" title="结果计算与聚集计算"></a>结果计算与聚集计算</h2><p>在 <code>select</code> 后面不一定跟一个属性名，也可以跟一个表达式或者聚集函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> $$Expression <span class="keyword">from</span> ... <span class="keyword">where</span> ...;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> $$AggregateFunction <span class="keyword">from</span> ... <span class="keyword">where</span> ...;</span><br></pre></td></tr></table></figure><p>SQL 标准的聚集函数包括 <code>count</code>、<code>sum</code>、<code>avg</code>、<code>max</code>、<code>min</code>。</p><h2 id="分组聚集计算与分组过滤"><a href="#分组聚集计算与分组过滤" class="headerlink" title="分组聚集计算与分组过滤"></a>分组聚集计算与分组过滤</h2><p>分组查询用于将所有记录划分为多个集合，对每个集合单独进行计算或者聚集。分组过滤会去掉其中不希望出现的分组。</p><p>分组聚集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ... <span class="keyword">group</span> <span class="keyword">by</span> $$GroupingCondition;</span><br></pre></td></tr></table></figure><p>如果需要过滤掉分组是不能使用 <code>where</code> 子句的，它只能对单条记录过滤，应该使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ... <span class="keyword">group</span> <span class="keyword">by</span> $$GroupingCondition <span class="keyword">having</span> $$FilterCondition;</span><br></pre></td></tr></table></figure><p>其中 <code>$$FilterCondition</code> 中可以使用聚集函数。</p><h2 id="用-SQL-表达并交差操作"><a href="#用-SQL-表达并交差操作" class="headerlink" title="用 SQL 表达并交差操作"></a>用 SQL 表达并交差操作</h2><p>子查询之间可以进行集合运算：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$SubQuery1 &lt;union | intersect | except&gt; [all] $$SubQuery2</span><br></pre></td></tr></table></figure><p>分别进行并、交、差运算。如果不加 <code>all</code> 的话，会去掉重复记录。如果加上 <code>all</code> 的话重复记录会被保留。</p><h2 id="用-SQL-处理空值"><a href="#用-SQL-处理空值" class="headerlink" title="用 SQL 处理空值"></a>用 SQL 处理空值</h2><p>在有空值的情况下会影响到聚集函数的语义。</p><p> SQL 中可以使用 <code>is [not] null</code> 来判定一个值是否为空。</p><p>空值的处理：</p><ul><li>空值不满足任何查找条件，除了 <code>is null</code>。</li><li>参与算术表达式时表达式结果为空值。</li><li>参与比较运算时总是返回 false。</li><li>除了 <code>count(*)</code> 之外的所有聚集函数都忽略空值所在记录。</li></ul><h2 id="用-SQL-表达连接与外连接操作"><a href="#用-SQL-表达连接与外连接操作" class="headerlink" title="用 SQL 表达连接与外连接操作"></a>用 SQL 表达连接与外连接操作</h2><p>连接类型有四种：内连接、左外连接、右外连接和全外连接，分别是 <code>inner join</code>、<code>left outer join</code>、<code>right outer join</code>、<code>full outer join</code>。</p><p>连接方式有三种：自动的自然连接、带条件的连接和指定属性的自然连接。自动自然连接就是数学含义上的自然连接，所有属性名相同并且值相同就会发生连接；待条件的连接需要给出两个关系中不同记录需要满足什么条件才会连接；指定属性的自然连接也是自然连接，但是属性不是所有属性，而是用户指定的。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> $Table1 <span class="keyword">natural</span> JOIN_TYPE $Table2 <span class="keyword">where</span> ...;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> $Table1 JOIN_TYPE $Table2 <span class="keyword">on</span> $$Condition <span class="keyword">where</span> ...;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> $Table1 JOIN_TYPE $Table2 <span class="keyword">using</span> ($AttributeName1, ...) <span class="keyword">where</span> ...;</span><br></pre></td></tr></table></figure><h2 id="SQL-SELECT-小结"><a href="#SQL-SELECT-小结" class="headerlink" title="SQL-SELECT 小结"></a>SQL-SELECT 小结</h2><p>基本 SQL 中子查询只能出现在 <code>where</code> 子句中。而面向对象的数据库查询语言 OQL 则可以允许子查询出现在任何可以使用聚集函数的地方。OQL 中，<code>select</code>、<code>from</code> 后面也可以加子查询。</p><h2 id="SQL-视图"><a href="#SQL-视图" class="headerlink" title="SQL 视图"></a>SQL 视图</h2><p>上面写的所有东西在三层模型中都属于中间的逻辑层次，而不是用户层次。</p><p>SQL 使用 <strong>视图</strong> 包括了用户层次以及 C-E 映射。视图没有直接被存储。</p><h3 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> $ViewName ($ColName1, ...) <span class="keyword">as</span> $$SubQuery [$$CheckOption];</span><br></pre></td></tr></table></figure><p>其中 <code>$$CheckOption</code> 表示用户对视图进行修改时应当满足的条件。</p><h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><p>当视图定义好后，可以像一张表一样使用这个视图。对视图的查询在实现上被转换为了对表的查询。</p><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图没有保存数据，因此更新视图比较复杂。不是所有的列都能更新，需按照以下规则：</p><img src="/2019/03/01/数据库系统（上）：模型与语言-笔记-7-SQL-语言之复杂查询与视图/DeepinScreenshot_select-area_20190314154254.png"><h3 id="撤销视图"><a href="#撤销视图" class="headerlink" title="撤销视图"></a>撤销视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> $ViewName;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（上）：模型与语言 笔记 6 SQL 语言之概述</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-6-SQL-%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-6-SQL-%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-语言之概述"><a href="#SQL-语言之概述" class="headerlink" title="SQL 语言之概述"></a>SQL 语言之概述</h1><blockquote><p>笔记做到一半，还是只记录自己觉得有必要记录的吧。</p></blockquote><h2 id="SQL-语言概述"><a href="#SQL-语言概述" class="headerlink" title="SQL 语言概述"></a>SQL 语言概述</h2><p>SQL 是集 DDL、DML 和 DCL 与一体的数据库语言。通过 SQL 标准，不同厂商开发的数据库共享一套语言标准。</p><p>SQL 语句主要由以下引导词引导：</p><ul><li>DDL：<code>create</code>、<code>alter</code>、<code>drop</code></li><li>DML：<code>insert</code>、<code>delete</code>、<code>update</code>、<code>select</code></li><li>DCL：<code>grant</code>、<code>revoke</code></li></ul><h2 id="利用-SQL-建立数据库"><a href="#利用-SQL-建立数据库" class="headerlink" title="利用 SQL 建立数据库"></a>利用 SQL 建立数据库</h2><h3 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h3><p>后面使用 <code>$</code> 开头的变量在实际使用时进行替换。<code>[...]</code> 表示可选，<code>|</code> 表示单选，<code>&lt;...&gt;</code> 表示必选。</p><h3 id="定义数据库"><a href="#定义数据库" class="headerlink" title="定义数据库"></a>定义数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> $DatabaseName;</span><br></pre></td></tr></table></figure><p>定义时可以定义一些物理特性。</p><a id="more"></a><h3 id="定义表"><a href="#定义表" class="headerlink" title="定义表"></a>定义表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> $TableName($AttribName1 $AttribType1 [primary <span class="keyword">key</span> | <span class="keyword">unique</span>] [<span class="keyword">not</span> <span class="literal">null</span>], ...);</span><br></pre></td></tr></table></figure><ul><li><p>使用 <code>primary key</code> 进行主键约束，只能有一个。</p></li><li><p>使用 <code>unique</code> 进行唯一性约束，可以有多个。</p></li><li><code>not null</code> 表示不能为空。</li></ul><h3 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> $TableName <span class="keyword">values</span> ($Value1, $Value2, ...);</span><br></pre></td></tr></table></figure><p>该形式下值和定义表时的列的顺序一致。</p><hr><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> $TableName($AttribName1, $AttribName2, ...) <span class="keyword">values</span> ($Value1, $Value2, ...);</span><br></pre></td></tr></table></figure><p>该形式下值和指定的列的顺序一致。</p><h2 id="利用-SQL-进行基本查询"><a href="#利用-SQL-进行基本查询" class="headerlink" title="利用 SQL 进行基本查询"></a>利用 SQL 进行基本查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...;</span><br></pre></td></tr></table></figure><ul><li><p>数学上不允许一个关系中出现多个相同记录。但是 DBMS 中允许。使用 <code>select distinct</code> 保证结果中没有重复的记录。</p></li><li><p>在 <code>where</code> 子句后使用 <code>order by $AttribName &lt;asc | desc&gt;</code> 进行排序。</p></li><li>在 <code>where</code> 子句中可以使用个字符串有关的模糊查询和简单的规则匹配。</li></ul><h2 id="利用-SQL-进行多表联合查询"><a href="#利用-SQL-进行多表联合查询" class="headerlink" title="利用 SQL 进行多表联合查询"></a>利用 SQL 进行多表联合查询</h2><p>在上述的 <code>from</code> 子句中使用多个表名即可进行多表联合查询；连接条件处于 <code>where</code> 子句中。</p><ul><li>多表连接时使用 <code>$TableName.$AttribName</code> 区分不同表的同名属性。</li><li>在 <code>select</code> 中可以使用 <code>as</code> 对属性去取别名；在 <code>from</code> 中可以使用 <code>as</code> 对表名取别名。</li></ul><h2 id="结合-SELECT-的-INSERT-语句"><a href="#结合-SELECT-的-INSERT-语句" class="headerlink" title="结合 SELECT 的 INSERT 语句"></a>结合 SELECT 的 INSERT 语句</h2><p>前面写的 <code>insert</code> 一次只能插一条记录。通过子查询可以一次插入多条记录，只要将前面从 <code>values</code> 开始的地方换成一个查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> $TableName (<span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> $TableName($AttribName1, ...) (<span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...);</span><br></pre></td></tr></table></figure><p><strong>插入受到完整性约束的约束。</strong></p><h2 id="结合-SELECT-的-DELETE-与-UPDATE-语句"><a href="#结合-SELECT-的-DELETE-与-UPDATE-语句" class="headerlink" title="结合 SELECT 的 DELETE 与 UPDATE 语句"></a>结合 SELECT 的 DELETE 与 UPDATE 语句</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>对记录进行删除是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> $TableName [<span class="keyword">where</span> ...];</span><br></pre></td></tr></table></figure><p>省略 <code>where</code> 会全部删除。一个典型用法是 <code>where</code> 后面跟一个 <code>in</code> 然后跟一个子查询。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> $TableName <span class="keyword">set</span> $AttribName1 = $Expression1 | $$Subquery1, ... [<span class="keyword">where</span> ...];</span><br></pre></td></tr></table></figure><p>仅对满足 <code>where</code> 中的记录修改。一个典型用法是 <code>where</code> 后面跟一个 <code>in</code> 然后跟一个子查询。</p><h2 id="数据库定义的修正与撤销"><a href="#数据库定义的修正与撤销" class="headerlink" title="数据库定义的修正与撤销"></a>数据库定义的修正与撤销</h2><h3 id="修正对表的定义"><a href="#修正对表的定义" class="headerlink" title="修正对表的定义"></a>修正对表的定义</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> $TableName</span><br><span class="line">[<span class="keyword">add</span> $AttribName1 $AttribType1, ...]</span><br><span class="line">[<span class="keyword">drop</span> $$<span class="keyword">Constraint</span>]</span><br><span class="line">[<span class="keyword">modify</span> $AttribName1 $AttribType1, ...];</span><br></pre></td></tr></table></figure><p>其中 <code>drop $$Constraint</code> 表示移除约束，例如不再要求元素唯一。</p><h3 id="撤销表"><a href="#撤销表" class="headerlink" title="撤销表"></a>撤销表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> $TableName;</span><br></pre></td></tr></table></figure><h3 id="撤销数据库"><a href="#撤销数据库" class="headerlink" title="撤销数据库"></a>撤销数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> $DatabaseName;</span><br></pre></td></tr></table></figure><h3 id="制定当前数据库与关闭数据库"><a href="#制定当前数据库与关闭数据库" class="headerlink" title="制定当前数据库与关闭数据库"></a>制定当前数据库与关闭数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> $DatabaseName;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close $DatabaseName;</span><br></pre></td></tr></table></figure><h2 id="用-SQL-Server-进行练习"><a href="#用-SQL-Server-进行练习" class="headerlink" title="用 SQL Server 进行练习"></a>用 SQL Server 进行练习</h2><blockquote><p>本节没有问题。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（上）：模型与语言 笔记 4 关系模型之关系代数</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-4-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-4-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="关系模型之关系代数"><a href="#关系模型之关系代数" class="headerlink" title="关系模型之关系代数"></a>关系模型之关系代数</h1><p>关系代数都是对集合进行操作的：输入和输出都是集合，从已有集合得到想要的集合。</p><p>下面的操作按照难度递增，分别是基本操作、扩展操作和复杂扩展操作。</p><h2 id="什么是关系代数"><a href="#什么是关系代数" class="headerlink" title="什么是关系代数"></a>什么是关系代数</h2><p>关系代数通常以一个或多个关系作为输入，结果是新的关系。关系代数是一种抽象的语言。</p><p>关系代数可以分成 <strong>集合操作</strong>（并交差积） 和 <strong>纯关系操作</strong>（投影、选择、连接、除）。</p><p>DBMS 可以先解析 SQL 语言，将其翻译为多个关系代数操作的序列。这样，只要实现了基本的一些关系代数操作就可以实现一个 DBMS 了。</p><h2 id="并相容性的概念"><a href="#并相容性的概念" class="headerlink" title="并相容性的概念"></a>并相容性的概念</h2><p>两个关系是并相容的，如果它们的属性数目相同，相同位置上的属性的类型也相同。</p><p>简单来说，两个关系并相容，表示可以把一个关系纵向拼接到另一个关系下面形成更大的关系。</p><p><strong>并相容性是其它很多操作的基础。</strong></p><a id="more"></a><h2 id="并操作"><a href="#并操作" class="headerlink" title="并操作"></a>并操作</h2><p>两个并相容关系的并是两个关系的并形成的更大的关系。重复记录被移除：</p><script type="math/tex; mode=display">R\cup S = \{r | r \in R \lor r\in S\}</script><p>显然并操作是交换的。</p><blockquote><p>学习各种操作时，也应从自然语义的角度进行理解。</p></blockquote><h2 id="差操作"><a href="#差操作" class="headerlink" title="差操作"></a>差操作</h2><p>两个并相容关系的差是两个关系的差形成的关系。差由属于一个关系但不属于另一个关系的记录构成：</p><script type="math/tex; mode=display">R - S = \{r | r \in R \land r \notin S\}</script><p>差操作不是交换的。</p><h2 id="广义积操作"><a href="#广义积操作" class="headerlink" title="广义积操作"></a>广义积操作</h2><p>广义积可以直接称为集。它是关系的笛卡尔积，但是其结果不像普通笛卡尔积那样。</p><p>如果 $R$ 的类型是 $(R_1, \cdots, R_n)$，$S$ 的类型是 $(S_1, \dots, S_m)$，那么笛卡尔积 $R\times S$ 的类型应该是 $((R_1,\dots, R_n), (S_1, \dots, S_m))$，而广义积的类型是两个元组的拼接 $(R_1,\dots, R_n, S_1, \dots, S_m)$。</p><p>关系的广义积会得到所有可能的拼接：</p><script type="math/tex; mode=display">R\times S = \{\langle r_1, \dots, r_n, s_1, \dots, s_m\rangle | \langle r_1, \dots, r_n\rangle\in R \land \langle s_1, \dots, s_m\rangle\in S \}</script><p>广义积是交换的（注意关系中列是可以交换的）。</p><p><strong>广义积的性质</strong>：度数是原关系度数之和，基数是原关系基数之积。</p><p>当涉及到多个表时，就可能要用到广义积。</p><h2 id="选择操作"><a href="#选择操作" class="headerlink" title="选择操作"></a>选择操作</h2><p>选择操作相当于对记录进行 filter。选择操作的结果依然是关系。</p><script type="math/tex; mode=display">\sigma_{cond}(R) = \{t | t \in R \land cond (t) = \texttt{true}\}</script><p>将 $cond$ 替换为想要的条件即可。这个是有某种语法的，不过我猜瞎写也可以。</p><blockquote><p>$\sigma \to sigma \to select$</p></blockquote><h2 id="投影操作及基本操作小结"><a href="#投影操作及基本操作小结" class="headerlink" title="投影操作及基本操作小结"></a>投影操作及基本操作小结</h2><h3 id="投影操作"><a href="#投影操作" class="headerlink" title="投影操作"></a>投影操作</h3><p>投影操作相当于只保留关系中感兴趣的那些列。投影操作的结果依然是关系。投影完成后，可能需要删除重复的行。</p><script type="math/tex; mode=display">\pi_{\langle A_1, \dots, A_n\rangle}(R) = \{t[A_1],\dots,t[A_n] | t\in R\}</script><blockquote><p>$\pi \to pi\to project$</p></blockquote><p><strong>投影操作是删除列，选择操作是选择行。</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面五种操作是基本操作。推荐在书写时从右往左写，这和自然思维的方向一致。</p><h2 id="交操作"><a href="#交操作" class="headerlink" title="交操作"></a>交操作</h2><p>下面的这些操作称为扩展操作，可以用基本操作实现。</p><p>交操作是并相容关系的交。交运算是交换的。</p><script type="math/tex; mode=display">R\cap S = \{r | r\in R \land r\in S\}</script><p>交运算可以通过差运算实现：$R\cap S = R - (R - S)$。</p><h2 id="theta-连接操作及更名操作"><a href="#theta-连接操作及更名操作" class="headerlink" title="theta 连接操作及更名操作"></a>theta 连接操作及更名操作</h2><h3 id="theta-连接操作"><a href="#theta-连接操作" class="headerlink" title="theta 连接操作"></a>theta 连接操作</h3><p>连接操作有几种不同的定义，这里是 theta 连接。连接操作用来进行涉及多个表的查询。</p><p>Theta 连接操作是笛卡尔积和选择的复合，其中选择操作的条件是来自两个关系的某两个属性的比较。</p><script type="math/tex; mode=display">R\underset{A\theta B}{\bowtie}S = \sigma_{t[A]\theta s[B]}(R\times S)</script><p>上式中，$A$ 是 $R$ 的某个属性，$B$ 是 $S$ 的某个属性，二者是可比的；$t$ 和 $s$ 分别是 $R$ 和 $S$ 中的记录；$\theta$ 是一个二元运算符。</p><p>在实现上，theta 连接操作一般要比笛卡尔积然后选择要更快。<strong>尽量避免积操作。</strong></p><hr><p>当 $\theta$ 为相等时，得到特例 <strong>等值连接</strong>。等值连接很实用，因为要进行 theta 连接时可能产生大量中间数据，而很多需要进行 theta 连接的场景实际上可以用等值连接减小运算量。</p><h3 id="更名操作"><a href="#更名操作" class="headerlink" title="更名操作"></a>更名操作</h3><p>对一个关系重新进行命名：</p><script type="math/tex; mode=display">\rho_{T}(S) =T</script><p>$S$ 会被重新命名为 $T$。</p><p>更名操作存在的意义是关系自己和自己进行连接。</p><p><strong>更名操作可以被归为基本操作。</strong></p><blockquote><p>$\rho\to rho\to rename$</p></blockquote><h2 id="自然连接操作"><a href="#自然连接操作" class="headerlink" title="自然连接操作"></a>自然连接操作</h2><p>自然连接是另一种连接，是一种特殊的等值连接。</p><p>假定 $R$ 和 $S$ 中存在相同的属性（可能有多个），经过笛卡尔积后，<strong>只保留所有相同属性的值相等的那些记录</strong>，随后删除重复的列，这个操作是自然连接操作。</p><script type="math/tex; mode=display">R\bowtie S = \sigma_{r[B] = s[B]}(R\times S)</script><h2 id="应用关系代数操作训练"><a href="#应用关系代数操作训练" class="headerlink" title="应用关系代数操作训练"></a>应用关系代数操作训练</h2><p><em>套路较多，本节没有问题。</em></p><p>常用的套路是“选投连”：连接，然后选择，然后投影。</p><h2 id="除操作"><a href="#除操作" class="headerlink" title="除操作"></a>除操作</h2><p>除操作比较绕，常用来回答“所有的”之类的问题。</p><p>能够执行 $R\div S$ 的前提条件是，$S$ 的属性是 $R$ 的属性的真子集。</p><ul><li>$R\div S$ 的结果的属性是 $R$ 的属性减去 $S$ 的属性</li><li>$R\div S$ 的结果的记录满足这样的性质：这些记录和 $S$ 做了广义积之后应该全部位于 $R$ 中。</li></ul><script type="math/tex; mode=display">\begin{aligned}R\div S &= \{t | t\in \pi_{R - S}(R)\land \forall u\in S, (tu\in R)\} \\&=\pi_{R - S}(R) - \pi_{R - S}((\pi_{R - S}(R)\times S) - R)\end{aligned}</script><h2 id="外连接操作"><a href="#外连接操作" class="headerlink" title="外连接操作"></a>外连接操作</h2><p>外连接是一种特殊的连接。在自然连接中，只有相同属性值相同的记录会被保留，这样损失了一部分信息。</p><p>外连接的操作是，对于相同属性的不同值，为了避免信息丢失，使用除了该属性以外全空的记录进行连接。例子：</p><img src="/2019/03/01/数据库系统（上）：模型与语言-笔记-4-关系模型之关系代数/DeepinScreenshot_select-area_20190308010255.png"><p>外连接可以进一步细分：</p><ul><li><strong>左外连接</strong>：$R ⟕ S​$，保留 $R​$ 中的失配记录（$R​$ 中的信息不丢失）。</li><li><strong>右外连接</strong>：$R⟖S$，保留 $S$ 中的失配记录（$S$ 中的信息不丢失）。</li><li><strong>全外连接</strong>：$R⟗S$，两边的失配记录都被保留。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>五个基本操作（算上更名是六个）。</li><li>三个扩展操作。</li><li>两个复杂扩展操作。</li></ul><p>各种操作都是对集合进行的！</p><p>操作的“选投连”套路正好和 SQL 的 <code>select ... from ... where</code> 是一致的。</p><p>DBMS 的功能就是将 SQL 解释为各种关系代数操作，然后在数据上执行这些操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（上）：模型与语言 笔记 5 关系模型之关系演算</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-5-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-5-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="关系模型之关系演算"><a href="#关系模型之关系演算" class="headerlink" title="关系模型之关系演算"></a>关系模型之关系演算</h1><h2 id="什么是关系元组演算"><a href="#什么是关系元组演算" class="headerlink" title="什么是关系元组演算"></a>什么是关系元组演算</h2><p>关系运算分为关系代数（见上次的笔记）与关系演算。关系演算是以谓词演算为基础的，按照谓词变量不同分为 <strong>元组演算</strong> 和 <strong>域演算</strong>。从名字可以看出一个是针对行，一个是针对列。</p><p>后面可以看到在一定的条件下，关系代数和关系演算是可以相互转化的。</p><hr><p>元组演算也是用来找出某个关系中的记录的。这里的“元组”就是记录的意思，但是名字听起来让人不爽。</p><p>元组演算和一般形式是：</p><script type="math/tex; mode=display">\{t| P(t)\}</script><p>其中 $t$ 一般表示一个元组，$P(t)$ 是一个逻辑表达式，它的格式有严格限定，只能是以下的形式：</p><ul><li>（原子）$t\in R$，$t[A]\ \theta\ c$，$t[A]\ \theta\ s[B]$（中括号表示取出分量；$\theta$ 表示二元关系，例如大于或等于）</li><li>（逻辑连接词）原子通过与或非连接起来</li><li>（量词）使用存在量词和全称量词进一步修饰</li></ul><p>其它所有形式都不是。</p><p>语义上，这个表达式会选择出所有符合 $P(t)​$ 的所有 $t​$。为了实用，基本上所有的 $P(t)​$ 都会以 $t\in R​$ 开头来限制 $t​$ 的取值范围。</p><a id="more"></a><h2 id="简单运用元组演算公式"><a href="#简单运用元组演算公式" class="headerlink" title="简单运用元组演算公式"></a>简单运用元组演算公式</h2><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>这一讲中的所有例子都是基于以下 Schema：</p><ul><li>Student 表：包括 SNum，Sname，Ssex，Sage，DNum，Sclass</li><li>SC 表：包括 SNum，CNum，Score</li><li>Course 表：包括 CNum，Cname，Chours，Credit，TNum，Tname</li></ul><h3 id="元组演算示例"><a href="#元组演算示例" class="headerlink" title="元组演算示例"></a>元组演算示例</h3><p>看了例子就知道元组演算是啥了。</p><ul><li>找出叫 Bob 的所有学生：$\{t|t\in\text{Student}\land t[\text{Sname}]=\text{Bob}\}​$</li><li>年龄小于 20 岁的男生：$\{t|t\in\text{Student}\land t[\text{Ssex}]=\text{Male}\land t[\text{Sage}] &lt; 20\}$</li></ul><h2 id="存在量词与全称量词"><a href="#存在量词与全称量词" class="headerlink" title="存在量词与全称量词"></a>存在量词与全称量词</h2><p>存在量词和全称量词也可以用来进行元组演算，在关系的连接中很有用。以下是一些例子：</p><ul><li>找出年龄不是最小的所有同学：$\{t|t\in\text{Student}\land (\exists(u\in\text{Student})(u[\text{Sage}] &lt; t[\text{Sage}])\}$。</li><li><strong>量词可以用来进行表的连接</strong>，找出所有课程都及格的同学：$\{t|t\in\text{Student}\land\forall(u\in\text{SC}\land u[SNum]=t[SNum])(u[Score] \ge 60)\}$。</li></ul><p>可以看到关系连接时也满足：</p><blockquote><p>语义上，这个表达式会选择出所有符合 $P(t)$ 的所有 $t$。为了实用，基本上所有的 $P(t)$ 都会以 $t\in R$ 开头来限制 $t$ 的取值范围。</p></blockquote><h2 id="等价变换"><a href="#等价变换" class="headerlink" title="等价变换"></a>等价变换</h2><p>这一节讲的是逻辑运算的等价性，比如摩根律这种。没什么好记的。复习一下下面两个：</p><ul><li>$\exists(P[t])(Q[t])​$ 等价于 $\lnot\forall(P[t])(\lnot Q[t])​$</li><li>$\forall(P[t])(Q[t])$ 等价于 $\lnot\exists(P[t])(\lnot Q[t])$</li></ul><p>至于为啥量词后面可以跟一个命题，因为 $\exists(P[t])(Q[t])$ 和 $\exists(t)(P[t]\to Q[t])$，而后者可以使用与或非转换出。</p><h2 id="四个典型示例"><a href="#四个典型示例" class="headerlink" title="四个典型示例"></a>四个典型示例</h2><p>本节主要是元组演算的几个较为复杂的示例，同时使用关系代数作了比较。摘录一个：找出 Alice 老师教的所有课程的所有学生。</p><ul><li><strong>关系代数</strong>：$\pi_{Sname}(\pi_{Sname, CNum}(\text{Student}\bowtie\text{SC}\bowtie\text{Course})\div\pi_{CNum}(\sigma_{Tname=Alice}(\text{Course})))$</li><li><strong>元组演算</strong>：$\{t|t\in\text{Student}\land \forall(u\in\text{Course}\land u[\text{Tname}]=\text{Alice})(\exists (v\in\text{SC})(v[SNum]=t[SNum]\land v[CNum]=u[CNum]))\}$</li></ul><h2 id="用元组演算实现关系代数操作"><a href="#用元组演算实现关系代数操作" class="headerlink" title="用元组演算实现关系代数操作"></a>用元组演算实现关系代数操作</h2><p>可以看到关系代数是以关系作为基本单位的，元组演算是以元组作为基本单位的，不过得到的依然是集合。</p><p>后者可以对前者进行模拟。例如 $\sigma_{cond}(R)$ 可以使用 $\{t|t\in R\land cond(t)\}$ 完成。</p><h2 id="什么是域演算"><a href="#什么是域演算" class="headerlink" title="什么是域演算"></a>什么是域演算</h2><p>域演算和元组演算很相似，不同的是它的粒度更细。元组演算每次操作一个元组，而域演算操作的是其中的一个域。但是二者是等价的。形式上，域演算也是使用集合，并且短竖线右端也是和元组演算相同的格式。</p><p>从例子来看，找出所有不是 03 系的学生的记录：$\{\langle a, b, c, d,e, f\rangle|\langle a, b, c, d,e, f\rangle\in\text{Student}\land e\neq 03\}​$。可以看到域演算相当于 unpack 了的元组演算。</p><p>如果希望不查询所有的域，套路是将其它域移到短竖线后面的存在量词中。</p><p>假设上面的例子中我们只对名字感兴趣：$\{b|\exists(a, c, d, e, f)(\langle a, b, c, d,e, f\rangle\in\text{Student}\land e\neq 03)\}$</p><h2 id="什么是按按示例查询-QBE"><a href="#什么是按按示例查询-QBE" class="headerlink" title="什么是按按示例查询-QBE"></a>什么是按按示例查询-QBE</h2><p>QBE（Query by example）是一种非过程化的查询语言。使用域演算实现，适合终端用户使用。</p><p>QBE 中有四种操作：Print、Update、Insert、Delete。QBE 在一张表格上进行操作，这张表格中用来填写条件。表格的每一列是对应关系中的一个属性，每一行是要进行的 QBE 操作。例如找到所有小于 17 岁的女生，表格应该这样填写：</p><div class="table-container"><table><thead><tr><th></th><th>SNum</th><th>Sname</th><th>Ssex</th><th>Sage</th><th>DNum</th><th>DClass</th></tr></thead><tbody><tr><td>Print</td><td></td><td></td><td>Female</td><td>&lt;17</td><td></td></tr></tbody></table></div><p>这就会找到所有记录并打印。更新、插入删除同理。</p><h3 id="示例元素"><a href="#示例元素" class="headerlink" title="示例元素"></a>示例元素</h3><p>使用示例元素可以将不同的记录关联起来。作者使用的符号是下划线，但是 Markdown 里没有，这里用斜体。</p><p>找到年龄介于 17 岁到 20 岁的学生：</p><div class="table-container"><table><thead><tr><th></th><th>SNum</th><th>Sname</th><th>Ssex</th><th>Sage</th><th>DNum</th><th>DClass</th></tr></thead><tbody><tr><td></td><td>Print.<em>S</em></td><td></td><td></td><td>&gt;17</td><td></td><td></td></tr><tr><td></td><td>Print.<em>S</em></td><td></td><td></td><td>&lt;20</td><td></td></tr></tbody></table></div><p>如果将第二行的 <em>S</em> 换成其它字母，就可以表示“或”关系。</p><p>使用示例元素可以对不同的表进行连接。</p><h2 id="QBE-应用训练"><a href="#QBE-应用训练" class="headerlink" title="QBE 应用训练"></a>QBE 应用训练</h2><p>使用 QBE 可以表达很多查询，实际上它可以模拟出关系代数。例子略去。</p><h2 id="关系演算的安全性"><a href="#关系演算的安全性" class="headerlink" title="关系演算的安全性"></a>关系演算的安全性</h2><p><strong>安全性</strong>：不产生无限关系和无穷验证的演算是安全的。</p><p>关系代数是安全的，因为是对有限集合的有限操作。</p><p>关系演算不一定安全，例如 $\{t|t\notin R\}$ 就可以产生无限的 $t$（无限关系）。量词中如果不加限定的话也可能导致对无数个元素进行验证（无穷验证）。</p><h3 id="元组演算的安全化"><a href="#元组演算的安全化" class="headerlink" title="元组演算的安全化"></a>元组演算的安全化</h3><p>对于命题 $\phi$ 引入安全约束有限集合 $DOM(\phi)$，它是一些值的集合，元素要么是 $\phi$ 中的值（如常量），要么是 $\phi$ 中的关系的记录的某个属性的值。注意 $DOM(\phi)$ 是有限的。</p><p>满足以下条件的元组演算 $\{t|\phi(t)\}$ 是安全的：</p><ul><li>如果 $\phi(t)$ 为真，$t$ 的每个分量都在 $DOM(\phi)$ 中。（集合不能产出无限的元素，这条性质避免掉了无限关系。）</li><li>对于 $\phi(t)$ 中的存在量词子句 $\exists u(\omega(u))$，只要 $\omega(u)$ 为真，$u$ 的每个分量都在 $DOM(\phi)$ 中。</li><li>对于 $\phi(t)$ 中的全称量词子句 $\forall u(\omega(u))$，只要 $\omega(u)$ 为假，$u$ 的每个分量都在 $DOM(\phi)$ 中。（量词子句本质上会得到一个布尔值，通过这些约束可以让判定的时候只用从一个有限集合中找是否存在、不存在即可，避免掉了无穷验证。）</li></ul><h3 id="域演算的安全化"><a href="#域演算的安全化" class="headerlink" title="域演算的安全化"></a>域演算的安全化</h3><p>上面是元组演算的安全化，对域演算有类似定义。</p><h2 id="三种关系运算之比较"><a href="#三种关系运算之比较" class="headerlink" title="三种关系运算之比较"></a>三种关系运算之比较</h2><p>三种关系运算从不同层面反映了查询操作。</p><p>按照过程化程度递减、函数式程度递增的顺序：关系代数、元组演算、域演算。</p><p><strong>关系代数</strong>、<strong>安全的元组演算</strong>、<strong>安全的域演算</strong> 三者表达能力等价。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（上）：模型与语言 笔记 3 关系模型之基本概念</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-3-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-3-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="关系模型之基本概念"><a href="#关系模型之基本概念" class="headerlink" title="关系模型之基本概念"></a>关系模型之基本概念</h1><h2 id="什么是关系模型"><a href="#什么是关系模型" class="headerlink" title="什么是关系模型"></a>什么是关系模型</h2><h3 id="关系模型的提出"><a href="#关系模型的提出" class="headerlink" title="关系模型的提出"></a>关系模型的提出</h3><p><strong>提出</strong>：关系模型从对表的处理中提出，多数商业数据库在使用基于关系模型的数据库。</p><h3 id="关系与关系模型"><a href="#关系与关系模型" class="headerlink" title="关系与关系模型"></a>关系与关系模型</h3><p><strong>简单来说一张表就是一个关系。</strong></p><p>关系模型就是处理表的模型，包括三个部分：</p><ul><li><strong>结构</strong>：描述数据库、数据的结构</li><li><strong>操作</strong>：描述表之间可能进行的操作（运算）</li><li><strong>完整性约束</strong>：描述上述操作需要遵循的条件</li></ul><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><p>关系运算分为 <strong>关系代数</strong> 和 <strong>关系演算</strong>，关系演算又分为 <strong>元组演算</strong> 和 <strong>域演算</strong>（一个按行一个按列）。这三种演算都有对应的语言实现。</p><ul><li><strong>关系代数</strong> 一次对一个集合进行操作（很多非关系的代数一次对单条记录进行操作）。</li><li><strong>元组演算</strong> 是基于逻辑的演算，域演算比较少见。</li></ul><a id="more"></a><h2 id="什么是关系"><a href="#什么是关系" class="headerlink" title="什么是关系"></a>什么是关系</h2><p>复习离散数学：<strong>关系是笛卡尔积的子集</strong>。</p><h3 id="表的严格定义"><a href="#表的严格定义" class="headerlink" title="表的严格定义"></a>表的严格定义</h3><p>假设有三个集合：学生姓名集合、参加课程集合、授课老师集合。每个集合中的元素是可以穷举的。这样的集合称为 <strong>域</strong>。域就是一组值的集合，可选的值的集合为值域。</p><p>将这三个集合作笛卡尔积会得到很多的三元组，所有可能的三元组都包含在笛卡尔积中。但是并不是所有的三元组都是有意义的，选出这些三元组的有意义的子集，这个子集即称为 <strong>关系</strong>。</p><p>因为作笛卡尔积时不一定总是像这个例子一样是不同的集合作笛卡尔积，因此需要为元组中不同分量取新的名字，即 <strong>属性名</strong>。</p><p>描述关系的结构的是 <strong>关系模式（Schema）</strong>，关系中元组的数量称为关系的 <strong>基数</strong>，元组的长度称为关系的 <strong>目</strong> 或者度。</p><p><em>在很多DBMS 中，域被简化为各种数据类型和长度，例如 <code>char(8)</code> 或者 <code>integer</code> 等。</em></p><p><em>关系模式的记号是 $R(A_1: D_1, A_2: D_2, \dots, A_n: D_n)$，其中 $A_i$ 是属性名，$D_i$ 是域名。</em></p><h3 id="关系与关系模式"><a href="#关系与关系模式" class="headerlink" title="关系与关系模式"></a>关系与关系模式</h3><p>关系模式是固定的，同一个关系模式可以对应多个关系（不同的子集）。关系模式是对关系的描述。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>为了定义一张表（得到一个关系）：</p><ul><li>指出有多少列</li><li>指出每列允许的取值范围</li><li>得到所有可能的元组</li><li>选取有意义的子集</li></ul><h2 id="关系有什么特性"><a href="#关系有什么特性" class="headerlink" title="关系有什么特性"></a>关系有什么特性</h2><p>关系满足以下特性：</p><ul><li><strong>列的同质性</strong>：相同的列的数据必须来自同一个域。不同的列的数据也允许来自同一个数据，靠属性名进行区分。</li><li><strong>列与行的互换性</strong>：区分不同列靠的是属性名而不是位置，区分不同行靠的是元组内容而不是位置。交换不同的行和不同的列得到的关系是相同的。（尽管笛卡尔积得到的元组是有序的，这里使用属性名进行区分。）</li><li><strong>行的唯一性</strong>：理论上关系中不能出现相同的元组（因为是元组的集合）。<strong>但是现实中的表的实现不一定遵守这个约束，这可以认为是表和关系的差异。</strong></li><li><strong>遵循第一范式</strong>：不允许存在多值属性（列分裂）和复合属性（行分裂）。<del>第一范式这个名字听起来很牛逼。</del></li></ul><h2 id="候选码与外码"><a href="#候选码与外码" class="headerlink" title="候选码与外码"></a>候选码与外码</h2><h3 id="候选码与主码"><a href="#候选码与主码" class="headerlink" title="候选码与主码"></a>候选码与主码</h3><p><strong>主码、候选码不一定是单个元素！</strong></p><p>关系中能够唯一确定一条记录的属性的子集称为 <strong>候选码</strong>，并且要求这样的子集是最小的，去掉任意元素都不在满足该性质。一个关系可能有多个候选码。</p><p>DBMS 中要求选择某个候选码作为 <strong>主码</strong>，主码用来在 DBMS 中对记录进行管理。</p><h3 id="主属性与非主属性、全码"><a href="#主属性与非主属性、全码" class="headerlink" title="主属性与非主属性、全码"></a>主属性与非主属性、全码</h3><p>如果一个属性是属于某个候选码，称为 <strong>主属性</strong>，否则是 <strong>非主属性</strong>。</p><p>特殊情形：如果只有所有的属性全部选上才能构成一个候选码，此时的候选码称为 <strong>全码</strong>。</p><h3 id="外码（外键）"><a href="#外码（外键）" class="headerlink" title="外码（外键）"></a>外码（外键）</h3><p>如果一个属性集合不是候选码，但是是其它关系的候选码，那么这样的属性集合称为 <strong>外键</strong>。关系之间的关联往往是通过外键进行的。</p><h2 id="关系模型的完整性"><a href="#关系模型的完整性" class="headerlink" title="关系模型的完整性"></a>关系模型的完整性</h2><ul><li><strong>实体完整性</strong>：主码的属性值不能为空值。</li><li><strong>参照完整性</strong>：外码的属性值可以为空值，但是一旦取值，只能取自己作为主码的那张表中的值，即一定要能够找到对应的行。</li><li><strong>用户自定义完整性</strong>：用户根据实际应用情况施加的完整性约束。实现上，DBMS 允许用户自行进行定义，当发生数据库更改时，数据库会自动进行检查。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关系模型包括关系结构、关系操作和完整性。本节只涉及了关系结构和完整性。完整性包括三个方面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（上）：模型与语言 笔记 2 数据库系统的结构抽象与演变</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E6%8A%BD%E8%B1%A1%E4%B8%8E%E6%BC%94%E5%8F%98/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E6%8A%BD%E8%B1%A1%E4%B8%8E%E6%BC%94%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库系统的结构抽象与演变"><a href="#数据库系统的结构抽象与演变" class="headerlink" title="数据库系统的结构抽象与演变"></a>数据库系统的结构抽象与演变</h1><h2 id="数据库系统的标准结构"><a href="#数据库系统的标准结构" class="headerlink" title="数据库系统的标准结构"></a>数据库系统的标准结构</h2><h3 id="三层次抽象"><a href="#三层次抽象" class="headerlink" title="三层次抽象"></a>三层次抽象</h3><p>数据的存储可以看做有三个抽象层次：</p><ul><li><strong>外部层次</strong>（用户层次）：DBAP 可以看到的层次，一般是所有数据的一部分。</li><li><strong>概念层次</strong>（逻辑层次）：DBMS 使用到的层次，包括对应的约束和关联。</li><li><strong>内部层次</strong>（物理层次）：数据在介质上的存储，包括路径、索引等。</li></ul><h3 id="模式与视图"><a href="#模式与视图" class="headerlink" title="模式与视图"></a>模式与视图</h3><ul><li><strong>模式（Schema）</strong>：对数据库中的数据的结构化描述。</li><li><strong>视图（View）</strong>（又称数据）：通过某种表现形式表现出的数据库中的数据。它是一种表现。</li></ul><p>将三层次抽象和模式视图结合，排列组合一下可以得到六个概念：内部模式、内部视图、概念模式、概念视图、外部模式、外部视图。当然知道这几个概念并没有什么用。</p><p>在不指明抽象层次的情况下，模式指的是概念模式，视图指的是外部视图。</p><a id="more"></a><h3 id="两层映像"><a href="#两层映像" class="headerlink" title="两层映像"></a>两层映像</h3><p>两层映像指的是不同抽象层次之间的 <strong>模式</strong> 的映射：</p><ul><li><strong>C-E 映像</strong>：将概念模式映射到外部模式，这么做是为了方便用户观察和使用。</li><li><strong>I-C 映像</strong>：将内部模式映射到概念模式，这么做是在保证计算机方便处理的前提下提供足够的抽象性。</li></ul><p>DBMS 应该能让用户自己定义三个层次的模式，然后自动生成对应的两层映像。</p><p>一般只会有一个概念模式，但是可以有多个内部模式和外部模式。</p><h3 id="逻辑数据独立性与物理数据独立性"><a href="#逻辑数据独立性与物理数据独立性" class="headerlink" title="逻辑数据独立性与物理数据独立性"></a>逻辑数据独立性与物理数据独立性</h3><p>抽象层次使得一层发生变动时其它层次可以几乎不用修改。各层有一定的 <strong>独立性</strong>。</p><ul><li><strong>逻辑数据独立性</strong> 指的是在概念模式发生变动时，外部模式不用进行修改，只要修改 C-E 映射即可。</li><li><strong>物理数据独立性</strong> 指的是在内部模式发生变动时，概念模式不用进行修改，只要修改 I-C 映射即可。</li></ul><h2 id="什么是数据模型"><a href="#什么是数据模型" class="headerlink" title="什么是数据模型"></a>什么是数据模型</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>有三个概念，数据、模式和数据模型。下面的描述中将三者加粗。</p><p><strong>数据</strong> 的模式称为 <strong>模式</strong>，<strong>模式</strong> 描述了 <strong>数据</strong> 应当如何进行组织，<strong>模式</strong> 是对 <strong>数据</strong> 的结构的抽象。</p><p><strong>模式</strong> 的模式称为 <strong>数据模型</strong>，<strong>数据模型</strong> 描述了 <strong>模式</strong> 应当如何进行组织，<strong>数据模型</strong> 是对 <strong>模式</strong> 的结构的抽象。</p><h3 id="数据模型的三个经典实例"><a href="#数据模型的三个经典实例" class="headerlink" title="数据模型的三个经典实例"></a>数据模型的三个经典实例</h3><p>三个经典的数据模型分别是关系模型、层次模型和网状模型。</p><p>关系模型是很多数据库采用的数据模型，使用表组织数据。但是并非所有的数据库都是关系型的。</p><p>层次模型和网状模型分别使用有根树和有向图图来描述 <strong>模式</strong>，这些树和图中，每个结点称为 <strong>实体型</strong>、边称为 <strong>系型</strong>。每个实体型是对一个实体应当如何描述的模式，在存储数据时，多个实体按照实体型制定的模式进行存储，构成一个集合。不同类型的实体的集合之间通过有向边进行连接。</p><h2 id="数据库系统的演变之一"><a href="#数据库系统的演变之一" class="headerlink" title="数据库系统的演变之一"></a>数据库系统的演变之一</h2><h3 id="简要发展史"><a href="#简要发展史" class="headerlink" title="简要发展史"></a>简要发展史</h3><p>数据库的研究从 1959 年左右开始，在 1976 年左右开始成熟。早期的数据库很多不是关系型的，在成熟时关系型数据库和对应的理论开始迅速进步。</p><h3 id="重要演变经历"><a href="#重要演变经历" class="headerlink" title="重要演变经历"></a>重要演变经历</h3><h4 id="从文件系统到数据库"><a href="#从文件系统到数据库" class="headerlink" title="从文件系统到数据库"></a>从文件系统到数据库</h4><p>早期数据管理使用操作系统提供的文件系统直接进行管理，但是此时数据和程序的耦合性严重。因此过渡到了数据库。数据库的引入使得数据和程序解耦，提高了数据的共享程度。</p><h4 id="从层次模型和网状模型到关系模型"><a href="#从层次模型和网状模型到关系模型" class="headerlink" title="从层次模型和网状模型到关系模型"></a>从层次模型和网状模型到关系模型</h4><p>早期数据库有些是层次模型和网状模型的，实现要用到指针（指向关系要用户手动建立），很复杂而且难以对记录的集合进行操作。关系模型理论成熟并且容易对记录的集合进行操作，并且容易实现非过程化的查询。</p><p>使用了层次和网状模型的数据库称为第一代数据库，使用了关系模型的数据库称为第二代数据库。</p><h2 id="数据库系统的演变之二"><a href="#数据库系统的演变之二" class="headerlink" title="数据库系统的演变之二"></a>数据库系统的演变之二</h2><h3 id="重要演变经历（续）"><a href="#重要演变经历（续）" class="headerlink" title="重要演变经历（续）"></a>重要演变经历（续）</h3><h4 id="关系数据库到对象关系数据库和面向对象数据库"><a href="#关系数据库到对象关系数据库和面向对象数据库" class="headerlink" title="关系数据库到对象关系数据库和面向对象数据库"></a>关系数据库到对象关系数据库和面向对象数据库</h4><ul><li><strong>复合属性</strong>：关系型数据库中，每个域都是原子化的，不可继续分割。但是有时候希望一个域下面还有子域，可以进行分割，这种域称为复合属性。</li><li><strong>多值属性</strong>：关系型数据库中，每个记录的一个域只有一个值。但是有时候希望它能够有多个值，这种域称为多值属性。</li></ul><p>通过引入 OOP 中的一些思路可以解决上述问题。引入列对象和行对象的概念解决复合属性的问题，引入聚集对象和结构对象的概念解决多值属性的问题。此时数据库中每个值都是一个对象。引入这些玩意后关系数据库就变成了对象关系数据库，并且还能支持多态等 OOP 概念。</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li><strong>XML 数据库</strong>：一种半结构化数据库，数据和数据的语义合并存储和处理。</li><li>从多种数据库能够进行开放式互联的变化。多种不同厂商的数据库通过同样的标准可以互相访问。</li><li>其它各种新型数据库。</li></ul><h2 id="回顾本讲学习了什么"><a href="#回顾本讲学习了什么" class="headerlink" title="回顾本讲学习了什么"></a>回顾本讲学习了什么</h2><ul><li>数据、模式、数据模型。</li><li>外模式、概念模式、内模式。</li><li>E-C 映像、C-I 映像。</li><li>逻辑独立性与物理独立性：抽象层次引入导致的解耦。</li><li>网状模型、层次模型、关系模型。</li><li>各种不同的数据库。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（上）：模型与语言 笔记 1 初步认识数据库系统</title>
      <link href="/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-1-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-1-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="初步认识数据库系统"><a href="#初步认识数据库系统" class="headerlink" title="初步认识数据库系统"></a>初步认识数据库系统</h1><p>来自 <a href="http://www.xuetangx.com/courses/course-v1:HITx+13SC03100710_1x+sp/about" target="_blank" rel="noopener">学堂在线</a>。</p><h2 id="数据库系统课程简要介绍"><a href="#数据库系统课程简要介绍" class="headerlink" title="数据库系统课程简要介绍"></a>数据库系统课程简要介绍</h2><p><em>本节没有问题。</em></p><h2 id="本讲学习什么"><a href="#本讲学习什么" class="headerlink" title="本讲学习什么"></a>本讲学习什么</h2><p><em>本节没有问题，学习时注意从使用者和实现者两方面进行考虑。</em></p><h2 id="为什么要学习数据库系统"><a href="#为什么要学习数据库系统" class="headerlink" title="为什么要学习数据库系统"></a>为什么要学习数据库系统</h2><p><em>本节没有问题。</em></p><h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><p><strong>数据库</strong>：有相联关系的数据的集合。</p><p><strong>表</strong>：按行按列组织和展示的数据。</p><a id="more"></a><h3 id="表的一些术语"><a href="#表的一些术语" class="headerlink" title="表的一些术语"></a>表的一些术语</h3><p>下面定义中的 <strong>表</strong> 指的是包含每列标题的表。</p><ul><li><strong>表名</strong>：一张表的名称。</li><li><strong>表标题（格式）</strong>：每列的标题。</li><li><strong>表内容</strong>：表中除去表标题剩下的数据。</li><li><strong>记录（元组）</strong>：一行数据。</li><li><strong>字段（属性、数据项）</strong>：一列数据。一列数据又分 <strong>列名</strong> 和 <strong>列值</strong>。</li><li><strong>关系模式</strong>：表名和表标题。</li><li><strong>关系</strong>：不严格地讲，关系就是整张表。</li></ul><p>由此可以重新定义数据库：相互之间有关联关系的表的集合。</p><hr><p>关系数据库是结构化的数据库。存在非结构化的数据库。</p><h2 id="什么是数据库系统"><a href="#什么是数据库系统" class="headerlink" title="什么是数据库系统"></a>什么是数据库系统</h2><p>数据库系统是以下软硬件的合称：</p><ul><li><strong>数据库（DB）</strong>：存储的实际数据。</li><li><strong>数据库管理系统（DBMS）</strong>：管理数据库的系统软件，例如 MySQL。</li><li><strong>数据库应用（DBAP）</strong>：可以想成是访问、修改数据库的客户端，可以完成特定的业务功能。</li><li><strong>数据库管理员（DBA）</strong>：负责管理数据库和使用 DBMS 的人员。</li><li><strong>计算机基本系统</strong>：基本硬件设施。</li></ul><h2 id="从用户角度看数据库管理系统"><a href="#从用户角度看数据库管理系统" class="headerlink" title="从用户角度看数据库管理系统"></a>从用户角度看数据库管理系统</h2><p>在 DBMS 的使用者看来，DBMS 应当提供以下功能：</p><ul><li><strong>允许用户创建表</strong>：DBMS 提供了 <em>数据定义语言</em>（DDL），可以用来创建表。</li><li><strong>允许用户操纵数据</strong>：DBMS 提供了 <em>数据操纵语言</em>（DML），可以用来进行增删改查。</li><li><strong>允许用户控制客户的权限</strong>：DBMS 提供了 <em>数据控制语言</em>（DCL），可以用来控制 DBA 的访问权限。</li><li><strong>提供一些实用程序</strong>：例如转储、性能监控等。</li></ul><p>DDL、DML、DCL 合起来就构成了 SQL。</p><p>SQL 可以被嵌入到其它高级语言中，被嵌入的语言称为 <strong>宿主语言</strong>。</p><h2 id="从系统角度看数据库管理系统"><a href="#从系统角度看数据库管理系统" class="headerlink" title="从系统角度看数据库管理系统"></a>从系统角度看数据库管理系统</h2><p>在 DBMS 的实现者来看，DBMS 完成了以下事情：对于各种语言（例如 DDL），DBMS 会先使用一个编译器得知该语言的语义，然后使用对应的执行引擎操作文件完成任务。不同语言的编译器和执行引擎都不同。</p><p>DBMS 可以经由操作系统工作，也有越过操作系统进行底层控制的 DBMS。</p><p>DBMS 由很多更小的程序构成以完成工作：</p><ul><li><strong>语言编译器</strong></li><li><strong>查询优化与查询实现</strong>：主要用于提高查询的性能</li><li><strong>数据存储与索引</strong>：运用各种缓冲和索引</li><li><strong>通信控制</strong>：提供网络环境下的操作与传输功能</li><li><strong>事务管理</strong>：提供可靠性与一致性</li><li><strong>故障恢复</strong></li><li><strong>安全性控制</strong>：防止出现授权问题</li><li><strong>完整性控制</strong>：保证数据完整、正确</li><li><strong>数据字典管理</strong></li><li><strong>应用程序接口</strong></li><li>其它</li></ul><h2 id="数据库系统课程学习什么"><a href="#数据库系统课程学习什么" class="headerlink" title="数据库系统课程学习什么"></a>数据库系统课程学习什么</h2><p><em>本节没有问题。</em></p><h2 id="回顾本讲学习了什么"><a href="#回顾本讲学习了什么" class="headerlink" title="回顾本讲学习了什么"></a>回顾本讲学习了什么</h2><p><em>本节没有问题。记住 DBMS 可以从使用者角度和实现者角度来看待。使用者看到的是各种语言，实现者看到的是各种程序。</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Probabilistic Graphical Models 1: Representation 笔记 7 Knowledge Engineering &amp; Summary</title>
      <link href="/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-7-Knowledge-Engineering-Summary/"/>
      <url>/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-7-Knowledge-Engineering-Summary/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 概率图模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Probabilistic Graphical Models 1: Representation 笔记 6 Decision Making</title>
      <link href="/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-6-Decision-Making/"/>
      <url>/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-6-Decision-Making/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 概率图模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Probabilistic Graphical Models 1: Representation 笔记 5 Markov Networks (Undirected Models)</title>
      <link href="/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-5-Markov-Networks-Undirected-Models/"/>
      <url>/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-5-Markov-Networks-Undirected-Models/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 概率图模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Probabilistic Graphical Models 1: Representation 笔记 4 Structured CPDs for Bayesian Networks</title>
      <link href="/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-4-Structured-CPDs-for-Bayesian-Networks/"/>
      <url>/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-4-Structured-CPDs-for-Bayesian-Networks/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 概率图模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Probabilistic Graphical Models 1: Representation 笔记 3 Template Models for Bayesian Networks</title>
      <link href="/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-3-Template-Models-for-Bayesian-Networks/"/>
      <url>/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-3-Template-Models-for-Bayesian-Networks/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 概率图模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Probabilistic Graphical Models 1: Representation 笔记 2 Bayesian Network (Directed Models)</title>
      <link href="/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-2-Bayesian-Network-Directed-Models/"/>
      <url>/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-2-Bayesian-Network-Directed-Models/</url>
      
        <content type="html"><![CDATA[<h1 id="Bayesian-Network-Directed-Models"><a href="#Bayesian-Network-Directed-Models" class="headerlink" title="Bayesian Network (Directed Models)"></a>Bayesian Network (Directed Models)</h1><h2 id="Bayesian-Network-Fundamentals"><a href="#Bayesian-Network-Fundamentals" class="headerlink" title="Bayesian Network Fundamentals"></a>Bayesian Network Fundamentals</h2><h3 id="Semantics-amp-Factorization"><a href="#Semantics-amp-Factorization" class="headerlink" title="Semantics &amp; Factorization"></a>Semantics &amp; Factorization</h3><p>贝叶斯网是一个 DAG，每个结点表示一个随机变量。将 DAG $G$ 中结点 $A$ 的直接前驱记作 $\text{Par}_G(A)$，则每个结点实际上表示了一个条件分布（conditional probability distribution, CPD），结点 $X_i$ 对应 $P(X_i | \text{Par}_G(X_i))$。</p><p><em>（约定“前驱”表示直接前驱和非直接前驱的并集。）</em></p><p>贝叶斯网编码了一个所有结点代表的随机变量的联合分布：$P(X_1, \dots, X_n) = \prod\limits_{i = 1}^nP(X_i|\text{Par}_G(X_i))$。可以证明这个联合分布是满足定义的（例如一定非负、和为 1 等）。<em>证明过程中使用了性质 $\sum_A P(A|B) = 1$（与 $B$ 无关）。</em>如果一张图 $G$ 中每个结点代表了一个随机变量，存在一个联合分布 $P$，并且满足 $P(X_1, \dots, X_n) = \prod\limits_{i = 1}^nP(X_i|\text{Par}_G(X_i))$，则称 $P$ factorizes over $G$。</p><a id="more"></a><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>如果有 5 个随机变量：</p><ul><li>Grade</li><li>Course Difficulty</li><li>Student Intelligence</li><li>Student SAT</li><li>Reference Letter</li></ul><p>它们之间相互影响的关系如下：</p><img src="/2019/02/27/Probabilistic-Graphical-Models-1-Representation-笔记-2-Bayesian-Network-Directed-Models/DeepinScreenshot_select-area_20190302131201.png"><p>每个结点表示一个 CPD，具体的值如下：</p><img src="/2019/02/27/Probabilistic-Graphical-Models-1-Representation-笔记-2-Bayesian-Network-Directed-Models/DeepinScreenshot_select-area_20190302131703.png"><p>这个例子中有 $P(D,I,G,S,L) = P(D) P(I) P(G|I,D) P(S|I) P(L|G)$。</p><h3 id="Reasoning-Patterns"><a href="#Reasoning-Patterns" class="headerlink" title="Reasoning Patterns"></a>Reasoning Patterns</h3><p>贝叶斯网可以用来进行推断。这一节讲了三种推断类型。</p><h4 id="Causal-Reasoning"><a href="#Causal-Reasoning" class="headerlink" title="Causal Reasoning"></a>Causal Reasoning</h4><p>给定原因，研究结果。在贝叶斯图网上表现为给定了结点的情况，求它后继结点的情况。例如，在上一节的例子中，如果没给定学生的其它信息，那么拿到推荐信的概率是一个值 $p$；但是一旦给定学生不够聪明这一条件，那么拿到推荐信的概率会下降。即 $P(l^1) &gt; P(l^1 | i^0)$。</p><h4 id="Evidential-Reasoning"><a href="#Evidential-Reasoning" class="headerlink" title="Evidential Reasoning"></a>Evidential Reasoning</h4><p>给定结果，研究原因。在贝叶斯图网上表现为给定了结点的情况，求它前驱结点的情况。例如，在上一节的例子中，如果没有任何其它信息，那么学生是聪明的概率是一个值 $p$；但是一旦给定课程成绩为 C 这一条件，那么学生是聪明的概率会下降。即 $P(i^1) &gt; P(i^1 | g^3)$。</p><h4 id="Intercausal-Reasoning"><a href="#Intercausal-Reasoning" class="headerlink" title="Intercausal Reasoning"></a>Intercausal Reasoning</h4><p>这个 reasoning 很有意思。已经知道了 $P(i^1) &gt; P(i^1 | g^3)$，如果这时再给定课程的难度很难，那么学生是聪明的概率又会上升，即 $P(i^1 | g^3, d_1) &gt; P(i^1 | g^3)$。有趣的是，在贝叶斯网中，并没有从难度指向智商的边，但是它依然能够施加影响。（贝叶斯网中的边指的是一个随机变量的分布会受到另一个的影响。）</p><hr><p>考虑最简单的等价情况：</p><img src="/2019/02/27/Probabilistic-Graphical-Models-1-Representation-笔记-2-Bayesian-Network-Directed-Models/DeepinScreenshot_select-area_20190302134716.png"><p>在此例子中，$x_1$ 和 $x_2$ 是独立的，但是如果给定 $y = 1$，那么它们就不独立了，一个的取值会影响到另一个。这就解释了前面的现象。</p><hr><p>另外一个例子是在给定了课程成绩的情况下可以计算课程难度的概率。但是又给定了 SAT 分数的情况下，课程难度的分布会发生变化。从 intercausal reasoning 可以看出给定一个结点的取值后施加在其它结点上的影响是可以沿着边（顺或者逆）多跳传播的。</p><h3 id="Flow-of-Probabilistic-Influence"><a href="#Flow-of-Probabilistic-Influence" class="headerlink" title="Flow of Probabilistic Influence"></a>Flow of Probabilistic Influence</h3><p>给定一个结点的值（又称确定了观测值），那么其它结点的 <strong>边际分布</strong> 会受到影响。</p><h4 id="无观测情况下结点间的影响"><a href="#无观测情况下结点间的影响" class="headerlink" title="无观测情况下结点间的影响"></a>无观测情况下结点间的影响</h4><p>用 $A\to B$ 表示 $A$ 是 $B$ 的直接前驱。</p><p>这几种情况下给定 $X$ 会影响到 $Y$ 的分布：</p><ul><li>$X \to Y$</li><li>$X \leftarrow Y$</li><li>$X \to Z \to Y$</li><li>$X \leftarrow Z \leftarrow Y$</li><li>$X \leftarrow Z \to Y$（给定 $X$ 会影响 $Z$，进而影响 $Y$）</li></ul><p>唯一一种没有影响的情况是 $X \to Z \leftarrow Y$，给定 $X$ 会影响 $Z$ 的分布，但是不会影响 $Y$ 的分布。这和上一节的 intercausal reasoning 情况不同。这样的结构称作 <strong>V-structure</strong>。</p><h4 id="有观测情况下结点间的影响"><a href="#有观测情况下结点间的影响" class="headerlink" title="有观测情况下结点间的影响"></a>有观测情况下结点间的影响</h4><p>如果贝叶斯网中给定了一个结点的集合，这个集合中的结点的情况已经给定了，那么影响情况会发生改变。</p><p>以下两种情况，$X$ 和 $Y$ 总是会发生影响的，不管其它结点的情况是否给定：</p><ul><li>$X \to Y$</li><li>$X \leftarrow Y$</li></ul><p>以下三种情况，在 $Z$ 没给定的情况下 $X$ 可以影响 $Y$，但是 $Z$ 给定时就不能影响了：</p><ul><li>$X \to Z \to Y$</li><li>$X \leftarrow Z \leftarrow Y$</li><li>$X \leftarrow Z \to Y$</li></ul><p>最复杂的情况是 V-structure 的情况，对于 $X \leftarrow Z \to Y$，如果 $Z$ 给定了，就是 intercausal reasoning 对应的情形，$X$ 可以影响 $Y$；即使 $Z$ 没有给定，只要它的任意一个后继结点给定了，也是 intercausal reasoning 的情形，依然可以发生影响；只有 $Z$ 及其任意的后继结点都没有给定，才无法影响。</p><h4 id="Active-Trails"><a href="#Active-Trails" class="headerlink" title="Active Trails"></a>Active Trails</h4><p>一条 active trail 是若干结点的路径。路径是 active trail 要满足：</p><ul><li>所有的 V-structure $X \to Z \leftarrow Y$，$Z$ 或者其后继结点中至少有一个取值要给定；</li><li>路径上其它所有结点取值都没给定。</li></ul><p>结点间的影响只能通过 active trail 传播。</p><h2 id="Bayesian-Networks-Independencies"><a href="#Bayesian-Networks-Independencies" class="headerlink" title="Bayesian Networks: Independencies"></a>Bayesian Networks: Independencies</h2><h3 id="Conditional-Independence"><a href="#Conditional-Independence" class="headerlink" title="Conditional Independence"></a>Conditional Independence</h3><h4 id="非条件独立"><a href="#非条件独立" class="headerlink" title="非条件独立"></a>非条件独立</h4><p>事件 $X$ 和 $Y$ 独立（记作 $X \bot Y$），如果 $P(X, Y) = P(X) P(Y)$ 或者 $P(X | Y) = P(X)$。</p><p>对于随机变量的情况定义类似。</p><h4 id="条件独立"><a href="#条件独立" class="headerlink" title="条件独立"></a>条件独立</h4><p>事件 $X$ 和 $Y$ 在给定条件 $Z$ 下独立（记作 $X \bot Y | Z$），如果 $P(X, Y | Z) = P(X | Z) P(Y | Z)$ 或者 $P(X | Y, Z) = P(X | Z)$。</p><p>对于随机变量的情况定义类似。</p><p>在条件下独立应该验证条件的所有取值。如果要证明变量 $X$ 和 $Y$ 在给定随机变量 $Z$ 时独立，应该要验证 $Z$ 的所有取值。</p><h3 id="Independencies-in-Bayesian-Networks"><a href="#Independencies-in-Bayesian-Networks" class="headerlink" title="Independencies in Bayesian Networks"></a>Independencies in Bayesian Networks</h3><h4 id="d-separated"><a href="#d-separated" class="headerlink" title="d-separated"></a>d-separated</h4><p>贝叶斯网中的 active trail 和条件独立联系紧密。在给定取值一致的结点集合 $Z$ 的情况下，如果结点 $X$ 和 $Y$ 之间没有 active trail，则称它们是 d-separated 的，记作 $\text{d-sep}_G(X, Y | Z)$。</p><p><strong>定理</strong>：如果 $P$ factorizes over $G$，$\text{d-sep}_G(X, Y | Z)$，那么在 $P$ 下有 $X\bot Y | Z$。</p><p>对于结点 $X$，如果给定了它的所有直接前驱，那么对于任意一个不是它直接前驱也不是它任意后继的结点 $Y$，有 $X$ 和 $Y$ d-separated。于是 $X$ 和 $Y$ 是独立的。直观来看，这说明如果不给定一个结点的后继结点的情况，那么这个结点的取值只依赖于直接前驱结点。</p><h4 id="I-map"><a href="#I-map" class="headerlink" title="I-map"></a>I-map</h4><p>一张贝叶斯网中所有的 d-separated 的情况的集合为这张网 $G$ 的 $I(G)$：</p><script type="math/tex; mode=display">I(G) = \{(X\bot Y | Z) | \text{d-sep}_G(X, Y | Z)\}</script><p><strong>定义</strong>：如果概率分布 $P$ 满足 $I(G)$，那么 $G$ 称为 $P$ 的 I-map。（相当于概率分布的贝叶斯网表示。）</p><p><strong>定理（从独立性到分解）</strong>：如果 $P$ factorizes over $G$，那么 $G$ 是 $P$ 的 I-map。</p><p><strong>定理（从分解到独立性）</strong>：如果 $G$ 是 $P$ 的 I-map，那么 $P$ factorizes over $G$。</p><p>这说明贝叶斯网本质上和可以概率分布的独立性是等价的。贝叶斯网可以编码概率分布中那些独立变量的关系，反过来给定一个联合概率分布也可以使用贝叶斯网编码其中的那些独立变量的关系。</p><hr><p>这一节最重要的结论是：</p><ul><li>如果 $P$ factorizes over $G$，$\text{d-sep}_G(X, Y | Z)$，那么在 $P$ 下有 $X\bot Y | Z$。</li><li>贝叶斯网可以表示联合概率分布中的独立变量。</li></ul><h3 id="Naive-Bayes"><a href="#Naive-Bayes" class="headerlink" title="Naive Bayes"></a>Naive Bayes</h3><p>贝叶斯网的一个应用是朴素贝叶斯。这个模型对变量之间的相关性作了一些假设，导致计算变得更加容易。朴素贝叶斯一般用来分类，它的图长这样：</p><img src="/2019/02/27/Probabilistic-Graphical-Models-1-Representation-笔记-2-Bayesian-Network-Directed-Models/DeepinScreenshot_select-area_20190302165520.png"><p>其中 $X_1$ 等都是 feature。朴素贝叶斯的假设就是在给定了类型的情况下，各个 feature 出现的概率是独立的。（从图中可以看出。）</p><p>使用贝叶斯公式，得到：</p><script type="math/tex; mode=display">P(C = c^1 | X_1 = x_1, \dots, X_n = x_n) = \frac{P(C = c^1)\prod_iP(X_i = x_i|c = c^1)}{\prod_i P(X_i = x_i)}</script><p>因为分类时大家分母都是一样的，所以只看分子。</p><p>以文本分类为例，在如何得到 $P(X_i = x_i|c = c^1)$ 这个问题上，有两种方法：</p><ul><li>伯努利朴素贝叶斯（feature 是词典中出现的单词）</li><li>多项式朴素贝叶斯（feature 是样本中出现的单词）</li></ul><h2 id="Bayesian-Networks-Knowledge-Engineering"><a href="#Bayesian-Networks-Knowledge-Engineering" class="headerlink" title="Bayesian Networks: Knowledge Engineering"></a>Bayesian Networks: Knowledge Engineering</h2><h3 id="Application-Medical-Diagnosis"><a href="#Application-Medical-Diagnosis" class="headerlink" title="Application - Medical Diagnosis"></a>Application - Medical Diagnosis</h3><p>贝叶斯网络的一个应用是医疗诊断。</p><h3 id="Knowledge-Engineering-Example-SAMIAM"><a href="#Knowledge-Engineering-Example-SAMIAM" class="headerlink" title="Knowledge Engineering Example - SAMIAM"></a>Knowledge Engineering Example - SAMIAM</h3><p>SAMIAM 是一个可以进行贝叶斯网络建模的工具。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 概率图模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Probabilistic Graphical Models 1: Representation 笔记 1 Introduction and Overview</title>
      <link href="/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-1-Introduction-and-Overview/"/>
      <url>/2019/02/27/Probabilistic-Graphical-Models-1-Representation-%E7%AC%94%E8%AE%B0-1-Introduction-and-Overview/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction-and-Overview"><a href="#Introduction-and-Overview" class="headerlink" title="Introduction and Overview"></a>Introduction and Overview</h1><h2 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome!"></a>Welcome!</h2><p><em>本节没有问题。</em></p><h2 id="Overview-and-Motivation"><a href="#Overview-and-Motivation" class="headerlink" title="Overview and Motivation"></a>Overview and Motivation</h2><h3 id="PGM-的一些应用"><a href="#PGM-的一些应用" class="headerlink" title="PGM 的一些应用"></a>PGM 的一些应用</h3><p>疾病诊断、图像分割、文本信息提取、传感器数据融合等。</p><h3 id="Probabilistic-Graphical-Models-中各个词的含义"><a href="#Probabilistic-Graphical-Models-中各个词的含义" class="headerlink" title="Probabilistic Graphical Models 中各个词的含义"></a>Probabilistic Graphical Models 中各个词的含义</h3><ul><li><strong>Models</strong>：模型是人类对世界认知的声明式的描述。专家可以导出模型，数据可以让模型学习到参数，最终被多种算法应用。</li><li><strong>Probabilistic</strong>：设计这些模型是为了处理大量的不确定性。不确定性来自于对世界的不完全认知、观测噪声、建模的不完全性和世界的随机性。</li><li><strong>Graphical</strong>：使用图建模可以处理含有大量变量的复杂系统。使用图建模直观而易于解释。</li></ul><h3 id="贝叶斯网与马尔科夫网"><a href="#贝叶斯网与马尔科夫网" class="headerlink" title="贝叶斯网与马尔科夫网"></a>贝叶斯网与马尔科夫网</h3><p>贝叶斯网和马尔科夫网都是图，每个节点表示一个随机变量，节点之间的边表示关联。区别在于 <strong>贝叶斯网是有向的，马尔科夫网是无向的</strong>。</p><p>在前面的应用中，疾病诊断适合贝叶斯网，图像分割适合马尔科夫网。</p><a id="more"></a><h3 id="PGM-学习的三个方面"><a href="#PGM-学习的三个方面" class="headerlink" title="PGM 学习的三个方面"></a>PGM 学习的三个方面</h3><ul><li><strong>Representation</strong>：有向图/无向图建模、空间/时间建模。</li><li><strong>Inference</strong>：作出精确或估计的决策。</li><li><strong>Learning</strong>：在完整或不完整的情况下学习模型的结构与参数。</li></ul><h2 id="Distributions"><a href="#Distributions" class="headerlink" title="Distributions"></a>Distributions</h2><h3 id="联合分布"><a href="#联合分布" class="headerlink" title="联合分布"></a>联合分布</h3><p>多个随机变量的分布同时考虑起来为联合分布，联合分布是一个概率分布。</p><p>独立参数是分布不受其它参数影响的参数。</p><h3 id="在联合分布上的操作"><a href="#在联合分布上的操作" class="headerlink" title="在联合分布上的操作"></a>在联合分布上的操作</h3><ul><li><strong>Reduction</strong>：联合分布中，如果已经知道某个变量的取值情况，就可以删掉一些不可能出现的情况。</li><li><strong>Renormalization</strong>：Reduction 完成后概率和不为 1，重新进行归一化，将这些概率都除以它们的和。</li><li><strong>Marginalization</strong>：从联合分布得到边缘分布的过程。</li></ul><h2 id="Factors"><a href="#Factors" class="headerlink" title="Factors"></a>Factors</h2><h3 id="Factor"><a href="#Factor" class="headerlink" title="Factor"></a>Factor</h3><p>Factor 是一个函数，它以多个随机变量为参数。它将这些随机变量的赋值映射到一个实数：</p><script type="math/tex; mode=display">\phi(X_1, \dots, X_k) \to \R</script><p>Factor 的 scope 是作为其参数的随机变量的集合：</p><script type="math/tex; mode=display">\text{scope}(\phi) = \{X_1,\dots, X_k\}</script><p>联合分布、经过 reduction 之后的联合分布、条件分布都可以看作是 Factor。Factor 不要求在所有可能取值下得到的实数加和为 1，任意值都行。</p><h3 id="Factor-的运算"><a href="#Factor-的运算" class="headerlink" title="Factor 的运算"></a>Factor 的运算</h3><ul><li><p><strong>Product</strong>：两个 factor 的积的 scope 是二者 scope 的并，取值是二者对应取值的积，例如：</p><script type="math/tex; mode=display">\begin{aligned}&&\phi_1(X = a, Y = b) &= v_1 \\&&\phi_2(Y = b, Z = c) &= v_2 \\&\Rightarrow&\phi'(X = a, Y = b, Z = c) &= v_1\cdot v_2 \end{aligned}</script></li><li><p><strong>Marginalization</strong>：将 factor 中某个参数从 scope 中去掉，假设 $X$ 只可能取 $a_1$ 和 $a_2$：</p><script type="math/tex; mode=display">\begin{aligned}&&\phi(X = a_1, Y = b) &= v_1 \\&&\phi(X = a_2, Y = b) &= v_2 \\&\Rightarrow& \phi'(Y = b) &= v_1 + v_2\\\end{aligned}</script></li><li><p><strong>Reduction</strong>：只保留 factor 中的某个参数取单个值的情况，下面例子中只保留 $X$ 取 $a_1$ 的情况：</p><script type="math/tex; mode=display">\begin{aligned}&&\phi(X = a_1, Y = b_1) &= v_1 \\&&\phi(X = a_1, Y = b_2) &= v_2 \\&&\phi(X = a_2, Y = b_1) &= v_3 \\&&\phi(X = a_2, Y = b_2) &= v_4 \\&\Rightarrow& \phi'(Y = b_1) &= v_1 \\&& \phi'(Y = b_2) &= v_2 \\\end{aligned}</script></li></ul><p>Factor 的 marginalization 和 reduction 与联合分布中的很像。</p><h3 id="为何使用-factor"><a href="#为何使用-factor" class="headerlink" title="为何使用 factor"></a>为何使用 factor</h3><p>Factor 是在高维空间中定义分布的重要工具。它的运算可以对分布进行各种变换。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 概率图模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Structuring Machine Learning Projects 笔记 2 ML Strategy (2)</title>
      <link href="/2019/02/24/Structuring-Machine-Learning-Projects-%E7%AC%94%E8%AE%B0-2-ML-Strategy-2/"/>
      <url>/2019/02/24/Structuring-Machine-Learning-Projects-%E7%AC%94%E8%AE%B0-2-ML-Strategy-2/</url>
      
        <content type="html"><![CDATA[<h1 id="ML-Strategy-2"><a href="#ML-Strategy-2" class="headerlink" title="ML Strategy (2)"></a>ML Strategy (2)</h1><h2 id="Error-Analysis"><a href="#Error-Analysis" class="headerlink" title="Error Analysis"></a>Error Analysis</h2><h3 id="Carrying-out-error-analysis"><a href="#Carrying-out-error-analysis" class="headerlink" title="Carrying out error analysis"></a>Carrying out error analysis</h3><p>对于分类任务来说，如果测试集上的效果不好，可以找到那些分错类的样本，看看他们的共性是什么，然后单独训练一个专门负责这个的分类器。</p><p>在查看共性时应当找到出现最多的共性。假设有一个将动物中的猫寻找出来的分类器，错误率是 10%，有些错误是将狗分类为了猫。如果在分类错误的样本中狗只占到了 5%，那么即使有专门的分类器处理这个情况，错误率也只能从 10% 降低到 9.5%，这是理论的错误值下限。找到分类错误的样本中那些占比较高的错误类别并进行处理的效果更好。</p><h3 id="Cleaning-up-incorrectly-labeled-data"><a href="#Cleaning-up-incorrectly-labeled-data" class="headerlink" title="Cleaning up incorrectly labeled data"></a>Cleaning up incorrectly labeled data</h3><p>在分类器分类错误的那些样本中，当 train 集中的样本出现标注错误时，如果只是很少部分的样本标注错误可以不用管，因为算法本身对这种随机误差是鲁棒的。但是当 train 集中存在系统性的标注错误时，应当修正这些错误。</p><p>在分类器分类错误的那些样本中，当 dev/test 集中的样本出现标注错误时，先估计一下这些错误是否会影响到测试集的功能。如果分类器本身错误率为 10%，标注错误的样本占总样本的 5%，说明即使修正后，错误率最低也只能降到 9.5%。如果对于问题而言这种错误率的下降无关紧要，那么可以不用管；但是如果影响到了测试集的功能（可能错误地选出更好的模型）就应该修正这一错误。当修正了 dev 集中的错误后，为了保证 dev 集和 test 集依然同分布应当再修正 test 集中的错误。当修正完成后，训练集和测试集的分布可能轻微不同。</p><p>在分类器分类正确的那些样本中也可以进行对应的修正。但是因为这个的数据规模会比分类错误的数据规模大很多，所以经常跳过。</p><a id="more"></a><h3 id="Build-your-first-system-quickly-then-iterate"><a href="#Build-your-first-system-quickly-then-iterate" class="headerlink" title="Build your first system quickly, then iterate"></a>Build your first system quickly, then iterate</h3><p>当要完成一项实际任务时，应当尽快搭建出原型系统然后开始迭代，具体步骤：</p><ol><li>分割训练集、测试集；设定性能指标</li><li>构建原型系统</li><li>进行 Bias/Variance 分析；进行错误分析（上两节的内容）然后决定下一步怎么做</li></ol><p>很多情况下会高估问题的难度，因此从简单的模型开始是更好的。</p><h2 id="Mismatched-training-and-dev-test-set"><a href="#Mismatched-training-and-dev-test-set" class="headerlink" title="Mismatched training and dev/test set"></a>Mismatched training and dev/test set</h2><h3 id="Training-and-testing-on-different-distributions"><a href="#Training-and-testing-on-different-distributions" class="headerlink" title="Training and testing on different distributions"></a>Training and testing on different distributions</h3><p>如果数据由非实际数据和实际数据组成，当非实际数据和实际应用数据分布不同时，对训练集和测试集的分割比较讲究。这种情况出现于用于非实际数据容易获得，但是实际应用数据暂时难以获得。</p><p>例如小猫图片分类器中，应用可能是让用户拍照上传，然后判断这是否是一只猫。非实际数据可从网上爬取获得，实际数据是用户拍摄的，二者质量不同，因此分布不同。</p><p>为了保证最后获得的是符合目的模型，应当将所有的非实际数据全部放入 train 集中，将实际数据中的一部分放入 train 集中，剩下一部分构成 dev 和 test 集。需要保证 dev 和 test 集的内容和最后要应用的数据分布相同。</p><h3 id="Bias-and-Variance-with-mismatched-data-distributions"><a href="#Bias-and-Variance-with-mismatched-data-distributions" class="headerlink" title="Bias and Variance with mismatched data distributions"></a>Bias and Variance with mismatched data distributions</h3><p>当采用上一节的方法时，会出现一个问题：因为训练集和测试集数据分布不同，因此 bias 和 variance 难以度量。当贝叶斯错误率和训练误差接近，而 dev 集误差较大时，并不能知道到底是 variance 的问题，还是数据分布不同造成的问题（data mismatch）。</p><p>可以采用的办法是从 train 集中均匀分出一部分并从 train 集中剔除作为 train-dev 集。这个集合专门用来度量 bias 和 variance。训练时只在 train 集上训练，然后在 train-dev 集、dev 集和 test 集上验证。正常情况下，贝叶斯错误率、train 集错误率、train-dev 集错误率、dev 集错误率、test 集错误率是逐渐上升的。但是如果实际应用比非实际数据学到的东西更简单的话，dev 集错误率和 test 集错误率也可能较低。</p><ul><li>贝叶斯错误率、train 集错误率之差反映了 avoidable bias</li><li>train 集错误率、train-dev 集错误率之差反映了 variance</li><li>train-dev 集错误率、dev 集错误率之差反映了 data mismatch 的程度</li><li>dev 集错误率、test 集错误率之差反映了在 dev 集上的过拟合程度</li></ul><p>通过上述描述可以定位问题所在。</p><h3 id="Addressing-data-mismatch"><a href="#Addressing-data-mismatch" class="headerlink" title="Addressing data mismatch"></a>Addressing data mismatch</h3><p>当 data mismatch 的程度比较严重时，可以考虑向训练集中加入更多符合实际应用数据分布的数据。例如汽车中的语音识别任务，实际数据可能充斥汽车噪声，而非实际数据没有，此时可以向非实际数据中添加额外的模拟汽车噪声（混合噪声和数据）来降低二者之间分布的差异。</p><p>这种策略实际上是人工进行混合。注意人工混合时尽量覆盖数据空间所有可能的取值。如果混合得到的数据只占数据空间中的一个小子集，那么神经网络有过拟合的风险。</p><h2 id="Learning-from-multiple-tasks"><a href="#Learning-from-multiple-tasks" class="headerlink" title="Learning from multiple tasks"></a>Learning from multiple tasks</h2><h3 id="Transfer-learning"><a href="#Transfer-learning" class="headerlink" title="Transfer learning"></a>Transfer learning</h3><p>如果要完成的任务 A 满足以下性质：</p><ul><li>存在一个任务 B，输入和任务 A 相同</li><li>对于任务 B，可以轻松获得大量样本，但是任务 A 不行</li><li>任务 B 的低级特征对任务 A 的学习可能有用</li></ul><p>此时可以考虑使用 transfer learning。首先使用神经网络完成任务 B。在完成后，去掉网络的最后一层，此时有几种选择：</p><ul><li>添加新的一层或多层，然后对任务 A 进行训练。训练时只调整新添的这几层的权值。</li><li>添加新的一层或多层，然后对任务 A 进行训练。训练时调整所有的权值。</li></ul><p>在第二种情况下，对任务 B 的学习又称 pre-training，对任务 A 的学习又称 fine tuning。</p><p>当任务 A 的数据比任务 B 的数据更加珍贵并且量很少的时候，这么做是合理的。这可以充分利用任务 B 学到的网络能够提取出的低级特征。但是如果任务 A 的数据量已经很大了，这么做不是合理的。</p><h3 id="Multi-task-learning"><a href="#Multi-task-learning" class="headerlink" title="Multi-task learning"></a>Multi-task learning</h3><p>如果有多个任务需要完成（记作 $A_1, A_2, \dots, A_n$），它们的输入性质相同，并且彼此之间的低级特征对其它任务可能有用，此时可以考虑使用 multi-task learning。典型的例子是视觉中检测不同种类的物体（任务 $A_1$ 可能是检测行人、任务 $A_2$ 可能是检测车辆） 。</p><p>使用普通神经网络时，最终输出 $\hat y$ 是一个标量（或者将要进行 softmax 的向量） 。使用 multi-task learning 时，最终的输出是一个向量，每个分量对应一个任务。训练时，所有任务的样本全部都可以用于训练，不同任务共享网络的前面的部分，直到最后的输出才有所不同。优化的目标函数是</p><script type="math/tex; mode=display">J = \sum\limits_{i = 1}^m\sum\limits_{j = 1}^nL(\hat y^{(i)}_j, y^{(i)}_j)</script><p>Multi-task learning 一般使用在每个任务的数据量差不多的情况下。即使对于某个任务而言它只在自己对应的数据集上有标注，从而导致整体数据集中出现了一些残缺的标注也是可以工作的。</p><p>Multi-task learning 的思路和 transfer learning 很相近，但是前者不如后者使用广泛。</p><h2 id="End-to-end-deep-learning"><a href="#End-to-end-deep-learning" class="headerlink" title="End-to-end deep learning"></a>End-to-end deep learning</h2><h3 id="What-is-end-to-end-deep-learning"><a href="#What-is-end-to-end-deep-learning" class="headerlink" title="What is end-to-end deep learning?"></a>What is end-to-end deep learning?</h3><p>以语音识别为例，在深度学习出现之前，处理这个问题的方法是用一群专家首先从音频中提取手工特征，然后提取音素、识别单词，然后得到文字。但是使用深度学习的方法可以一步直接从原始音频得到文字，这种过程称为 end-to-end deep learning，它跳过了中间很多需要人手动设计的步骤而直接给出答案。</p><p>但是并非所有的任务都可以适合使用端到端的学习。例如一个需要采集图片然后决定是否放行的闸机，如果先使用一个算法提取出相机中的人脸部分，然后使用深度学习的方法判断这张脸是否是合法身份的，就比直接让网络学习从相机图像映射到是否放行要容易很多。</p><h3 id="Whether-to-use-end-to-end-deep-learning"><a href="#Whether-to-use-end-to-end-deep-learning" class="headerlink" title="Whether to use end-to-end deep learning"></a>Whether to use end-to-end deep learning</h3><p>使用端到端学习的好处：</p><ul><li>网络可以学习到任意的原始数据的表示。在语音识别任务中，“音素”概念是人类发明的概念，是某种对语音的表示，但是使用端到端的学习，机器可能可以学到更好的中间表示。</li><li>需要更少的手工特征。</li></ul><p>坏处：</p><ul><li>需要大量数据。如果拆分成多步的话每一步需要的数据可能较少，因为任务相对简单。</li><li>无法使用手工特征中的经由专家经验得到的特征。</li></ul><p>很多问题并不适合端到端的学习，这些问题应该具体分析后拆分成多个容易的任务。</p><hr><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Structuring Machine Learning Projects 笔记 1 ML Strategy (1)</title>
      <link href="/2019/02/24/Structuring-Machine-Learning-Projects-%E7%AC%94%E8%AE%B0-1-ML-Strategy-1/"/>
      <url>/2019/02/24/Structuring-Machine-Learning-Projects-%E7%AC%94%E8%AE%B0-1-ML-Strategy-1/</url>
      
        <content type="html"><![CDATA[<h1 id="ML-Strategy-1"><a href="#ML-Strategy-1" class="headerlink" title="ML Strategy (1)"></a>ML Strategy (1)</h1><p>来源 <a href="https://www.coursera.org/learn/machine-learning-projects" target="_blank" rel="noopener">Coursera</a>。</p><h2 id="Introduction-to-ML-Strategy"><a href="#Introduction-to-ML-Strategy" class="headerlink" title="Introduction to ML Strategy"></a>Introduction to ML Strategy</h2><h3 id="Why-ML-Strategy"><a href="#Why-ML-Strategy" class="headerlink" title="Why ML Strategy"></a>Why ML Strategy</h3><p>当有一个任务需要完成的时候，如果效果不好可能需要进行相关调整和修改。如何找到关键的影响因素需要知道 ML 中的策略。</p><h3 id="Orthogonalization"><a href="#Orthogonalization" class="headerlink" title="Orthogonalization"></a>Orthogonalization</h3><p>如果任务有多个性能指标需要调整，同时有多个因素可以被调节，那么较好的情况是这些因素对结果的影响是正交的，对单个因素的调节应当只影响某个性能指标。</p><p>ML 中的性能指标有：</p><ul><li>train 集上的表现</li><li>dev 集上的表现</li><li>test 集上的表现</li><li>实际产品的表项</li></ul><p>对于第一个指标，可以调节网络规模、优化器选择等；对于第二个指标，可以调节正则化方法、使用更大的 train 集等；对于第三个指标，可以使用更大的 dev 集等；对于第四个指标，可以尝试修改代价函数（就是重新定义问题）。</p><p><em>Early stop 是一个正交的反例——它同时影响了 train 和 test 集上的性能。</em></p><a id="more"></a><h2 id="Setting-up-your-goal"><a href="#Setting-up-your-goal" class="headerlink" title="Setting up your goal"></a>Setting up your goal</h2><h3 id="Single-number-evaluation-metric"><a href="#Single-number-evaluation-metric" class="headerlink" title="Single number evaluation metric"></a>Single number evaluation metric</h3><p>如果有多个算法或者模型需要进行选择，最好在任务开始前定义一个能够用标量表示的性能指标。用这个指标衡量算法性能能够快速判断两个算法哪个更优。</p><p><strong>例子</strong>：设计了一个分类器，它的评判标准有 <strong>准确率</strong> 和 <strong>召回率</strong>，这两者一般不能做到都高，因此引入它们的调和平均数（<strong>F1 score</strong>）来衡量这个分类器的效果。</p><h3 id="Satisfying-and-Optimizing-metric"><a href="#Satisfying-and-Optimizing-metric" class="headerlink" title="Satisfying and Optimizing metric"></a>Satisfying and Optimizing metric</h3><p>如果上述方法难以实现，可以尝试将性能指标分为 <strong>satisfying</strong> 性质的和 <strong>optimizing</strong> 性质的。其中 satisfying 性质的是只要满足某个阈值即可的，optimizing 性质的是需要尽可能好的。</p><p>仍然以分类器为例，准确率可能是需要看重的，是 optimizing 性质的。而分类单个样本的时间可能不是很敏感，低于 100 毫秒即可，这种就是 satisfying 性质的。训练时在满足 satisfying 性质的指标前提下优化 optimizing 性质的目标即可。</p><h3 id="Train-dev-test-distributions"><a href="#Train-dev-test-distributions" class="headerlink" title="Train/dev/test distributions"></a>Train/dev/test distributions</h3><p>Dev  集和 test 集应当尽量贴近于最后应用时的数据来源，并且二者分布应当一直。否则可能出现在 dev 集上效果很好但是在 test 集上效果突然变差的情况，这就表明最后的实际应用结果可能不好。</p><h3 id="Size-of-the-dev-and-test-sets"><a href="#Size-of-the-dev-and-test-sets" class="headerlink" title="Size of the dev and test sets"></a>Size of the dev and test sets</h3><p>当用于训练和评测数据量非常大时（典型数量级 $10^6$），分配用于训练的数据和用于测试的数据的比例相差会很大。好的做法是将大量的数据用于训练，测试方面只要达到满足评测目的最小数目就行了。在 $10^6$ 量级下，典型做法是把 99% 的数据用于测试，1% 用于评测。</p><p>Dev 集和 test 集功能不同，尽管很多人都搞混了。人们常说的 train/test 集分割实际上指的是 train/dev 集分割，并且这些任务中没有 test 集。</p><h3 id="When-to-change-dev-test-sets-and-metrics"><a href="#When-to-change-dev-test-sets-and-metrics" class="headerlink" title="When to change dev/test sets and metrics"></a>When to change dev/test sets and metrics</h3><p>正常情况下，在 dev 和 test 集上跑出来的指标应该和算法的好坏是严格正相关的。如果发现高指标的算法的实际效果还不如低指标的算法，就应考虑换 dev/test 集或者更换指标（毕竟指标是用来评价算法的质量的）。</p><p>一个调整指标的例子：</p><p>一般情况下，我们使用错误率来衡量一个分类器的性能，假设这个分类器对样本分类并将一类作为最终结果：</p><script type="math/tex; mode=display">Error = \frac{1}{m}\sum\limits_{i = 1}^mI\{y^{(i)}_{predict}\neq y^{(i)}\}</script><p>但是如果分类任务中有些样本我们非常不希望它们出现在最终结果中，但是分类器错误地将这些样本展示在了结果中，则可以考虑使用加权了的错误率：</p><script type="math/tex; mode=display">Error = \frac{1}{\sum_{i = 1}^m w_i}\sum\limits_{i = 1}^mw_iI\{y^{(i)}_{predict}\neq y^{(i)}\}</script><p>如果不希望样本出现，将 $w_i$ 设大即可。这么做对训练没有影响，只能帮助我们找出更加符合需要的模型。</p><hr><p>这是另一个正交化的例子。在很多任务中都可以（1）预先定义一个好的指标，然后（2）将这个指标作为目标进行优化。第（1）步和第（2）步是正交的。</p><hr><p>如果模型在 dev 集和 test 集上面的表现都很好，但是在实际应用中效果不够好，说明 dev 和 test 集选择有问题或者指标定义有问题，应该进行修改。</p><h2 id="Comparing-to-human-level-performance"><a href="#Comparing-to-human-level-performance" class="headerlink" title="Comparing to human-level performance"></a>Comparing to human-level performance</h2><h3 id="Why-human-level-performance"><a href="#Why-human-level-performance" class="headerlink" title="Why human-level performance?"></a>Why human-level performance?</h3><p>对于一项任务，以分类器为例，其性能有两个比较关键的节点：</p><ul><li>人类能够做到的准确率</li><li>理论上的最高准确率（对应贝叶斯错误率），不可能超过该准确率（除非发生过拟合）</li></ul><p>在没有达到人类能够做到的准确率之前的工作是相对容易的，因为可以直接用人力来分析算法中的不足。但是一旦超过之后进展会开始变得缓慢。在逼近贝叶斯错误率之前会变得更加缓慢。一部分原因也是因为人类的结果本身已经比较接近贝叶斯错误率了，没有多少提升空间。</p><h3 id="Avoidable-bias"><a href="#Avoidable-bias" class="headerlink" title="Avoidable bias"></a>Avoidable bias</h3><p>模型的 train 集性能和贝叶斯错误率之间的差值称为 avoidable bias，这个 bias 是可以通过更好的算法避免掉的。</p><p>当知道了人类能够做到的准确率（可以直接认为是贝叶斯错误率）、train 集上的准确率和 dev 集上的准确率后，如果：</p><ul><li>train 集准确率明显比人类准确率低，表明 bias 较高，此时应该尝试优化 bias（例如修改网络结构）</li><li>train 集准确率和人类相近，但是 dev 准确率明显较低，表明 variance 较高，此时应该优化 variance（例如加上各种正则化方法）</li></ul><h3 id="Understanding-human-level-performance"><a href="#Understanding-human-level-performance" class="headerlink" title="Understanding human-level performance"></a>Understanding human-level performance</h3><p>在使用人类准确率估计贝叶斯错误率时，应当采用人类能够做到的最高准确率：如果一个专家的结果比普通人要好，一群专家的结果比一个专家要好，那么应该采用一群专家的结果作为贝叶斯错误率的估计。</p><p>在训练过程中，一般有贝叶斯错误率（记作 $E_b$）、train 集误差（记作 $E_t$）和 dev 集误差（记作 $E_d$）三个量，并且 $E_b &lt; E_t &lt; E_d$。可以通过比较 $E_d - E_t$ 和 $E_t - E_b$ 的大小来决定要优化 bias 还是 variance。但是随着 $E_t$ 减小，由于不能精确地从人类准确率估计贝叶斯错误率，这时 $E_b$ 实际上不是准的。当任务的性能已经足够好的时候， $E_d - E_t$ 和 $E_t - E_b$ 的比较结果很可能是错的。在不知道 $E_b$ 到底是多少的情况下没法知道任务是否已经快接近理论上的极限了，则从一定程度上可以解释为什么后期任务会更加难以完成。</p><h3 id="Surpassing-human-level-performance"><a href="#Surpassing-human-level-performance" class="headerlink" title="Surpassing human-level performance"></a>Surpassing human-level performance</h3><p>在非 natural perception task 上，神经网络可以比较轻松地超过人类的表现，这种任务一般使用结构化数据，例如在线广告和推荐系统。但是在 natural perception task 上难以超过，例如语音识别。（尽管如此，在某些情况下，神经网络也在 natural perception task 上超过了人类的表现。）</p><p>当超过了人类的表现之后就没法用上一节的内容来判断接下来该往哪个方向努力了，因为此时 test 的错误率介于贝叶斯错误率和人类误差之间，而贝叶斯错误率是不知道的，此时就不知道应当减小 bias 还是 variance。</p><h3 id="Improving-your-model-performance"><a href="#Improving-your-model-performance" class="headerlink" title="Improving your model performance"></a>Improving your model performance</h3><p>监督学习的效果好基于两个假设：</p><ul><li>在 train 集上的效果好（表示 avoidable bias 低）</li><li>从 train 集泛化到 dev/test 集的效果好（表示 variance 低）</li></ul><p>为了实现上面两个目的：</p><ul><li><strong>降低 avoidable bias</strong>：尝试更大的网络、训练更长时间或尝试其它优化方法、更改网络结构或使用其它超参数</li><li><strong>降低 variance</strong>：尝试使用更多数据、使用正则化、更改网络结构或使用其它超参数</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part C) 笔记 4 Section 10</title>
      <link href="/2019/02/23/Programming-Languages-Part-C-%E7%AC%94%E8%AE%B0-4-Section-10/"/>
      <url>/2019/02/23/Programming-Languages-Part-C-%E7%AC%94%E8%AE%B0-4-Section-10/</url>
      
        <content type="html"><![CDATA[<h1 id="Section-10"><a href="#Section-10" class="headerlink" title="Section 10"></a>Section 10</h1><h2 id="Subtyping-From-the-Beginning"><a href="#Subtyping-From-the-Beginning" class="headerlink" title="Subtyping From the Beginning"></a>Subtyping From the Beginning</h2><p>接下来的几节中使用了作者自己定义的语言。语言中的记录类型和 ML 很类似，并且是 mutable 的。语法：</p><ul><li><strong>字面量</strong>：<code>e = {f1=e1, f2=e2, ..., fn=en}</code></li><li><strong>读写</strong>：<code>e.f1 = e1</code></li><li><strong>类型标注</strong>：<code>{f1: t1, f2: t2, ..., fn: tn}</code></li></ul><p>这个语言可以建立简单的类型系统，该系统的规则和直觉一致。</p><h3 id="为何引入-subtyping"><a href="#为何引入-subtyping" class="headerlink" title="为何引入 subtyping"></a>为何引入 subtyping</h3><p>假设有这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun distance_to_origin(point: &#123;x: real, y: real&#125;) =</span><br><span class="line">Math.sqrt(point.x * point.x + point.y * point.y)</span><br></pre></td></tr></table></figure><p>当传入 <code>{x=3.0, y=4.0}</code> 时可以通过类型检查，但是假设没有 subtyping，传入 <code>{x=3.0, y=4.0, color=&#39;red&#39;}</code> 不能通过类型检查，但是这样的输入明显是合理的。</p><p>引入 subtyping 就是为了解决这种问题，为静态类型系统提供更高的灵活性。</p><a id="more"></a><h2 id="The-Subtype-Relation"><a href="#The-Subtype-Relation" class="headerlink" title="The Subtype Relation"></a>The Subtype Relation</h2><p>为了引入子类型，加入两条规则：</p><ul><li>将 <code>t1</code> 为 <code>t2</code> 的子类型记作 <code>t1 &lt;: t2</code></li><li>如果 <code>e</code> 的类型是 <code>t1</code>，<code>t1 &lt;: t2</code>，那么 <code>e</code> 也具有 <code>t2</code> 类型</li></ul><p>正确的子类型定义应该保证凡是能够出现 <code>e2</code> 实例的地方，必然也可以使用 <code>e1</code> 进行替换。将 <strong>程序访问或修改一个不存在于记录中的域</strong> 作为一个要拒绝的性质，在引入子类型前，类型系统是可靠的。为了保证引入后类型系统依然可靠，需要继续满足前述性质。为此定义如下的子类型规则：</p><ul><li>如果类型 <code>t1</code> 具有类型 <code>t2</code> 所有的域（并且对应的类型一致），那么 <code>t1 &lt;: t2</code></li><li>如果类型 <code>t1</code> 和 <code>t2</code> 域相同（并且对应的类型一致），但是排序不同，那么 <code>t1 &lt;: t2</code></li><li><strong>自反性</strong>：对任意 <code>t1</code>，有 <code>t1 &lt;: t1</code></li><li><strong>传递性</strong>：对任意 <code>t1</code>，<code>t2</code>，<code>t3</code>，如果 <code>t1 &lt;: t2</code>，<code>t2 &lt;: t3</code>，则 <code>t1 &lt;: t3</code></li></ul><p>按照这个定义可以继续保证类型系统的可靠性，因为对记录的操作只有读和写，而对某个记录的读和写对其子类型也适用。</p><h2 id="Depth-Subtyping"><a href="#Depth-Subtyping" class="headerlink" title="Depth Subtyping"></a>Depth Subtyping</h2><p>假设我们为上述的子类型引入新的定义：</p><ul><li>如果 <code>ta &lt;: tb</code>，那么 <code>{f1: t1, ..., f: ta, ..., fn: tn} &lt;: {f1: t1, ..., f: tb, ..., fn: tn}</code></li></ul><p>按此定义，凡是使用了 <code>circle = {center={x=3.0, y=4.0}, color=&#39;red&#39;}</code> 的地方，都可以使用 <code>sphere = {center={x=3.0, y=4.0, z=5.0}, color=&#39;red&#39;}</code> 进行代替。</p><p><strong>但是这样会导致类型系统不再继续可靠，其原因是可以写出如下代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun setToOrigin (c: &#123;center: &#123;x: real, y: real&#125;, r: real&#125;) =</span><br><span class="line">c.center = &#123;x=0.0, y=0.0&#125;</span><br><span class="line">val sphere: &#123;center: &#123;x: real, y: real, z: real&#125;, r:real&#125;) =</span><br><span class="line">    &#123;center=&#123;x=3.0, y=4.0, z=0.0&#125;, r=1.0&#125;</span><br><span class="line">val _ = setToOrigin(sphere)</span><br><span class="line">val _ = sphere.center.z</span><br></pre></td></tr></table></figure><p>在运行到第四句话的时候会因为不存在 <code>z</code> 域而报错。原因是第三句话的调用将 <code>sphere</code> 变成了一个 <code>circle</code>。</p><p>因此上述定义是不行的。</p><p>不过，可以通过禁止掉 mutation 来保证类型系统继续可靠。简言之，可以做到以下三点中的两点：</p><ul><li>允许 mutation</li><li>允许上述子类型规则</li><li>类型系统是可靠的</li></ul><hr><p><em>出现上述问题是因为可以直接将记录作为值进行赋值。如果赋值语句右边不能是记录，只能逐个域进行赋值是否也能保证类型系统可靠性？不过这样的语言可能用处很小。</em></p><h2 id="Java-C-Arrays"><a href="#Java-C-Arrays" class="headerlink" title="Java/C# Arrays"></a>Java/C# Arrays</h2><p>实际上 Java 中存在上一节的内容中的情况，下面的代码可以通过类型检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Point[] arr)</span> </span>&#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Point();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ColorPoint[] points = <span class="keyword">new</span> ColorPoint[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            points[i] = <span class="keyword">new</span> ColorPoint();</span><br><span class="line">        foo(points);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            System.out.println(points[i].a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test().bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管 <code>ColorPoint &lt;: Point</code>，但是按照上一节的内容，不应有 <code>ColorPoint[] &lt;: Point[]</code>。上面的代码虽然通过了类型检查，但是如果什么都不做的话，在 <code>System.out.println(points[i].a);</code> 这里会出问题。</p><p>Java 为了保证：</p><ul><li>对于 <code>foo.bar</code> 的使用，永远不会出现 <code>foo</code> 没有 <code>bar</code> 这个域的情况。</li><li>数组读取 <code>foo[bar]</code> 中，如果 <code>foo</code> 的类型是 <code>t1[]</code>，那么读取出来的内容一定是 <code>t1</code> 或其子类型。</li></ul><p>对上述情况，Java 在数组写入时会做动态检查：如果有代码 <code>foo[bar] = bazz</code>，除了静态检查外，如果 <code>foo</code> 的动态类型是 <code>t1[]</code>，而 <code>bazz</code> 的动态类型不是 <code>t1</code> 的子类型，就会抛出 <code>ArrayStoreException</code> 异常。</p><hr><p><strong>关于 null</strong>：null 是所有类型的子类型，虽然理论上讲，应该把所有的类型都作为 null 的子类型，但是实现上往往相反。使用 null 会带来运行时性能的损失。</p><p>另一种设计是像 ML 那样引入  <code>Option</code>，而不是用 null。</p><h2 id="Function-Subtyping"><a href="#Function-Subtyping" class="headerlink" title="Function Subtyping"></a>Function Subtyping</h2><p>从维基上抄的，假设有一个类型构造器可以把一个类型 <code>t</code> 构造成另一个类型 <code>g[t]</code></p><ul><li><strong>covariant（协变）</strong>：若 <code>t1 &lt;: t2</code>，则 <code>g[t1] &lt;: g[t2]</code></li><li><strong>contravariant（逆变）</strong>：若 <code>t1 &lt;: t2</code>，则 <code>g[t1] &gt;: g[t2]</code></li></ul><p>对于函数而言，它的参数是逆变的，返回值是协变的，即如果 <code>t1 &lt;: t2</code> 且 <code>t3 &lt;: t4</code>，则</p><ul><li><code>(t1 -&gt; t3) &lt;: (t1 -&gt; t4)</code></li><li><code>(t2 -&gt; t3) &lt;: (t1 -&gt; t3)</code></li></ul><p>例子。假设有一个高阶函数，它的实现是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun foo f x = f x</span><br></pre></td></tr></table></figure><p>考虑科里化</p><ul><li>如果 <code>foo</code> 的签名是 <code>(t1 -&gt; t4) -&gt; t1</code>，那么为 <code>foo</code> 提供 <code>f</code> 参数时可以填入类型为 <code>(t1 -&gt; t3)</code> 的参数，原来会从函数中得到 <code>t4</code>，现在得到的是 <code>t3</code>，更加具体，所以是没问题的。</li><li>如果 <code>foo</code> 的签名是 <code>(t1 -&gt; t3) -&gt; t1</code>，那么为 <code>foo</code> 提供 <code>f</code> 参数时可以填入类型为 <code>(t2 -&gt; t3)</code> 的参数，原来使用 <code>f</code> 时希望 <code>x</code> 是 <code>t1</code>，但是现在只要求 <code>x</code> 是 <code>t2</code> 即可，更加抽象，所以也是可以的。</li></ul><p><strong>这可能比较反直觉，记住函数的参数是逆变的！</strong></p><h2 id="Subtyping-for-OOP"><a href="#Subtyping-for-OOP" class="headerlink" title="Subtyping for OOP"></a>Subtyping for OOP</h2><p>OOP 中的子类型和前面几节的原理类似。将 OOP 语言中的每个类当成一个类型，将继承关系当做是子类型关系。因为继承时会保留所有的成员，所以和之前看到的原理基本相同。</p><p>理论上，可以在子类中对父类的方法进行重写，并且保证参数逆变、返回值协变即可。实际上，在 Java 和 C# 中只支持了返回值协变的重写。如果对参数进行了逆变操作，那么会变成静态的重载，多了一个方法。</p><p>类和类型是两个不同的概念——类是对象行为的描述，子类继承了行为描述并且作了修改；类型是对接口的描述，子类型替换了其中的一些类型。但是大部分 OOP 语言都刻意混淆这两个概念，这种混淆是很方便的。</p><p>最后，一个有趣的事实是，OOP 语言中的方法可以看做是接受特殊参数 <code>self</code> 的函数。前面提到过函数的参数是逆变的，但是 <code>self</code> 是很特殊的参数，在讨论函数的子类型时，它要按照协变来处理！因为这个参数可以访问到类中成员，只有设计成协变的才能继续保证类型系统的可靠性。</p><h2 id="Generics-Versus-Subtyping"><a href="#Generics-Versus-Subtyping" class="headerlink" title="Generics Versus Subtyping"></a>Generics Versus Subtyping</h2><p>泛型和子类型是两种不同的策略，适用于解决不同的问题。二者不是相同的。</p><p>泛型可以用来实现例如泛型高阶函数的功能。FP 和 OOP 中都有泛型的概念。在能够使用泛型的地方使用子类型效果可能不好。例如使用泛型实现容器时，如果使用了子类型，那么存入容器的时候还好，从容器中读取的时候就不知道元素的具体类型是什么，需要作动态类型转换。</p><p>子类型可以用来在需要提供某些信息的地方提供额外的信息。ML 中没有子类型的概念，但是可以模拟出来（传入任意参数，以及对应的 getter）。在能够使用子类型的地方使用泛型效果可能不好。例如写 GUI 程序时，需要的公共功能是能够显示在屏幕上。如果使用了泛型就失去了多态的使用。</p><h2 id="Bounded-Polymorphism"><a href="#Bounded-Polymorphism" class="headerlink" title="Bounded Polymorphism"></a>Bounded Polymorphism</h2><p>使用 bounded polymorphism 可以把泛型和子类型结合起来使用。</p><p>泛型：对于所有的类型 <code>T</code>。</p><p>子类型：对于 <code>A</code> 的子类型 <code>B</code>。</p><p>结合起来：对于 <code>A</code> 的所有任意子类型 <code>T</code>。</p><hr><p>例子：假设要写一个函数，它接受类 <code>A</code> 的列表，并返回过滤后的列表，其签名应该为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;A&gt; <span class="title">foo</span><span class="params">(List&lt;A&gt; xs)</span></span></span><br></pre></td></tr></table></figure><p>但是根据前面 depth subtyping 的知识知道，<code>List&lt;B&gt;</code>  不是 <code>List&lt;A&gt;</code> 的子类型，因此传 <code>List&lt;B&gt;</code> 类型的参数是不好的。在只有 <code>foo</code> 的情况下，无法做到让 <code>foo</code> 接受 <code>List&lt;B&gt;</code> 并保证只返回 <code>List&lt;B&gt;</code>。</p><p>这时就要用到 bounded polymorphism 了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends A&gt; <span class="function">List&lt;T&gt; <span class="title">foo</span><span class="params">(List&lt;T&gt; xs)</span></span></span><br></pre></td></tr></table></figure><p>此时可以做到，只要 <code>T &lt;: A</code>，就能让 <code>foo</code> 在接受 <code>List&lt;T&gt;</code> 的情况下返回 <code>List&lt;T&gt;</code>。</p><hr><p>Programming Languages 所有部分笔记结束。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程语言理论 </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part C) 笔记 3 Section 9</title>
      <link href="/2019/02/23/Programming-Languages-Part-C-%E7%AC%94%E8%AE%B0-3-Section-9/"/>
      <url>/2019/02/23/Programming-Languages-Part-C-%E7%AC%94%E8%AE%B0-3-Section-9/</url>
      
        <content type="html"><![CDATA[<h1 id="Section-9"><a href="#Section-9" class="headerlink" title="Section 9"></a>Section 9</h1><h2 id="OOP-Versus-Functional-Decomposition"><a href="#OOP-Versus-Functional-Decomposition" class="headerlink" title="OOP Versus Functional Decomposition"></a>OOP Versus Functional Decomposition</h2><h3 id="Breaking-things-down"><a href="#Breaking-things-down" class="headerlink" title="Breaking things down"></a>Breaking things down</h3><ul><li>FP 的策略是将程序拆分为若干执行不同功能的函数</li><li>OOP 的策略是将程序拆分为若干类，每个类有各自的行为</li></ul><p>这两种策略是正好相反的。采用哪种方法一般是个人喜好，但是两种不同方式适合于软件不同的扩展方式。</p><h3 id="直观认识"><a href="#直观认识" class="headerlink" title="直观认识"></a>直观认识</h3><p>假设要实现一个简单的解释器，支持三种表达式 <code>Int</code>、<code>Add</code> 和 <code>Negate</code>，每种表达式都支持 <code>eval</code>、<code>toString</code> 和 <code>hasZero</code> 操作。这样就一共要实现 9 个函数。</p><p>可以将这 9 个函数组织到一张表中，每行对应一个表达式类型，每列对应一个操作：</p><div class="table-container"><table><thead><tr><th></th><th><code>eval</code></th><th><code>toString</code></th><th><code>hasZero</code></th></tr></thead><tbody><tr><td><code>Int</code></td><td></td><td></td><td></td></tr><tr><td><code>Add</code></td><td></td><td></td><td></td></tr><tr><td><code>Negate</code></td><td></td><td></td></tr></tbody></table></div><p>使用 FP 的策略：每次实现一个操作（函数），这个函数中通过模式匹配来对不同的类型作出不同的操作。这种情况下，表格中每次被填写了一列。</p><p>使用 OOP 的策略：每次实现一个表达式（类），这个类会继承自一个基类（例如 <code>Expr</code>，但是鸭子类型可以不进行继承），然后通过多态的方式保证每个类能够对同一个操作作出不同响应。这种情况下，表格中每次被填写了一行。</p><a id="more"></a><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><ul><li><p>当要实现一个解释器的时候，可以考虑使用 FP 的策略。</p></li><li><p>当要实现一个图形界面程序的时候，可以考虑使用 OOP 的策略。</p></li></ul><p><em>我认为这是因为解释器中，类型多而操作少；图形界面程序中，操作多而类型少。选择合适的方式可以让要编写的单元数更少。</em></p><h2 id="Adding-Operations-or-Variants"><a href="#Adding-Operations-or-Variants" class="headerlink" title="Adding Operations or Variants"></a>Adding Operations or Variants</h2><p>接着上一节的例子，当要添加新的操作或者表达式时：</p><ul><li><strong>如果使用 FP</strong>，那么在添加新的操作时不会影响到原来的代码，只要从零写一个函数并处理所有已有的表达式即可；在添加新的表达式时，则要在所有的已有函数中添加新的情况（因为使用了模式匹配），不过因为编译器可以对模式匹配的完备性进行检查，所以这件事情只是麻烦，不一定会出错。</li><li><strong>如果使用 OOP</strong>，那么在添加新的操作时要在所有的对象中增加对这种操作的支持（因为使用了多态），不过因为编译器可以检查对抽象类的实例化，所以这件事情只是麻烦，不一定会出错；在添加新的表达式时，只要从零写一个类并支持所有的操作即可。</li></ul><p>从上面的例子可以看到 FP 和 OOP 实际上是在向两个正交的方向解耦问题。你可以通过将来可能要进行何种扩展来选择使用 FP 还是 OOP。</p><p>尽管这两种编程范式在一个方向上扩展容易而另一个方向上扩展困难，但是通过一些模式是可以做到另一个方向上扩展也相对容易的。依然用上一个例子举例：</p><ul><li><strong>如果使用 FP</strong>，在实现基础部分时，给每一个操作函数都加一个额外的 case 用来处理所有其它情况。此后，每当要添加新的表达式，就扩展原有表达式的 datatype，但是约定扩展的时候要为新扩展的表达式提供各种操作的支持，作为回调函数。在每个操作函数的额外 case 中会使用这些回调函数。这实际上是用 FP 实现 OOP。（然而一旦要添加新的操作，就要修改各个新增成员的回调函数。）</li><li><strong>如果使用 OOP</strong>，在实现基础部分时，为每个表达式类使用访问者模式。每个表达式类有一个 <code>accept</code> 方法用来指明访问自己时的行为，然后有一个叫做 <code>Visitor</code> 的接口，需要实现的方法是对各个表达式的 <code>visit</code> 方法。当要添加新操作时就实现 <code>visit</code>，然后实现其中的各种方法即可。（然而一旦要添加新的表达式，就要修改 <code>Visitor</code> 导致大量的访问者类被修改。）</li></ul><p>可见两个方向上都要满足可扩展性是困难的。</p><hr><p>为了可扩展性而写出的代码可读性可能较差，一些语言提供了禁止扩展的方法（ML 中将 datatype 封装为模块、Java 中将类标记为 final）。</p><h2 id="Binary-Methods-with-Functional-Decomposition"><a href="#Binary-Methods-with-Functional-Decomposition" class="headerlink" title="Binary Methods with Functional Decomposition"></a>Binary Methods with Functional Decomposition</h2><p>这一节和下一节是在另一个场景下对 FP 和 OOP 可扩展性的比较。</p><p>假设要扩展加法函数的功能，并加入两个新的表达式 <code>String</code> 和 <code>Rational</code>，使得字符串、分数和整数之间任意两个类型都可以相加（一共有 9 种情况）。</p><p>在 FP 的情况下，需要：</p><ul><li>为所有已经定义的操作添加对 <code>String</code> 和 <code>Rational</code> 的处理；</li><li>改写 <code>Add</code> 的定义。但是在这里可以使用模式匹配来完成“使得字符串、分数和整数之间任意两个类型都可以相加”的需求。</li></ul><p>因为有第二条操作的存在，可以使用模式匹配，所以此时使用 FP 是比较方便的。</p><h2 id="Double-Dispatch"><a href="#Double-Dispatch" class="headerlink" title="Double Dispatch"></a>Double Dispatch</h2><p>OOP 中解决上一节的需求的方法是使用 double dispath。</p><h3 id="不使用-double-dispatch"><a href="#不使用-double-dispatch" class="headerlink" title="不使用 double dispatch"></a>不使用 double dispatch</h3><p>在 FP 中可以把 9 种情况放在一个函数中解决，在 OOP 中如果只使用一次 dynamic dispatch，写出来的代码大概是这样的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyValue</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(other)</span></span></span><br><span class="line">    raise <span class="string">'Not implemented'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInt</span> &lt; MyValue</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(other)</span></span></span><br><span class="line">    <span class="keyword">if</span> other.instance_of? MyInt</span><br><span class="line">      MyInt.new(x + other.x)</span><br><span class="line">    <span class="keyword">elsif</span> other.instance_of? MyString</span><br><span class="line">      MyString.new(x.to_s + other.x)</span><br><span class="line">    <span class="keyword">elsif</span> other.instance_of? MyRational</span><br><span class="line">      MyRational.new(x * other.y + other.x, other.y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &lt; MyValue</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(other)</span></span></span><br><span class="line">    <span class="keyword">if</span> other.instance_of? MyInt</span><br><span class="line">      MyString.new(x + other.x.to_s)</span><br><span class="line">    <span class="keyword">elsif</span> other.instance_of? MyString</span><br><span class="line">      MyString.new(x + other.x)</span><br><span class="line">    <span class="keyword">elsif</span> other.instance_of? MyRational</span><br><span class="line">      MyString.new(x + other.to_s)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRational</span> &lt; MyValue</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span>, <span class="symbol">:y</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x, y)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">    @y = y</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">"<span class="subst">#&#123;x&#125;</span>/<span class="subst">#&#123;y&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(other)</span></span></span><br><span class="line">    <span class="keyword">if</span> other.instance_of? MyInt</span><br><span class="line">      MyRational.new(y * other.x + x, y)</span><br><span class="line">    <span class="keyword">elsif</span> other.instance_of? MyString</span><br><span class="line">      MyString.new(to_s + other.x)</span><br><span class="line">    <span class="keyword">elsif</span> other.instance_of? MyRational</span><br><span class="line">      MyRational.new(x * other.y + y * other.x, y * other.y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>尽管在不知道 <code>x</code> 和 <code>y</code> 的类型的情况下计算 <code>x.add y</code> 时确实使用了一次 dynamic dispatch，但在每个 <code>add</code> 实现中需要对 <code>y</code> 的类型进行分类。这么做实际上 <strong>混合了 OOP 和 FP 的风格</strong>（<code>add</code> 的实现可以看作是某种不优雅的模式匹配），不推荐这么做。</p><h3 id="使用-double-dispatch"><a href="#使用-double-dispatch" class="headerlink" title="使用 double dispatch"></a>使用 double dispatch</h3><p>Double dispatch 的思路就是对于上面那种要判断类型然后采用不同行为的代码，使用多态达到这一点。之所以叫 double dispatch 是因为进行了两次 dynamic dispatch。代码会变成：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyValue</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(other)</span></span></span><br><span class="line">    other.add <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addInt</span><span class="params">(_other)</span></span></span><br><span class="line">    raise <span class="string">'Not implemented'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addString</span><span class="params">(_other)</span></span></span><br><span class="line">    raise <span class="string">'Not implemented'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addRational</span><span class="params">(_other)</span></span></span><br><span class="line">    raise <span class="string">'Not implemented'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInt</span> &lt; MyValue</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addInt</span><span class="params">(other)</span></span></span><br><span class="line">    MyInt.new(other.x + x)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addString</span><span class="params">(other)</span></span></span><br><span class="line">    MyString.new(other.x + x.to_s)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addRational</span><span class="params">(other)</span></span></span><br><span class="line">    MyRational.new(x * other.y + other.x, other.y)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &lt; MyValue</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addInt</span><span class="params">(other)</span></span></span><br><span class="line">    MyString.new(other.x.to_s + x)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addString</span><span class="params">(other)</span></span></span><br><span class="line">    MyString.new(other.x + x)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addRational</span><span class="params">(other)</span></span></span><br><span class="line">    MyString.new(other.to_s + x)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRational</span> &lt; MyValue</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span>, <span class="symbol">:y</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x, y)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">    @y = y</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">"<span class="subst">#&#123;x&#125;</span>/<span class="subst">#&#123;y&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addInt</span><span class="params">(other)</span></span></span><br><span class="line">    MyRational.new(y * other.x + x, y)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addString</span><span class="params">(other)</span></span></span><br><span class="line">    MyString.new(other.x + to_s)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addRational</span><span class="params">(other)</span></span></span><br><span class="line">    MyRational.new(x * other.y + y * other.x, y * other.y)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在语句中没有任何判断，全靠 dynamic dispatch 完成。</p><hr><p>如果代码中出现了上述模式（需要判断某个类到底是哪个更加具体的子类，然后使用不同策略），就应该考虑要不要将这种判断通过 dynamic dispatch 来完成。</p><h2 id="Multimethods"><a href="#Multimethods" class="headerlink" title="Multimethods"></a>Multimethods</h2><p><strong>Ruby 不支持多分派。</strong></p><p>Multimethods 又称 multiple dispatch，中文为 <strong>多分派</strong>，与之相对的是单分派。（分派指的是选择合适的方法进行调用。）</p><p>单分派的 OOP 语言中，使用 <code>e1.foo(e2)</code> 进行方法调用时，具体使用哪个 <code>foo</code> 依赖于 <code>e1</code> 的运行时类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo Base"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> override </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo A"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> override </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo B"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Base *&gt; xs(<span class="number">3</span>);</span><br><span class="line">    xs[<span class="number">0</span>] = <span class="keyword">new</span> Base();</span><br><span class="line">    xs[<span class="number">1</span>] = <span class="keyword">new</span> A();</span><br><span class="line">    xs[<span class="number">2</span>] = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : xs)</span><br><span class="line">    &#123;</span><br><span class="line">        x-&gt;Print();</span><br><span class="line">        <span class="keyword">delete</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo Base</span></span><br><span class="line"><span class="comment">// Foo A</span></span><br><span class="line"><span class="comment">// Foo B</span></span><br></pre></td></tr></table></figure><p>C++、Java、C#、Ruby 都是（动态）单分派的。</p><p>多分派的语言中，<code>e1.foo(e2)</code> 具体调用哪个不仅取决于 <code>e1</code> 还取决于 <code>e2</code>，这里没有现成的例子。在一个支持了多分派的语言中要实现上一节的解释器的例子，不需要手动进行 double dispatch，假设 C++ 支持多分派的话，只要（用 C++ 举例子是因为它是静态类型的；以下例子仅为举例）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyValue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInt</span> :</span> <span class="keyword">public</span> MyValue</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    MyInt(<span class="keyword">int</span> x) : _x&#123;x&#125; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyValue <span class="title">Add</span><span class="params">(MyInt &amp;other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MyInt(_x + other._x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyValue <span class="title">Add</span><span class="params">(MyString &amp;other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MyString(_x.ToString() + other._x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>x + y</code> 的时候，如果 <code>x</code> 和 <code>y</code> 的静态类型（即静态分析得到的类型）都是 <code>MyValue</code>。运行环境会先通过 <code>x</code> 的动态类型（实际为 <code>MyInt</code>）决定使用 <code>MyInt</code> 中的函数，然后通过 <code>y</code> 的动态类型决定使用 <code>MyValue Add(MyString &amp;other)</code>。这就是多分派。</p><hr><p>Ruby 不支持多分派的原因：</p><ul><li>Ruby 是动态类型的，没法给方法参数加上类型标注</li><li>Ruby 中不允许出现同名函数</li></ul><hr><p>像 C++ 这样的语言支持静态的多分派（就是重载），但是没有支持动态多分派。在运行时，分派的方法就是看 <code>e1.foo(e2)</code> 中的 <code>e1</code>。</p><p>C# 中使用 dynamic 语法可以实现多分派。</p><h2 id="Multiple-Inheritance"><a href="#Multiple-Inheritance" class="headerlink" title="Multiple Inheritance"></a>Multiple Inheritance</h2><p><strong>Ruby 不支持多继承。</strong></p><p><em>Immediate subclass 是直接子类，transitive subclass 是间接子类。</em></p><p>多继承、Mixin 和接口是三种不同的策略。灵活性依次递减，带来的问题也依次减少。</p><p>多继承指的是一个类具有多于一个的父类。多继承会使得语义更加复杂，并且让类型检查和语言实现更加麻烦，但是也是很有用的。</p><p>使用单继承时，类之间的继承关系一定会形成一棵树，叫做 class hierarchy。但是在多继承的情况下，继承关系会形成一张 DAG。如果出现了某个类 A 是另一个类 B 的子类，但是存在多条不同的继承路径，称为菱形继承。在菱形继承时会出现很多问题，例如 B 中的成员变量到底是一份还是多份、A 的多个直接父类中有同名方法时应该调用哪个等问题。因为问题较多，很多语言不支持多继承。</p><h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><p><em>Ruby 中的 Mixin 在其它语言中可能被称为 traits。</em></p><p>Mixin 实际上是一个方法的集合。Mixin 无法实例化。Ruby 中的类可以选择性地 include 这些 Mixin，数量不限。这么做会导致类的定义被这些 Mixin 扩展，而 Mixin 中的方法可以通过 <code>self</code> 来访问不在 Mixin 中定义但是在类中定义的函数。注意 Mixin 中也可以使用或者创建新的成员变量，但是每个 Mixin 并不具有独立的空间，这些成员变量可能会搞混。</p><p>当调用方法时，查找方法的顺序：</p><ul><li>找这个类中进行查找</li><li>如果没有找到，在类包含的 Mixin 中查找；后出现的 Mixin 会覆盖掉前面的 Mixin</li><li>如果没有找到，在父类中进行查找</li><li>如果没有找到，在父类包含的 Mixin 中查找；后出现的 Mixin 会覆盖掉前面的 Mixin</li><li>依此类推</li></ul><hr><p>以下是两个实用 Mixin 的例子。</p><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a><code>Comparable</code></h3><p><code>Comparable</code> Mixin 假定类中实现了 <code>&lt;=&gt;</code> 操作符，然后提供了 <code>&lt;</code>、<code>&gt;</code>、<code>==</code>、<code>!=</code>、<code>&gt;=</code>、<code>&lt;=</code> 的实现。</p><p><code>&lt;=&gt;</code> 在左边小于右边时应当返回负数、右边小于左边应当返回正数、相当应当返回零。</p><h3 id="Enumerable"><a href="#Enumerable" class="headerlink" title="Enumerable"></a><code>Enumerable</code></h3><p><code>Enumerable</code> Mixin 假定类中实现了 <code>each</code> 函数，然后提供了很多常用的适用于枚举的函数，以下是自己实现 <code>Range</code> 的例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRange</span></span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(low, high)</span></span></span><br><span class="line">    @low = low</span><br><span class="line">    @high = high</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">each</span></span></span><br><span class="line">    a = @low</span><br><span class="line">    <span class="keyword">while</span> a &lt;= @high</span><br><span class="line">      <span class="keyword">yield</span> a</span><br><span class="line">      a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">print(MyRange.new(<span class="number">3</span>, <span class="number">10</span>).map&#123;<span class="params">|x|</span> x + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="定义一个-Mixin"><a href="#定义一个-Mixin" class="headerlink" title="定义一个 Mixin"></a>定义一个 Mixin</h3><p>使用 <code>module</code> 关键字定义 Mixin：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Doubler</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">double</span></span></span><br><span class="line">    <span class="keyword">self</span> + <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p>接口是静态类型语言中常见的概念，用来将类型系统变得更加灵活和强大。动态类型语言不需要这个东西，因为类型系统本身已经很灵活了。</p><p>以 Java 为例，使用 <code>interface</code> 定义一个接口并在其中声明或定义一系列函数，然后凡是标明要实现这个接口的类都要实现这些函数。当完成了实现后，这个类就成为了该接口的 <strong>subtype</strong>。一般的类型系统中，如果类 A 继承自类 B，那么 A 就是 B 的 subtype，并且所有可以出现某个类型的地方都可以用它的 subtype 进行代替。因此凡是用到了那个接口的地方，都可以把实现了那个接口的类传进去。这样就使得类型系统更加灵活了。</p><h2 id="Abstract-Methods"><a href="#Abstract-Methods" class="headerlink" title="Abstract Methods"></a>Abstract Methods</h2><p>只有声明没有定义的方法，在Java 和 C# 中叫抽象方法，C++ 中叫纯虚函数。在编译层面上禁止用户实例化一个带有抽象方法或者纯虚函数的类 A，这样用户就必须继承 A 然后实现这些方法，同时 A 中的其它函数也可以使用这些方法（dynamic dispatch 到正确的实现上）。</p><p>OOP 中的抽象方法和 FP 中的高阶函数二者概念很相似。</p><p>接口只会出现在静态类型且不支持多继承的语言中。由于 C++ 支持多继承，并且允许定义纯虚函数，所以可以模拟出接口的概念。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程语言理论 </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part C) 笔记 2 Section 8</title>
      <link href="/2019/02/23/Programming-Languages-Part-C-%E7%AC%94%E8%AE%B0-2-Section-8/"/>
      <url>/2019/02/23/Programming-Languages-Part-C-%E7%AC%94%E8%AE%B0-2-Section-8/</url>
      
        <content type="html"><![CDATA[<h1 id="Section-8"><a href="#Section-8" class="headerlink" title="Section 8"></a>Section 8</h1><h2 id="Introduction-to-Ruby"><a href="#Introduction-to-Ruby" class="headerlink" title="Introduction to Ruby"></a>Introduction to Ruby</h2><p>Ruby 的一些特性：</p><ul><li>所有的值都是对象，是纯 OOP 的。</li><li>是基于类的（存在不基于类的语言，比如 JavaScript）。</li><li>是动态类型语言。</li><li>方便进行反射：能够在运行时查看对象属性。</li><li>能在运行时改变类。</li><li>闭包是一种常用的 idiom。</li><li>是一门脚本语言。</li></ul><p>Ruby 的 hello world 程序（缩进无所谓）：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># this is a comment</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello_method</span></span></span><br><span class="line">        puts <span class="string">"Hello, world!"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">x = Hello.new</span><br><span class="line">x.hello_method</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Classes-and-Objects"><a href="#Classes-and-Objects" class="headerlink" title="Classes and Objects"></a>Classes and Objects</h2><p>Ruby 中的所有值都是某个对象的引用，包括其它语言中的原生类型，所以可以执行像 <code>5.abs</code> 这样的操作来求 5 的绝对值。</p><p>对象拥有自己的状态（Ruby 中所有的状态都是私有的）和自己属于的类，这个类决定了自己的行为，彼此之间通过类的方法进行交流（调用某个对象的方法可以看做是 <strong>向对象传递消息</strong>）。</p><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_name</span><span class="params">(func_args_1, func_args_2)</span></span></span><br><span class="line">        <span class="keyword">if</span> func_args_1 &gt; func_args_2</span><br><span class="line">            print func_args_1</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            print func_args_2</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_with_ret</span> <span class="title">single_arg</span></span></span><br><span class="line">        print single_arg</span><br><span class="line">        <span class="comment"># last expression is return value</span></span><br><span class="line">        single_arg</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>定义或调用类的方法时参数用括号括起，逗号分割。如果只有一个或零个参数可以省略括号。</p><p>使用 <code>ClassName.new</code> 构造新对象。</p><h3 id="self-关键字"><a href="#self-关键字" class="headerlink" title="self 关键字"></a><code>self</code> 关键字</h3><p>使用 <code>self</code> 关键字访问当前实例。如果在类中调用当前实例的方法，也可以省略 <code>self</code>，作为语法糖。</p><p>使用 <code>self</code> 的一个 idiom 是实现链式调用：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m1</span></span></span><br><span class="line">        print <span class="string">"hi"</span>; <span class="keyword">self</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m2</span></span></span><br><span class="line">        print <span class="string">"bye"</span>; <span class="keyword">self</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m3</span></span></span><br><span class="line">        print <span class="string">"\n"</span>; <span class="keyword">self</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>随后可以链式调用：<code>Foo.new.m1.m2.m3.m1.m2.m3</code>。</p><h2 id="Object-State"><a href="#Object-State" class="headerlink" title="Object State"></a>Object State</h2><h3 id="Instance-variables"><a href="#Instance-variables" class="headerlink" title="Instance variables"></a>Instance variables</h3><p>Ruby 中每个对象有自己的变量（称作状态），这些变量都是私有的，只能通过函数来访问。这些变量叫 instance variables。</p><p>Instance variables 通过 <code>@</code> 前缀定义和访问，例如 <code>@foo</code>。访问未定义的私有变量会返回 <code>nil</code> 但是不报错。</p><h3 id="Aliasing"><a href="#Aliasing" class="headerlink" title="Aliasing"></a>Aliasing</h3><p><code>x = y</code> 会导致 <code>x</code> 和 <code>y</code> 指向同一个对象。对 <code>x</code> 状态的改变也会影响 <code>y</code> 的状态，因为实际上是同一个对象。</p><h3 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h3><p>可以为类定义 <code>initialize</code> 方法，该方法可以接受参数。<code>initialize</code> 方法会在构造对象时被调用。常见的用法是在 <code>initialize</code> 方法中初始化各个 instance variable，防止后续访问时返回 <code>nil</code>。由于这种用法不是语言定义的一部分，因此和其它 OOP 语言不同，Ruby 中同一个类的不同对象可能有不同的 instance variables。</p><p><em>Ruby 中的方法可以有默认参数。</em></p><h3 id="Class-variables"><a href="#Class-variables" class="headerlink" title="Class variables"></a>Class variables</h3><p>类可以有自己的变量，这种变量通过 <code>@@</code> 前缀进行定义和访问，例如 <code>@@bar</code>。</p><h3 id="Class-constants-and-methods"><a href="#Class-constants-and-methods" class="headerlink" title="Class constants and methods"></a>Class constants and methods</h3><p>类可以有常量，常量通过大写首字母进行定义，例如 <code>Bazz</code>。常量不能被更改，在类外通过 <code>ClassName::Bazz</code> 进行访问。</p><p>类方法在定义时的语法为 <code>def self.method_name(args) ... end</code>，调用语法为 <code>ClassName.method_name(args)</code>。类方法中只能访问类变量、类常量和其它类方法。</p><h2 id="Visibility"><a href="#Visibility" class="headerlink" title="Visibility"></a>Visibility</h2><h3 id="Getter-Setter"><a href="#Getter-Setter" class="headerlink" title="Getter/Setter"></a>Getter/Setter</h3><p>隐藏状态对于模块化和抽象而言很重要。Ruby 中的对象的变量总是私有的（语言强制），并且 <strong>只有这个对象可以访问</strong>，和这个对象属于同一个类的其它对象也无法访问。私有变量唯一可能出现的形式只有 <code>@foo</code>，不可能出现 <code>e.@foo</code> 的情况。</p><p>为了状态能和外界沟通，需要定义 getter 和 setter：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_foo</span></span></span><br><span class="line">    @foo</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_foo</span> <span class="title">x</span></span></span><br><span class="line">    @foo = x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Conventions-and-sugar"><a href="#Conventions-and-sugar" class="headerlink" title="Conventions and sugar"></a>Conventions and sugar</h3><p>常用的习惯是，对于状态 <code>@foo</code>，getter 的名字叫 <code>foo</code>，setter 的名字叫 <code>foo=</code>。Ruby 有个语法糖是，如果某个方法以等号结尾，调用时等号前是可以插入空格的，因此可以这样调用 <code>foo=</code>：<code>e.foo = 3</code>。</p><p>Ruby 提供了定义 getter、setter 的快捷方式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:read1</span>, <span class="symbol">:read2</span>     <span class="comment"># read only</span></span><br><span class="line">    <span class="keyword">attr_accessor</span> <span class="symbol">:write1</span>, <span class="symbol">:write2</span> <span class="comment"># read and write</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sum</span></span></span><br><span class="line">        @write1 + @write2</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这样可以快捷定义出 <code>read1</code>、<code>write1</code>、<code>write1=</code> 等函数。</p><h3 id="Why-private-object-state"><a href="#Why-private-object-state" class="headerlink" title="Why private object state"></a>Why private object state</h3><p>Ruby 强制让类的变量是私有的，这样更加符合 OOP 设计，用户不知道类中具体实现是怎么样的。</p><p>这种设计使得看上去像某个状态的 getter、setter 实际上拥有不同实现：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">celsius_temp=</span> <span class="title">x</span></span></span><br><span class="line">    @kelvin_temp = x + <span class="number">273.15</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>同时使得鸭子类型变得可能。</p><h3 id="Method-visibility"><a href="#Method-visibility" class="headerlink" title="Method visibility"></a>Method visibility</h3><p>方法默认访问性是 public 的。</p><p>可以使用 <code>public</code>、<code>protected</code>、<code>private</code> 关键字指明方法的可见性。一旦使用，在该关键字到下一个关键字之间的所有方法都会拥有这种可见性（与 C++ 类似，与 Java 不同）。</p><p>对象访问自己的方法时可以省略掉 <code>self</code> 关键字，但是使用自己的私有方法时，Ruby 要求 <strong>不能带有 <code>self</code> 关键字</strong>，因此私有方法不能指明是调用谁的。和私有变量类似，同属一个类的对象不能访问别人的私有方法。不过作为同一个对象的子类对象是可以在类定义中访问父类的私有方法的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line">    private</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span></span><br><span class="line">        print <span class="string">'foo'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> &lt; Base</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span></span><br><span class="line">        foo</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Derive.new.bar</span><br><span class="line"><span class="comment"># cannot `Derive.new.foo`</span></span><br></pre></td></tr></table></figure><p>原则是，私有方法不能指定接收者（将函数调用想成传递消息）。</p><h2 id="A-Longer-Example"><a href="#A-Longer-Example" class="headerlink" title="A Longer Example"></a>A Longer Example</h2><ul><li>使用 <code>raise &quot;something as string&quot;</code> 抛出异常；</li><li>使用 <code>if ... elsif ... else</code> 进行多分支判断；</li><li>大部分类型可以使用 <code>to_s</code> 方法将自己转为字符串，这是 convention；</li><li>使用 <code>e1 if e2</code> 语句在仅当 <code>e2</code> 为真的情况下执行 <code>e1</code>；</li><li><code>&quot;2 is #{if 2 &gt; 1 then &quot;greater&quot; else &quot;less&quot; end} than 1&quot;</code>，使用 <code>#{...}</code> 进行字符串插值。</li><li>如果某个方法会改变对象状态，这个方法命名习惯以 <code>!</code> 结尾。</li><li>如果一个方法名称为 <code>+</code>，例如 <code>def + r</code>，那么调用的时候 <code>a.+ b</code> 可以写为 <code>a + b</code>，这是语法糖。</li><li>Ruby 中可以在顶层定义函数。</li></ul><h2 id="Everything-is-an-Object"><a href="#Everything-is-an-Object" class="headerlink" title="Everything is an Object"></a>Everything is an Object</h2><p>Ruby 中大部分的“东西”都是对象。几乎所有的操作都是在调用某个对象的方法。例如 3 + 4 实际上调用的是 3 这个对象的 <code>+</code> 方法。</p><p><code>nil</code> 也是一个对象，它有 <code>nil?</code> 等方法。除了 <code>nil</code> 之外的所有对象在调用 <code>nil?</code> 时都返回 false。Ruby 中进行判断时，只有 <code>nil</code> 和 <code>false</code> 两个值被认为是假的。</p><p>Ruby 中所有的类都继承自 <code>Object</code> 类，顶层定义的函数被看做是向 <code>Object</code> 类中添加了新的方法。所以顶层函数实际上还是对象的方法。</p><p>每个对象都有一些共有的方法（来自 <code>Object</code> 类），例如 <code>methods</code> 方法会列出这个对象的所有方法，<code>class</code> 对象会给出这个对象所属的类。这些函数可以用来进行反射。Ruby 中的“类”也是一个对象，这个对象所属的类是 <code>Class</code> 类，<code>Class</code> 类也继承自 <code>Object</code> 类。（<code>Object</code> 的父类是 <code>BasicObject</code>，<code>BasicObject</code> 的父类是 <code>nil</code>。）</p><p>总结：Ruby 中只有对象和对方法的调用。</p><h2 id="Class-Definitions-are-Dynamic"><a href="#Class-Definitions-are-Dynamic" class="headerlink" title="Class Definitions are Dynamic"></a>Class Definitions are Dynamic</h2><p>Ruby 中类的定义是可以动态改变的，可以在运行时向其中添加新的方法或修改已有的方法。一旦修改完成，该类的所有对象都会使用新的定义，不管它们是否在修改前就被构造出来了。这么做可行的理由是 Ruby 中的类也是一个对象，对象可以被修改，而类则定义了示例如何工作。</p><p>这么做实际上破坏了程序的抽象性，但是有时候很方便，例如想要在一个类中扩展出一个方法。</p><p>为了对类进行修改，只要重新定义一遍类，写出要修改的地方即可：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span></span><br><span class="line">        print <span class="string">"foo"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span></span><br><span class="line">        print <span class="string">"bar"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">foo = Foo.new</span><br><span class="line">foo.foo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span></span><br><span class="line">        print <span class="string">"foo-foo"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bazz</span></span></span><br><span class="line">        print <span class="string">"bazz"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">foo.foo</span><br><span class="line">foo.bar</span><br><span class="line">foo.bazz</span><br></pre></td></tr></table></figure><p>上面例子中给 <code>Foo</code> 类添加了方法 <code>bazz</code>，同时修改了 <code>foo</code> 的定义。注意修改后，即使 <code>foo</code> 在 <code>Foo</code> 被修改前就被定义了，调用 <code>foo</code> 的 <code>foo</code> 方法时使用的是后来的定义。其它语言（例如 Java）不会有这种考虑，因此它们对于函数方法调用的实现会更加简单。</p><p>当定义顶层函数的时候，实际上是给 <code>Object</code> 类定义了新的方法，因此：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span></span><br><span class="line">    print <span class="string">"foo"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span></span><br><span class="line">        print <span class="string">"bar"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这两种定义方式是等价的。</p><h2 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h2><p>鸭子类型指的是当使用 <code>foo.method</code> 时，并不要求 <code>foo</code> 一定是 <code>Foo</code> 的实例，只要求 <code>foo</code> 是某个具有 <code>method</code> 方法的对象即可。函数的定义者不需要判定传入的参数到底是不是 <code>Foo</code>，只用确定传入的参数具有 <code>foo</code> 方法即可。使用鸭子类型可以让代码复用性更好，缺点是几乎所有的代码都不是相等的（例如 <code>2 * x</code> 和 <code>x * 2</code> 语义不一样了），并且调用函数的人需要知道函数的实现细节。</p><p>对于这个函数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirror_update</span> <span class="title">pt</span></span></span><br><span class="line">    pt.x = pt.x * (-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>看上去是将一个点关于 x 轴对称，实际上，这个函数的功能是：接受某个具有 <code>x</code> 和 <code>x=</code> 方法的对象，在这个对象上调用 <code>x</code>，然后在结果上调用 <code>*</code> 并传入 -1，最后将这个结果作为参数对 <code>pt</code> 调用 <code>x=</code>。Ruby 并没有强制 <code>x</code>、<code>x=</code>、<code>*</code> 的语义，所以这个函数到底是干嘛的实际上很难说清楚。</p><p>这种实现方式的好处是，一个函数的适用性更广（如上面的函数可能适用于二维的点、三维的点等），但是一旦有人滥用鸭子类型的特性就会导致 <code>mirror_update</code> 的定义不能轻易被改变（比如交换 <code>-1</code> 和 <code>pt.x</code> 就改变了程序的语义）。</p><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Ruby 中的数组（<code>Array</code> 类）是最常用的线性结构。数组中元素类型不要求一致。</p><p>它的使用方式比较灵活，下面是一些使用方式：</p><ul><li><p>使用 <code>a[i]</code> 进行读取，<code>a[i] = b</code> 进行修改，越界时会得到 <code>nil</code> 但是不报错（和访问未定义变量一样）；</p></li><li><p>使用负的下标从末尾开始索引（与 Python 类似）；</p></li><li><p>当为越界的元素定了值时，数组会自行扩展（与 JavaScript 类似）：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a[<span class="number">5</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a is [1, 2, 3, nil, nil, 4] now</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>+</code> 连接两个数组；</p></li><li><p>使用 <code>|</code> 可以得到两个数组中不重复的元素：<code>[3, 2, 3] | [1, 2, 3]</code> 的结果是 <code>[3, 2, 1]</code>；</p></li><li><p>使用 <code>Array.new(size)</code> 可以得到大小为 <code>size</code> 的空数组，元素全部是 <code>nil</code>。</p></li><li><p>使用 <code>push</code> 和 <code>pop</code> 可以把数组当栈用，栈底是数组头；</p></li><li><p>使用 <code>push</code> 和 <code>shift</code> 可以把数组当队列用，队尾是数组尾，使用 <code>unshift</code> 可以在头部插入元素；</p></li><li><p>数组可以使用 <code>[index, offset]</code> 方式的索引来进行切片，并且可以对切片赋值，结果会影响到原数组；</p></li><li><p>调用用数组的 <code>each</code> 方法相当于做 map 操作，语法上需要用到下一节的内容。</p></li></ul><p>注意数组的 alias 问题。如果 <code>a</code> 是数组，<code>b = a</code> 会得到相同指向的数组，<code>b = a + []</code> 会创建新数组。</p><h2 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h2><p>Ruby 中的 Block 是很有趣的一个特性。<strong>对于所有的方法，在调用时都可以传入 0 个或者 1 个 block，但是具体怎么使用取决于要调用的函数。</strong></p><p>Block 和闭包很像，可以用来传递匿名函数，并且使用词法作用域。</p><p><strong>语法</strong>：使用 <code>{ e1 }</code> 构建不带参数的 block，<code>{ |x, y| x + y }</code> 构建带参数的 block。如果有多行，推荐将 <code>{</code> 和 <code>}</code> 替换为 <code>do</code> 和 <code>end</code>。</p><p><strong>示例</strong>：</p><ul><li><code>3.times { puts &quot;hi&quot; }</code></li><li><code>[4, 5, 6].each { |x| puts x }</code></li></ul><p>一个方法可以同时接受参数和 block，例如构造规律性的数组：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = Array.new(<span class="number">5</span>) &#123; <span class="params">|i|</span> <span class="number">4</span> * i &#125;</span><br><span class="line"><span class="comment"># now a is [0, 4, 8, 12, 16]</span></span><br></pre></td></tr></table></figure><p>数组上定义了一些需要 block 的方法用来进行函数式编程：</p><ul><li><code>each</code> 类似会将元素传入 block 中执行</li><li><code>map</code>/<code>collect</code> 会执行 map 操作（会得到新的数组）</li><li><code>inject</code> 会执行 foldl 操作</li><li><code>select</code> 会执行 filter 操作</li><li><code>any?</code> 和 <code>all?</code> 询问数组中是否存在某性质的元素或者全为某性质的元素</li><li><code>count</code> 统计符合性质元素个数</li></ul><p>通过使用 block、这些函数以及 range 特性（后面会写）可以避免编程时使用循环。</p><h2 id="Using-Blocks"><a href="#Using-Blocks" class="headerlink" title="Using Blocks"></a>Using Blocks</h2><p>Callee 使用 caller 传入的 block 时，使用 <code>block_given?</code> 可以判断是否传入了 block，使用 <code>yield</code> 来访问这个 block。例如实现一个 <code>each</code> 函数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_each</span> <span class="title">xs</span></span></span><br><span class="line">    <span class="keyword">if</span> xs.size != <span class="number">0</span></span><br><span class="line">        <span class="keyword">yield</span> xs[<span class="number">0</span>]</span><br><span class="line">        my_each(xs[<span class="number">1</span>, xs.size - <span class="number">1</span>]) &#123;<span class="params">|i|</span> <span class="keyword">yield</span> i&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><em>当传入 block 而函数只有一个参数的时候括号不能省略。</em></p><p>调用为 <code>my_each([1, 2, 3, 4, 5, 6]) {|x| puts x}</code>。</p><p>其中 <code>{|i| yield i}</code> 表示将对应的 block 继续传递下去，因为 block 没有被绑定上一个名字，所以用这种麻烦的方式做。</p><h2 id="Procs"><a href="#Procs" class="headerlink" title="Procs"></a>Procs</h2><h3 id="First-class-expression"><a href="#First-class-expression" class="headerlink" title="First class expression"></a>First class expression</h3><p>Ruby 中，block 不是对象。所谓的 first class expression 指的是满足可以作为表达式的结果、可以被传递给函数、可以放在数组中等性质的那些表达式，但是 Ruby 中 block 不能这么用。不是 first class expression 的表达式是 second class expression。</p><p>Ruby 中的 block 的使用方式受限于上一节的那种情况，虽然大部分情况下使用高阶函数都是这么用的，但是 block 比 closure 要弱一些，比如它没法存到一个数组中。</p><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>Ruby 中可以将一个 block 封装成对象，在 <code>Object</code> 类中有一个方法（因此是全局可访问的）<code>lambda</code> 可以做到这一点。<code>lambda</code> 接受一个 block，然后返回一个 <code>Proc</code> 对象。在该对象上调用 <code>call</code> 方法即可执行原来的 block。</p><p>见以下示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">b = a.map &#123;<span class="params">|x|</span> lambda &#123;<span class="params">|y|</span> y &gt; x&#125;&#125;</span><br></pre></td></tr></table></figure><p>现在 <code>b</code> 中存放了 5 个 <code>Proc</code>，实际上是 5 个 closure。可以逐个进行调用：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.map &#123;<span class="params">|x|</span> x.call <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>返回的结果是 <code>a</code> 中哪些位置上的值比 5 小。</p><h3 id="为何这样设计"><a href="#为何这样设计" class="headerlink" title="为何这样设计"></a>为何这样设计</h3><p>因为大部分情况下，使用高阶函数的模式都是只传入一个闭包，并且要将闭包存起来的需求较少，这就有两种不同的设计：</p><ul><li>将函数作为 first class 的，但是使用的时候可能会带来不便</li><li>将函数作为 second class 的，但是通过设计语法让使用高阶函数更加简单，代价是当有复杂的需求时要对 second class 的东西进行封装</li></ul><p>Ruby 选择第二种方式，将使用高阶函数的常用模式作为语言的一部分。</p><h2 id="Hashes-and-Ranges"><a href="#Hashes-and-Ranges" class="headerlink" title="Hashes and Ranges"></a>Hashes and Ranges</h2><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash 类似 Python 中的 dict，它的键可以是任意值，并且是无序的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h1 = &#123;&#125;</span><br><span class="line">h2 = &#123;<span class="number">1</span> =&gt; <span class="string">"Hi"</span>, <span class="literal">false</span> =&gt; <span class="string">"bye"</span>&#125;</span><br><span class="line"></span><br><span class="line">h1[<span class="string">"a"</span>] <span class="comment"># get nil</span></span><br><span class="line">h1[<span class="string">"b"</span>] = <span class="number">3</span> <span class="comment"># h1 is &#123;"b" =&gt; 3&#125; now</span></span><br><span class="line"></span><br><span class="line">h2.size <span class="comment"># 2</span></span><br><span class="line">h2.each &#123;<span class="params">|k, v|</span> puts <span class="string">"<span class="subst">#&#123;k&#125;</span>: <span class="subst">#&#123;v&#125;</span>"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>Range 类似 Python 中的 range，它是一段连续数值的高效实现（占用更小的空间）。例如 <code>(1..1000)</code> 在实现上可能只维护了两个元素，而不是有 1000 个元素的数组。</p><p>例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">100</span>).inject &#123;<span class="params">|x, y|</span> x + y&#125; <span class="comment"># 5050</span></span><br></pre></td></tr></table></figure><hr><ul><li>当键不为整数时，使用 Hash</li><li>当要表示连续数值时，使用 Range</li></ul><p>Hash、Range 和 Array 具有一些相同的方法，这就可以发挥鸭子类型的作用：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span> <span class="title">a</span></span></span><br><span class="line">    a.count &#123;<span class="params">|x|</span> x * x &lt; <span class="number">50</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在 <code>foo</code> 既可以用在 Array 上也可以用在 Range 上。</p><p>这是一个关注点分离的例子：一个函数负责对结构进行遍历，另一个函数使用遍历的结果进行逻辑上的处理。</p><h2 id="Subclassing"><a href="#Subclassing" class="headerlink" title="Subclassing"></a>Subclassing</h2><p>Ruby 中继承的语法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> &lt; Base</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果不指明，则继承自 <code>Object</code> 类。继承后可以得到父类中的所有 public 和 protected 方法。Ruby 中的继承不会得到父类的变量，因为它们都是私有的，也因为它们都是动态创建出来的。子类中是否会拥有这些变量取决于父类的相应函数是否会执行。</p><p>在子类的 <code>initialize</code> 函数中可以通过调用 <code>super</code> 函数访问父类的构造函数。<code>super</code> 也可以用来调用父类同名函数（如果在子类中被覆盖的话）。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span></span><br><span class="line">        print <span class="string">"foo"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> &lt; Base</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span></span><br><span class="line">        print <span class="string">"bar"</span></span><br><span class="line">        <span class="keyword">super</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>super</code> 这里会将函数的参数传给父类同名函数的参数，也可以手动指定。</p><p><em>在继承自 <code>Class</code> 对象的函数上调用 <code>superclass</code> 方法可以获取到父类类型。</em></p><ul><li><p>使用 <code>is_a?</code> 方法可以判定某个对象是否是某个类的实例，或者它的类型是否继承自某个类。</p></li><li><p>使用 <code>instance_of?</code> 方法可以判定某个对象是否是某个类的实例。</p></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">b = Base.new</span><br><span class="line">d = Derive.new</span><br><span class="line"></span><br><span class="line">b.is_a? Base <span class="comment"># true</span></span><br><span class="line">b.is_a? Derive <span class="comment"># false</span></span><br><span class="line">d.is_a? Base <span class="comment"># true</span></span><br><span class="line">d.is_a? Derive <span class="comment"># true</span></span><br><span class="line"></span><br><span class="line">b.instance_of? Base <span class="comment"># true</span></span><br><span class="line">b.instance_of? Derive <span class="comment"># false</span></span><br><span class="line">d.instance_of? Base <span class="comment"># false</span></span><br><span class="line">d.instance_of? Derive <span class="comment"># true</span></span><br></pre></td></tr></table></figure><p>使用这些判断会失去鸭子类型的优势。</p><h2 id="Why-Use-Subclassing"><a href="#Why-Use-Subclassing" class="headerlink" title="Why Use Subclassing?"></a>Why Use Subclassing?</h2><p>使用继承可以复用代码；将子类对象看作是特化的父类对象也是有好处的。但是滥用继承有时候也不好。</p><p>在不使用继承的情况下要实现类似的效果，可以：</p><ul><li>直接修改原始类的代码。这在 Ruby 中是可行的（见前面的笔记），然而，这么做会破坏模块化的性质。如果其它类假定了被修改的这个类是原来的实现方式的话就会有问题。</li><li>重新定义一个更加具体的类，并将代码从原来的类中复制过来再添加新的内容。这么做无法复用代码，原始类发生修改时也无法影响到新的类，并且无法使用 <code>is_a</code> 进行正确的判断。</li><li>定义一个类，这个类中的某个成员是原始类的实例。这么做的坏处在于，如果要和原来的类保持相同接口就要写一堆 wrapper 函数，并且也无法使用 <code>is_a</code> 进行判断。但是有时候这么做比直接继承要好。</li></ul><p>综上来看继承的好处还是比较明显的。</p><h2 id="Overriding-and-Dynamic-Dispatch"><a href="#Overriding-and-Dynamic-Dispatch" class="headerlink" title="Overriding and Dynamic Dispatch"></a>Overriding and Dynamic Dispatch</h2><p>假设有一个 <code>Vec2</code> 类：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vec2</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x, y)</span></span></span><br><span class="line">        @x = x</span><br><span class="line">        @y = y</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span></span></span><br><span class="line">        @x</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x=</span> <span class="title">v</span></span></span><br><span class="line">        @x = v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span></span></span><br><span class="line">        @y</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y=</span> <span class="title">v</span></span></span><br><span class="line">        @y = v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span></span></span><br><span class="line">        Math.sqrt(@x * @x + @y * @y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length_squared</span></span></span><br><span class="line">        x * x + y * y</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用 <code>Vec2Polar</code> 继承它：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vec2Polar</span> &lt; Vec2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(r, theta)</span></span></span><br><span class="line">        @r = r</span><br><span class="line">        @theta = theta</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span></span></span><br><span class="line">        @r * Math.cos(@theta)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x=</span> <span class="title">a</span></span></span><br><span class="line">        b = y</span><br><span class="line">        @theta = Math.atan(b / a)</span><br><span class="line">        @r = Math.sqrt(a * a + b * b)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span></span></span><br><span class="line">        @r * Math.sin(@theta)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y=</span> <span class="title">b</span></span></span><br><span class="line">        a = x</span><br><span class="line">        @theta = Math.atan(b / a)</span><br><span class="line">        @r = Math.sqrt(a * a + b * b)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span></span></span><br><span class="line">        @r</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 <code>Vec2Polar</code> 中是没有 <code>@x</code> 的。如果没有重写 <code>x</code> 方法的话，调用 <code>x</code> 方法得到的是 <code>nil</code>，同样地，调用 <code>x=</code> 会创建 <code>@x</code> 成员并且为其赋值。如果没有重写 <code>length</code> 方法的话，访问 <code>length</code> 会报错。</p><p>按照上述实现，<code>Vec2Polar</code> 保持了和 <code>Vec2</code> 同样的接口。尽管没有重写 <code>length_squared</code> 方法，但是这是不会报错的，因为 <code>length_squared</code> 方法实际上是：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_squared</span></span></span><br><span class="line">    <span class="keyword">self</span>.x() * <span class="keyword">self</span>.x() + <span class="keyword">self</span>.y() * <span class="keyword">self</span>.y()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对于 <code>Vec2Polar</code>，这个函数会调用 <code>Vec2Polar</code> 自己的 <code>x</code> 函数。<code>Vec2Polar</code> 函数对 <code>x</code> 的修改影响了 <code>Vec2</code> 中函数的表现。</p><p>抽象来说，类中的方法对于形如 <code>self.foo()</code> 这样的调用总是会调用最具体的那个类的函数。这种特性在 Ruby 中称为 <strong>dynamic dispatch</strong>，在其他语言中就是调用虚函数了。</p><hr><p>是否将 <code>Vec3</code> 实现为 <code>Vec2</code> 的子类比较有争议，</p><ul><li><strong>优点</strong>：可以对代码进行复用。</li><li><strong>缺点</strong>：破坏了 is-a 关系。</li></ul><h2 id="Method-Lookup-Rules-Precisely"><a href="#Method-Lookup-Rules-Precisely" class="headerlink" title="Method-Lookup Rules, Precisely"></a>Method-Lookup Rules, Precisely</h2><p>这一节讲的是对于 dynamic dispatch 的精确定义，这种定义对大部分 OOP 语言都是适用的。</p><p>Dynamic dispatch 的一个描述是，在类 C 中调用 <code>self.m()</code> 可能导致 C 的某个子类中的 <code>m</code> 方法被调用。这可能是 OOP 最独特的性质。</p><p>Ruby 中的 <code>self</code> 是一个特殊的关键词，在所有的环境中，它总是指向 <strong>当前对象</strong>。以下是 dynamic dispatch 的实现，在一个类（这个类不一定和 <code>self.class</code> 相同 ）的方法中：</p><ul><li>当要访问 <code>@x</code> 时，在 <code>self</code> 指向的对象中查找 <code>@x</code>。</li><li>当要访问 <code>@@x</code> 时，在 <code>self.class</code> 指向的对象中查找 <code>@@x</code>。</li><li>当要访问方法时，如果方法的形式为 <code>e0.m(e1, ... , en)</code>：<ol><li>对 <code>e0</code> 到 <code>en</code> 求值，假设求值结果为 <code>obj0</code> 到 <code>objn</code>。求值过程中会递归地应用这些规则；</li><li>从 <code>e0</code> 的类中开始找 <code>m</code>，如果没有找到就找它的父类，以此类推，直到找到根类为止。如果还没找到就报错；</li><li>找到 <code>m</code> 后开始执行这个方法，执行前将对应的形参绑定为实参，并且将 <code>self</code> 绑定为 <code>obj0</code>。这一步实现了 dynamic dispatch。因此在 <code>m</code> 中总是会优先使用更加“具体”的方法。</li></ol></li></ul><p>Dynamic dispatch 机制比 closure 要更加复杂，因为要特殊对待 <code>self</code>。但是这不意味着二者孰优孰劣。</p><hr><p>其它语言中有 <strong>重载（overloading）</strong>的概念，但是 Ruby 中没有。这是因为重载需要编译器进行类型分析然后找到最适合调用的函数（没有最优则报错），但是 Ruby 是动态类型的，没有类型分析。</p><p>Ruby 中，如果使用同名函数，则总是覆盖掉之前的函数。</p><h2 id="Dynamic-Dispatch-Versus-Closures"><a href="#Dynamic-Dispatch-Versus-Closures" class="headerlink" title="Dynamic Dispatch Versus Closures"></a>Dynamic Dispatch Versus Closures</h2><h3 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h3><p>Closure 的好处在于写出代码的时候，函数的功能是确定的：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> even x = (print <span class="string">"in even\n"</span> ; <span class="keyword">if</span> x=<span class="number">0</span> <span class="keyword">then</span> <span class="literal">true</span> <span class="keyword">else</span> odd (x-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">and</span> odd x = (print <span class="string">"in odd\n"</span> ; <span class="keyword">if</span> x=<span class="number">0</span> <span class="keyword">then</span> <span class="literal">false</span> <span class="keyword">else</span> even (x-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>即使后来覆盖了 <code>even</code> 的定义，<code>odd</code> 的行为也不会改变，因为 <code>even</code> 的定义已经包括在 <code>odd</code> 的闭包中了。</p><p>这给阅读代码带来了优势：总是可以预测 <code>odd</code> 的行为。</p><h3 id="Dynamic-Dispatch"><a href="#Dynamic-Dispatch" class="headerlink" title="Dynamic Dispatch"></a>Dynamic Dispatch</h3><p>另一方面，OOP 中的 dynamic dispatch 则与此相反：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">even</span> <span class="title">x</span></span></span><br><span class="line">    puts <span class="string">"in even A"</span></span><br><span class="line">    <span class="keyword">if</span> x==<span class="number">0</span> <span class="keyword">then</span> <span class="literal">true</span> <span class="keyword">else</span> odd(x-<span class="number">1</span>) <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">odd</span> <span class="title">x</span></span></span><br><span class="line">    puts <span class="string">"in odd A"</span></span><br><span class="line">    <span class="keyword">if</span> x==<span class="number">0</span> <span class="keyword">then</span> <span class="literal">false</span> <span class="keyword">else</span> even(x-<span class="number">1</span>) <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果继承了 <code>A</code>，并且重写了 <code>even</code> 方法，那么 <code>odd</code> 的行为会发生改变。这种改变可能是好的或者坏的：</p><ul><li>如果将 <code>even</code> 的效率提高了，并且保证了正确性，就是比较好的；这种好处甚至不需要 <code>A</code> 的作者参与就能得到；</li><li>但是也有可能破坏了 <code>even</code> 的正确性导致 <code>odd</code> 也是错的；这给阅读代码带来了劣势：看的时候不知道 <code>odd</code> 的作用到底是什么，除非用户使用的就是 <code>A</code>。</li></ul><p>所以 dynamic dispatch 的策略有好处也有坏处。</p><p>为了规避这种坏处，可以通过将函数搞成不可重写的（用 <code>private</code> 进行修饰）。</p><hr><p>二者差异在如果方法 <code>foo</code> 依赖方法 <code>bar</code>，而 <code>bar</code> 被修改了，那么 <code>foo</code> 的实际行为是否应当被修改。</p><h2 id="Dynamic-Dispatch-Manually-in-Racket"><a href="#Dynamic-Dispatch-Manually-in-Racket" class="headerlink" title="Dynamic Dispatch Manually in Racket"></a>Dynamic Dispatch Manually in Racket</h2><p>这节讲的是在 Racket 中实现 dynamic dispatch。实现上的一些 trick：</p><ul><li>在实现类的方法时每个方法额外带一个 <code>self</code> 参数。每次调用的时候将相应的对象作为 <code>self</code> 传进去。在这个方法的实现中可以使用 <code>self</code>。</li><li>把类的所有方法（继承的以及自己的）放在同一个列表中，自己的方法放在最前面，根类的方法放在最后面，按照这个顺序排列。这样查找的时候就会正确表现出 dynamic dispatch 的性质。</li></ul><p>这样实现 dynamic dispatch 的原理就是，一个对象调用方法的时候是从这个对象的方法列表中找到对应方法的，而又因为越“具体”的方法越先被找到，所以会优先被调用。</p><p>直接把作者的整个代码贴上来：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Programming Languages, Dan Grossman</span></span><br><span class="line"><span class="comment">; Section 7: Optional: Dynamic Dispatch Manually in Racket</span></span><br><span class="line"></span><br><span class="line">#lang racket</span><br><span class="line"></span><br><span class="line"><span class="comment">;; We can "use" dynamic dispatch in a language without it manually</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; Our "objects" will have:</span></span><br><span class="line"><span class="comment">;;  * an immutable list of mutable "fields" (symbols and contents)</span></span><br><span class="line"><span class="comment">;;  * an immutable list of immutable "methods" (symbols and functions taking self)</span></span><br><span class="line">(<span class="name">struct</span> obj (<span class="name">fields</span> methods))</span><br><span class="line"></span><br><span class="line"><span class="comment">; like assoc but for an immutable list of mutable pairs</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">assoc-m</span> v xs)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> [(<span class="name"><span class="builtin-name">null?</span></span> xs) <span class="literal">#f</span>]</span><br><span class="line">        [(<span class="name"><span class="builtin-name">equal?</span></span> v (<span class="name">mcar</span> (<span class="name"><span class="builtin-name">car</span></span> xs))) (<span class="name"><span class="builtin-name">car</span></span> xs)]</span><br><span class="line">        [<span class="literal">#t</span> (<span class="name">assoc-m</span> v (<span class="name"><span class="builtin-name">cdr</span></span> xs))]))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get</span> obj fld)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">pr</span> (<span class="name">assoc-m</span> fld (<span class="name">obj-fields</span> obj))])</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> pr</span><br><span class="line">        (<span class="name">mcdr</span> pr)</span><br><span class="line">        (<span class="name">error</span> <span class="string">"field not found"</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set</span> obj fld v)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">pr</span> (<span class="name">assoc-m</span> fld (<span class="name">obj-fields</span> obj))])</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> pr</span><br><span class="line">        (<span class="name">set-mcdr!</span> pr v)</span><br><span class="line">        (<span class="name">error</span> <span class="string">"field not found"</span>))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">send</span> obj msg . args) <span class="comment">; convenience: multi-argument functions (2+ arguments)</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">pr</span> (<span class="name"><span class="builtin-name">assoc</span></span> msg (<span class="name">obj-methods</span> obj))])</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> pr</span><br><span class="line">        ((<span class="name"><span class="builtin-name">cdr</span></span> pr) obj args) <span class="comment">; do the call</span></span><br><span class="line">        (<span class="name">error</span> <span class="string">"method not found"</span> msg))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-point</span> _x _y)</span><br><span class="line">  (<span class="name">obj</span></span><br><span class="line">   (<span class="name"><span class="builtin-name">list</span></span> (<span class="name">mcons</span> <span class="symbol">'x</span> _x)</span><br><span class="line">         (<span class="name">mcons</span> <span class="symbol">'y</span> _y))</span><br><span class="line">   (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'get-x</span> (<span class="name"><span class="builtin-name">lambda</span></span> (self args) (<span class="name">get</span> self <span class="symbol">'x</span>)))</span><br><span class="line">         (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'get-y</span> (<span class="name"><span class="builtin-name">lambda</span></span> (self args) (<span class="name">get</span> self <span class="symbol">'y</span>)))</span><br><span class="line">         (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'set-x</span> (<span class="name"><span class="builtin-name">lambda</span></span> (self args) (<span class="name">set</span> self <span class="symbol">'x</span> (<span class="name"><span class="builtin-name">car</span></span> args))))</span><br><span class="line">         (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'set-y</span> (<span class="name"><span class="builtin-name">lambda</span></span> (self args) (<span class="name">set</span> self <span class="symbol">'y</span> (<span class="name"><span class="builtin-name">car</span></span> args))))</span><br><span class="line">         (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'distToOrigin</span> </span><br><span class="line">               (<span class="name"><span class="builtin-name">lambda</span></span> (self args)</span><br><span class="line">                 (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">a</span> (<span class="name">send</span> self <span class="symbol">'get-x</span>)]</span><br><span class="line">                       [<span class="name">b</span> (<span class="name">send</span> self <span class="symbol">'get-y</span>)])</span><br><span class="line">                   (<span class="name"><span class="builtin-name">sqrt</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> a a) (<span class="name"><span class="builtin-name">*</span></span> b b)))))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-color-point</span> _x _y _c)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">pt</span> (<span class="name">make-point</span> _x _y)])</span><br><span class="line">    (<span class="name">obj</span></span><br><span class="line">     (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">mcons</span> <span class="symbol">'color</span> _c) </span><br><span class="line">           (<span class="name">obj-fields</span> pt))</span><br><span class="line">     (<span class="name"><span class="builtin-name">append</span></span> (<span class="name"><span class="builtin-name">list</span></span></span><br><span class="line">              (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'get-color</span> (<span class="name"><span class="builtin-name">lambda</span></span> (self args) (<span class="name">get</span> self <span class="symbol">'color</span>)))</span><br><span class="line">              (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'set-color</span> (<span class="name"><span class="builtin-name">lambda</span></span> (self args) (<span class="name">set</span> self <span class="symbol">'color</span> (<span class="name"><span class="builtin-name">car</span></span> args)))))</span><br><span class="line">           (<span class="name">obj-methods</span> pt)))))</span><br><span class="line">      </span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-polar-point</span> _r _th)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">pt</span> (<span class="name">make-point</span> <span class="literal">#f</span> <span class="literal">#f</span>)])</span><br><span class="line">    (<span class="name">obj</span></span><br><span class="line">     (<span class="name"><span class="builtin-name">append</span></span> (<span class="name"><span class="builtin-name">list</span></span> (<span class="name">mcons</span> <span class="symbol">'r</span> _r)</span><br><span class="line">                   (<span class="name">mcons</span> <span class="symbol">'theta</span> _th))</span><br><span class="line">             (<span class="name">obj-fields</span> pt)) <span class="comment">; Java-style field extension</span></span><br><span class="line">     (<span class="name"><span class="builtin-name">append</span></span> <span class="comment">; overriding by being earlier in the list (see send function)</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">list</span></span> </span><br><span class="line">       (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'set-r-theta</span> </span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> (self args)</span><br><span class="line">               (<span class="name"><span class="builtin-name">begin</span></span> </span><br><span class="line">                 (<span class="name">set</span> self <span class="symbol">'r</span> (<span class="name"><span class="builtin-name">car</span></span> args))</span><br><span class="line">                 (<span class="name">set</span> self <span class="symbol">'theta</span> (<span class="name"><span class="builtin-name">cadr</span></span> args)))))</span><br><span class="line">       (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'get-x</span> (<span class="name"><span class="builtin-name">lambda</span></span> (self args)</span><br><span class="line">                      (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">r</span> (<span class="name">get</span> self <span class="symbol">'r</span>)]</span><br><span class="line">                            [<span class="name">theta</span> (<span class="name">get</span> self <span class="symbol">'theta</span>)])</span><br><span class="line">                        (<span class="name"><span class="builtin-name">*</span></span> r (<span class="name"><span class="builtin-name">cos</span></span> theta)))))</span><br><span class="line">       (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'get-y</span> (<span class="name"><span class="builtin-name">lambda</span></span> (self args)</span><br><span class="line">                      (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">r</span> (<span class="name">get</span> self <span class="symbol">'r</span>)]</span><br><span class="line">                            [<span class="name">theta</span> (<span class="name">get</span> self <span class="symbol">'theta</span>)])</span><br><span class="line">                        (<span class="name"><span class="builtin-name">*</span></span> r (<span class="name"><span class="builtin-name">sin</span></span> theta)))))</span><br><span class="line">       (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'set-x</span> (<span class="name"><span class="builtin-name">lambda</span></span> (self args) </span><br><span class="line">                      (<span class="name"><span class="builtin-name">let*</span></span> ([<span class="name">a</span>     (<span class="name"><span class="builtin-name">car</span></span> args)]</span><br><span class="line">                             [<span class="name">b</span>     (<span class="name">send</span> self <span class="symbol">'get-y</span>)]</span><br><span class="line">                             [<span class="name">theta</span> (<span class="name"><span class="builtin-name">atan</span></span> b a)]</span><br><span class="line">                             [<span class="name">r</span>     (<span class="name"><span class="builtin-name">sqrt</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> a a) (<span class="name"><span class="builtin-name">*</span></span> b b)))])</span><br><span class="line">                        (<span class="name">send</span> self <span class="symbol">'set-r-theta</span> r theta))))</span><br><span class="line">       (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'set-y</span> (<span class="name"><span class="builtin-name">lambda</span></span> (self args) </span><br><span class="line">                      (<span class="name"><span class="builtin-name">let*</span></span> ([<span class="name">b</span>     (<span class="name"><span class="builtin-name">car</span></span> args)]</span><br><span class="line">                             [<span class="name">a</span>     (<span class="name">send</span> self <span class="symbol">'get-x</span>)]</span><br><span class="line">                             [<span class="name">theta</span> (<span class="name"><span class="builtin-name">atan</span></span> b a)]</span><br><span class="line">                             [<span class="name">r</span>     (<span class="name"><span class="builtin-name">sqrt</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> a a) (<span class="name"><span class="builtin-name">*</span></span> b b)))])</span><br><span class="line">                        (<span class="name">send</span> self <span class="symbol">'set-r-theta</span> r theta)))))</span><br><span class="line">      (<span class="name">obj-methods</span> pt)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> p1 (<span class="name">make-point</span> <span class="number">-4</span> <span class="number">0</span>))</span><br><span class="line">p1</span><br><span class="line">(<span class="name">send</span> p1 <span class="symbol">'get-x</span>)</span><br><span class="line">(<span class="name">send</span> p1 <span class="symbol">'get-y</span>)</span><br><span class="line">(<span class="name">send</span> p1 <span class="symbol">'distToOrigin</span>)</span><br><span class="line">(<span class="name">send</span> p1 <span class="symbol">'set-y</span> <span class="number">3</span>)</span><br><span class="line">(<span class="name">send</span> p1 <span class="symbol">'distToOrigin</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> p2 (<span class="name">make-color-point</span> <span class="number">-4</span> <span class="number">0</span> <span class="string">"red"</span>))</span><br><span class="line">p2</span><br><span class="line">(<span class="name">send</span> p2 <span class="symbol">'get-x</span>)</span><br><span class="line">(<span class="name">send</span> p2 <span class="symbol">'get-y</span>)</span><br><span class="line">(<span class="name">send</span> p2 <span class="symbol">'distToOrigin</span>)</span><br><span class="line">(<span class="name">send</span> p2 <span class="symbol">'set-y</span> <span class="number">3</span>)</span><br><span class="line">(<span class="name">send</span> p2 <span class="symbol">'distToOrigin</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> p3 (<span class="name">make-polar-point</span> <span class="number">4</span> <span class="number">3.1415926535</span>))</span><br><span class="line">p3</span><br><span class="line">(<span class="name">send</span> p3 <span class="symbol">'get-x</span>)</span><br><span class="line">(<span class="name">send</span> p3 <span class="symbol">'get-y</span>)</span><br><span class="line">(<span class="name">send</span> p3 <span class="symbol">'distToOrigin</span>)</span><br><span class="line">(<span class="name">send</span> p3 <span class="symbol">'set-y</span> <span class="number">3</span>)</span><br><span class="line">(<span class="name">send</span> p3 <span class="symbol">'distToOrigin</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 编程语言理论 </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part C) 笔记 1 Introduction</title>
      <link href="/2019/02/23/Programming-Languages-Part-C-%E7%AC%94%E8%AE%B0-1-Introduction/"/>
      <url>/2019/02/23/Programming-Languages-Part-C-%E7%AC%94%E8%AE%B0-1-Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>感谢 <a href="https://www.coursera.org/learn/programming-languages-part-c/home/welcome" target="_blank" rel="noopener">Coursera</a>。</p><h2 id="Course-Information-and-Overview"><a href="#Course-Information-and-Overview" class="headerlink" title="Course Information and Overview"></a>Course Information and Overview</h2><h3 id="Welcome-to-Part-C"><a href="#Welcome-to-Part-C" class="headerlink" title="Welcome to Part C"></a>Welcome to Part C</h3><p>Ruby 是动态类型 OOP 语言，并且是纯 OOP 的（所有的值都是对象）。</p><h3 id="Overview-of-Part-C-Concepts"><a href="#Overview-of-Part-C-Concepts" class="headerlink" title="Overview of Part C Concepts"></a>Overview of Part C Concepts</h3><ul><li>动态类型 OOP 语言</li><li>OOP 和 FP 在解决问题时如何对问题进行分解</li><li>子类型、泛型和子类型</li></ul><a id="more"></a><h3 id="Part-C-Course-Structure"><a href="#Part-C-Course-Structure" class="headerlink" title="Part C Course Structure"></a>Part C Course Structure</h3><p><em>本节没有问题。</em></p><h2 id="Software-Installation"><a href="#Software-Installation" class="headerlink" title="Software Installation"></a>Software Installation</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S ruby ruby-irb</span><br></pre></td></tr></table></figure><p>使用 <code>ruby &quot;foo.rb&quot;</code> 运行文件，使用 <code>irb</code> 进入 REPL，REPL 中使用 <code>load &quot;foo.rb&quot;</code> 读取文件。</p><p>安装 VS Code 的 Ruby 扩展。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程语言理论 </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part B) 笔记 4 Section 7</title>
      <link href="/2019/02/17/Programming-Languages-Part-B-%E7%AC%94%E8%AE%B0-4-Section-7/"/>
      <url>/2019/02/17/Programming-Languages-Part-B-%E7%AC%94%E8%AE%B0-4-Section-7/</url>
      
        <content type="html"><![CDATA[<h1 id="Section-7"><a href="#Section-7" class="headerlink" title="Section 7"></a>Section 7</h1><h2 id="ML-Versus-Racket"><a href="#ML-Versus-Racket" class="headerlink" title="ML Versus Racket"></a>ML Versus Racket</h2><p>ML 和 Racket 最大的不同在于 ML 是静态类型而 Racket 是动态类型。采用静态类型可以在运行前的编译阶段检查出一系列错误，从而减少程序程序的潜在错误。</p><p>它们可以互相实现对方的类型系统。</p><h3 id="Racket-实现-ML"><a href="#Racket-实现-ML" class="headerlink" title="Racket 实现 ML"></a>Racket 实现 ML</h3><p>在 Racket 程序员看来，ML 是 Racket 的一个子集，只允许一部分合法的程序运行。Racket 程序中，只有一部分符合 ML 类型系统要求的程序能够通过 ML 编译器（忽略语法差异），这种限制使得程序的一些潜在 bug 被提前检查出来，但是同时一些本来可以正常运行的程序也被拒绝了。例如以下程序在 Racket 中合法但是在 ML 中不合法：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> x) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> x <span class="number">0</span>) <span class="literal">#t</span> (<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="number">2</span>)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> xs (<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="literal">#t</span> <span class="string">"hi"</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> y (<span class="name">f</span> (<span class="name"><span class="builtin-name">car</span></span> xs)))</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="ML-实现-Racket"><a href="#ML-实现-Racket" class="headerlink" title="ML 实现 Racket"></a>ML 实现 Racket</h3><p>在 ML 程序员看来，Racket 是 ML 的一个超集，一些在 ML 中无法通过编译的程序被 Racket 编译器接受，其中一些有 bug，另一些没有。</p><p>但是有另外一种看法，可以在 ML 中模拟出 Racket 的类型系统来。在此观点下，Racket 的类型系统实际上是 ML 类型系统应用的某种 idiom。具体来说，Racket 中所有的类型都是某个 datatype 的一个类型，即</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">datatype</span> theType = <span class="type">Int</span> <span class="keyword">of</span> <span class="built_in">int</span></span><br><span class="line">    | <span class="type">String</span> <span class="keyword">of</span> <span class="built_in">string</span></span><br><span class="line">    | <span class="type">Pair</span> <span class="keyword">of</span> theType * theType</span><br><span class="line">    | <span class="type">Fun</span> <span class="keyword">of</span> theType -&gt; theType</span><br><span class="line">    | ... <span class="comment">(* one constructor per built-in type *)</span></span><br></pre></td></tr></table></figure><p>而各种函数实际上都有一个隐式的模式匹配，实现上可能是：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> car v = <span class="keyword">case</span> v <span class="keyword">of</span> <span class="type">Pair</span>(a,b) =&gt; a | _ =&gt; <span class="keyword">raise</span> ... <span class="comment">(* give some error *)</span></span><br><span class="line"><span class="keyword">fun</span> pair? v = <span class="keyword">case</span> v <span class="keyword">of</span> <span class="type">Pair</span> _ =&gt; <span class="literal">true</span> | _ =&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这样就能模拟出来的。用 ML 模拟 Racket 时，Racket 中的各种类型实际是 ML 某个 datatype 下的构造函数。</p><p>但是 Racket 中可以使用 <code>struct</code> 来动态地添加新类型，在 ML 中做到这一点比较麻烦，需要用到 <code>exn</code> 类型。ML 是不能实现一个能够动态添加构造函数的 datatype 的类型系统的，这会导致一些问题，例如模式匹配完备性的检查无法静态完成。</p><h2 id="What-is-Static-Checking"><a href="#What-is-Static-Checking" class="headerlink" title="What is Static Checking?"></a>What is Static Checking?</h2><p>静态检查的定义：语法解析完成后、程序运行前的检查。静态检查可能是语言规范的一部分，但是也不一定是，有些静态检查工具，它们不属于语言定义本身。</p><p>最常见的静态检查就是类型系统。类型系统是静态检查的一种手段，静态检查的目的是拒绝可能错误的程序。Racket 的动态类型系统在运行时需要维护每个变量的类型信息，而 ML 的静态类型系统则不需要在运行时维护，可以在编译时确定，这么做的代价是一部分本可以运行正确的程序也被拒绝了。</p><p>检查可以发生在任何时候，以防止除以 0 为例，从早到晚有这些检查方式：</p><ul><li>在文本编辑器中禁止用户输入 0；</li><li>允许文本输入，但是编译阶段禁止除以 0；</li><li>允许除以 0 的函数通过编译阶段，但是链接时，主函数不能调用这些函数；</li><li>允许链接并运行这些函数，在即将计算前报错；</li><li>计算时不报错，返回无穷大。</li></ul><p>最常用的是编译阶段时的检查和运行时的检查，对应静态检查和动态检查。</p><h2 id="Soundness-and-Completeness"><a href="#Soundness-and-Completeness" class="headerlink" title="Soundness and Completeness"></a>Soundness and Completeness</h2><p>假设一个类型系统希望阻止所有有性质 X 的程序（性质 X 例如数组访问有可能越界）：</p><ul><li>如果一个在某个输入下带有性质 X 的程序总是被类型系统拒绝，这样的类型系统称为 sound 的（可靠的）。可靠的类型系统不会产生 false negative，永远不会错误地接受可能带有性质 X 的程序（但是有 false positive，即有可能拒绝不会带有性质 X 的程序）。</li><li>如果一个在所有的输入下都不会带有性质 X 的程序总是被类型系统接收，这样的类型系统称为是 complete 的（完备的）。完备的系统不会产生 false positive，永远不会错误地拒绝不会带有性质 X 的程序（但是有 false negative，即有可能接受带有性质 X 的程序）。</li></ul><p>这两个性质是 <strong>正确性的两方面</strong>。在阻止性质 X 的层面上，可靠性比完备性要靠谱。由于不可判定性，同时满足可靠、完备、以及在有限时间内停机的类型系统是不存在的（和停机问题类似）。一般的类型系统会放弃掉完备性，只做到可靠和在有限时间类停机。</p><h2 id="Weak-Typing"><a href="#Weak-Typing" class="headerlink" title="Weak Typing"></a>Weak Typing</h2><p><strong>弱类型</strong> 是一个性质。弱类型的语言可能通过类型检查，但是如果类型本身依然存在错误的话，在运行阶段 <strong>可能发生任何事情</strong>，行为是未定义的。相反地，强类型语言不会允许这种事情发生。一个例子是数组越界，弱类型的语言往往不会处理数组越界，越界行为是未定义的；但是强类型语言可能会保证抛出异常。简单来说，弱类型出现错误无法预测结果，强类型出现错误可以预测结果。</p><p>弱类型有这些好处：</p><ul><li>语言实现更加简单（因为部分类型检查工作需要程序员完成而不是编译器）</li><li>性能更好（运行时没有动态检查）</li><li>语言更加底层（如果要处理数组越界就要为数组维护长度，不够底层）</li></ul><p>人们引入弱类型是为了达到上述好处，但是随着代码量增大，强类型的用处逐渐体现出来了。</p><p>Racket 是强类型的，因为它会在运行时进行动态的类型检查，这是语言定义的一部分。</p><p>即时使用了强类型，也无法避免代码中的逻辑错误。</p><hr><p>经常与强类型、弱类型搞混的一个话题是关于原生类型可以执行的操作。不同语言对此处理不同：有的语言允许字符串相加（表示连接），有的语言还允许字符串和数字相加（会发生对应的转换）。这个话题和强弱类型容易搞混是因为它也涉及到及早发现 bug 和便利性之间的权衡。</p><h2 id="Static-Versus-Dynamic-Typing-Part-One"><a href="#Static-Versus-Dynamic-Typing-Part-One" class="headerlink" title="Static Versus Dynamic Typing, Part One"></a>Static Versus Dynamic Typing, Part One</h2><p>大部分语言执行的检查都是混合了动态性和静态性的。部分检查动态进行、部分检查静态进行。</p><h3 id="关于便利性"><a href="#关于便利性" class="headerlink" title="关于便利性"></a>关于便利性</h3><p>动态类型语言的便利性在于你可以混合不同的类型，例如创建一个返回不同类型的值的函数，然后让用户决定如何使用这个不确定类型的返回值。用户使用时可以使用类似 <code>string?</code> 的函数进行判断，而要在静态类型语言中做到这一点就要用模式匹配。</p><p>静态类型语言的便利性在于函数的创建者知道用户传入的参数的类型，而不用为这个参数到底是什么类型作判断和处理。传入类型不符时会报错。</p><h3 id="关于类型检查"><a href="#关于类型检查" class="headerlink" title="关于类型检查"></a>关于类型检查</h3><p>静态类型语言的检查会拒绝掉一部分没有问题的程序：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> f g = (g <span class="number">7</span>, g <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> pair_of_pairs = f (<span class="keyword">fn</span> x =&gt; (x, x))</span><br></pre></td></tr></table></figure><p>这段代码无法通过类型检查。这种拒绝会带来一定的麻烦，不过也避免了一些 bug。</p><p>如果希望绕过这种类型检查可以使用前面提到的用 ML 模拟 Racket 类型系统的方式，将所有想要混用的类型创建为一个 datatype。这种方式尽管麻烦，但是给了程序员更加细粒度的控制。这种方式在平时几乎用不上。</p><h3 id="关于错误检查"><a href="#关于错误检查" class="headerlink" title="关于错误检查"></a>关于错误检查</h3><p>静态类型语言能够在编译阶段就检查出一些 bug，这是比较有用的。但是它能够检查出的 bug 比较低级。</p><p>不论是静态语言还是动态语言，很多逻辑上的 bug 都是类型系统无法检查出的。对于这种 bug，如果想要检查到它们的话，二者可以使用相同的策略。</p><h2 id="Static-Versus-Dynamic-Typing-Part-Two"><a href="#Static-Versus-Dynamic-Typing-Part-Two" class="headerlink" title="Static Versus Dynamic Typing, Part Two"></a>Static Versus Dynamic Typing, Part Two</h2><h3 id="关于性能"><a href="#关于性能" class="headerlink" title="关于性能"></a>关于性能</h3><p>静态类型系统具有更好的性能，同时能够防止一些简单的 bug，这是因为动态类型语言中必须对每个值维护一个表明它是什么类型的 tag。</p><p>对于动态语言来说，因为语言本身没有规定要进行所有的检查，所以编译器可以选择性地优化一部分动态类型检查。</p><h3 id="关于代码重用性"><a href="#关于代码重用性" class="headerlink" title="关于代码重用性"></a>关于代码重用性</h3><p>动态类型语言可以在类型系统很简单的情况下重用代码，但是可能引入 bug。</p><p>静态类型语言中可重用代码部分的类型可能很复杂，但是使用起来不一定复杂，并且可以检查出一些 bug。</p><h3 id="关于写一个原型程序"><a href="#关于写一个原型程序" class="headerlink" title="关于写一个原型程序"></a>关于写一个原型程序</h3><p>动态类型语言可以快速地写出原型程序，而不用考虑到所有对可能情况。静态类型语言在写原型程序之前，为了能让程序跑通也要写一些和原型程序逻辑几乎无关的代码，比较麻烦。</p><p>静态类型语言保证了可以使用类型系统作为一种约束，而那些需要额外考虑的其它所有情况可以通过抛异常、通配模式匹配等方式较容易地解决。</p><h3 id="关于软件演化"><a href="#关于软件演化" class="headerlink" title="关于软件演化"></a>关于软件演化</h3><p>动态类型语言可以较容易地保持后向兼容性。如果一个函数总是接受 int 返回 int，要扩展一个接受 string 返回 string 的功能，使用动态类型语言时所有之前调用这个函数的用户都不会受到影响。而静态语言中则会破坏掉后向兼容。</p><p>静态类型语言可以依赖类型系统来完成软件的演化。例如假设需要修改一个函数的返回值类型，通过类型系统可以轻易找到所有调用这个函数的地方，并且直到所有的修改都已完成程序才会跑通。用户自己对类型的定义越详细，受益于类型系统就越多。不过，这样就无法在修改了一部分的情况下运行程序查看结果了。</p><h2 id="eval-and-quote"><a href="#eval-and-quote" class="headerlink" title="eval and quote"></a><code>eval</code> and <code>quote</code></h2><p><code>eval</code> 和 <code>quote</code> 是两个相反的概念。</p><p><code>eval</code> 用于 <strong>将数据当作程序</strong>。在很多语言中 <code>eval</code> 接受的是符合当前程序语法的字符串，但是在 Racket 中由于数据的表示方式和程序表示方式相同，因此可以统一进行表示（实际上从外观上是不可能区分出程序与数据的）。Racket 中在函数前加一个 <code>&#39;</code> 可以将其转化为符号，因此可以构造出这样的 <strong>列表</strong>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> foo (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'begin</span> (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'print</span> <span class="string">"hi"</span>) (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'+</span> <span class="number">4</span> <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>注意 <code>foo</code> 是数据，它是一个列表，里面有三个元素（REPL 中显示的不一样，列表中的单引号都不会显示出来）：</p><ul><li><code>&#39;begin</code></li><li><code>(list &#39;print &quot;hi&quot;)</code></li><li><code>(list &#39;+ 4 2)</code></li></ul><p>这一步中没有任何求值发生。随后可以对 <code>foo</code> 进行 <code>eval</code>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> bar (<span class="name"><span class="builtin-name">eval</span></span> foo))</span><br></pre></td></tr></table></figure><p>屏幕会打印 &quot;hi&quot; 并且 <code>bar</code> 会绑定为 6，此时就运行了代码。</p><p>对于函数都要写单引号比较麻烦，<code>quote</code> 可以 <strong>将程序当作数据</strong>，是 <code>eval</code> 的反过程：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> foo (<span class="name"><span class="builtin-name">quote</span></span> begin (<span class="name">print</span> <span class="string">"hi"</span>) (<span class="name"><span class="builtin-name">+</span></span> <span class="number">4</span> <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>这和上面的定义是等价的。这个过程中 <code>list</code> 被省去了。可以在 <code>quote</code> 中使用quasiquoting 概念来引入一个需要计算的表达式，有点类似其它接受字符串的语言中，对这个字符串本身进行插值。</p><hr><p>实现了 <code>eval</code> 函数的往往是解释性的工具，但这不意味着带有 <code>eval</code> 的语言必然以解释性的方式实现，实际上编译性的也是可以的。</p><p>一个典型的需要用到 <code>eval</code> 的地方是使用语言 A 写语言 A 的 REPL，这里的 REPL 中的 E 就可以使用 <code>eval</code>。</p><hr><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> 编程语言理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part B) 笔记 3 Section 6</title>
      <link href="/2019/02/17/Programming-Languages-Part-B-%E7%AC%94%E8%AE%B0-3-Section-6/"/>
      <url>/2019/02/17/Programming-Languages-Part-B-%E7%AC%94%E8%AE%B0-3-Section-6/</url>
      
        <content type="html"><![CDATA[<h1 id="Section-6"><a href="#Section-6" class="headerlink" title="Section 6"></a>Section 6</h1><h2 id="Datatype-Programming-in-Racket-Without-Structs"><a href="#Datatype-Programming-in-Racket-Without-Structs" class="headerlink" title="Datatype-Programming in Racket Without Structs"></a>Datatype-Programming in Racket Without Structs</h2><p>在 Racket 中使用列表和 symbol 可以模拟出 ML 中的 datatype。Racket 中的 symbol 是以 <code>&#39;</code> 开头的字符串，例如 <code>&#39;foo</code>，symbol 之间用 <code>eq?</code> 判断相等。</p><p>以下是一个移植的例子：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">datatype</span> exp = <span class="type">Const</span> <span class="keyword">of</span> <span class="built_in">int</span></span><br><span class="line">             | <span class="type">Negate</span> <span class="keyword">of</span> exp</span><br><span class="line">             | <span class="type">Add</span> <span class="keyword">of</span> exp * exp</span><br><span class="line">             | <span class="type">Multiply</span> <span class="keyword">of</span> exp * exp</span><br></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">Const</span> i) (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'Const</span> i))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">Negate</span> e) (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'Negate</span> e))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">Add</span> e1 e2) (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'Add</span> e1 e2))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">Multiply</span> e1 e2) (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'Multiply</span> e1 e2))</span><br></pre></td></tr></table></figure><p>针对于 <code>exp</code> 类型的 ML 函数都可以使用 Racket 写出，模式匹配功能可以用 cond 进行模拟，通过对列表的第一个元素进行比较确定它到底是哪种类型即可。</p><a id="more"></a><h2 id="Datatype-Programming-in-Racket-With-Structs"><a href="#Datatype-Programming-in-Racket-With-Structs" class="headerlink" title="Datatype-Programming in Racket With Structs"></a>Datatype-Programming in Racket With Structs</h2><p>Racket 中可以通过定义表达式的类型的方式更好的完成上一节的任务。通用的语法是</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">struct</span> foo (<span class="name">bar</span> baz quux) #:transparent)</span><br></pre></td></tr></table></figure><p>结尾的 <code>#:transparent</code> 属性用来在 REPL 中更好地打印这个结构。完成定义以后，会免费得到以下函数：</p><ul><li><code>foo</code>：进行构造。</li><li><code>foo?</code>：判断表达式类型。</li><li><code>foo-bar</code>，<code>foo-baz</code>，<code>foo-quux</code>：用来取出对应域的值。</li><li>如果额外定义了 <code>#:mutable</code> 属性，还会得到 <code>set-foo-bar!</code>、<code>set-foo-baz!</code> 以及 <code>set-foo-quux!</code> 三个函数。</li></ul><p>注意 <code>bar</code> 这样的只是标记了一个域，域里面的内容的类型是没有限制的，由用户自己控制。</p><hr><p>这样一来上一节的任务可以写为：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">struct</span> const (<span class="name">int</span>) #:transparent)</span><br><span class="line">(<span class="name">struct</span> negate (<span class="name">e</span>) #:transparent)</span><br><span class="line">(<span class="name">struct</span> add (<span class="name">e1</span> e2) #:transparent)</span><br><span class="line">(<span class="name">struct</span> multiply (<span class="name">e1</span> e2) #:transparent)</span><br></pre></td></tr></table></figure><p>针对于 <code>exp</code> 类型的 ML 函数都可以使用 Racket 写出，合理使用定义结构时得到的函数可以让实现更简单。</p><h2 id="Advantages-of-Structs"><a href="#Advantages-of-Structs" class="headerlink" title="Advantages of Structs"></a>Advantages of Structs</h2><p><code>struct</code> 不是其它东西的语法糖，而是原生的能够构造出新类型的方式。如果用它构造了 <code>foo</code> 类型，那么只有 <code>foo?</code> 能返回 <code>#t</code>，其它所有类型判断都会返回 <code>#f</code>。尽管使用列表可以模拟出 <code>struct</code>，但是使用 <code>struct</code> 构造出的类型不是列表，即 <code>list?</code> 返回 <code>#f</code>。</p><p>通过使用 <code>struct</code> 可以更加精确地描述类型，同时使用它创建出来的函数也更加安全。如果没有 <code>struct</code> 的话就只能用列表和元组来定义新的类型，同时用户也能通过 <code>car</code> 和 <code>cdr</code> 进行访问，封装性不好。</p><h2 id="Implementing-Programming-Languages"><a href="#Implementing-Programming-Languages" class="headerlink" title="Implementing Programming Languages"></a>Implementing Programming Languages</h2><p>实现语言的工作流是：</p><ol><li>语法解析字符串，得到 AST</li><li>如果有类型检查的话对 AST 进行类型检查</li><li>进行编译或者解释</li></ol><p>在第 3 步中编译或者解释取决于语言的实现，解释指用语言 A 运行语言 B 并得到结果；编译指用语言 A 将语言 B 翻译到语言 C，这需要语言 C 已经被实现。对于翻译到机器语言的，可以认为机器语言的实现是具体的硬件。语言 A 称为 metalanguage。这两种方式可以结合起来，比如 Java。</p><p>语言本身不会有“解释型语言”和“编译型语言”的分类，解释和编译只是语言实现方式的选择，大部分语言都是既能解释也能编译的，因此“解释型语言”这种说法有问题。</p><h2 id="What-Your-Interpreter-Can-and-Cannot-Assume"><a href="#What-Your-Interpreter-Can-and-Cannot-Assume" class="headerlink" title="What Your Interpreter Can and Cannot Assume"></a>What Your Interpreter Can and Cannot Assume</h2><p><em>从这一节开始的内容都是在讲怎么用 Racket 实现一个玩具语言。</em></p><p>在实现语言的时候会跳过语法解析步骤，直接在 Racket 中写出语法树。因为 Racket 的语法，这么做是很容易的。实现语言时直接用 Racket 解释输入的语法树即可，可以假定输入的语法树总是正确的，但是正确的语法树不一定对应正确的程序，例如还有可能有类型错误。因此：</p><ul><li>解释器可以假定语法树是正确的，即语言通过了语法解析</li><li>解释器不能假定程序具有正确的语义，还要在解释时进行类型检查</li></ul><p>例子如下，假设实现的语言具有以下元素：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; a larger language with two kinds of values, booleans and numbers</span></span><br><span class="line"><span class="comment">; an expression is any of these:</span></span><br><span class="line">(<span class="name">struct</span> const (<span class="name">int</span>) #:transparent) <span class="comment">; int should hold a number</span></span><br><span class="line">(<span class="name">struct</span> negate (<span class="name">e1</span>) #:transparent)  <span class="comment">; e1 should hold an expression</span></span><br><span class="line">(<span class="name">struct</span> add (<span class="name">e1</span> e2) #:transparent) <span class="comment">; e1, e2 should hold expressions</span></span><br><span class="line">(<span class="name">struct</span> multiply (<span class="name">e1</span> e2) #:transparent) <span class="comment">; e1, e2 should hold expressions</span></span><br><span class="line">(<span class="name">struct</span> bool (<span class="name">b</span>) #:transparent) <span class="comment">; b should hold #t or #f</span></span><br><span class="line">(<span class="name">struct</span> eq-num (<span class="name">e1</span> e2) #:transparent) <span class="comment">; e1, e2 should hold expressions</span></span><br><span class="line">(<span class="name">struct</span> if-then-else (<span class="name">e1</span> e2 e3) #:transparent) <span class="comment">; e1, e2, e3 should hold expressions</span></span><br><span class="line"><span class="comment">; a value in this language is a legal const or bool</span></span><br></pre></td></tr></table></figure><p>那么实现解释器时应当注意到类型检查：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">eval-exp</span> e)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> [(<span class="name">const?</span> e)</span><br><span class="line">         e]</span><br><span class="line">        [(<span class="name">negate?</span> e)</span><br><span class="line">         (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">v</span> (<span class="name">eval-exp</span> (<span class="name">negate-e1</span> e))])</span><br><span class="line">           (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">const?</span> v)</span><br><span class="line">               (<span class="name">const</span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">const-int</span> v)))</span><br><span class="line">               (<span class="name">error</span> <span class="string">"negate applied to non-number"</span>)))]</span><br><span class="line">        [(<span class="name">add?</span> e)</span><br><span class="line">         (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">v1</span> (<span class="name">eval-exp</span> (<span class="name">add-e1</span> e))]</span><br><span class="line">               [<span class="name">v2</span> (<span class="name">eval-exp</span> (<span class="name">add-e2</span> e))])</span><br><span class="line">           (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name">const?</span> v1) (<span class="name">const?</span> v2))</span><br><span class="line">               (<span class="name">const</span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">const-int</span> v1) (<span class="name">const-int</span> v2)))</span><br><span class="line">               (<span class="name">error</span> <span class="string">"add applied to non-number"</span>)))]</span><br><span class="line">        [(<span class="name">multiply?</span> e)</span><br><span class="line">         (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">v1</span> (<span class="name">eval-exp</span> (<span class="name">multiply-e1</span> e))]</span><br><span class="line">               [<span class="name">v2</span> (<span class="name">eval-exp</span> (<span class="name">multiply-e2</span> e))])</span><br><span class="line">           (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name">const?</span> v1) (<span class="name">const?</span> v2))</span><br><span class="line">               (<span class="name">const</span> (<span class="name"><span class="builtin-name">*</span></span> (<span class="name">const-int</span> v1) (<span class="name">const-int</span> v2)))</span><br><span class="line">               ((<span class="name">error</span> <span class="string">"multiply applied to non-number"</span>))))]</span><br><span class="line">        [(<span class="name">bool?</span> e)</span><br><span class="line">         e]</span><br><span class="line">        [(<span class="name">eq-num?</span> e)</span><br><span class="line">         (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">v1</span> (<span class="name">eval-exp</span> (<span class="name">eq-num-e1</span> e))]</span><br><span class="line">               [<span class="name">v2</span> (<span class="name">eval-exp</span> (<span class="name">eq-num-e2</span> e))])</span><br><span class="line">           (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name">const?</span> v1) (<span class="name">const?</span> v2))</span><br><span class="line">               (<span class="name">bool</span> (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">const-int</span> v1) (<span class="name">const-int</span> v2))) <span class="comment">; creates (bool #t) or (bool #f)</span></span><br><span class="line">               (<span class="name">error</span> <span class="string">"eq-num applied to non-number"</span>)))]</span><br><span class="line">        [(<span class="name">if-then-else?</span> e)</span><br><span class="line">         (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">v-test</span> (<span class="name">eval-exp</span> (<span class="name">if-then-else-e1</span> e))])</span><br><span class="line">           (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">bool?</span> v-test)</span><br><span class="line">               (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">bool-b</span> v-test)</span><br><span class="line">                   (<span class="name">eval-exp</span> (<span class="name">if-then-else-e2</span> e))</span><br><span class="line">                   (<span class="name">eval-exp</span> (<span class="name">if-then-else-e3</span> e)))</span><br><span class="line">               (<span class="name">error</span> <span class="string">"if-then-else applied to non-boolean"</span>)))]</span><br><span class="line">        [<span class="literal">#t</span> (<span class="name">error</span> <span class="string">"eval-exp expected an exp"</span>)] <span class="comment">; not strictly necessary but helps debugging</span></span><br><span class="line">        ))</span><br></pre></td></tr></table></figure><p>正如上面代码中这段一样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">if</span></span> (<span class="name">const?</span> v)</span><br><span class="line">(<span class="name">const</span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">const-int</span> v)))</span><br><span class="line">(error "negate applied to non-number")))]</span><br></pre></td></tr></table></figure><p>但是下面这种错误是不用管的，因为它根本不是合法的语法树：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">multiply</span> (<span class="name">negate</span> (<span class="name">add</span> (<span class="name">const</span> <span class="number">3</span>) <span class="number">5</span>)))</span><br></pre></td></tr></table></figure><h2 id="Implementing-Variables-and-Environments"><a href="#Implementing-Variables-and-Environments" class="headerlink" title="Implementing Variables and Environments"></a>Implementing Variables and Environments</h2><p>为了实现变量的概念，需要写一个递归的辅助函数，它接受一个表达式和对应的环境，在该环境下对表达式进行求值。有变量时在传入的环境中进行查询。对于有 mutation 和异常的语言，这个辅助函数还要有更多的参数。</p><p>环境的实现可以用高效的数据结构，在不考虑性能的情况下它只要是个映射表就行了。</p><p>对于给定的环境，它可能被按照如下方式使用：</p><ul><li>在对变量进行求值时，在环境中找到变量</li><li>在对大部分表达式进行求值时，将环境传给对子表达式进行求值的函数</li><li>在对例如绑定语句的表达式进行求值时，求完值后后续的环境会发生变化（例如添加了新的表项）</li></ul><p>初始时，环境应该是空的。</p><h2 id="Implementing-Closures"><a href="#Implementing-Closures" class="headerlink" title="Implementing Closures"></a>Implementing Closures</h2><p>为了实现词法作用域，需要实现闭包。在创建函数时，需要创建的内容为函数体和创建时当前的环境的二元组，即闭包。函数体不是值，闭包才是值。对函数进行求值时，应当返回一个闭包而不仅仅是函数体。</p><p>当要进行函数调用时（Racket 中的 <code>e1 e2</code>），按照如下步骤进行：</p><ol><li><strong>对函数求值</strong>：首先对 <code>e1</code> 进行求值，使用的环境为当前环境，得到闭包 $(body, env)$。闭包中的环境就是当前环境。</li><li><strong>对参数求值</strong>：对 <code>e2</code> 进行求值，使用的环境依然为当前环境，得到 <code>e2</code> 的值。</li><li><strong>进行函数调用</strong>：对 $body$ 进行求值，使用的环境是 $env$，但是要加上“函数参数对应 <code>e2</code> 的值”这一表项。为了实现函数自己递归调用，还要加上函数自身。</li></ol><h2 id="Are-Closures-Efficient"><a href="#Are-Closures-Efficient" class="headerlink" title="Are Closures Efficient?"></a>Are Closures Efficient?</h2><h3 id="更高效地实现闭包"><a href="#更高效地实现闭包" class="headerlink" title="更高效地实现闭包"></a>更高效地实现闭包</h3><p>每创建一个函数都要复制一遍当前的环境，看上去对空间浪费较严重，但是实际上使用 Racket 时，因为 <code>cons</code> 得到的列表和原列表是共享存储的，所以浪费没有想象中那么大。</p><p>另一个实现时的技巧是 <strong>只保留函数体求值过程中要用到的绑定</strong>，为了完成这一点可以在编译阶段确定函数体中哪些在外部的绑定是有可能被用到的（注意是编译阶段而不是在运行时即将创建函数的阶段，后者会慢很多，而前者对程序中的每个函数只要进行一次），这种绑定中，变量称为 <strong>free variable</strong>（也可以把所有的绑定都看成是变量）。在对函数进行求值后返回的闭包的环境中只包含这些 free variables 即可，对于用不上的变量不用包含，这样就能让闭包的环境空间占用更小。</p><h3 id="将有闭包的语言编译到没有闭包的语言"><a href="#将有闭包的语言编译到没有闭包的语言" class="headerlink" title="将有闭包的语言编译到没有闭包的语言"></a>将有闭包的语言编译到没有闭包的语言</h3><p>如果源语言有闭包，目标语言没有闭包，依然是可以编译的。编译器对源语言函数进行求值时依然求出闭包，但是在目标语言中，所有的函数定义都额外接受一个“环境”参数，所有的函数调用都额外传入一个“环境”参数。在函数体中，如果函数需要用到 free variable 就在自己的“环境”参数中进行查询。</p><p>只要从头到尾都保证这个 convention 就可以在没有闭包的语言中模拟出闭包特性。</p><h2 id="Racket-Functions-As-“Macros”-For-Interpreted-Language"><a href="#Racket-Functions-As-“Macros”-For-Interpreted-Language" class="headerlink" title="Racket Functions As “Macros”  For Interpreted Language"></a>Racket Functions As “Macros”  For Interpreted Language</h2><p>在 Racket 中实现玩具语言时应当将 <strong>语言特性</strong> 和 <strong>元语言在实现时的功能</strong> 二者区分，例如在 <em>What Your Interpreter Can and Cannot Assume</em> 这节的代码中，<code>const</code> 是语言特性，<code>eval-exp</code> 是源语言在实现时的功能。</p><p>不过为了使玩具语言能够更好地被编写，可以使用 Racket 定义一些函数，这些函数接受若干 AST 并返回一个 AST，可以将这种函数看作是玩具语言的宏。例如可以定义这样的函数：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">list-product</span> es)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> es)</span><br><span class="line">    (<span class="name">const</span> <span class="number">1</span>)</span><br><span class="line">    (<span class="name">multiply</span> (<span class="name"><span class="builtin-name">car</span></span> es) (<span class="name">list-product</span> (<span class="name"><span class="builtin-name">cdr</span></span> es)))))</span><br></pre></td></tr></table></figure><p>尽管 <code>list-product</code> 看上去不是玩具语言特性的一部分，但依然可以在书写时使用之：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add</span> (<span class="name">const</span> <span class="number">3</span>) (<span class="name">list-product</span> (<span class="name"><span class="builtin-name">list</span></span> (<span class="name">const</span> <span class="number">1</span>) (<span class="name">const</span> <span class="number">2</span>) (<span class="name">const</span> <span class="number">3</span>) (<span class="name">const</span> <span class="number">4</span>))))</span><br></pre></td></tr></table></figure><p>由于这种函数的输入和输出都是玩具语言的 AST，因此确实可以看做是宏（将新的语法翻译到旧的语法上的方案）。注意在这个宏中不要执行任何的求值操作！因为宏是在编译前进行的，此处不应有任何实际的计算，计算不是宏的功能的一部分。上面的式子将会得到玩具语言中的一个合法表达式（而不应该得到 <code>(add (const 3) (const 24))</code>，否则违反前面的规则）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(add</span><br><span class="line">  (const 3)</span><br><span class="line">  (multiply</span><br><span class="line">    (const 1)</span><br><span class="line">    (multiply (const 2) (multiply (const 3) (multiply (const 4) (const 1))))))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> 编程语言理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part B) 笔记 2 Section 5</title>
      <link href="/2019/02/17/Programming-Languages-Part-B-%E7%AC%94%E8%AE%B0-2-Section-5/"/>
      <url>/2019/02/17/Programming-Languages-Part-B-%E7%AC%94%E8%AE%B0-2-Section-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Section-5"><a href="#Section-5" class="headerlink" title="Section 5"></a>Section 5</h1><h2 id="Introduction-to-Racket"><a href="#Introduction-to-Racket" class="headerlink" title="Introduction to Racket"></a>Introduction to Racket</h2><p>Racket 和 ML 最大的区别在于 Racket 是动态类型的。</p><p>Racket 和 Scheme 是很相似的语言，Racket 更加实用和现代。</p><p>一个简单的 Racket 程序：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; this is a comment</span></span><br><span class="line"></span><br><span class="line">#lang racket ; tell the language</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">provide</span></span> (<span class="name">all-defined-out</span>)) <span class="comment">; make all things visible</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> s <span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure><p>其中 <code>#lang racket</code> 是告诉 DrRacket 使用的是何种语言，因为 DrRacket 可以解释其它语言，所以必须在第一句话指出。<code>(provide (all-defined-out))</code> 是为了在其他文件中直接使用该文件的顶层定义，因为 Racket 的类型系统将每个文件单独试做一个模块，顶层定义默认不可见。</p><a id="more"></a><hr><p>因为没有用 DrRacket，如果要在 REPL 中读入代码的话（假设是 filename.rkt 文件），不需要 <code>#lang racket</code> 和 <code>(provide (all-defined-out))</code> 这两行，直接在 REPL 中使用 <code>(load &quot;filename.rkt&quot;)</code> 即可。</p><h2 id="Racket-Definitions-Functions-Conditionals"><a href="#Racket-Definitions-Functions-Conditionals" class="headerlink" title="Racket Definitions, Functions, Conditionals"></a>Racket Definitions, Functions, Conditionals</h2><p>使用 <code>define</code> 定义变量和函数，<code>lambda</code> 定义匿名函数，<code>if</code> 进行条件判断。</p><p>Racket 中的运算也是函数，所有的函数调用形式都是 <code>(func arg1 arg2 ... argn)</code>，使用前缀表达式：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> x <span class="number">3</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> y (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>凡是使用了函数就必然出现括号，凡是出现了括号必然用了函数（或者其它的什么玩意），反正括号不要少也不能多，例如 <code>(define x (3))</code> 是错的，解释器会认为程序想调用 <code>3</code> 这个函数。</p><p>定义函数可以使用匿名函数，也有对应的语法糖：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> cube1</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> x (<span class="name"><span class="builtin-name">*</span></span> x x))))</span><br><span class="line"></span><br><span class="line"><span class="comment">; * can take many arguments</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> cube2</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> x x x)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cube3</span> x) (<span class="name"><span class="builtin-name">*</span></span> x x x))</span><br></pre></td></tr></table></figure><p>Racket 有内建的多参数支持，不过依然可以人为使用科里化。下面是使用条件和手动科里化的例子：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">pow1</span> x y)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> y <span class="number">0</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> x (<span class="name">pow1</span> x (<span class="name"><span class="builtin-name">-</span></span> y <span class="number">1</span>)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> pow2</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (y)</span><br><span class="line">      (<span class="name">pow1</span> x y))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> three-to-the (<span class="name">pow2</span> <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> res1 ((<span class="name">pow2</span> <span class="number">2</span>) <span class="number">10</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> res2 (<span class="name">three-to-the</span> <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>由于没有内建科里化的语法糖，所以要使用上面那种麻烦的调用方式。</p><h2 id="Racket-Lists"><a href="#Racket-Lists" class="headerlink" title="Racket Lists"></a>Racket Lists</h2><ul><li>使用 <code>null</code> 构建空列表（或者 <code>&#39;()</code>）</li><li>使用 <code>cons</code> 进行元素和列表的连接</li><li>使用 <code>car</code> 取出列表头，<code>cdr</code> 取出列表尾</li><li>使用 <code>null?</code> 对列表判空</li><li>使用 <code>(list e1 e2 e3 ... en)</code> 构建列表，或者使用 <code>&#39;(e1 e2 e3 ... en)</code></li></ul><p>以下是一些函数（<code>append</code> 和 <code>map</code> 是 Racket 内建的）：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">my-sum</span> xs)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> xs)</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">car</span></span> xs) (<span class="name">my-sum</span> (<span class="name"><span class="builtin-name">cdr</span></span> xs)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">my-append</span> xs ys)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> xs)</span><br><span class="line">    ys</span><br><span class="line">    (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">car</span></span> xs) (<span class="name">my-append</span> (<span class="name"><span class="builtin-name">cdr</span></span> xs) ys))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">my-map</span> f xs)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> xs)</span><br><span class="line">    null</span><br><span class="line">    (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">f</span> (<span class="name"><span class="builtin-name">car</span></span> xs)) (<span class="name">my-map</span> f (<span class="name"><span class="builtin-name">cdr</span></span> xs)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> res (<span class="name">my-map</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>)) '(<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)))</span><br></pre></td></tr></table></figure><h2 id="Syntax-and-Parentheses"><a href="#Syntax-and-Parentheses" class="headerlink" title="Syntax and Parentheses"></a>Syntax and Parentheses</h2><p>Racket 的语法很简单，只要几句话。Racket 中的一切都是以下几种之一：</p><ul><li><strong>Atom</strong>：例如 <code>#t</code> 和 <code>#f</code>（其他语言的 true 和 false），<code>34</code>，<code>&quot;str&quot;</code>，<code>null</code>，<code>4.0</code> 和变量 <code>x。</code></li><li><strong>Special form</strong>：例如 <code>define</code>、<code>lambda</code> 和 <code>if</code>，可以使用宏来扩展。</li><li><strong>Sequence</strong>：<code>(t0 t1 t2 ... tn)</code>，如果 <code>t0</code> 是 special form 那么整个序列就有特殊含义，否则就是函数调用。</li></ul><p>Racket 中的小括号可以和中括号混用——所有可以使用小括号的地方都可以使用中括号，但是有特定的习惯。</p><p>这种语法的一个好处是将语言转换为抽象语法树是很容易的，基本上每个括号代表一棵子树。</p><h2 id="Parentheses-Matter-Debugging-Practice"><a href="#Parentheses-Matter-Debugging-Practice" class="headerlink" title="Parentheses Matter! (Debugging Practice)"></a>Parentheses Matter! (Debugging Practice)</h2><p>Racket 中额外的括号可能是错误的。<code>(e)</code> 表示以 0 个参数调用 <code>e</code> 的结果，<code>((e))</code> 表示以 0 个参数调用 <code>e</code> 的结果，对调用的结果，再次以 0 个参数调用之。每个括号如果不是上节提到的 special form 的话，都表示一次函数调用。</p><p>如果写出了这种错误的代码，或者对于函数调用了错误数量的参数，这种错误只有在运行到对应的语句时才会表现出来（例如写出了 <code>(1 + 2)</code>）。不过对于一些 special form 来说在编译阶段也能确定错误，例如写出了 <code>(if #t + 1 2 3)</code> 就是错的，因为 <code>if</code> 开头的 sequence 必须有 4 个元素，正确写法应该是 <code>(if #t (+ 1 2) 3)</code>。</p><h2 id="Dynamic-Typing"><a href="#Dynamic-Typing" class="headerlink" title="Dynamic Typing"></a>Dynamic Typing</h2><p>由于 Racket 是动态类型的，所以列表中的元素类型不一定相同，并且列表中可以元素与列表同级。</p><p>在静态类型的语言中，很难写出一个将列表 flatten 后跳过其中非数字的元素然后求和的函数，但是动态类型语言中很容易这么搞：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">flatten-sum</span> xs)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> xs)</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">number?</span></span> (<span class="name"><span class="builtin-name">car</span></span> xs))</span><br><span class="line">      (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">car</span></span> xs) (<span class="name">flatten-sum</span> (<span class="name"><span class="builtin-name">cdr</span></span> xs)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">list?</span></span> (<span class="name"><span class="builtin-name">car</span></span> xs))</span><br><span class="line">        (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">flatten-sum</span> (<span class="name"><span class="builtin-name">car</span></span> xs)) (<span class="name">flatten-sum</span> (<span class="name"><span class="builtin-name">cdr</span></span> xs)))</span><br><span class="line">        (<span class="name">flatten-sum</span> (<span class="name"><span class="builtin-name">cdr</span></span> xs))))))</span><br></pre></td></tr></table></figure><p>如果在静态类型语言中，可能需要定义新的数据结构才能完成类似的事情。</p><h2 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h2><p>cond 语句相当于多个 if-else 语句。它需要多个条件顺次进行判断，一旦其中一个满足，就会对相应表达式求值。语法为 <code>(cond [cond_1 expr_1] [cond_2 expr_2] ... [cond_n expr_n])</code>。一般建议将 <code>cond_n</code> 设定为 <code>#t</code>，否则 Racket 会返回一个空类型的数据。语句中的中括号为习惯。</p><p>利用这个可以将上一节的函数写成更好看的形式：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">flatten-sum-2</span> xs)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">    [(<span class="name"><span class="builtin-name">null?</span></span> xs) <span class="number">0</span>]</span><br><span class="line">    [(<span class="name"><span class="builtin-name">number?</span></span> (<span class="name"><span class="builtin-name">car</span></span> xs)) (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">car</span></span> xs) (<span class="name">flatten-sum</span> (<span class="name"><span class="builtin-name">cdr</span></span> xs)))]</span><br><span class="line">    [(<span class="name"><span class="builtin-name">list?</span></span> (<span class="name"><span class="builtin-name">car</span></span> xs)) (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">flatten-sum</span> (<span class="name"><span class="builtin-name">car</span></span> xs)) (<span class="name">flatten-sum</span> (<span class="name"><span class="builtin-name">cdr</span></span> xs)))]</span><br><span class="line">    [<span class="literal">#t</span> flatten-sum (<span class="name"><span class="builtin-name">cdr</span></span> xs)]))</span><br></pre></td></tr></table></figure><hr><p>在 Racket 中，if 语句和 cond 语句中的条件判断内容不需要一定是布尔值，只要条件值不是 <code>#f</code> 就认为是真（包括 <code>null</code> 等），只有条件值是 <code>#f</code> 才认为是假。</p><h2 id="Local-Bindings"><a href="#Local-Bindings" class="headerlink" title="Local Bindings"></a>Local Bindings</h2><p>Racket 中可以在函数内部进行 local 的绑定，语法是 <code>(let ([x1 e1] [x2 e2] ... [xn en]) body)</code>，其中 <code>xi</code> 是绑定，<code>ei</code> 是表达式，<code>body</code> 是要计算的值。</p><p>例如求列表的最大值：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">max-list</span> xs)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">    [(<span class="name"><span class="builtin-name">null?</span></span> xs) (<span class="name">error</span> <span class="string">"empty list"</span>)]</span><br><span class="line">    [(<span class="name"><span class="builtin-name">null?</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> xs)) (<span class="name"><span class="builtin-name">car</span></span> xs)]</span><br><span class="line">    [<span class="literal">#t</span> (<span class="name"><span class="builtin-name">let</span></span> (</span><br><span class="line">      [<span class="name">tail-ans</span> (<span class="name">max-list</span> (<span class="name"><span class="builtin-name">cdr</span></span> xs))]</span><br><span class="line">      [<span class="name">hd</span> (<span class="name"><span class="builtin-name">car</span></span> xs)])</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> tail-ans hd) tail-ans hd))]))</span><br></pre></td></tr></table></figure><p>除了 let 之外还有其它的几种 local 绑定的方法。区别在于：</p><ul><li><p>用 <code>let</code> 进行绑定时使用的所有绑定来自于 <code>let</code> 语句之前，即 <code>(let ([x t] [y x]) body)</code> 中 <code>y</code> 绑定的是外部的 <code>x</code>，即使 <code>x</code> 在该绑定中被使用了。</p></li><li><p>用 <code>let*</code> 进行绑定时使用的所有绑定来自于已经被绑定的绑定，即 <code>(let ([x t] [y x]) body)</code> 中 <code>y</code> 绑定的是内部的 <code>x</code>，这种语义和 ML 中的 let 类似。</p></li><li><p>用 <code>letrec</code> 进行绑定时可以使用后面的绑定，一般用于 mutual recursive 的情况。但是即便如此，求值的顺序也是按顺序求值的（所以应该在函数体中使用更加后面的内容）。例子：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">is-odd</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">letrec</span></span> (</span><br><span class="line">    [<span class="name">is-odd-silly</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>) <span class="literal">#f</span> (<span class="name">is-even-silly</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>))))]</span><br><span class="line">    [<span class="name">is-even-silly</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>) <span class="literal">#t</span> (<span class="name">is-odd-silly</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>))))])</span><br><span class="line">  (<span class="name">is-odd-silly</span> x)))</span><br></pre></td></tr></table></figure></li><li><p>也可以使用 <code>define</code> 进行 local 绑定，语义上和 <code>letrec</code> 一致。语法上，见下面的例子：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">is-odd</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">is-odd-silly</span> x) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>) <span class="literal">#f</span> (<span class="name">is-even-silly</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>))))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">is-even-silly</span> x) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>) <span class="literal">#t</span> (<span class="name">is-odd-silly</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>))))</span><br><span class="line">  (<span class="name">is-odd-silly</span> x))</span><br></pre></td></tr></table></figure><p><code>define</code> 的语法比较迷，而且和 let 系列的语法统一性不够好，还是用 let 系列好了。</p></li></ul><h2 id="Toplevel-Bindings"><a href="#Toplevel-Bindings" class="headerlink" title="Toplevel Bindings"></a>Toplevel Bindings</h2><p>在文件中顶层建立的绑定在语义上类似于 <code>letrec</code>，可以对使用后面绑定的内容，但是求值是按照顺序进行的。</p><p>此外无法对同一个变量绑定多次（但是用 REPL 和 <code>load</code> 的话貌似是可以的）。</p><p>由于每个文件是一个隐式的模块，而在这个模块中是可以覆盖掉其他模块和标准库中的绑定的。这种覆盖只在自己这个模块中生效。</p><h2 id="Mutation-with-set"><a href="#Mutation-with-set" class="headerlink" title="Mutation with set!"></a>Mutation with <code>set!</code></h2><h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><p>Racket 中存在可变的引用，只需使用 <code>set!</code>，例子：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> a <span class="number">3</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">set!</span></span> a (<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> <span class="number">2</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> b a)</span><br></pre></td></tr></table></figure><p><code>b</code> 的值会变成 4。</p><h3 id="副作用序列"><a href="#副作用序列" class="headerlink" title="副作用序列"></a>副作用序列</h3><p>Racket 中可以使用 <code>begin</code> 创建一个序列，依次求值并以最后一个的结果为准。如果这个序列中某个表达式（除最后一个）的求值是没有副作用的，那么它实际上没有用。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">begin</span></span> (<span class="name"><span class="builtin-name">define</span></span> a <span class="number">3</span>) (<span class="name"><span class="builtin-name">define</span></span> c a) (<span class="name"><span class="builtin-name">set!</span></span> a (<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> <span class="number">2</span>)) (<span class="name"><span class="builtin-name">define</span></span> b a))</span><br></pre></td></tr></table></figure><h3 id="可变引用的问题"><a href="#可变引用的问题" class="headerlink" title="可变引用的问题"></a>可变引用的问题</h3><p>Racket 采用词法作用域（和 ML 类似），但是由于不像 ML 中有专门放可变引用的容器，所以有一些潜在的问题，例如：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> a <span class="number">1</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> x) (<span class="name"><span class="builtin-name">*</span></span> x a))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> r1 (<span class="name">f</span> <span class="number">2</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">set!</span></span> a <span class="number">2</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> r2 (<span class="name">f</span> <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>在分析到第二行的时候，可能会认为 <code>f</code> 的作用就是返回一个整数本身，因为 <code>a</code> 的值此时是 1。但是在第四行它的值被改了，这导致 <code>f</code> 的作用也发生了变化，<code>f</code> 计算的时候找的是 <code>a</code> 此时的值而不是初次定义时的值（从 ML 角度来看，<code>a</code> 既是值也是值的容器）。所以 <code>r1</code> 和 <code>r2</code> 的值实际上是不一样的。</p><p><em>然而根据我的测试，连重新 <code>define</code> 一遍 <code>a</code> 都会出问题。</em></p><p>一个避免的方法是在定义函数的时候对用到的外部变量都建立副本：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> a <span class="number">1</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> f (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">a</span> a]) (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">*</span></span> x a))))</span><br><span class="line">(<span class="name"><span class="builtin-name">set!</span></span> a <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>只有使用匿名函数才有效，用普通函数是无效的。普通函数的写法应该是</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> x) (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">a</span> a]) (<span class="name"><span class="builtin-name">*</span></span> x a)))</span><br></pre></td></tr></table></figure><p>当 <code>a</code> 被修改后，执行 <code>f</code> 时又会执行一遍 let 语句，所以没用。</p><hr><p>尽管如此，还是没法避免乘号没有被人改过啊。所以最好把乘号也搞一个副本。这么玩下去是不行的，所以 Racket 有对 <code>set!</code> 的限制。</p><h3 id="Racket-中对于-set-的限制"><a href="#Racket-中对于-set-的限制" class="headerlink" title="Racket 中对于 set! 的限制"></a>Racket 中对于 <code>set!</code> 的限制</h3><p>每个文件都是一个模块。模块中的内容如果在模块内部没有被 <code>set!</code> 过，那么无法在模块外部 <code>set!</code> 它们。语言自带的例如 <code>+</code>，<code>-</code>，<code>cons</code> 等都位于一个没有 <code>set!</code> 它们的模块中。</p><p>编程中强烈不推荐使用 <code>set!</code>。</p><h2 id="The-Truth-About-Cons"><a href="#The-Truth-About-Cons" class="headerlink" title="The Truth About Cons"></a>The Truth About Cons</h2><p>Racket 中的列表本质上是嵌套的二元组。<code>cons</code> 可以构造出这样的二元组：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> a (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">3</span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">4</span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">5</span> null))))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> b (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">3</span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">4</span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">5</span> <span class="number">6</span>))))</span><br></pre></td></tr></table></figure><p>形如这样的是列表，但是 <code>length</code> 函数只对 <code>a</code> 有效，<code>list?</code> 只对 <code>a</code> 返回 <code>#t</code>，而 <code>pair?</code> 对二者都返回 <code>#t</code>。</p><p><code>a</code> 这样的是 proper list，它是一个二元组，并且嵌套的最后是 <code>null</code>，如果最后不是 <code>null</code>（像 <code>b</code> 这样的）就是 improper list。</p><p>improper list 存在的意义是实现像其它语言中元组一样的功能（分量个数较少并且固定）。如果元素个数不确定的话最好用 proper list。</p><h2 id="mcons-For-Mutable-Pairs"><a href="#mcons-For-Mutable-Pairs" class="headerlink" title="mcons For Mutable Pairs"></a><code>mcons</code> For Mutable Pairs</h2><p>Racket 中的列表中的元素默认是不可改变的，这样设计的好处有：</p><ul><li>防止某个变量绑定为列表的子列表时列表发生变动导致该变量也变动</li><li>可以以常数时间计算出列表长度，只有 proper list 能这么做，如果列表可变的话可能会把 proper list 转换成 improper list</li></ul><hr><p>Racket 中存在可变元素的列表，用以下函数进行构造和修改：</p><ul><li><code>mcons</code> 建立可变列表。</li><li><code>mcar</code> 访问可变列表的头。</li><li><code>mcdr</code> 访问可变列表的尾。</li><li><code>mpair?</code> 询问是否是一个可变列表。</li><li><code>set-mcar!</code> 将列表的头改变为指定元素。</li><li><code>set-mcdr!</code> 将列表的尾改变为制定元素。</li></ul><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> a (<span class="name">mcons</span> <span class="number">3</span> (<span class="name">mcons</span> <span class="number">4</span> (<span class="name">mcons</span> <span class="number">5</span> <span class="number">6</span>))))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> b (<span class="name">mpair?</span> a))</span><br><span class="line">(<span class="name">set-mcar!</span> a <span class="number">2</span>)</span><br><span class="line">(<span class="name">set-mcdr!</span> a (<span class="name">mcons</span> <span class="number">5</span> (<span class="name">mcons</span> <span class="number">6</span> <span class="number">7</span>)))</span><br><span class="line">(<span class="name">set-mcar!</span> (<span class="name">mcdr</span> a) <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>其中 <code>set-mcdr!</code> 可对一个子列表进行操作，所以如果需要改变 <code>a</code> 的第二个元素的话可以用 <code>(set-mcar! (mcdr a) x)</code>。</p><h2 id="Delayed-Evaluation-and-Thunks"><a href="#Delayed-Evaluation-and-Thunks" class="headerlink" title="Delayed Evaluation and Thunks"></a>Delayed Evaluation and Thunks</h2><p>Racket 中对函数进行调用时，在函数体求值之前会先对所有的参数求值，但是这不一定是期望的，例如：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">bad-if</span> x y z) (<span class="name"><span class="builtin-name">if</span></span> x y z))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fact1</span> x) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>) <span class="number">1</span> (<span class="name"><span class="builtin-name">*</span></span> x (<span class="name">fact1</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>)))))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fact2</span> x) (<span class="name">bad-if</span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>) <span class="number">1</span> (<span class="name"><span class="builtin-name">*</span></span> x (<span class="name">fact2</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>)))))</span><br></pre></td></tr></table></figure><p><code>bad-if</code> 会导致 <code>x</code>、<code>y</code> 和 <code>z</code> 都被求值，于是 <code>fact2</code> 的实现就有问题（会不断计算 <code>fact2 (- x 1)</code> 导致无限循环）。</p><p>解决的方法是利用匿名函数，只有在需要计算的时候才求值，这种策略称为 delayed evaluation：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-if</span> x y z) (<span class="name"><span class="builtin-name">if</span></span> x (<span class="name">y</span>) (<span class="name">z</span>)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fact3</span> x)</span><br><span class="line">  (<span class="name">good-if</span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> () <span class="number">1</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name"><span class="builtin-name">*</span></span> x (<span class="name">fact3</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>))))))</span><br></pre></td></tr></table></figure><p>引入传入 <code>good-if</code> 的是不带参数的匿名函数，所以它们不会被求值，只会得到一个没有开始计算的匿名函数，只有在必要的时候才会求出匿名函数的函数体的值。</p><hr><p>这种做法是一种 idiom，称作 <strong>thunk</strong>（同时是动词和名词）。把一个表达式用不带参数的匿名函数包裹起来称为对这个表达式进行 thunk，得到的结构也叫 thunk。</p><h2 id="Avoiding-Unnecessary-Computations"><a href="#Avoiding-Unnecessary-Computations" class="headerlink" title="Avoiding Unnecessary Computations"></a>Avoiding Unnecessary Computations</h2><p>尽管使用 thunk 可以延后求值，但是这会引入新的问题：如果某个表达式作为参数在一次调用中需要多次被使用，那么用 thunk 来延后这个参数的求值不如提前计算出来。最麻烦的问题是，假如这个参数计算代价很高，但是在写代码是既不知道函数中到底会不会用这个参数，也不知道如果会用的话到底会用几次，例如：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">slow-add</span> x y) (<span class="name"><span class="builtin-name">begin</span></span> (<span class="name">sleep</span> <span class="number">3</span>) (<span class="name"><span class="builtin-name">+</span></span> x y)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">duplicate-plain</span> x n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">    null</span><br><span class="line">    (<span class="name"><span class="builtin-name">cons</span></span> x (<span class="name">duplicate-plain</span> x (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">duplicate-thunk</span> x n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">    null</span><br><span class="line">    (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">x</span>) (<span class="name">duplicate-thunk</span> x (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))))</span><br></pre></td></tr></table></figure><p>注意到 <code>duplicate-plain</code> 中 <code>x</code> 总是会被求值一次（及时 <code>n</code> 为 0），<code>duplicate-thunk</code> 中 <code>x</code> 被调用的次数和 <code>n</code> 相同。因此：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">duplicate-plain</span> (<span class="name">slow-add</span> <span class="number">1</span> <span class="number">2</span>) <span class="number">0</span>) <span class="comment">; 3 sec</span></span><br><span class="line">(<span class="name">duplicate-plain</span> (<span class="name">slow-add</span> <span class="number">1</span> <span class="number">2</span>) <span class="number">5</span>) <span class="comment">; 3 sec</span></span><br><span class="line">(<span class="name">duplicate-thunk</span> (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">slow-add</span> <span class="number">1</span> <span class="number">2</span>)) <span class="number">0</span>) <span class="comment">; 0 sec</span></span><br><span class="line">(<span class="name">duplicate-thunk</span> (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">slow-add</span> <span class="number">1</span> <span class="number">2</span>)) <span class="number">5</span>) <span class="comment">; 15 sec</span></span><br></pre></td></tr></table></figure><p>现在希望找到一种写法使得 <code>n</code> 为 0 时不产生计算开销，并且在 <code>n</code> 不为 0 时只产生一次计算开销，这种求值策略称为 lazy evaluation。这需要用到下一节的做法。</p><h2 id="Delay-and-Force"><a href="#Delay-and-Force" class="headerlink" title="Delay and Force"></a>Delay and Force</h2><p>为了解决上述问题需要用到可变列表和 delayed evaluation。用到的可变列表实际上是二元组，第一个元素记录值是否被求出来了，是一个布尔；第二个元素在没有被求出的时候是对应表达式的 thunk，否则就是结果本身。</p><p><code>delay</code> 和 <code>force</code> 是 Racket 中内建的用来实现 lazy evaluation 的元素。它的一个简单的实现如下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">my-delay</span> t) (<span class="name">mcons</span> <span class="literal">#f</span> t))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">my-force</span> p)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">mcar</span> p)</span><br><span class="line">    (<span class="name">mcdr</span> p)</span><br><span class="line">    (<span class="name"><span class="builtin-name">begin</span></span> (<span class="name">set-mcdr!</span> p ((<span class="name">mcdr</span> p))) (<span class="name">set-mcar!</span> p <span class="literal">#t</span>) (<span class="name">mcdr</span> p))))</span><br></pre></td></tr></table></figure><p>被 <code>my-delay</code> 返回的这种二元组结构称为 promise。<code>my-delay</code> 需要传入一个 thunk，返回未计算的 promise。<code>my-force</code> 接受一个 promise，返回对应的结果，仅在 promise 还没计算的计算它。使用方式如下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">duplicate-promise</span> x n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">    null</span><br><span class="line">    (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">my-force</span> x) (<span class="name">duplicate-promise</span> x (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">duplicate-promise</span> (<span class="name">my-delay</span> (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">slow-add</span> <span class="number">1</span> <span class="number">2</span>))) <span class="number">0</span>) <span class="comment">; 0sec</span></span><br><span class="line">(<span class="name">duplicate-promise</span> (<span class="name">my-delay</span> (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">slow-add</span> <span class="number">1</span> <span class="number">2</span>))) <span class="number">20</span>) <span class="comment">; 3sec</span></span><br></pre></td></tr></table></figure><p>这样就能实现上一节的要求了。</p><hr><p>Promise 也是一种很常用的 idiom。使用的时候需要注意对应的 thunk 的副作用的问题。</p><p>顺带一提 Haskell 默认就是这种求值策略，称为 <em>call by need</em>。Racket 对参数的求值策略称为 <em>call by value</em>。</p><h2 id="Using-Streams"><a href="#Using-Streams" class="headerlink" title="Using Streams"></a>Using Streams</h2><p>Stream 是一种 idiom，表示无穷长的序列。这种序列是没法显式地写出来的。</p><p>用一个 thunk 表示一个 stream。对这个 thunk 求值后会得到一个二元组，第一个元素是该 stream 的第一个值，第二个元素又是一个 thunk。如果调用该 thunk 会得到一个二元组，第一个元素是 stream 的第二个值，第二个元素是可以从中求出第三个值的 thunk。依此类推。第 k 个值会从某个 thunk 中求出，这个 thunk 求值后得到的是一个二元组，第一个元素是第 k 个值，第二个元素是可以求出下一个值和下一个 thunk 所组成二元组的 thunk。</p><p>下面是几个例子，其中 <code>first-n</code> 可以得到 stream 的前 n 个元素。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> ones (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">1</span> ones)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> nats (<span class="name"><span class="builtin-name">letrec</span></span> ([<span class="name">f</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">cons</span></span> x (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">f</span> (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>)))))]) (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">f</span> <span class="number">0</span>))))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> powers (<span class="name"><span class="builtin-name">letrec</span></span> ([<span class="name">f</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">cons</span></span> x (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">f</span> (<span class="name"><span class="builtin-name">*</span></span> x <span class="number">2</span>)))))]) (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">f</span> <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">first-n</span> st n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">    '()</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">r</span> (<span class="name">st</span>)]) (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">car</span></span> r) (<span class="name">first-n</span> (<span class="name"><span class="builtin-name">cdr</span></span> r) (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> r1 (<span class="name">first-n</span> ones <span class="number">10</span>)) <span class="comment">; '(1 1 1 1 1 1 1 1 1 1)</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> r2 (<span class="name">first-n</span> nats <span class="number">10</span>)) <span class="comment">; '(0 1 2 3 4 5 6 7 8 9)</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> r3 (<span class="name">first-n</span> powers <span class="number">10</span>)) <span class="comment">; '(1 2 4 8 16 32 64 128 256 512)</span></span><br></pre></td></tr></table></figure><h2 id="Defining-Streams"><a href="#Defining-Streams" class="headerlink" title="Defining Streams"></a>Defining Streams</h2><p>这节讲的是如何定义 stream。只要注意整个 stream 用一个 thunk 来表示，然后这个 thunk 的地位等同于它自己被求值后得到的二元组的第二个分量即可。只要保证以下关系正确：</p><blockquote><p>第 k 个值会从某个 thunk 中求出，这个 thunk 求值后得到的是一个二元组，第一个元素是第 k 个值，第二个元素是可以求出下一个值和下一个 thunk 所组成二元组的 thunk。</p></blockquote><p>就能得到正确的 stream 的定义。</p><h2 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>Racket 中的 <code>assoc</code> 函数可以在二元组列表中找到第一个符合项，类似哈希表。但是复杂度可能是线性的：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">assoc</span></span> <span class="number">3</span> (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="number">2</span>) (<span class="name"><span class="builtin-name">list</span></span> <span class="number">3</span> <span class="number">4</span>) (<span class="name"><span class="builtin-name">list</span></span> <span class="number">5</span> <span class="number">6</span>))) <span class="comment">; '(3 4)</span></span><br></pre></td></tr></table></figure><h3 id="Memoization-例子"><a href="#Memoization-例子" class="headerlink" title="Memoization 例子"></a>Memoization 例子</h3><p>这只是一个例子，实际上这个算法的复杂度还不够好。假设要求斐波那契数列，如果使用递归的求法，复杂度是指数级的。可以通过使用带有前两项的辅助函数求解，但是也可以通过把已计算出的结果暂存到一个数据结构中来求解。代码如下（直接复制作者的）：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> fibonacci</span><br><span class="line">  (<span class="name"><span class="builtin-name">letrec</span></span>([<span class="name">memo</span> null]</span><br><span class="line">          [<span class="name">f</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">               (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">ans</span> (<span class="name"><span class="builtin-name">assoc</span></span> x memo)])</span><br><span class="line">                 (<span class="name"><span class="builtin-name">if</span></span> ans</span><br><span class="line">                     (<span class="name"><span class="builtin-name">cdr</span></span> ans)</span><br><span class="line">                     (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">new-ans</span> (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">1</span>) (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">2</span>))</span><br><span class="line">                                        <span class="number">1</span></span><br><span class="line">                                        (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">f</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>))</span><br><span class="line">                                           (<span class="name">f</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">2</span>))))])</span><br><span class="line">                       (<span class="name"><span class="builtin-name">begin</span></span></span><br><span class="line">                         (<span class="name"><span class="builtin-name">set!</span></span> memo (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">cons</span></span> x new-ans) memo))</span><br><span class="line">                         new-ans)))))])</span><br><span class="line">    f))</span><br></pre></td></tr></table></figure><h2 id="Macros-The-Key-Points"><a href="#Macros-The-Key-Points" class="headerlink" title="Macros: The Key Points"></a>Macros: The Key Points</h2><p>使用宏可以为语言扩展新语法，添加语法糖。宏实际上是指示如何将新的语法翻译到旧的语法上。宏的展开一般在编译之前进行。</p><p>Racket 的宏系统设计较好，比 C、C++ 的宏系统靠谱。</p><h2 id="Tokenization-Parenthesization-and-Scope"><a href="#Tokenization-Parenthesization-and-Scope" class="headerlink" title="Tokenization, Parenthesization, and Scope"></a>Tokenization, Parenthesization, and Scope</h2><p>这节是一个评价宏系统的三个方面。如果宏系统在这些方便处理得较好，用起来就比较爽。</p><h3 id="Tokenization"><a href="#Tokenization" class="headerlink" title="Tokenization"></a>Tokenization</h3><p>宏展开实际上是查找替换的过程，但是这种查找是以 token 为单位的，不是以字符串为单位的。也就是说，如果将 <code>head</code> 定义为 <code>car</code> 的宏，那么 <code>cart</code> 不应该被替换为 <code>headt</code>。</p><h3 id="Parenthesization"><a href="#Parenthesization" class="headerlink" title="Parenthesization"></a>Parenthesization</h3><p>C、C++ 中的宏需要考虑到括号的问题，因此容易写出 <code>#define ADD(x, y) ((x) + (y))</code> 这样的代码以防止运算优先级出现问题。但是 Racket 的宏系统已经考虑到了这一点。实际上因为 Racket 的语法简单而统一，宏系统的括号问题很容易得以优雅地解决。</p><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>Racket 中的宏定义拥有自己独立的 scope。</p><p>简单地进行替换可能出现问题，例如：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">hd</span> <span class="number">0</span>] [<span class="name"><span class="builtin-name">car</span></span> <span class="number">1</span>]) hd) <span class="comment">; evaluates to 0</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let*</span></span> ([<span class="name">hd</span> <span class="number">0</span>] [<span class="name"><span class="builtin-name">car</span></span> <span class="number">1</span>]) hd) <span class="comment">; evaluates to 0</span></span><br></pre></td></tr></table></figure><p>将 <code>car</code> 替换为 <code>hd</code> 之后第一句会报错，第二句的求值结果为 1，反正都是不对的。但是 Racket 的宏系统避免了这个问题，和宏有关的绑定在宏展开之后都不会被覆盖。</p><h2 id="Racket-Macros-With-define-syntax"><a href="#Racket-Macros-With-define-syntax" class="headerlink" title="Racket Macros With define-syntax"></a>Racket Macros With define-syntax</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Racket 中定义宏的方式为</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define-syntax</span></span> my-if</span><br><span class="line">  (<span class="name"><span class="builtin-name">syntax-rules</span></span> (<span class="name">then</span> else)</span><br><span class="line">    [(<span class="name">my-if</span> e1 then e2 else e3) (<span class="name"><span class="builtin-name">if</span></span> e1 e2 e3)]</span><br><span class="line">    [(<span class="name">my-if</span> e1 then e2) (<span class="name"><span class="builtin-name">if</span></span> e1 e2 <span class="literal">#f</span>)]))</span><br></pre></td></tr></table></figure><p><code>define-syntax</code> 后面接宏的 special form 名称；<code>syntax-rules</code> 后面接要增加的关键字，随后是一个模式的列表，列表中是一些二元组，左边的模式会在宏展开时替换为右边的形式。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>可以使用宏重写 <code>my-delay</code>，这样用户不用手写 <code>lambda</code>。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define-syntax</span></span> my-delay</span><br><span class="line">  (<span class="name"><span class="builtin-name">syntax-rules</span></span> () [(<span class="name">my-delay</span> e) (<span class="name"><span class="builtin-name">cons</span></span> <span class="literal">#f</span> (<span class="name"><span class="builtin-name">lambda</span></span> () e))]))</span><br></pre></td></tr></table></figure><p>现在直接在 <code>my-delay</code> 后面加上表达式就可以将其 thunk，例如 <code>(my-delay (+ 1 1))</code>。使用函数是不可能完成这一点的，因为参数必须先被求值。</p><hr><p>需要注意的是不要用宏实现 <code>my-force</code>。这涉及到一个关于宏的问题，以上面那段定义 <code>my-delay</code> 的代码为例，其中 <code>e</code> 在展开后只出现了一次。如果用宏定义 <code>my-force</code> 的话 <code>e</code> 会出现多次（<code>e</code> 是一个表达式；相同的表达式出现了多次）。如果 <code>e</code> 有副作用的话就比较诡异了。作者给的例子是：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">my-force</span> (<span class="name"><span class="builtin-name">begin</span></span> (<span class="name">print</span> <span class="string">"hi"</span>) (<span class="name">my-delay</span> some-complicated-expression)))</span><br></pre></td></tr></table></figure><p>一个修正的方法是，在使用宏实现 <code>my-force</code> 的时候通过 <code>let</code> 保证 <code>e</code> 只被求值一次。但是这么麻烦的搞法不如直接用函数实现之。</p><hr><p>最后需要注意的是，使用宏时最好让宏中各个表达式的求值顺序是从左到右的。这种风格是不好的：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define-syntax</span></span> take</span><br><span class="line">  (<span class="name"><span class="builtin-name">syntax-rules</span></span> (<span class="name">from</span>)</span><br><span class="line">    [(<span class="name">take</span> e1 from e2) (<span class="name"><span class="builtin-name">-</span></span> e2 e1)]))</span><br></pre></td></tr></table></figure><p>展开后的求值顺序是 <code>e2</code> 然后 <code>e1</code>，但是代码中 <code>e2</code> 在 <code>e1</code> 右边，这样比较反直觉。</p><h2 id="Variables-Macros-and-Hygiene"><a href="#Variables-Macros-and-Hygiene" class="headerlink" title="Variables, Macros, and Hygiene"></a>Variables, Macros, and Hygiene</h2><p>在 Racket 中宏内部是可以有局部变量的，并且这种局部变量和外界相对独立。得益于 Racket 的宏系统，在 C/C++ 的宏系统中会出现的以下问题在 Racket 中都不会出现：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define-syntax</span></span> double (<span class="name"><span class="builtin-name">syntax-rules</span></span> ()</span><br><span class="line">  [(<span class="name">double</span> e) (<span class="name"><span class="builtin-name">let*</span></span> ([<span class="name">zero</span> <span class="number">0</span>] [<span class="name">x</span> e]) (<span class="name"><span class="builtin-name">+</span></span> x x zero))]))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> r (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">zero</span> <span class="number">2</span>]) (<span class="name">double</span> zero)))</span><br></pre></td></tr></table></figure><p>这个例子中如果直接作查找替换的话得到的是</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> r (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">zero</span> <span class="number">2</span>]) (<span class="name"><span class="builtin-name">let*</span></span> ([<span class="name">zero</span> <span class="number">0</span>] [<span class="name">x</span> zero]) (<span class="name"><span class="builtin-name">+</span></span> x x zero))))</span><br></pre></td></tr></table></figure><p>两种情况下 <code>r</code> 的值不一样，第二种是宏被“污染”了。</p><p>另一个例子：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define-syntax</span></span> double (<span class="name"><span class="builtin-name">syntax-rules</span></span> ()</span><br><span class="line">  [(<span class="name">double</span> e) (<span class="name"><span class="builtin-name">let*</span></span> ([<span class="name">zero</span> <span class="number">0</span>] [<span class="name">x</span> e]) (<span class="name"><span class="builtin-name">+</span></span> x x zero))]))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> r (<span class="name"><span class="builtin-name">let</span></span> [<span class="name"><span class="builtin-name">+</span></span> *] (<span class="name">double</span> <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>在宏的外部将 <code>+</code> 替换为 <code>*</code> 并不会影响宏的功能，宏不受影响。</p><hr><p>这两个例子中宏是不会受到外界影响的，有点类似于 ML 中函数闭包“函数定义后功能就会确定，不管外部变量变化如何”的性质。</p><h2 id="More-Macro-Examples"><a href="#More-Macro-Examples" class="headerlink" title="More Macro Examples"></a>More Macro Examples</h2><p>Racket 中的宏是可以自己递归的，使用 <code>...</code> 可以表示 syntax 中“列表的剩余部分”。下面是利用 <code>let</code> 实现 <code>let*</code> 的例子（代码复制自作者）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(define-syntax my-let*</span><br><span class="line">  (syntax-rules ()</span><br><span class="line">    [(my-let* () body)</span><br><span class="line">     body]</span><br><span class="line">    [(my-let* ([var0 val0]</span><br><span class="line">               [var-rest val-rest] ...)</span><br><span class="line">              body)</span><br><span class="line">     (let ([var0 val0])</span><br><span class="line">       (my-let* ([var-rest val-rest] ...)</span><br><span class="line">                body))]))</span><br></pre></td></tr></table></figure><p>注意这种用法有可能在编译前导致无限循环。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> 编程语言理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part B) 笔记 1 Introduction</title>
      <link href="/2019/02/17/Programming-Languages-Part-B-%E7%AC%94%E8%AE%B0-1-Introduction/"/>
      <url>/2019/02/17/Programming-Languages-Part-B-%E7%AC%94%E8%AE%B0-1-Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>感谢 <a href="https://www.coursera.org/learn/programming-languages-part-b" target="_blank" rel="noopener">Coursera</a>。</p><h2 id="Course-Information-and-Overview"><a href="#Course-Information-and-Overview" class="headerlink" title="Course Information and Overview"></a>Course Information and Overview</h2><h3 id="Welcome-to-Part-B"><a href="#Welcome-to-Part-B" class="headerlink" title="Welcome to Part B"></a>Welcome to Part B</h3><p><em>本节没有问题。</em></p><h3 id="Overview-of-Part-B-Concepts"><a href="#Overview-of-Part-B-Concepts" class="headerlink" title="Overview of Part B Concepts"></a>Overview of Part B Concepts</h3><h4 id="Section-5"><a href="#Section-5" class="headerlink" title="Section 5"></a>Section 5</h4><ul><li>Racket 是动态类型的。</li><li>Racket 可以实现 delaying evaluation（就是惰性求值）。</li><li>Racket 具有优秀的宏系统。宏可以让程序员扩展语言的语法，同时不改变语言实现。</li></ul><h4 id="Section-6"><a href="#Section-6" class="headerlink" title="Section 6"></a>Section 6</h4><ul><li>Racket 的类型系统。</li><li>如何实现一个解释器。</li></ul><h4 id="Section-7"><a href="#Section-7" class="headerlink" title="Section 7"></a>Section 7</h4><ul><li>静态类型系统、动态类型系统及其比较。</li></ul><a id="more"></a><h3 id="Part-B-Course-Structure"><a href="#Part-B-Course-Structure" class="headerlink" title="Part B Course Structure"></a>Part B Course Structure</h3><p><em>本节没有问题。</em></p><h2 id="Software-Installation"><a href="#Software-Installation" class="headerlink" title="Software Installation"></a>Software Installation</h2><p>我不打算采用 DrRacket 的方式。</p><p>安装 Racket：<code>sudo pacman -S racket</code>，使用 <code>socat READLINE EXEC:racket</code> 命令启动。</p><p>安装 VS Code 上的 Racket 插件。VS Code 的 Code Runner 插件可以直接运行 racket 程序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> 编程语言理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Improving Deep Neural Networks 笔记 3 Hyperparameter tuning, Batch Normalization and Programming Frameworks</title>
      <link href="/2019/02/12/Improving-Deep-Neural-Networks-%E7%AC%94%E8%AE%B0-3-Hyperparameter-tuning-Batch-Normalization-and-Programming-Frameworks/"/>
      <url>/2019/02/12/Improving-Deep-Neural-Networks-%E7%AC%94%E8%AE%B0-3-Hyperparameter-tuning-Batch-Normalization-and-Programming-Frameworks/</url>
      
        <content type="html"><![CDATA[<h1 id="Hyperparameter-tuning-Batch-Normalization-and-Programming-Frameworks"><a href="#Hyperparameter-tuning-Batch-Normalization-and-Programming-Frameworks" class="headerlink" title="Hyperparameter tuning, Batch Normalization and Programming Frameworks"></a>Hyperparameter tuning, Batch Normalization and Programming Frameworks</h1><h2 id="Hyperparameter-tuning"><a href="#Hyperparameter-tuning" class="headerlink" title="Hyperparameter tuning"></a>Hyperparameter tuning</h2><h3 id="Tuning-process"><a href="#Tuning-process" class="headerlink" title="Tuning process"></a>Tuning process</h3><p>经验上，学习率 $\displaystyle{\alpha}$ 是最重要的超参数；其次是 Momentum 等优化方法中的 $\displaystyle{\beta}$、网络的神经元数目以及小批量的大小；最后是网络的层数和学习衰减率。</p><p>因为各个超参数的重要程度不一样，有多个超参数需要调节的时候 <strong>不要进行 grid search</strong>。所谓 grid search 就是每个超参数选取若干个值，然后不同超参数就用这些值的组合，类似于控制变量法。推荐的做法是直接在整个所有超参数可选的值构成的空间中随机选取。这么做的理由是在 grid search 的情况下，如果某个超参数实际上对结果影响不大，那么针对它的调节几乎都是无效的，这就参数调节工作中只有一部分是有效的。而在随机选取的情况下，不论各个超参数对结果影响如何，影响较显著的那些超参数都被取了很多个不同的值，这些值都是有用的。</p><p>当找到了效果最好的那些点之后，如果这些点在空间上分布较密集，则可以对那一个较小的超参数空间进行更加密集的搜索。更密集的搜索也应采用随机选取的策略，依此类推。</p><a id="more"></a><h3 id="Using-an-appropriate-scale-to-pick-hyperparameters"><a href="#Using-an-appropriate-scale-to-pick-hyperparameters" class="headerlink" title="Using an appropriate scale to pick hyperparameters"></a>Using an appropriate scale to pick hyperparameters</h3><p>在对超参数进行搜索时，虽然是随机选取，但是未必是均匀随机选取。下面讨论的是对单个超参数该如何搜索，对多个超参数进行搜索时应当采用同样的策略（即整个超参数空间中的分布不应当是均匀的）。</p><ul><li>对于像神经元数目和层数这样的超参数，确定上下限后均匀随机选取即可。</li><li>对于学习率 $\displaystyle{\alpha}$ 这样的参数，它比较接近 0。这种参数应该按照对数的尺度进行搜索，如果要从 0.0001 搜索到 1，应该先均匀随机选取 $\displaystyle{r\in[-4,0]}$，然后使用 $\displaystyle{\alpha = 10^r}$。</li><li>对于 Momentum 中的指数加权平均系数 $\displaystyle{\beta}$，它比较接近 1。这种超参数应该按照上限与值的差的对数的尺度进行搜索，如果要从 0.9999 搜索到 0.9，应该先均匀随机选取 $\displaystyle{r\in[-4, -1]}$，然后使用 $\displaystyle{\beta = 1 - 10^r}$。</li></ul><p>其中第二条和第三条的原理是超参数越接近上下限时，效果越显著。轻微的扰动可能造成效果巨大变化，因此应当按照对数尺度搜索。</p><h3 id="Hyperparameters-tuning-in-practice-Pandas-vs-Caviar"><a href="#Hyperparameters-tuning-in-practice-Pandas-vs-Caviar" class="headerlink" title="Hyperparameters tuning in practice: Pandas vs. Caviar"></a>Hyperparameters tuning in practice: Pandas vs. Caviar</h3><p>取决于计算资源，有两种找超参数的策略：</p><ul><li><strong>Pandas 策略</strong>：计算资源少时，训练一个模型时可以边训练边调整参数，然后查看结果变化。</li><li><strong>Caviar 策略</strong>：计算资源多时，可以同时开始训练多个模型，然后直接用表现最好的那个。</li></ul><h2 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h2><h3 id="Normalizing-activations-in-a-network"><a href="#Normalizing-activations-in-a-network" class="headerlink" title="Normalizing activations in a network"></a>Normalizing activations in a network</h3><h4 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h4><p>对数据进行标准化可以优化第一层网络的训练，因此如果能对中间层的结果也进行标准化就可以优化后面一层的训练。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>对中间层的结果进行标准化时可以选择对 $\displaystyle{a}$（经过激活函数）进行标准化或者对 $\displaystyle{z}$（未经过激活函数）进行。一般对 $\displaystyle{z}$ 进行。</p><p>对于一个小批量在某层的输出 $\displaystyle{Z^{\{\cdot\}}=(Z^{(1)}, Z^{(2)},\dots, Z^{(k)})}$，作处理 $\displaystyle{Z^{(i)}_{norm} = \frac{Z^{(i)} - \mu}{\sqrt{\sigma^2 + \epsilon}}}$，其中 $\mu$ 和 $\displaystyle{\sigma}$ 是 $Z^{(1)}, Z^{(2)},\dots, Z^{(k)}$ 的均值和标准差，$\displaystyle{\epsilon}$ 防止标准差为 0。这就完成了标准化。但是并不总是希望标准化后数据的均值为 0，方差为 1，因此可以再施加一个线性变化 $\displaystyle{\tilde Z^{(i)} = \gamma Z^{(i)}_{norm} + \beta}$，其中 $\displaystyle{\gamma, \beta}$ 是可以学习的参数。如果该层有 $n$ 个神经元，那么 $\gamma$ 和 $\displaystyle{\beta}$ 的规模都是 $\displaystyle{n \times 1}$。随后将 $\displaystyle{\tilde Z^{(i)}}$ 代替原来的 $\displaystyle{Z^{(i)}}$ 送入激活函数即可。（后续添加的这个线性变换在参数取特定值的时候可以抵消掉标准化效果。）</p><h3 id="Fitting-Batch-Norm-into-a-neural-network"><a href="#Fitting-Batch-Norm-into-a-neural-network" class="headerlink" title="Fitting Batch Norm into a neural network"></a>Fitting Batch Norm into a neural network</h3><p>实现上，使用 Batch norm 会添加新的参数 $\displaystyle{\beta, \gamma}$。</p><p>在使用 mini batch 的时候，整个数据集在某层的输出的均值方差没法知道，所以算均值和方差的时候是按照 mini batch 的数据来计算的，也就是说每个小批次都被标准化到了以自己为基础的值上。</p><p>当使用 Batch norm 的时候，$\displaystyle{Z^{[l]} = W^{[l]}A^{[l - 1]} + b^{[l]}}$，此处的 $\displaystyle{b^{[l]}}$ 对于该小批次而言是一样的，而标准化过程会将其统一减掉。因此使用 Batch norm 的时候每层中不需要学习偏置（相当于偏置总是 0），只用学习权值。</p><h3 id="Why-does-Batch-Norm-work"><a href="#Why-does-Batch-Norm-work" class="headerlink" title="Why does Batch Norm work?"></a>Why does Batch Norm work?</h3><p>首先 batch norm 做了和对数据集标准化类似的操作，使得学习更容易了。</p><p>然后是 covariate shift 的问题。如果有一个将 $X$ 映射到 $Y$ 的函数被学习出来了，并且效果很好，但是 $X$ 中的元素分布突然改变的话，那么效果可能就会下降。在网络层数较深时，对于中间某层 $\displaystyle{L}$ 而言，可以将它前一层的输出作为“原始数据的特征”，它自己的任务是学习这些数据到最终结果的映射。但是因为它的前一层是一个网络的输出，这种输出的分布可能发生变化，所以加上 Batch norm 后可以通过控制均值和方差来减小变化的程度，从而让 $\displaystyle{L}$ 工作得更好。这么做可以让不同的层之间的耦合程度下降。</p><p>另一方面，Batch norm 使用的是 mini batch 的数据进行标准化，每个 mini batch 的数据是含有噪声的，因此 Batch norm 相当于对层施加了噪声。这起到了轻微的正规化作用。<strong>尽管如此，Batch norm 还是在进行标准化，不能作为正规化手段。</strong></p><h3 id="Batch-Norm-at-test-time"><a href="#Batch-Norm-at-test-time" class="headerlink" title="Batch Norm at test time"></a>Batch Norm at test time</h3><p>Batch norm 改变了中间层的输出，因此在测试的时候这种改变也该被保留下来，但是测试的时候是对单个样本进行测试的，没有分布可言。对于这个样本，需要某种方法知道用于训练的数据在这个中间层的输出的分布。</p><p>解决方案是在 batch norm 过程中维护两个变量 $\displaystyle{\mu_0}$ 和 $\displaystyle{\sigma_0}$ 表示整个数据集在经过这层后的输出的均值和方差的大致估计。每训练一个 mini batch 就用指数加权平均的方式更新这两个变量。当训练完成后，需要进行测试时，用这两个变量作为需要的均值和方差进行计算。</p><h2 id="Multi-class-classification"><a href="#Multi-class-classification" class="headerlink" title="Multi-class classification"></a>Multi-class classification</h2><h3 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h3><p>Softmax regression 是逻辑回归的推广。对于多分类任务，如果有 $\displaystyle{C}$ 个类，就在最后一层得到具有 $\displaystyle{C}$ 维的特征，然后进行 softmax 归一化。Softmax 函数为</p><script type="math/tex; mode=display">softmax((x_1,x_2,\dots,x_n)^T) = \frac{(e^{x_1},e^{x_2},\dots,e^{x_n})^T}{\sum\limits_{i = 1}^n e^{x_i}}</script><p>计算出来的这个向量中的分量可以作为该样本属于每个分类的概率。所有的值加起来是 1。</p><p>可以使用没有隐藏层的 softmax 分类器作为一个线性的多分类器。</p><h3 id="Training-a-softmax-classifier"><a href="#Training-a-softmax-classifier" class="headerlink" title="Training a softmax classifier"></a>Training a softmax classifier</h3><p>关于 softmax：</p><ul><li>名称来与之相对的 hard max，hard max 的处理策略是选取最大的分量，将其设为 1，并将其它分量设为 0，这样做很直接，而 softmax 就较温和。</li><li>当只有两个类的时候，softmax 回归退化为逻辑回归。</li></ul><p>实现一个 softmax 多分类器时，单个样本的损失函数定义如下：对于最后一层 softmax 归一化得到的输出 $\displaystyle{\hat y}$ 和真实值 $\displaystyle{y}$（一般是一个只有一个分量为一，其它分量都为零的向量），损失函数为</p><script type="math/tex; mode=display">L(y, \hat y) = -\sum\limits_{i = 1}^Cy_i\log(\hat y_i)</script><p>在多个样本的情况下，代价函数依然是损失函数的代数平均。</p><p>在计算梯度时，对于最后一层，有 $\displaystyle{\hat y =a^{[l]}= softmax(z^{[l]})}$，对应的导数为 $\displaystyle{\frac{\partial J}{\partial z^{[l]}} = \hat y - y}$。</p><h2 id="Introduction-to-programming-frameworks"><a href="#Introduction-to-programming-frameworks" class="headerlink" title="Introduction to programming frameworks"></a>Introduction to programming frameworks</h2><h3 id="Deep-learning-frameworks"><a href="#Deep-learning-frameworks" class="headerlink" title="Deep learning frameworks"></a>Deep learning frameworks</h3><p><em>本节没有问题。</em></p><h3 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h3><p><em>本节没有问题。</em></p><hr><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Improving Deep Neural Networks 笔记 2 Optimization algorithms</title>
      <link href="/2019/02/12/Improving-Deep-Neural-Networks-%E7%AC%94%E8%AE%B0-2-Optimization-algorithms/"/>
      <url>/2019/02/12/Improving-Deep-Neural-Networks-%E7%AC%94%E8%AE%B0-2-Optimization-algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="Optimization-algorithms"><a href="#Optimization-algorithms" class="headerlink" title="Optimization algorithms"></a>Optimization algorithms</h1><h2 id="Optimization-algorithms-1"><a href="#Optimization-algorithms-1" class="headerlink" title="Optimization algorithms"></a>Optimization algorithms</h2><h3 id="Mini-batch-gradient-descent"><a href="#Mini-batch-gradient-descent" class="headerlink" title="Mini-batch gradient descent"></a>Mini-batch gradient descent</h3><p>如果训练的时候采用向量化的方式，一次性将所有的数据全部用于训练，称为是 batch gradient descent（批量梯度下降）。但是硬件条件不满足或者追求速度的情况下可以考虑 mini-batch gradient descent（小批量梯度下降），这种训练方式是将整个数据集分成若干批，每次输入一小批。</p><p>记号上，例如数据集用 $X$ 表示，mini-batch 的大小选择为 $\displaystyle{k}$，那么 $X^{(1)}, \dots, X^{(k)}$ 将作为第一个 mini-batch，记作 $\displaystyle{X^{\{1\}}}$。用这 $\displaystyle{k}$ 个样本向量化地进行前向传播和反向传播并更新参数，然后换一个 mini-batch 再跑一次，以此类推。</p><p>小批量梯度下降比梯度下降快得多。小批量梯度下降中每遍历一次数据集成为一个 epoch（遍历），一次遍历需要多个 mini-batch。</p><a id="more"></a><h3 id="Understanding-mini-batch-gradient-descent"><a href="#Understanding-mini-batch-gradient-descent" class="headerlink" title="Understanding mini-batch gradient descent"></a>Understanding mini-batch gradient descent</h3><p>使用批量梯度下降时，代价函数随着训练时间是严格单调下降的。但是使用小批量梯度下降时，代价函数会发生震荡，不过整体趋势依然是随训练时间下降的。</p><p>如果小批量的大小为整个数据集的大小会退化为批量梯度下降，此时一轮训练耗费的时间很长，但效果稳定；如果小批量的大小为 1，算法退化为 stochastic gradient descent（随机梯度下降），此时失去了向量化优势，因此训练时间也变长，并且震荡严重；合适的小批量大小是这两种极端情况的平衡，具有较快的速度同时震荡程度也被控制。</p><p>当整个数据集较小时可以采用批量梯度下降。当数据集较大时最好用小批量梯度下降，由于内存访问的关系，小批量的大小最好设为 2 的整数次幂，常用的值为从 64 到 512 的各个 2 的整数次幂。</p><h3 id="Exponentially-weighted-averages"><a href="#Exponentially-weighted-averages" class="headerlink" title="Exponentially weighted averages"></a>Exponentially weighted averages</h3><p>对于一个序列 $\displaystyle{a}$，使用指数加权平均可以将其变得平滑，得到另一个序列 $\displaystyle{b}$，方法如下：</p><script type="math/tex; mode=display">\begin{aligned}b_0 &= 0 \\b_1 &= (1 - \beta) a_1 + \beta b_0 \\b_2 &= (1 - \beta) a_2 + \beta b_1 \\b_3 &= (1 - \beta) a_3 + \beta b_2 \\\vdots \\b_k &= (1 - \beta) a_k + \beta b_{k - 1}\end{aligned}</script><p>可以将 $b$ 中的值粗略看作是对 $\displaystyle{a}$ 中过去 $\displaystyle{\frac{1}{1 - \beta}}$ 个值的加权平均，越近的值权值越大。其中 $\displaystyle{0&lt; \beta&lt; 1}$ 是超参数。</p><ul><li>$\displaystyle{\beta}$ 越小，平滑程度越弱，但是 $\displaystyle{b}$ 随着 $\displaystyle{a}$ 改变得更快。</li><li>$\displaystyle{\beta}$ 越大，平滑程度越强，但是 $\displaystyle{a}$ 改变后 $\displaystyle{b}$ 的改变要更加滞后。</li></ul><h3 id="Understanding-exponentially-weighted-averages"><a href="#Understanding-exponentially-weighted-averages" class="headerlink" title="Understanding exponentially weighted averages"></a>Understanding exponentially weighted averages</h3><p>如果序列足够长，可以看到</p><script type="math/tex; mode=display">b_n = (1 - \beta)\beta^0 a_n + (1 - \beta)\beta^1a_{n - 1} + (1 - \beta)\beta^2a_{n - 2} + \cdots</script><p>所以 $\displaystyle{a}$ 中的权的确是指数减少的。</p><p>至于为什么 $\displaystyle{b}$ 中的值可以看作是 $\displaystyle{a}$ 中的过去 $\displaystyle{\frac{1}{1 - \beta}}$ 个值的平均，因为有 $\displaystyle{\lim_{\epsilon \to 0}(1 -\epsilon)^\frac{1}{\epsilon} = \frac{1}{e}}$，当 $\displaystyle{\beta}$ 足够接近 1 时，将 $\displaystyle{\epsilon}$ 视作 $\displaystyle{1 - \beta}$ 可知 $\displaystyle{\beta^{\frac{1}{1 - \beta}}}$ 将会接近 $\displaystyle{\frac{1}{e}}$，表明在这里的时候 $\displaystyle{a}$ 中的元素的权值已经低于 $\displaystyle{\frac{1}{3}}$，这个值已经足够小了。</p><p>使用指数加权平均实现的好处是，即时窗口很大也只用在内存中维护几个值。但是如果使用对窗口中的值进行算术平均，这样效果更好，但是要在内存中维护整个窗口。</p><h3 id="Bias-correction-in-exponentially-weighted-averages"><a href="#Bias-correction-in-exponentially-weighted-averages" class="headerlink" title="Bias correction in exponentially weighted averages"></a>Bias correction in exponentially weighted averages</h3><p>使用指数加权平均时，初始阶段 $\displaystyle{b}$ 的值会有异常，和 $\displaystyle{a}$ 相距较大，这是因为 $\displaystyle{b_0 =0}$。可以使用偏差修正的方式解决这个问题，它将 $\displaystyle{b}$ 中的每个数额外地进行扩大。首先对于序列 $a$，还是以上面的方式计算得到序列 $b$，此时的序列 $b$ 是没有修正的（尤其是初期偏差较大）。随后，对于序列 $b$ 进行修正得到序列 $c$，使得</p><script type="math/tex; mode=display">\begin{aligned}b_0 &= 0 \\b_k &= (1 - \beta)a_k + \beta b_{k - 1} &\text{ for } k > 0\\c_k &= \frac{b_k}{1 - \beta^k} &\text{ for } k> 0\end{aligned}</script><p>随后使用序列 $c$ 作为对序列 $a$ 的指数加权平均。这样在初始阶段，$\displaystyle{k}$ 较小，扩大效果明显；在后来分母接近于 1，因此和之前的公式类似。</p><p>如果比较在意初始阶段的平滑效果的话可以考虑使用这个方法。</p><h3 id="Gradient-descent-with-momentum"><a href="#Gradient-descent-with-momentum" class="headerlink" title="Gradient descent with momentum"></a>Gradient descent with momentum</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于小批量梯度下降时会产生震荡，而指数加权平均可以减小震荡，因此二者结合起来即可对训练加速。在这个应用中，要平滑的序列是代价函数对各参数的梯度。假设有个权值 $w$，在训练过程中各轮得到的梯度为 $\displaystyle{d^{\{1\}}, d^{\{2\}}, \cdots}$，通过使用指数加权平均后会得到新的序列 $\displaystyle{v^{\{1\}}, v^{\{2\}}, \cdots}$，更新参数时以这个新的序列为准，即 $w&#39; = w - \alpha v^{\{i\}}$。</p><h4 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h4><p>直观的一个例子是，如果梯度在一个方向上震荡，另一个正交方向上不震荡，那么使用指数加权平均后就会发现基本只剩下了不震荡的那个方向，这样训练就会变得更快，梯度的整体震荡程度也变小。另一个直观的理解是在 $v^{\{i\}} = (1- \beta)d^{\{i\}} + \beta v^{\{i - 1\}}$ 中，可以将 $(1- \beta)d^{\{i\}}$ 视作是加速度，$\beta v^{\{i - 1\}}$ 视作是速度。在发生震荡时即时有较大的加速度，对速度的影响也要之后一段时间才能表现出来。如果加速度方向经常反向，速度的方向就会大体稳定。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>实现上不用考虑偏差修正的问题，并且 $\displaystyle{\beta}$ 的值一般取 0.9。此外有些实现中进行平滑时忽略了 $b_k = (1 - \beta) a_k + \beta b_{k - 1}$ 中的 $\displaystyle{(1 - \beta)}$ 项，此时调整 $\displaystyle{\beta}$ 会影响到学习率 $\displaystyle{\alpha}$ 的选取，因此不推荐这种实现。</p><h3 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h3><p>RMSprop 中的 RMS 指的是 root mean square。它的思路是对梯度的平方进行平滑。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>假设有权值 $w$，在训练过程中各轮得到的梯度为 $\displaystyle{d^{\{1\}}, d^{\{2\}}, \cdots}$。对这些梯度的平方进行指数加权平均：</p><script type="math/tex; mode=display">s^{\{i\}} = \beta s^{\{i - 1\}} + (1 - \beta) (d^{\{i\}})^2</script><p>随后在更新参数的时候按照如下公式：</p><script type="math/tex; mode=display">w' = w - \alpha\frac{d^{\{i\}}}{\sqrt{s^{\{i\}}}}</script><p>经过这样的操作后可以减少震荡，加快训练。</p><h4 id="直观理解-1"><a href="#直观理解-1" class="headerlink" title="直观理解"></a>直观理解</h4><p>这样做可以看作是对梯度变化的快慢做了补偿。如果梯度在一个方向上震荡，那么其梯度变化较快，对应的 $\displaystyle{s}$ 会比较大，而 $\displaystyle{s}$ 在分母中，因此更新时这个方向更新较慢；不震荡的方向上 $\displaystyle{s}$ 较小，因此更新较快。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ul><li>尽管各个梯度都可能是一个向量，但是各种运算都是逐元素的运算。</li><li><p>将 $\displaystyle{s}$ 的初始值赋为 0 即可，不用考虑偏差修正。</p></li><li><p>为了防止分母为零导致的数值稳定性问题，可以在分母上加上 $\epsilon$，即 $\displaystyle{w&#39; = w - \alpha\frac{d^{\{i\}}}{\sqrt{s^{\{i\}}} + \epsilon}}$，其中 $\epsilon$ 典型值为 $\displaystyle{10^{-8}}$。</p></li></ul><h3 id="Adam-optimization-algorithm"><a href="#Adam-optimization-algorithm" class="headerlink" title="Adam optimization algorithm"></a>Adam optimization algorithm</h3><p>Adam 指的是 adaptive moment estimation。它的思路是将 momentum 和 RMSprop 结合起来。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>由于 momentum 和 RMSprop 集合起来了，将来自 momentum 的超参数 $\displaystyle{\beta}$ 记作 $\displaystyle{\beta_1}$，将来自 RMSprop 的超参数 $\displaystyle{\beta}$ 记作 $\displaystyle{\beta_2}$。</p><p>假设有权值 $w$，在训练过程中各轮得到的梯度为 $\displaystyle{d^{\{1\}}, d^{\{2\}}, \cdots}$。同时对这些梯度以及它们的平方进行指数加权平均：</p><script type="math/tex; mode=display">\begin{aligned}v^{\{i\}} &= \beta_1 v^{\{i - 1\}} + (1 - \beta_1)d^{\{i\}} \\s^{\{i\}} &= \beta_2 s^{\{i - 1\}} + (1 - \beta_2)(d^{\{i\}}) ^ 2\end{aligned}</script><p>然后同时利用这两个序列更新参数：</p><script type="math/tex; mode=display">w' = w - \alpha\frac{v^{\{i\}}}{\sqrt{s^{\{i\}}}+ \epsilon}</script><p>经过这样的操作后可以减少震荡，加快训练。Adam 是一个比较通用的方法，很多问题都可以使用这种优化算法。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><ul><li><strong>使用 Adam 时需要考虑到偏差修正，使用上述提到的算法即可。</strong></li><li>$\displaystyle{\beta_1}$ 典型值为 0.9，$\displaystyle{\beta_2}$ 典型值为 0.999，$\displaystyle{\epsilon}$ 典型值同之前。这些值基本不用变动。</li></ul><h3 id="Learning-rate-decay"><a href="#Learning-rate-decay" class="headerlink" title="Learning rate decay"></a>Learning rate decay</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>学习率衰减是考虑到在接近最优解时，存在由于学习率依然较大，而训练数据中总是有噪声，导致难以找到最优解的情况。如果能够随着训练深入使得学习率变小就比较好。</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>需要给定初始学习率 $\displaystyle{\alpha_0}$ 和衰减率（暂记作 $\displaystyle{\gamma}$）。</p><p>学习率的递减一般是按照 epoch 进行递减的，假设目前进行到第 $k$ 个 epoch，有如下几种常用形式：</p><ul><li>$\displaystyle{\alpha = \frac{1}{1 + \gamma k}\alpha_0}$</li><li>$\displaystyle{\alpha = \gamma^k\alpha_0}$</li><li>$\displaystyle{\alpha = \frac{C}{\sqrt k}\alpha_0}$（也可以把 $\displaystyle{k}$ 替换为已进行的 mini-batch 数）</li><li>离散的指数递减：经过若干个 epoch 后将学习率减半</li></ul><p>当计算出了新的学习率后，在下一轮训练中使用新学习率更新参数。</p><p>学习率衰减作用实际上不是很大。</p><h3 id="The-problem-of-local-optima"><a href="#The-problem-of-local-optima" class="headerlink" title="The problem of local optima"></a>The problem of local optima</h3><h4 id="局部最优其实比较少"><a href="#局部最优其实比较少" class="headerlink" title="局部最优其实比较少"></a>局部最优其实比较少</h4><p>在低维空间中寻找全局最优时，很可能陷入局部最优中，局部最优的情况是比较多的。但是高维空间中寻找全局最优时局部最优的比例比较少，就是说如果找到了一个梯度为 0 的点，这个点大概率是个鞍点而不是极值点。直观的想法是，如果这个点要是极值点，它必须在所有的维度的方向上都是极值点，但只要一个维度不符合它就会成为鞍点，所以鞍点比极值点多很多。</p><h4 id="寻找全局最优的问题"><a href="#寻找全局最优的问题" class="headerlink" title="寻找全局最优的问题"></a>寻找全局最优的问题</h4><p>既然大部分梯度为零的点是鞍点，因此使用深度学习时问题主要在于碰上了很大一片梯度很小的区域时怎么办。这种区域称为“plateau”（高原）。如果使用普通的梯度下降，在高原地区时学习进度会很缓慢，这就是为什么使用基于指数加权平均的方法后学习会快很多，效果会好上不少。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Improving Deep Neural Networks 笔记 1 Practical aspects of Deep Learning</title>
      <link href="/2019/02/12/Improving-Deep-Neural-Networks-%E7%AC%94%E8%AE%B0-1-Practical-aspects-of-Deep-Learning/"/>
      <url>/2019/02/12/Improving-Deep-Neural-Networks-%E7%AC%94%E8%AE%B0-1-Practical-aspects-of-Deep-Learning/</url>
      
        <content type="html"><![CDATA[<h1 id="Practical-aspects-of-Deep-Learning"><a href="#Practical-aspects-of-Deep-Learning" class="headerlink" title="Practical aspects of Deep Learning"></a>Practical aspects of Deep Learning</h1><h2 id="Setting-up-your-Machine-Learning-Application"><a href="#Setting-up-your-Machine-Learning-Application" class="headerlink" title="Setting up your Machine Learning Application"></a>Setting up your Machine Learning Application</h2><h3 id="Train-Dev-Test-sets"><a href="#Train-Dev-Test-sets" class="headerlink" title="Train / Dev / Test sets"></a>Train / Dev / Test sets</h3><p>数据应当被分为三个集合：</p><ul><li>Train 集合用来对神经网络进行训练；</li><li>Dev 集合用来在开发时评估网络的性能，挑选出最佳的网络；</li><li>Test 集合用来测试这个最佳网络的性能。</li></ul><p>传统的做法是，如果只打算分出 Train/Dev，用 $70:30$ 的比例，如果三者兼顾，用 $60:20:20$。但是近年来各种问题数据量很大，而评估只需要部分数据即可，所以倾向于将大量数据设为 Train，其它设为 Dev/Test。</p><p>Dev 和 Test 二者分布最好相同。没有 Test 集合也是可以的。</p><a id="more"></a><h3 id="Bias-Variance"><a href="#Bias-Variance" class="headerlink" title="Bias / Variance"></a>Bias / Variance</h3><p>Bias 指的是结果和正确结果之间的差距；Variance 指的是结果不稳定的程度。</p><ul><li>如果 train 集正确率很高，dev 集较低，表明 bias 低 variance 高，表现为过拟合。</li><li>如果 train 集和 dev 集正确率都较低但是二者相近，表示 bias 高 variance 低，表现为欠拟合。</li><li>如果 train 集和 dev 集正确率都较低，并且 dev 集明显低于 train 集，表示 bias 和 variance 都高，模型很差。</li><li>如果 train 集和 dev 集正确率都较高并且而这相近，表示 bias 和 variance 都较低，模型较好。</li></ul><p>正确率应该是相对于 base error 而言的。如果问题本质上有不可避免的影响正确率的问题，那么不论何种模型都不会突破这个正确率的上限。</p><hr><p>以分类问题为例，对于 bias 和 variance 都高的情况，可视化的结果可能是分类器在大部分边界上都是线性的分界，然后在特定的几个点上有很复杂的边界。</p><h3 id="Basic-Recipe-for-Machine-Learning"><a href="#Basic-Recipe-for-Machine-Learning" class="headerlink" title="Basic Recipe for Machine Learning"></a>Basic Recipe for Machine Learning</h3><p>在寻找合适模型时：</p><ul><li><p>如果发现 bias 较高，考虑使用更大的网络、更长的训练时间或者其它网络结构；</p></li><li><p>如果发现 variance 较高，考虑使用更多的数据、使用 Regularization（正规化）或其它网络结构。</p></li></ul><p>早期的机器学习算法无法在保证降低 bias 或 variance 中的一个的同时不降低另一个，但是神经网络的方法可以。</p><h2 id="Regularizing-your-neural-network"><a href="#Regularizing-your-neural-network" class="headerlink" title="Regularizing your neural network"></a>Regularizing your neural network</h2><h3 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h3><h4 id="逻辑回归中的正规化"><a href="#逻辑回归中的正规化" class="headerlink" title="逻辑回归中的正规化"></a>逻辑回归中的正规化</h4><p>在代价函数中 $J(\vec w, b)$ 中添加一项使得</p><script type="math/tex; mode=display">J(\vec w, b) = \frac{1}{m}\sum\limits_{i = 1}^m L(\hat y^{(i)}, y^{(i)}) + \frac{\lambda}{2m}||\vec w||^2_2</script><p><em>这里也可以加上 $\displaystyle{\frac{\lambda}{2m}b^2}$，但是实际效果不是很好，一般不使用。</em></p><p>其中 $\lambda &gt; 0$ 为超参数，称为正规化系数。上述正规化为 L2 正规化，如果将正规化项 $||\cdot||_2$ 换成 $||\cdot||_1$ 就变成 L1 正规化（向量的 L1 范数是各分量绝对值之和）：</p><script type="math/tex; mode=display">J(\vec w, b) = \frac{1}{m}\sum\limits_{i = 1}^m L(\hat y^{(i)}, y^{(i)}) + \frac{\lambda}{m}||\vec w||_1</script><p>L1 正规化可以使其趋向于稀疏，但是用得比 L2 正规化少。</p><h4 id="神经网络中的正规化"><a href="#神经网络中的正规化" class="headerlink" title="神经网络中的正规化"></a>神经网络中的正规化</h4><p>神经网络中的 L2 正规化是对每一层都加上 L2 正规化使得代价函数变为：</p><script type="math/tex; mode=display">J(W^{[1]}, b^{[1]}, W^{[2]}, b^{[2]}, \cdots ,W^{[L]}, b^{[L]}) = \frac{1}{m}\sum\limits_{i = 1}^m L(\hat y^{(i)}, y^{(i)}) +  \frac{\lambda}{2m}\sum\limits_{l = 1}^L||W^{[l]}||^2_F</script><p>注意这里用的是 Frobenius 范数而不是矩阵的 2-范数。</p><p>实现上，添加了正规化项后，每次计算代价函数对权值的偏导时，会多出一项：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial W^{[l]}} = \cdots + \frac{\lambda}{m}W^{[l]}</script><h4 id="Weight-decay-观点"><a href="#Weight-decay-观点" class="headerlink" title="Weight decay 观点"></a>Weight decay 观点</h4><p>假设不添加正规化时， $\displaystyle{\frac{\partial J}{\partial W^{[l]}} = p}$。</p><p>在添加了正规化项后，每次权值更新的式子就变成了</p><script type="math/tex; mode=display">\begin{aligned}W^{[l]} &= W^{[l]} - \alpha (p +\frac{\lambda}{m}W^{[l]}) \\&= \left(1-\frac{\alpha\lambda}{m}\right)W^{[l]} - \alpha p\end{aligned}</script><p>可见相对于不添加 L2 正规化，添加后实际上每次更新权值时都会先将权值乘以 $\displaystyle{\left(1-\frac{\alpha\lambda}{m}\right)}$，这是一个比 1 略小的数。因此 L2 正规化也称 weight decay。</p><h3 id="Why-regularization-reduces-overfitting"><a href="#Why-regularization-reduces-overfitting" class="headerlink" title="Why regularization reduces overfitting?"></a>Why regularization reduces overfitting?</h3><p>使用正规化可以让每层网络中的输出值变得较小。这样相当于把一个复杂的网络简化成了相对简单的网络。一种直观的理解方式是通过正规化可以让一部分神经元输出为零，不过实际上是每个神经元都被使用到了，但是它们对整个结果的影响能力被削弱了。</p><p>另一个角度看，使用正规化可以让神经元变得更加“线性”。极端的例子是，考虑 tanh 激活函数，以及较大的 $\lambda$ 值，此时所有神经元的输入被限制在很小的范围内，距离 0 的距离很近，所以输入位于 tanh 的线性区，整个网络表现为一个线性的网络，因此会出现欠拟合。但是不加正规项时会出现过拟合，因此较小的正规项系数即可将过拟合的网络变得更“线性”。</p><h3 id="Dropout-Regularization"><a href="#Dropout-Regularization" class="headerlink" title="Dropout Regularization"></a>Dropout Regularization</h3><p>Dropout（随机失活）指的是每层神经元的输出以一定的概率被置为 0，以达到正规化目的。随机失活是另一种正规化手段。直观来看，这种方法会迫使大型的网络在训练时变得像较小的网络一样。</p><p>实现上，一般采用 inverted dropout 的方法。给定概率 $p$ 表示激活概率，对于第 $l$ 层网络，其输出规模是 $n^{[l]}\times m$ 的，构建一个同规模的矩阵，其中元素以 $p$ 的概率被置为 1，$(1 - p)$ 的概率被置为 0；将这个矩阵与输出矩阵 $A$ 作逐元素乘积，会得到新矩阵 $A&#39;$，将新矩阵的每个元素除以 $p$ 作为新的输出，这个新输出将作为下一层的输入。</p><p>采用上述实现时，即使是同时训练多个样本，每个样本的神经元失活情况也不一样。另外 $A&#39;$ 的每个元素需要除以 $p$，这是为了防止在最后应用模型的时候出现 scale 的问题（否则可能要在测试时引入进行 scale 的过程），毕竟输出被随机失活后每个样本对应的输出 scale 被改变了。</p><blockquote><p>在处理反向传播的时候，计算出 $\displaystyle{\frac{\partial J}{\partial A}}$ 后，使用 <strong>同样的</strong> 矩阵进行 dropout（因此需要将当时的矩阵记下来），然后再除以 $p$ 以保持 $\displaystyle{\frac{\partial J}{\partial A}}$ 的 scale。将得到的新矩阵当做 $\displaystyle{\left(\frac{\partial J}{\partial A}\right)&#39;}$ 继续进行反向传播和权值更新。</p><p>随机失活只在训练时使用，在测试和实际应用时不应当使用。</p></blockquote><h3 id="Understanding-Dropout"><a href="#Understanding-Dropout" class="headerlink" title="Understanding Dropout"></a>Understanding Dropout</h3><h4 id="随机失活的直观理解"><a href="#随机失活的直观理解" class="headerlink" title="随机失活的直观理解"></a>随机失活的直观理解</h4><p>每个神经元的输入是前层各个神经元输出的加权和。直观来看，采用了随机失活后，因为这些输出的每个维度都有变成 0 的可能，这就要求该层的神经元不要特别依赖于前层输出中某一维度的特性。因此该层神经元在分配权值时会倾向于对前层的每个神经元分配相近的权值。在 scale 不变的情况下，这么做会导致权值矩阵的范数减小，因此随机失活也可以看作某种形式的对权值的正规化。</p><h4 id="每层设置不同的失活率"><a href="#每层设置不同的失活率" class="headerlink" title="每层设置不同的失活率"></a>每层设置不同的失活率</h4><p>可以对每层设置不同的失活率，例如对神经元较多的层设置大的失活率，而对神经元少的层设置较小的失活率。</p><p>也可以对输入层设置失活率，不过一般不这么做。</p><h4 id="随机失活对代价函数的影响"><a href="#随机失活对代价函数的影响" class="headerlink" title="随机失活对代价函数的影响"></a>随机失活对代价函数的影响</h4><p>随机失活会导致代价函数不再是良好定义的，此时代价函数不能简单而精确地写出来，同时会导致代价函数的值在训练过程中不一定单调下降。作者建议实现时先关闭随机失活确认代价函数的值单调下降，然后再打开之。</p><h3 id="Other-regularization-methods"><a href="#Other-regularization-methods" class="headerlink" title="Other regularization methods"></a>Other regularization methods</h3><h4 id="Data-augmentation"><a href="#Data-augmentation" class="headerlink" title="Data augmentation"></a>Data augmentation</h4><p>在训练数据不足的情况下（典型的是和视觉有关的任务），可以对输入数据做一些预处理扩大数据集（以图片为例就是将图片翻转、拉伸等）。数据集扩大后过拟合现象可以减少。</p><h4 id="Early-stopping"><a href="#Early-stopping" class="headerlink" title="Early stopping"></a>Early stopping</h4><p>在训练阶段最小化的目标是代价函数，可以在每轮训练后查看网络在 <strong>dev 集</strong> 上的性能。这个性能以错误率衡量的话，随着训练的进行一般呈现先减小后增大的趋势（增大表明发生过拟合）。因此可以在检测到开始增大时直接打断训练，并以这个模型作为最终模型。</p><p>这个方法的原理的直观理解是，初始化权值时会导致权值接近 0，但是随着训练进行，权值会越来越大，越来越依赖于 test 集的特性。通过 early stopping 可以让权值没有变得过大之前就停下来。</p><p>这个方法的坏处是，<strong>最小化代价函数</strong> 和 <strong>防止过拟合</strong> 原本是两个正交的任务，在完成各任务时可以完全不理会另一个，但是采用这种方式会导致两个任务被耦合。不过，相对于使用 L2 正规化，使用 early stopping 时超参数的搜索空间更小。</p><h2 id="Setting-up-your-optimization-problem"><a href="#Setting-up-your-optimization-problem" class="headerlink" title="Setting up your optimization problem"></a>Setting up your optimization problem</h2><h3 id="Normalizing-inputs"><a href="#Normalizing-inputs" class="headerlink" title="Normalizing inputs"></a>Normalizing inputs</h3><p>通过对输入进行 normalize（标准化）可以加速训练。</p><p>标准化指将数据线性变换到均值为 0 方差为 1。实现上对于一组数据 $\vec x$，计算出均值 $\mu$ 和标准差 $\sigma$ 后令 $\displaystyle{x&#39; = \frac{\vec x - \mu}{\sigma}}$ 即可。</p><p>直观来看，如果原始数据每个维度的 scale 不一样，那么代价函数会比较“扁长”。如果将代价函数的等高线作出来，会发现从很多点开始时都要经过一个震荡的过程才能到局部最优（例如扁长的椭圆）。标准化后代价函数会比较好看，例如变成了一个比较圆的椭圆。这样的话通过梯度下降找到局部最优会较快。</p><h3 id="Vanishing-Exploding-gradients"><a href="#Vanishing-Exploding-gradients" class="headerlink" title="Vanishing / Exploding gradients"></a>Vanishing / Exploding gradients</h3><p>设想有一个层数很多的网络，采用线性激活函数，只有权值没有偏置，并且每层神经元数目相同（因此每层的权值矩阵是方阵）：</p><ul><li>如果每层的权值矩阵是对角阵，对角元素都比 1 稍微大一点，那么每层的输出值会以指数形式增大（exploding）</li><li>如果每层的权值矩阵是对角阵，对角元素都比 1 稍微小一点，那么每层的输出值会以指数形式减小（vanishing）</li></ul><p>这种情况下，最终的输出值会比较异常，导致难以训练。这里谈论的是输出值的情况，梯度方面也会发生类似的情况（梯度变得很大或很小，称为梯度爆炸和梯度消失），导致网络难以训练。</p><h3 id="Weight-Initialization-for-Deep-Networks"><a href="#Weight-Initialization-for-Deep-Networks" class="headerlink" title="Weight Initialization for Deep Networks"></a>Weight Initialization for Deep Networks</h3><p>对权值仔细地随机化可以部分解决上一节的问题。</p><p>想法是，对于第 $l$ 层网络中的某个神经元，其输出为 $\displaystyle{z^{[l]} = \sum\limits_{i = 1}^{n^{[l - 1]}}w^{[l]}_i a^{[l - 1]}+b^{[l]}}$。如果希望将 $\displaystyle{z^{[l]}}$ 控制在一个小范围内，可以将 $w^{[l]}$ 的方差设为 $\displaystyle{\frac{1}{n^{[l - 1]}}}$。</p><p>实现上，可以对每个权值标量单独赋权。典型做法是在 0 到 1 上均匀取值，然后乘以 $\displaystyle{\sqrt{\frac{1}{n^{[l - 1]}}}}$。这样以来前层神经元越多，权值就越小，在下一层上的输入就会比较小而容易优化。一些变种：</p><ul><li>如果使用 ReLU 激活函数，就乘 $\displaystyle{\sqrt{\frac{2}{n^{[l - 1]}}}}$。</li><li>如果使用 Tanh 激活函数，就乘 $\displaystyle{\sqrt{\frac{1}{n^{[l - 1]}}}}$，称为 Xavier 初始化。</li><li>可以尝试一下 $\displaystyle{\sqrt{\frac{1}{n^{[l - 1]} + n^{[l]}}}}$。</li></ul><p>不要让权值变得过大，尽量使用较小的权值。</p><hr><p>采用了这些方法后上面的问题会减轻，但是依然存在。直观来看，经过每层网络后输出的均值和方差和输入大致是同规模的，因此在网络层数较深的时候梯度爆炸/消失不会有随便初始化那么严重。</p><h3 id="Numerical-approximation-of-gradients"><a href="#Numerical-approximation-of-gradients" class="headerlink" title="Numerical approximation of gradients"></a>Numerical approximation of gradients</h3><p>在使用数值的方法计算导数的时候，用 $\displaystyle{\frac{f(x + \epsilon) - f(x - \epsilon)}{2\epsilon}}$ 要比 $\displaystyle{\frac{f(x + \epsilon) - f(x)}{\epsilon}}$ 精度要更好，尽管前者的计算量是后者两倍。这是因为泰勒展开后可以知道前者的误差是 $\displaystyle{O(\epsilon^2)}$ 的，后者只有 $O(\epsilon)$。</p><h3 id="Gradient-checking"><a href="#Gradient-checking" class="headerlink" title="Gradient checking"></a>Gradient checking</h3><p>这一节主要讲的是如何检查反向传播梯度计算是否正确。将所有可以学习的参数全部合并成一个参数 $\displaystyle{\vec\theta = (\theta_1, \theta_2, \cdots, \theta_k)}$，然后使用反向传播的方法得到 $\displaystyle{\frac{\partial J}{\partial \theta_i}}$；使用上一节的方法用数值的办法求得一个近似值</p><script type="math/tex; mode=display">\widehat{\left(\frac{\partial J}{\partial \theta_i}\right)} = \frac{J(\theta_1, \theta_2, \cdots, \theta_i + \epsilon, \cdots, \theta_k) - J(\theta_1, \theta_2, \cdots, \theta_i - \epsilon, \cdots, \theta_k)}{2\epsilon}</script><p>此时得到两个向量，记作 $\displaystyle{\vec a = \frac{\partial J}{\partial \theta_i}}$ 和 $\displaystyle{\vec{b} = \widehat{\left(\frac{\partial J}{\partial \theta_i}\right)}}$。计算 $\displaystyle{\frac{||\vec a - \vec b||_2}{||\vec a||_2 + ||\vec b||_2}}$，如果量级在 $\displaystyle{10^{-7}}$ 以下表示梯度没算错，$\displaystyle{10^{-3}}$ 以上表示很有可能算错了。</p><h3 id="Gradient-Checking-Implementation-Notes"><a href="#Gradient-Checking-Implementation-Notes" class="headerlink" title="Gradient Checking Implementation Notes"></a>Gradient Checking Implementation Notes</h3><ul><li>只在调试的时候检查梯度算对了没有，因为这种计算梯度的方式太慢了，不要在训练的时候使用。</li><li>如果计算出发现梯度没算对可以通过查看两个向量的分量的差距定位 bug 所在。</li><li>如果有正规项的话不要忘了在计算代价函数的时候带上。</li><li>有随机失活的话在调试前将随机失活率设为 0。</li><li>不一定要在每轮计算后都检查梯度，可以隔一段时间检查一次。有些情况下使用反向传播算出来的梯度只有在权值和偏置较小的情况下是对的（刚好是完成随机化的时候），为了避免这种情况最好训练一段事件后再次检查梯度。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part A) 笔记 5 Section 4</title>
      <link href="/2019/02/06/Programming-Languages-Part-A-%E7%AC%94%E8%AE%B0-5-Section-4/"/>
      <url>/2019/02/06/Programming-Languages-Part-A-%E7%AC%94%E8%AE%B0-5-Section-4/</url>
      
        <content type="html"><![CDATA[<h1 id="Section-4"><a href="#Section-4" class="headerlink" title="Section 4"></a>Section 4</h1><h2 id="Section-Introduction"><a href="#Section-Introduction" class="headerlink" title="Section Introduction"></a>Section Introduction</h2><p><em>本节没有问题。</em></p><h2 id="What-is-Type-Inference"><a href="#What-is-Type-Inference" class="headerlink" title="What is Type Inference"></a>What is Type Inference</h2><p>ML 是静态类型语言，所有表达式的类型在编译时确定。类型推断是为程序中的每个表达式确定类型的过程。如果能够找到一个解使得每个表达式类型确定且相容，则推断成功，否则推断失败，可以认为程序有问题。</p><p>一般来说类型推断后再实施类型检查，但是实践中二者往往合并。</p><p>类型推断的难度取决于类型系统。但是类型系统的严格程度和类型推断的难度没有直接的关系，拒绝所有程序的类型系统和接受所有程序的类型系统实现难度是一样的。</p><a id="more"></a><h2 id="ML-Type-Inference"><a href="#ML-Type-Inference" class="headerlink" title="ML Type Inference"></a>ML Type Inference</h2><p>ML 中类型推断的若干步骤：</p><ul><li>按照次序对绑定进行类型推断（这就是为什么不能使用后面才出现的绑定）。</li><li>对于每个 <code>val</code> 和 <code>fun</code> 绑定，根据其语句分析各种约束条件（constraints）。<ul><li>如果约束条件不足，表明这个函数是 polymorphic 的。</li><li>如果约束条件过多，表明实际上这个函数存在类型错误。</li></ul></li></ul><p>ML 的类型推断可以推断出带有类型参数的函数，但是类型推断和 polymorphic 是两个不相关的概念。</p><h2 id="Type-Inference-Examples"><a href="#Type-Inference-Examples" class="headerlink" title="Type Inference Examples"></a>Type Inference Examples</h2><p>这节是几个类型推断的例子。一些通用的方式：在分析绑定时，如果不确定某个绑定的类型，就先设未知类型 $T_n$ 等。设定完成后分析绑定中的各个语句和表达式建立不同的未知类型间的方程。解这些方程，如果得到了“精确的”解就表明所有的类型都可以推导出来；如果得不到精确的解表明绑定是 polymorphic 的；如果方程间存在矛盾表明函数类型错误。</p><h2 id="Polymorphic-Examples"><a href="#Polymorphic-Examples" class="headerlink" title="Polymorphic Examples"></a>Polymorphic Examples</h2><p>继续上一节的类型推断。当出现了得不到精确解的情况，即无法拥有更多信息确定绑定的类型，此时应将所有的未确定的未知类型换成类型参数。例如将所有的 $T_1$ 换成 <code>&#39;a</code>。完成替换后就得到了一个 polymorphic 的函数的类型。</p><h2 id="The-Value-Restriction-and-Other-Type-Inference-Challenges"><a href="#The-Value-Restriction-and-Other-Type-Inference-Challenges" class="headerlink" title="The Value Restriction and  Other Type-Inference Challenges"></a>The Value Restriction and  Other Type-Inference Challenges</h2><h3 id="Value-Restriction"><a href="#Value-Restriction" class="headerlink" title="Value Restriction"></a>Value Restriction</h3><p>ML 的类型系统存在一个问题。比如下面的代码看上去没问题：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r = <span class="built_in">ref</span> <span class="type">NONE</span>       <span class="comment">(* r has type 'a option ref *)</span></span><br><span class="line"><span class="keyword">val</span> _ = r := <span class="type">SOME</span> <span class="string">"hi"</span> <span class="comment">(* := is ('a -&gt; 'a ref), 'a is string *)</span></span><br><span class="line"><span class="keyword">val</span> i = <span class="number">1</span> + valOf (!r) <span class="comment">(* ! is ('a ref -&gt; 'a), 'a is int *)</span></span><br></pre></td></tr></table></figure><p>三句话在独立看的情况下都可以通过类型检测，但实际上有问题。可是因为模块系统的引入会导致不能单独禁止 <code>ref</code> 对此的使用，所以需要禁止掉所有潜在的形如这样的使用。</p><p>Value restriction 规则让所有的变量绑定在有 polymorphic 的情况下，右边要么是值，要么是变量，而不能是一个计算出来的值：</p><ul><li><strong>右边是值</strong>：<code>val x = NONE</code></li><li><strong>右边是变量</strong>：<code>val y = x</code></li><li><strong>右边是计算出的值，被禁止</strong>：<code>val z = ref NONE</code></li></ul><p>使用这个规则可以防止上述情况出现（不是很显然，不要多想）。但是另一方面会使得一些应用不方便，例如在 partial application 时下面的代码是不可行的：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pair_with_one = map (<span class="keyword">fn</span> x =&gt; (x, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>要么加上类型标注（从而限制了它的泛型性），要么不使用 partial application。</p><h3 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h3><p>ML 的类型系统实际上处于一个实现难度“极小值”之处，对这个类型系统的修改（不论是严格还是放松）都会导致实现难度上升。例如如果去掉 polymorphic 会导致类型推断时出现条件不够的情况、如果添加子类型会导致实现更加复杂等。</p><h2 id="Mutual-Recursion"><a href="#Mutual-Recursion" class="headerlink" title="Mutual Recursion"></a>Mutual Recursion</h2><p>Mutual recursion 指两个函数相互调用。因为绑定顺序必定是一个在另一个前，所以这个有点麻烦。</p><p>假设 <code>f</code> 比 <code>g</code> 先定义，如果要在 <code>f</code> 中调用 <code>g</code>，一个做法是在定义 <code>f</code> 的时候就预留一个函数参数，等会将 <code>g</code> 传进来，在 <code>f</code> 的定义中调用这个参数即可。</p><p>ML 有对 mutual recursion 的内建支持，如果希望 <code>f</code> 和 <code>g</code> 相互调用只需：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun f x = ... g y ...</span><br><span class="line">and g x = ... f y ...</span><br></pre></td></tr></table></figure><p>即可。使用 <code>and</code> 也可以定义 mutual recursion 的 datatype。</p><h2 id="Modules-for-Namespace-Management"><a href="#Modules-for-Namespace-Management" class="headerlink" title="Modules for Namespace Management"></a>Modules for Namespace Management</h2><p>使用以下语法定义一个模组：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">structure</span> <span class="type">MyLib</span> = <span class="keyword">struct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fun</span> fact x = <span class="keyword">if</span> x = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> x * fact (x - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> pi = <span class="type">Math</span>.pi</span><br><span class="line"><span class="keyword">val</span> zero = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用 <code>MyLib.fact</code> 和 <code>MyLib.pi</code> 引用模组中的内容。</p><p>使用 <code>open MyLib</code> 可以导入 <code>MyLib</code> 中的所有绑定，现在可以直接使用 <code>fact</code> 作为 <code>MyLib.fact</code>。</p><h2 id="Signatures-and-Hiding-Things"><a href="#Signatures-and-Hiding-Things" class="headerlink" title="Signatures and Hiding Things"></a>Signatures and Hiding Things</h2><p>Signature 是对模块外部接口的描述，它规定了一个模块至少应该实现哪些绑定，类型是什么。定义 signature 的语法：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signature</span> <span class="type">MYLIB</span> = <span class="keyword">sig</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fact : <span class="built_in">int</span> -&gt; <span class="built_in">int</span></span><br><span class="line"><span class="keyword">val</span> zero : <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果需要实现某个 signature，在定义模块时，将头部改为：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">structure</span> <span class="type">MyLib</span> :&gt; <span class="type">MYLIB</span> = <span class="keyword">struct</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>即可。当使用了这种写法的时候，只有 <code>MYLIB</code> 中定义的绑定会被暴露出来，其它的绑定只能在模块内部使用。</p><hr><p>引入 signature 的目的应该是控制模块中哪些内容是对外可见的，另外也能起到类似接口的作用。</p><h2 id="A-Module-Example"><a href="#A-Module-Example" class="headerlink" title="A Module Example"></a>A Module Example</h2><p>一个典型的模块具有 properties 和 invariants。其中 properties 相当于作者对使用者的保证，是模块的某种规范；invariants 是模块内部维护的一些约定，有了这些约定可以减少内部实现时的判定（比如某个函数实际上在边界情况下是错的，但是 invariants 保证了边界情况不会出现），但是这些约定对用户不可见。</p><p>通过使用 signature 可以保护 properties 和 invariants 确实是成立的，从而在一定程度上保证模块的正确性。</p><h2 id="Signatures-for-Our-Example"><a href="#Signatures-for-Our-Example" class="headerlink" title="Signatures for Our Example"></a>Signatures for Our Example</h2><p>这一节里面有价值的东西是可以在 signature 的定义中通过 <code>type</code> 关键字声明一个类型存在。一般用于必须要声明类型的存在以通过类型检查，但是又不能暴露出类型的定义以防止使用者构造出破坏了 properties 和 invariants 的数据。这种类型一般称为是抽象的。</p><p>如果希望部分地暴露出一个具体类型可以通过 <code>fun</code> 来暴露一个构造函数。</p><h2 id="Signature-Matching"><a href="#Signature-Matching" class="headerlink" title="Signature Matching"></a>Signature Matching</h2><p>判定一个模块是否具有指定的 signature：</p><ul><li>检查 signature 中所有的非抽象类型都在模块中存在。</li><li>检查 signature 中所有的抽象类型，模块中都存在一个对应的具体类型（不论是 datatype 还是 type 都行）。</li><li>signature 中所有的函数都应该在模块中找到一个抽象程度不比 signature 低的函数实现。</li><li>signature 中的每个异常应该都在模块中被声明。</li></ul><h2 id="An-Equivalent-Structure"><a href="#An-Equivalent-Structure" class="headerlink" title="An Equivalent Structure"></a>An Equivalent Structure</h2><p>通过使用 signature 可以为同样的功能提供不同的模块实现。如果希望用户无法区分出两个实现了同样 signature 的模块，signature 的设计应当尽量简洁。这两个模块称为是 equivalent 的。</p><h2 id="Another-Equivalent-Structure"><a href="#Another-Equivalent-Structure" class="headerlink" title="Another Equivalent Structure"></a>Another Equivalent Structure</h2><p><em>本节没有问题。</em></p><h2 id="Different-Modules-Define-Different-Types"><a href="#Different-Modules-Define-Different-Types" class="headerlink" title="Different Modules Define Different Types"></a>Different Modules Define Different Types</h2><p>同一个 signature 在被不同模块实现时，signature 中的同一个类型在不同模块中是不同的类型，无法混淆使用。</p><p>例如 signature 中定义 <code>type A</code>，那么模块 <code>B</code> 和模块 <code>C</code> 中的对应类型是 <code>B.A</code> 和 <code>C.A</code>，是不同的类型。一般来说 <code>B.A</code> 在 <code>C</code> 模块中会无法不兼容。这是因为两个模块可能在内部使用了不同的实现。</p><h2 id="Equivalent-Functions"><a href="#Equivalent-Functions" class="headerlink" title="Equivalent Functions"></a>Equivalent Functions</h2><p>两个函数如果要是相同的需要满足诸多条件，例如在所有的同样的输入下产生同样的输出，或者同时停机，或者同时抛出异常，或者同时产生相同的内存读写/副作用等（同时是针对于运算步骤而言的）。</p><p>只有两个函数相同时才能保证替换后所有的表现都不变。实际上函数相同的另一个定义就是不能观测到这是两个不同的函数。</p><p>总是使用纯函数编程可以让两个函数是否相同变得更加容易判定，因此推荐这种编程范式。</p><h2 id="Standard-Equivalences"><a href="#Standard-Equivalences" class="headerlink" title="Standard Equivalences"></a>Standard Equivalences</h2><p>有一些简单的判定函数相同的原则。</p><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>采用了语法糖的函数，和未采用语法糖的函数的相同是容易判定的，例如以下两个：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> f1 x = x <span class="keyword">andalso</span> g x</span><br><span class="line"><span class="keyword">fun</span> f2 x = <span class="keyword">if</span> x <span class="keyword">then</span> g x <span class="keyword">else</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>另外 <code>let val x = e1 in e2 end</code> 实际上是 <code>(fn x =&gt; e2) e1</code> 的语法糖。二者行为是一致的。</p><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p>将所有的同一个绑定换成另外一个名字。如果这种替换不会影响到运行的逻辑（没有和已经定义的绑定冲突、没有和未来要使用的绑定冲突）的话，两段代码是等价的。</p><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>使用了辅助函数的函数和将这个辅助函数提取出来作为单独的函数；或者使用了辅助函数和直接将辅助函数内联进函数的函数，两者是否相同是容易判定的。</p><h3 id="unnecessary-wrapping"><a href="#unnecessary-wrapping" class="headerlink" title="unnecessary wrapping"></a>unnecessary wrapping</h3><p>存在 unnecessary wrapping 的情况下两个函数是否相同是容易判定的。但是要注意如果被 wrap 的函数具有副作用的话，wrap 之后的和 partial application 的函数可能是不相同的（partial application 可能只触发一次副作用，wrap 了的函数会多次触发）。</p><h2 id="Equivalence-Versus-Performance"><a href="#Equivalence-Versus-Performance" class="headerlink" title="Equivalence Versus Performance"></a>Equivalence Versus Performance</h2><p>实际上前面的函数的相等是在编程语言的层面来说的。另外的层面包括 <strong>渐进性相等</strong>（时间复杂度和空间复杂度在忽略常数因子的情况下相等）和 <strong>系统性相等</strong>（在实际运行时，考虑常数因子和各种 tuning 的情况下二者的运行时间）。</p><p>每种不同的层面的描述各有利弊。尽管两个函数在编程语言层面是相等的，也可以将其中运行较慢的函数换成更快的版本以获取性能提升。</p><hr><p>Part A 完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> 编程语言理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part A) 笔记 4 Section 3</title>
      <link href="/2019/02/06/Programming-Languages-Part-A-%E7%AC%94%E8%AE%B0-4-Section-3/"/>
      <url>/2019/02/06/Programming-Languages-Part-A-%E7%AC%94%E8%AE%B0-4-Section-3/</url>
      
        <content type="html"><![CDATA[<h1 id="Section-3"><a href="#Section-3" class="headerlink" title="Section 3"></a>Section 3</h1><h2 id="Introduction-to-First-Class-Functions"><a href="#Introduction-to-First-Class-Functions" class="headerlink" title="Introduction to First-Class Functions"></a>Introduction to First-Class Functions</h2><h3 id="函数式编程与函数式语言"><a href="#函数式编程与函数式语言" class="headerlink" title="函数式编程与函数式语言"></a>函数式编程与函数式语言</h3><p>函数式编程是一种编程范式。具有如下特点：</p><ul><li>不使用可变数据类型。</li><li>函数可以作为值。</li></ul><p>大部分语言都可以进行函数式编程，但是有些语言更加便利，设计出来就是为了方便函数式编程的，这种语言的标准库可能也是用函数式编程的方法写出来的。这种语言为函数式语言。</p><a id="more"></a><h3 id="函数作为值与高阶函数"><a href="#函数作为值与高阶函数" class="headerlink" title="函数作为值与高阶函数"></a>函数作为值与高阶函数</h3><p>ML 中函数可以作为值，也就是说函数本身可以像值一样传来传去。</p><p>高阶函数指的是接受函数作为参数或者返回函数的函数。</p><h3 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h3><p>一个函数可以引用它外部环境中的变量，这种特性使得该函数成为了一个闭包。详细的后面会写。</p><h2 id="Functions-as-Arguments"><a href="#Functions-as-Arguments" class="headerlink" title="Functions as Arguments"></a>Functions as Arguments</h2><p>函数可以作为参数传递，作者实现了一个 <code>n_times</code> 函数作为示例。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> n_times(f, n, x) = <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span> x <span class="keyword">else</span> f(n_times(f, n - <span class="number">1</span>, x))</span><br></pre></td></tr></table></figure><p>这个函数是一个高阶函数，它会将传入的函数 <code>f</code> 在 <code>x</code> 上应用 <code>n</code> 次。等价于 $f(f(f(\dots f(x)\dots)))​$。</p><h2 id="Polymorphic-Types-and-Functions-as-Arguments"><a href="#Polymorphic-Types-and-Functions-as-Arguments" class="headerlink" title="Polymorphic Types and Functions as Arguments"></a>Polymorphic Types and Functions as Arguments</h2><p>很多高阶函数都是 polymorphic 的，但是有些高阶函数不是 polymorphic 的，也存在是 polymorphic 的非高阶的函数。</p><h2 id="Anonymous-Functions"><a href="#Anonymous-Functions" class="headerlink" title="Anonymous Functions"></a>Anonymous Functions</h2><p>当使用高阶函数的时候使用匿名函数很有用。</p><p><code>fn</code> 定义一个匿名函数，匿名函数是一个表达式：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> zz = n_times(<span class="keyword">fn</span> x =&gt; x * <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>匿名函数无法自己递归。如果函数没有递归的需求，那么 fun 绑定实际上是匿名函数的语法糖，以下两行等价：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> double x = <span class="number">2</span> * x</span><br><span class="line"><span class="keyword">val</span> double = <span class="keyword">fn</span> x =&gt; <span class="number">2</span> * x</span><br></pre></td></tr></table></figure><h2 id="Unnecessary-Function-Wrapping"><a href="#Unnecessary-Function-Wrapping" class="headerlink" title="Unnecessary Function Wrapping"></a>Unnecessary Function Wrapping</h2><p>下面这两段代码使用了不必要的函数包装：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> zz = n_times(<span class="keyword">fn</span> x =&gt; double x, <span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> yy = <span class="type">List</span>.rev yy</span><br></pre></td></tr></table></figure><p>替换成下面的形式会更简洁：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> zz = n_times(double, <span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> yy = <span class="type">List</span>.rev</span><br></pre></td></tr></table></figure><h2 id="Map-and-Filter"><a href="#Map-and-Filter" class="headerlink" title="Map and Filter"></a>Map and Filter</h2><p><code>map</code> 和 <code>filter</code> 是两个很常用的高阶函数：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> map(f, <span class="literal">[]</span>) = <span class="literal">[]</span></span><br><span class="line">  | map(f, x :: xs) = (f x) :: xs</span><br><span class="line"></span><br><span class="line"><span class="keyword">fun</span> filter(f, <span class="literal">[]</span>) = <span class="literal">[]</span></span><br><span class="line">  | filter(f, x :: xs) = <span class="keyword">if</span> f x <span class="keyword">then</span> x :: filter(f, xs) <span class="keyword">else</span> filter(f, xs)</span><br></pre></td></tr></table></figure><h2 id="Generalizing-Prior-Topics"><a href="#Generalizing-Prior-Topics" class="headerlink" title="Generalizing Prior Topics"></a>Generalizing Prior Topics</h2><p>函数可以作为参数和返回值。当要返回一个函数的时候可以采用匿名函数的写法。</p><p>ML 中高阶函数的类型表示里面的 <code>-&gt;</code> 是右结合的，<code>a -&gt; b -&gt; c -&gt; d</code> 相当于 <code>a -&gt; (b -&gt; (c -&gt; d))</code>。</p><p>高阶函数适合在任意形式的递归结构上使用。</p><h2 id="Lexical-Scope"><a href="#Lexical-Scope" class="headerlink" title="Lexical Scope"></a>Lexical Scope</h2><p>Lexical scope 是一个作用域（词法作用域），这个作用域是静态的，在编译时就确定的。一个函数可以在函数体中使用外部环境的变量，当被调用时，该变量的取值从 <strong>函数被定义时的环境</strong> 中得到（即词法作用域）而不是从调用的环境中得到。例如：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">fun</span> f y = x + y</span><br><span class="line"><span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> z = f(x + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>将会得到 <code>z = 4</code>。第四行进行调用的时候，参数中的子表达式 <code>x</code> 的取值从调用的环境中得到，为 2；函数体中的 <code>x</code> 从词法作用域中得到，为 1。</p><p>与 lexical scope 相对的是 dynamic scope。</p><hr><p>Lexical scope 是一个抽象概念，closure 是一种对词法作用域的实现方式。每个函数一旦定义，ML 实际上创建了两个部分：函数的代码，以及函数定义时的环境。这两个部分合称为函数的闭包。函数在执行的时候，所有的外部变量都从闭包中的定义时环境中获取，而不是从当前环境获取。</p><h2 id="Lexical-Scope-and-Higher-Order-Functions"><a href="#Lexical-Scope-and-Higher-Order-Functions" class="headerlink" title="Lexical Scope and Higher-Order Functions"></a>Lexical Scope and Higher-Order Functions</h2><ul><li>Lexical scope 的一个好处是在分析函数的时候不用管代码中其它部分的定义以及对这个函数的可能的调用，可对函数进行独立的分析。在没有运行之前，就可以搞清楚每个函数的具体作用是什么，而不依赖于运行时的输入等。</li><li>在使用高阶函数产生新函数的时候，每生成一个函数就会产生一个闭包。</li><li>调用函数时，参数不是从 lexical scope 中获取的。</li></ul><h2 id="Why-Lexical-Scope"><a href="#Why-Lexical-Scope" class="headerlink" title="Why Lexical Scope"></a>Why Lexical Scope</h2><h3 id="闭包可以让使函数的含义与变量名无关"><a href="#闭包可以让使函数的含义与变量名无关" class="headerlink" title="闭包可以让使函数的含义与变量名无关"></a>闭包可以让使函数的含义与变量名无关</h3><p>这个特性可以让代码更加模块化。什么是 dynamic scope，我感觉就是一个全局的变量和值的词典，每次要使用一个变量的时候都是从这个词典中取值。例如：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> f1 x = <span class="keyword">let</span> <span class="keyword">val</span> y = <span class="number">0</span> <span class="keyword">in</span> <span class="keyword">fn</span> <span class="literal">()</span> =&gt; x + y <span class="keyword">end</span></span><br><span class="line"><span class="keyword">fun</span> f2 x = <span class="keyword">let</span> <span class="keyword">val</span> z = <span class="number">0</span> <span class="keyword">in</span> <span class="keyword">fn</span> <span class="literal">()</span> =&gt; x + z <span class="keyword">end</span></span><br><span class="line"><span class="keyword">val</span> y = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> a1 = (f1 <span class="number">0</span>) <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> a2 = (f2 <span class="number">0</span>) <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在词法作用域看来，<code>f1</code> 和 <code>f2</code> 完全是等价的，因此 <code>a1</code> 和 <code>a2</code> 应该相同。但是在动态作用域看来，<code>f1 0</code> 得到的函数的作用是对参数加上 <code>y</code>，而此时 <code>y</code> 的取值是 1，<code>f2 0</code> 得到的函数作用是对参数加上 <code>z</code>，而此时 <code>z</code> 的取值是 0，因此 <code>a1</code> 和 <code>a2</code> 不同。</p><p>这么解释需要假定 let 语句只会执行一遍：在“编译”<code>f1</code> 时，<code>y = 0</code> 了，在调用 <code>f1</code> 时，这个 <code>y = 0</code> 不会再次被执行。</p><p>闭包的特性也可以让函数中可以独立地删掉无用变量，例如</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> f g = <span class="keyword">let</span> <span class="keyword">val</span> x = <span class="number">3</span> <span class="keyword">in</span> g <span class="number">2</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果是动态作用域，因为不知道 <code>g 2</code> 是否依赖于 <code>x</code> 而不能直接将 <code>x = 3</code> 删掉。</p><h3 id="闭包可以让函数能在定义时进行类型检查"><a href="#闭包可以让函数能在定义时进行类型检查" class="headerlink" title="闭包可以让函数能在定义时进行类型检查"></a>闭包可以让函数能在定义时进行类型检查</h3><p>这个不用多说了，如果函数中访问的外部变量是从动态环境中获取的，取值类型又不确定，肯定不能进行类型检查。</p><h3 id="闭包更加方便存储需要的数据"><a href="#闭包更加方便存储需要的数据" class="headerlink" title="闭包更加方便存储需要的数据"></a>闭包更加方便存储需要的数据</h3><p>这个是显然的。引入闭包的一个原因就是函数不会随着调用时的情况改变自己的功能。</p><hr><p>动态作用域有时会比较方便。ML 中异常的表现和动态作用域很像，异常被抛出后总是被栈上最近的 handle 语句处理，这个在编译时无法确定，只能在运行时确定。</p><h2 id="Closures-and-Recomputation"><a href="#Closures-and-Recomputation" class="headerlink" title="Closures and Recomputation"></a>Closures and Recomputation</h2><p>利用闭包可以节省不必要的重复计算：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> filter(f, <span class="literal">[]</span>) = <span class="literal">[]</span></span><br><span class="line">  | filter(f, x :: xs) = <span class="keyword">if</span> f x <span class="keyword">then</span> x :: filter(f, xs) <span class="keyword">else</span> filter(f, xs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">fun</span> longer_than_1(xs, x) = </span><br><span class="line">    filter(<span class="keyword">fn</span> s =&gt; <span class="type">String</span>.size s &gt; <span class="type">String</span>.size x, xs)</span><br><span class="line"><span class="keyword">fun</span> longer_than_2(xs, x) = </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">val</span> len = <span class="type">String</span>.size x <span class="keyword">in</span> filter(<span class="keyword">fn</span> s =&gt; <span class="type">String</span>.size s &gt; len, xs) <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 <code>longer_than_2</code> 中 <code>x</code> 的长度被缓存下来。</p><h2 id="Fold-and-More-Closures"><a href="#Fold-and-More-Closures" class="headerlink" title="Fold and More Closures"></a>Fold and More Closures</h2><p><code>fold</code> 是另一个很重要的函数。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> fold(f, acc, xs) =</span><br><span class="line">    <span class="keyword">case</span> xs <span class="keyword">of</span></span><br><span class="line">        <span class="literal">[]</span> =&gt; acc</span><br><span class="line">        | y :: ys =&gt; fold(f, f(acc, y), ys)</span><br></pre></td></tr></table></figure><p><code>fold</code> 的作用就是 <strong>从一个递归的结构中得到单一的结果</strong>。所有有这种需求的场景都可以考虑一下使用 <code>fold</code>。使用 <code>fold</code> 不一定是针对列表的，实际上对所有的递归结构都有效，并且 <code>fold</code> 的概念实际上将 <strong>结构的遍历方式</strong> 和 <strong>结果的计算方式</strong> 这两个不同的函数分离开了。</p><h2 id="Closure-Idiom-Combining-Functions"><a href="#Closure-Idiom-Combining-Functions" class="headerlink" title="Closure Idiom: Combining Functions"></a>Closure Idiom: Combining Functions</h2><p>从这一节开始的几小节是关于高阶函数和闭包的一些 idioms。</p><hr><p>这一节内容就是函数的复合。比如要算一个数的绝对值的平方根：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> sqrt_abs_1 x = <span class="type">Math</span>.sqrt(<span class="type">Real</span>.fromInt(abs x))</span><br><span class="line"><span class="keyword">val</span> sqrt_abs_2 = <span class="type">Math</span>.sqrt o <span class="type">Real</span>.fromInt o abs</span><br><span class="line"></span><br><span class="line"><span class="keyword">infix</span> |&gt;</span><br><span class="line"><span class="keyword">fun</span> x |&gt; f = f x</span><br><span class="line"><span class="keyword">fun</span> sqrt_abs_3 x = x |&gt; abs |&gt; <span class="type">Real</span>.fromInt |&gt; <span class="type">Math</span>.sqrt</span><br></pre></td></tr></table></figure><ul><li>第一种写法是常规写法。</li><li>第二种写法使用了中缀运算符 <code>o</code> 对函数进行复合。</li><li>第三种写法建立了新的中缀运算符 <code>|&gt;</code>，类似 F# 中的管道对函数复合。</li></ul><p>第二种和第三种的区别在于第三种复合方向是从左到右的，符合直觉。</p><hr><p>但是这和闭包有什么关系呢？我猜例如 <code>sqrt_abs_2</code> 这个函数使用了 <code>abs</code> 这个函数，而 <code>abs</code> 是处于 <code>sqrt_abs_2</code> 的闭包中的，只能这么强行解释了。</p><h2 id="Closure-Idiom-Currying"><a href="#Closure-Idiom-Currying" class="headerlink" title="Closure Idiom: Currying"></a>Closure Idiom: Currying</h2><p>科里化是将多参数的函数转化为多个单参数的函数的过程。前面提到所有的函数实际上只接受一个参数，是一个元组，但是逻辑上还是接受多个参数的。</p><p>例如有个函数接受一个三元组，判定它们是否是升序排列的：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> is_sorted(x, y, z) = x &lt; y <span class="keyword">andalso</span> y &lt; z</span><br></pre></td></tr></table></figure><p>这个函数逻辑上接受三个参数，通过科里化，变成：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> is_sorted_1 = <span class="keyword">fn</span> x =&gt; <span class="keyword">fn</span> y =&gt; <span class="keyword">fn</span> z =&gt; x &lt; y <span class="keyword">andalso</span> y &lt; z</span><br></pre></td></tr></table></figure><p>此时 <code>is_sorted_1</code> 变成了一个逻辑上接受单个参数的函数，它返回一个接受单个参数的函数，这个函数又返回一个接受单个参数的函数，最后这个函数才返回判定结果。闭包在其中的应用是显然的。如果要调用这个函数，只需：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> res_1 = ((is_sorted_1 <span class="number">3</span>) <span class="number">5</span>) <span class="number">7</span></span><br></pre></td></tr></table></figure><p>科里化后不管是定义还是使用看起来都比较复杂，但是它是有语法糖的。ML 中表达式 <code>e1 e2 e3</code> 的顺序为 <code>((e1) e2) e3</code>。加糖之后和 Haskell 很像，都是用空格分割参数（要两者混用也是可以的）：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> is_sorted_2 x y z = x &lt; y <span class="keyword">andalso</span> y &lt; z</span><br><span class="line"><span class="keyword">val</span> res_2 = is_sorted_2 <span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>匿名函数没有这个语法糖。</strong></p><p>需要注意 <code>is_sorted</code> 的类型是 <code>fn : int * int * int -&gt; bool</code>，而 <code>is_sorted_2</code> 的类型是 <code>fn : int -&gt; int -&gt; int -&gt; bool</code>，二者是不一样的。<strong>但是不要想成两种不同的具有三个参数的函数的签名写法，只要把第一种想成是接受三元组，第二种想成是效果上接受三个参数的函数即可。</strong></p><p>之前的写法是一个谎言，建议默认用科里化的写法。</p><h2 id="Partial-Application"><a href="#Partial-Application" class="headerlink" title="Partial Application"></a>Partial Application</h2><p>Partial application 是对科里化后的函数提供部分参数，从而得到一个新的可复用的函数。比如使用 <code>fold</code> 可以定义 <code>sum</code>：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> fold f acc xs = <span class="keyword">case</span> xs <span class="keyword">of</span> <span class="literal">[]</span> =&gt; acc | y :: ys =&gt; fold f (f acc y) ys</span><br><span class="line"><span class="keyword">val</span> sum = fold (<span class="keyword">fn</span> a =&gt; <span class="keyword">fn</span> b =&gt; a + b) <span class="number">0</span></span><br></pre></td></tr></table></figure><p>（受限于 ML 的类型系统，有时候可能需要显式写出自变量或者函数的签名。）</p><h2 id="Currying-Wrapup"><a href="#Currying-Wrapup" class="headerlink" title="Currying Wrapup"></a>Currying Wrapup</h2><p>有时候希望使用 partial application，但是要用的函数是一个接受元组的多参数函数；有时候要传入的不是函数的第一个参数。此时有些函数可以帮忙：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> curry f x y = f (x, y)</span><br><span class="line"><span class="keyword">fun</span> uncurry f (x, y) = f x y</span><br><span class="line"><span class="keyword">fun</span> flip f x y = f y x</span><br></pre></td></tr></table></figure><p><code>curry</code> 函数可以将一个接受元组的函数进行科里化；<code>uncurry</code> 函数则完成相反的过程；<code>flip</code> 函数将一个函数的两个参数顺序颠倒。</p><p>因为用这些函数的时候常常是以 partial application 的形式调用的，所以出现在等号左边的 <code>x</code> 和 <code>y</code> 的含义其实相当于一种“占位符”。我感觉这里最妙的是 <code>uncurry</code> 的写法，<code>f (x, y)</code> 看上去是一个函数调用，实际上只是一个模式匹配。</p><hr><p>关于科里化的效率问题，作者提到取决于实现而非语言，并且建议不要面向实现编程，除非十分重要。推荐总是使用科里化。</p><h2 id="Mutable-References"><a href="#Mutable-References" class="headerlink" title="Mutable References"></a>Mutable References</h2><p>ML 支持可变的引用（引用指向不可变，内容可变），但是不推荐使用。</p><p>对于一个类型 <code>t</code>，其可变引用类型为 <code>t ref</code>。（和 <code>t list</code> 类似。）例如指向整数的引用是 <code>int ref</code>。</p><p>使用以下函数进行访问、修改：</p><ul><li><code>ref e</code> 会创建一个以 <code>e</code> 的类型为元素类型、<code>e</code> 的值为内容的引用。</li><li><code>e1 := e2</code> 更新引用中的内容。</li><li><code>!e</code> 读取引用中的内容。</li></ul><p>如果要解决的问题中有本质上的需要更新内容的情形，可以考虑使用。</p><h2 id="Closure-Idiom-Callbacks"><a href="#Closure-Idiom-Callbacks" class="headerlink" title="Closure Idiom: Callbacks"></a>Closure Idiom: Callbacks</h2><p>用可变引用可以写出回调的效果。下面的例子里面，每次事件 <code>event</code> 触发都会产生一个 <code>onEvent</code> 的调用，进而调用对应的回调函数。</p><p>假设回调的框架如下：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> callbacks : (<span class="built_in">int</span> -&gt; <span class="built_in">unit</span>) <span class="built_in">list</span> <span class="built_in">ref</span> = <span class="built_in">ref</span> <span class="literal">[]</span></span><br><span class="line"><span class="keyword">fun</span> add_callback f = callbacks := f :: !callbacks</span><br><span class="line"><span class="keyword">fun</span> on_event n = <span class="keyword">let</span> <span class="keyword">fun</span> apply_all fns x = <span class="keyword">case</span> fns <span class="keyword">of</span></span><br><span class="line">    <span class="literal">[]</span> =&gt; <span class="literal">()</span></span><br><span class="line">    | f :: fs =&gt; (f x ; apply_all fs x)</span><br><span class="line">    <span class="keyword">in</span> apply_all (!callbacks) n <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>然后注册了两个回调函数：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> count = <span class="built_in">ref</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> count_callback = add_callback (<span class="keyword">fn</span> _ =&gt; count := !count + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> log_callback = add_callback (<span class="keyword">fn</span> x =&gt; print (<span class="type">Int</span>.toString x))</span><br></pre></td></tr></table></figure><p>随后，系统每次调用 <code>on_event n</code> 的时候，<code>count</code> 都会加一，并且 <code>n</code> 会被打印出来。</p><h2 id="Standard-Library-Documentation"><a href="#Standard-Library-Documentation" class="headerlink" title="Standard-Library Documentation"></a>Standard-Library Documentation</h2><p>ML 有一个标准库。</p><hr><p>可能有用的东西：</p><ol><li><p>在 REPL 中输入 <code>structure X = List</code>，可以得到一个输出 <code>LIST</code>。</p></li><li><p>再输入 <code>signature X = LIST</code> 就可以看到和 LIST 相关的所有函数的签名。</p></li></ol><h2 id="Abstract-Data-Types-With-Closures"><a href="#Abstract-Data-Types-With-Closures" class="headerlink" title="Abstract Data Types With Closures"></a>Abstract Data Types With Closures</h2><p>通过在记录中将某项设置为一个函数的方法可以写出类似 OOP 的效果。</p><p>如果将记录、闭包、可变数据类型这三者结合起来的话可以在函数式编程中用很折腾的方法写 OOP。</p><h2 id="Closure-Idioms-Without-Closures"><a href="#Closure-Idioms-Without-Closures" class="headerlink" title="Closure Idioms Without Closures"></a>Closure Idioms Without Closures</h2><p>有些语言没有闭包，这节准备在这种语言中实现几个函数式编程中常用的函数。</p><h2 id="Java-Without-Closures"><a href="#Java-Without-Closures" class="headerlink" title="Java Without Closures"></a>Java Without Closures</h2><p>这节讲的是如何使用 Java 中的类、接口和泛型来模拟闭包以及各种高阶函数。</p><p><em>本节没有问题。</em></p><h2 id="C-Without-Closures"><a href="#C-Without-Closures" class="headerlink" title="C Without Closures"></a>C Without Closures</h2><p>这节讲的是如何使用 C 中的结构体和函数指针模拟闭包和各种高阶函数。其实 C 和函数式语言类似，函数都是 first class 的，但是没有闭包。模拟出闭包的关键是在每个函数的参数中都加上一个表示环境的 <code>void*</code> 参数，这个参数用来存放该函数在某次调用中需要用到的环境。</p><h2 id="Course-Motivation-Introduction"><a href="#Course-Motivation-Introduction" class="headerlink" title="Course-Motivation Introduction"></a>Course-Motivation Introduction</h2><p><em>本节没有问题。</em></p><h2 id="Why-Study-General-PL-Concepts"><a href="#Why-Study-General-PL-Concepts" class="headerlink" title="Why Study General PL Concepts?"></a>Why Study General PL Concepts?</h2><p>课程将会重视语言的语义和惯用法。关于语言的基本使用需要掌握语义，掌握惯用法会让程序质量更好。</p><p>一些语言中存在的语义可能在别的语言中不支持，例如 ML 有模式匹配但是很多语言没有，这时可以将模式匹配的思路作为其它语言的惯用法使代码更优美。</p><h2 id="Are-All-PLs-the-Same"><a href="#Are-All-PLs-the-Same" class="headerlink" title="Are All PLs the Same?"></a>Are All PLs the Same?</h2><p>所有的编程语言在表现能力上等价，但是不同语言完成不同任务的方便程度不同。学习的时候应该注意不同语言的差异性，而不要只看到相似性。</p><h2 id="Why-Functional-Languages"><a href="#Why-Functional-Languages" class="headerlink" title="Why Functional Languages?"></a>Why Functional Languages?</h2><p>对程序语言的研究一般需要相当长的时间才会在实际工程上出现。函数式语言目前还没有大规模应用，但是有越来越多的使用函数式语言的特性被加入到现有的语言中，可以认为是大势所趋。</p><h2 id="Why-ML-Racket-and-Ruby"><a href="#Why-ML-Racket-and-Ruby" class="headerlink" title="Why ML, Racket, and Ruby?"></a>Why ML, Racket, and Ruby?</h2><p>ML 是静态类型函数式语言；Racket 是动态类型函数式语言；Ruby 是动态类型面向对象语言。</p><p><em>本节没有问题。</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> 编程语言理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part A) 笔记 3 Section 2</title>
      <link href="/2019/02/06/Programming-Languages-Part-A-%E7%AC%94%E8%AE%B0-3-Section-2/"/>
      <url>/2019/02/06/Programming-Languages-Part-A-%E7%AC%94%E8%AE%B0-3-Section-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Section-2"><a href="#Section-2" class="headerlink" title="Section 2"></a>Section 2</h1><p>我发现这课大部分时间居然是在讲语言的使用。现在我得记简略点，不然就太浪费时间了。</p><h2 id="Building-Compound-Types"><a href="#Building-Compound-Types" class="headerlink" title="Building Compound Types"></a>Building Compound Types</h2><h3 id="基础类型和复合类型"><a href="#基础类型和复合类型" class="headerlink" title="基础类型和复合类型"></a>基础类型和复合类型</h3><p>基础类型是“原子”的类型，无法继续分解。</p><p>复合类型例如列表、元组和 Option。</p><h3 id="构造复合类型的通用方法"><a href="#构造复合类型的通用方法" class="headerlink" title="构造复合类型的通用方法"></a>构造复合类型的通用方法</h3><p>复合类型都可以由三种方式组合地构造出：</p><ul><li><strong>Each of</strong>：包括全部的可选类型</li><li><strong>One of</strong>：包含若干个可选类型之一</li><li><strong>Self reference</strong>：包含自己这个类型</li></ul><p>例如元组就是 Each of 形式的，Option 就是 One of 形式的，列表是三种形式的组合：一个 <code>int list</code> 可以为空（One of），也可以为一个 <code>int</code> 加上一个 <code>int list</code>（Self reference 和 One of）。</p><a id="more"></a><h2 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h2><p>记录类型本质上是有名字的元组。</p><ul><li><p><strong>构造</strong>：<code>val r = {foo = 123, bar = false}</code> 。</p></li><li><p><strong>访问</strong>：<code>#foo r = 123, #bar r = false</code>。</p></li></ul><p>记录的键是无序的。</p><hr><p>记录和元组的区别在于一个是靠名称访问，一个是靠位置访问。</p><p>一个事实是很多语言中的函数调用是二者的结合：调用者使用位置访问传递参数，被调用者使用名称访问读取参数。有些语言允许不这样做。</p><h2 id="Tuples-as-Syntactic-Sugar"><a href="#Tuples-as-Syntactic-Sugar" class="headerlink" title="Tuples as Syntactic Sugar"></a>Tuples as Syntactic Sugar</h2><p>元组本质上是记录的语法糖。可以认为 ML 中没有元组，只有记录。以下两个绑定是等价的。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = (<span class="number">3</span>, <span class="string">"hi"</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = &#123;<span class="number">2</span> = <span class="string">"hi"</span>, <span class="number">1</span> = <span class="number">3</span>, <span class="number">3</span> = <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>记录的键可以是数字。当键不是 1 到 n 时，会成为普通记录。</p><h2 id="Datatype-Bindings"><a href="#Datatype-Bindings" class="headerlink" title="Datatype Bindings"></a>Datatype Bindings</h2><p><code>datatype</code> 和 <code>val</code> 以及 <code>fun</code> 一样，是一种绑定。</p><p>语法示例：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">datatype</span> <span class="type">MyType</span> = <span class="type">IntPair</span> <span class="keyword">of</span> <span class="built_in">int</span> * <span class="built_in">int</span> | <span class="type">Str</span> <span class="keyword">of</span> <span class="built_in">string</span> | <span class="type">Pizza</span></span><br></pre></td></tr></table></figure><p>后面的 <code>IntPair</code>、<code>Str</code> 和 <code>Pizza</code> 是 <strong>构造函数</strong>，本质上是函数，接受相应的参数构造出一个 <code>MyType</code> 类型的值。这句话会同时更新静态和动态环境：</p><ul><li><strong>静态环境更新</strong>：添加了新的类型 <code>MyType</code>。</li><li><strong>动态环境更新</strong>：添加了构造函数。</li></ul><p>使用构造函数和使用函数别无二致：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="type">IntPair</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> b = <span class="type">Str</span> <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">val</span> c = <span class="type">Pizza</span></span><br></pre></td></tr></table></figure><p>如果检查一下 <code>a</code> 的值发现它就是 <code>IntPair (3, 4)</code>，这是所谓的 tagged union，其中 <code>IntPair</code> 相当于一个 tag。</p><p>如果已经知道了一个 datatype，如何获取其中的值？可以像 Option 那样为每一个构造函数生成一个判定是否为该 tag 的函数和一个从这个 tag 中取出值的函数，但是这么做太蠢了。后面有更好的解决方案。</p><h2 id="Case-Expressions"><a href="#Case-Expressions" class="headerlink" title="Case Expressions"></a>Case Expressions</h2><p>这节解决上节的问题。</p><p>case 实际上是一个语句，用来进行模式匹配，匹配时可以直接取出变量的值：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="type">IntPair</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> k = <span class="keyword">case</span> a <span class="keyword">of</span></span><br><span class="line">    <span class="type">IntPair</span>(x, y) =&gt; x + y</span><br><span class="line">    | <span class="type">Str</span> s =&gt; <span class="number">0</span></span><br><span class="line">    | <span class="type">Pizza</span> =&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>=&gt;</code> 左边的称为 pattern，语法上和一个表达式类似，但是不是表达式。</p><p>模式匹配必须是不重复的，否则会引起编译错误。最好是完备的，否则会引起编译警告。</p><h2 id="Useful-Datatypes"><a href="#Useful-Datatypes" class="headerlink" title="Useful Datatypes"></a>Useful Datatypes</h2><p>Datatype 可以用来实现枚举（并且元素自己还可以带有属性）。</p><p>Datatype 相当于一种 one of 的结构，记录相当于一种 each of 的结构。两者不要混淆使用。</p><p>使用 Datatype 进行递归的使用可以构造类似语法树的结构（注意构造函数是普通的函数），再使用模式匹配还可以对这种语法树进行求值。</p><h2 id="Pattern-Matching-So-Far"><a href="#Pattern-Matching-So-Far" class="headerlink" title="Pattern Matching So Far"></a>Pattern Matching So Far</h2><p>这节正式写出了 datatype 和模式匹配的三个要素，比较显然。</p><h2 id="Another-Expression-Example"><a href="#Another-Expression-Example" class="headerlink" title="Another Expression Example"></a>Another Expression Example</h2><p><em>本节没有问题。</em></p><h2 id="Type-Synonyms"><a href="#Type-Synonyms" class="headerlink" title="Type Synonyms"></a>Type Synonyms</h2><p>使用 <code>type</code> 可以定义新的类型。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">IntBool</span> = <span class="built_in">int</span> * <span class="built_in">bool</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">Person</span> = &#123;name: <span class="built_in">string</span>, age: <span class="built_in">int</span>&#125;</span><br></pre></td></tr></table></figure><p>本质上只是取个别名而已，二者在所有的地方都可以交换使用，二者是完全等价的。</p><h2 id="Lists-and-Options-are-Datatypes"><a href="#Lists-and-Options-are-Datatypes" class="headerlink" title="Lists and Options are Datatypes"></a>Lists and Options are Datatypes</h2><p>列表和 Option 上是 datatype，通过使用模式匹配，可以避免掉使用 <code>isSome</code>、<code>valOf</code>、<code>null</code>、<code>hd</code> 以及 <code>tl</code>，因为这些函数实际上都可以使用模式匹配等价地搞出来。</p><p>例如列表的构造函数实际上是 <code>[]</code> 和 <code>::</code>。</p><p>这些函数存在的意义是有时候会便利，并且有时候需要将函数作为参数传递的时候有用。</p><p>可以认为列表和 Option 是可以自己造出来的，语言不一定要提供。</p><h2 id="Polymorphic-Datatypes"><a href="#Polymorphic-Datatypes" class="headerlink" title="Polymorphic Datatypes"></a>Polymorphic Datatypes</h2><p><code>list</code>和 <code>option</code> 本身不是类型，它们需要接受一个 <strong>类型参数</strong> 才能构造出具体的类型。<code>int list</code> 和 <code>int option</code> 才是类型。<code>&#39;a list</code> 也是具体的类型。<code>list</code> 和 <code>option</code> 称为 type constructor。</p><p>定义 polymorphic datatype：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">datatype</span> <span class="symbol">'a</span> <span class="type">MyList</span> =</span><br><span class="line">    <span class="type">Empty</span></span><br><span class="line">    | <span class="type">Cons</span> <span class="keyword">of</span> <span class="symbol">'a</span> * <span class="symbol">'a</span> <span class="type">MyList</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">datatype</span> (<span class="symbol">'a</span>, <span class="symbol">'b</span>) <span class="type">BinaryTree</span> =</span><br><span class="line">    <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">'a</span> * (<span class="symbol">'a</span>, <span class="symbol">'b</span>) <span class="type">BinaryTree</span> * (<span class="symbol">'a</span>, <span class="symbol">'b</span>) <span class="type">BinaryTree</span></span><br><span class="line">    | <span class="type">Leaf</span> <span class="keyword">of</span> <span class="symbol">'b</span></span><br></pre></td></tr></table></figure><p>它和列表一样使用。</p><p>当在函数中使用 polymorphic datatype 的时候如果依赖于语言的类型推断，语言会得到一个最大的适合函数的类型签名。例如对列表求和要求是 <code>int list</code>，但是对列表进行连接只要求是 <code>&#39;a list</code>。</p><h2 id="Each-of-Pattern-Matching-Truth-About-Functions"><a href="#Each-of-Pattern-Matching-Truth-About-Functions" class="headerlink" title="Each of Pattern Matching / Truth About Functions"></a>Each of Pattern Matching / Truth About Functions</h2><p><strong>这一节很有意思！</strong>主要的观点：</p><ul><li>所有的变量绑定和函数绑定都可以使用模式匹配来完成。</li><li>所有的函数本质上都只接受一个参数。</li></ul><h3 id="对元组和记录的模式匹配"><a href="#对元组和记录的模式匹配" class="headerlink" title="对元组和记录的模式匹配"></a>对元组和记录的模式匹配</h3><p>之前对模式匹配的使用是对 datatype 在用，这种用法实际上是匹配一个 one of 类型的数据。但是模式匹配可以对 each of 类型的数据进行匹配，例如元组和记录。在这种情况下，模式匹配相当于一种 unpack 的操作。</p><h3 id="绑定时的模式匹配"><a href="#绑定时的模式匹配" class="headerlink" title="绑定时的模式匹配"></a>绑定时的模式匹配</h3><p>绑定时，等号左边实际上是一个模式 $p$。对于变量绑定 <code>val x = 3</code> 而言，实际上 <code>x</code> 已经是一个特殊的模式了。可以使用这样的写法：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> triple = (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> (x, y, z) = triple</span><br></pre></td></tr></table></figure><p>这个绑定是一个模式的绑定，<code>x</code> 会等于 3，其它同理。</p><hr><p>现在看一下对元组的匹配。假设要实现一个函数 <code>sum</code>，作用是对三元组求和。最差的写法是使用 case 语句进行模式匹配：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> sum_1 triple =</span><br><span class="line">    <span class="keyword">case</span> triple <span class="keyword">of</span></span><br><span class="line">        (x, y, z) =&gt; x + y + z</span><br></pre></td></tr></table></figure><p>这是一种比较差的写法。因为这个实际上使用了单个分支的 case 语句。在对 one of 类型进行匹配的时候，这样的语句有可能产生运行时错误。为了 case 语句的一致性，尽管这里不会有任何问题（也不会有警告），还是不要这样写。</p><p>实际上我们知道了只可能出现一种 case，因此好一点的写法是使用绑定，代码如下：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> sum_2 triple =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">val</span> (x, y, z) = triple <span class="keyword">in</span> x + y + z <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个相当于做了一个 unpack 的操作。实际上 ML 是可以在函数的参数那里就地 unpack 的，写出来的话最终的形态是</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> sum_3 (x, y, z) = x + y + z</span><br></pre></td></tr></table></figure><p>然后可以直接将一个三元组传给 <code>sum_3</code>。<code>sum_3</code> 看上去和一个接受 3 个 int 的函数一模一样！它们是没有区别的，这就是为啥 ML 中的函数都接受一个参数。（对于不带参数的函数，实际上它接受一个空元组。）</p><p><strong>所以多参数的函数实际上是一种语法糖。</strong></p><hr><p>元组是记录的语法糖，对应地也有记录的模式匹配：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Person</span> = &#123;name: <span class="built_in">string</span>, age: <span class="built_in">int</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fun</span> show_1 person = <span class="keyword">case</span> person <span class="keyword">of</span> &#123;name = n, age = a&#125; =&gt; n ^ <span class="type">Int</span>.toString(a)</span><br><span class="line"><span class="keyword">fun</span> show_2 person = <span class="keyword">let</span> <span class="keyword">val</span> &#123;name = n, age = a&#125; = person <span class="keyword">in</span> n ^ <span class="type">Int</span>.toString(a) <span class="keyword">end</span></span><br><span class="line"><span class="keyword">fun</span> show_3 &#123;name = n, age = a&#125; = n ^ <span class="type">Int</span>.toString(a)</span><br></pre></td></tr></table></figure><p>这三个函数等价。</p><hr><p>这个特性的一个好处是：一个函数如果返回一个元组或者记录，这个返回值可以直接作为某个函数的输入，而不用显式地进行解包：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> rotate_right (x, y, z) = (z, x, y)</span><br><span class="line"><span class="keyword">fun</span> rotate_left tup = rotate_right (rotate_right tup)</span><br></pre></td></tr></table></figure><h2 id="A-Little-Type-Inference"><a href="#A-Little-Type-Inference" class="headerlink" title="A Little Type Inference"></a>A Little Type Inference</h2><h3 id="ML-类型系统的一个限制"><a href="#ML-类型系统的一个限制" class="headerlink" title="ML 类型系统的一个限制"></a>ML 类型系统的一个限制</h3><p>使用模式匹配，可以在不使用 <code>#</code> 和类型标注的情况下编写程序。但是如果不适用模式匹配就难以做到，例如下面这段代码：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> sum_1(tup: <span class="built_in">int</span> * <span class="built_in">int</span> * <span class="built_in">int</span>) = #<span class="number">1</span> tup + #<span class="number">2</span> tup + #<span class="number">3</span> tup</span><br><span class="line"><span class="keyword">fun</span> sum_2(tup) = #<span class="number">1</span> tup + #<span class="number">2</span> tup + #<span class="number">3</span> tup</span><br></pre></td></tr></table></figure><p>第一个函数可以通过编译，但是第二个不行。因为第二个的情况下 ML 不知道 <code>tup</code> 到底是什么类型的（可不可能有别的域）。ML 类型系统的一个限制就是无法写出这样的函数，使得它可以同时接受三元组和四元组。</p><hr><p>ML 进行类型推断的时候可能给出比自己期待的更加广泛的类型。</p><h2 id="Polymorphic-and-Equality-Types"><a href="#Polymorphic-and-Equality-Types" class="headerlink" title="Polymorphic and Equality Types"></a>Polymorphic and Equality Types</h2><h3 id="类型的广泛性"><a href="#类型的广泛性" class="headerlink" title="类型的广泛性"></a>类型的广泛性</h3><p>如果一个复合类型中存在形如 <code>&#39;a</code> 的类型变量，这种变量可以替换为一个具体的类型或者其它类型变量。一个复合类型 $T_1$ 比另一个复合类型 $T_2$ 更加广泛的判定是，如果将 $T_1$ 中某个类型变量的所有出现之处全部替换为另一个类型变量或者具体的类型能够得到 $T_2$，则 $T_1$ 比 $T_2$ 更加广泛。</p><h3 id="Equality-类型"><a href="#Equality-类型" class="headerlink" title="Equality 类型"></a>Equality 类型</h3><p>形如 <code>&#39;&#39;a</code> 的类型表示这个类型不仅是类型变量，而且可以使用 <code>=</code> 来判定相等性。</p><h2 id="Nested-Patterns"><a href="#Nested-Patterns" class="headerlink" title="Nested Patterns"></a>Nested Patterns</h2><p>模式匹配可以进行嵌套。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exception</span> <span class="type">Err</span></span><br><span class="line"><span class="keyword">fun</span> zip3 lists = <span class="keyword">case</span> lists <span class="keyword">of</span></span><br><span class="line">    (<span class="literal">[]</span>, <span class="literal">[]</span>, <span class="literal">[]</span>) =&gt; <span class="literal">[]</span></span><br><span class="line">    | (x :: xs, y :: ys, z :: zs) =&gt; (x, y, z) :: zip3 (xs, ys, zs)</span><br><span class="line">    | _ =&gt; <span class="keyword">raise</span> <span class="type">Err</span></span><br></pre></td></tr></table></figure><p>如果单纯地使用简单的模式匹配或者用 if 表达式进行判断会比这个复杂很多。</p><p>最后的 <code>_</code> 是通配符。</p><h2 id="More-Nested-Patterns"><a href="#More-Nested-Patterns" class="headerlink" title="More Nested Patterns"></a>More Nested Patterns</h2><p>对嵌套模式匹配的一些例子。</p><p><em>本节没有问题。</em></p><h2 id="Nested-Patterns-Precisely"><a href="#Nested-Patterns-Precisely" class="headerlink" title="Nested Patterns Precisely"></a>Nested Patterns Precisely</h2><p>这节对模式匹配能否成功做了递归的定义。</p><ul><li>如果模式是 $p$，值是 $v$，可以匹配，会引入绑定 $p = v$。</li><li>如果模式是 $_$，值是 $v$，可以匹配，不会引入绑定。</li><li>如果模式是 $(p_1, p_2, \dots, p_n)$，值是 $(v_1, v_2, \dots, v_n)$，可以匹配并引入对应的绑定。</li><li>如果模式是 $C\ p$，其中 $C$ 是一个构造函数，并且值是 $C\ v$，可以匹配并且引入绑定 $p = v$。</li></ul><p>上面的准则中的模式不一定是变量，也可以是复合的模式，这样一来整个准则可以递归应用下去。</p><h2 id="Function-Patterns"><a href="#Function-Patterns" class="headerlink" title="Function Patterns"></a>Function Patterns</h2><p>如果在进入一个函数后需要马上对参数进行模式匹配，有一个语法糖：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> len_1 <span class="built_in">list</span> = <span class="keyword">case</span> <span class="built_in">list</span> <span class="keyword">of</span></span><br><span class="line">    <span class="literal">[]</span> =&gt; <span class="number">0</span></span><br><span class="line">    | _ :: xs =&gt; <span class="number">1</span> + len_1 xs</span><br><span class="line"></span><br><span class="line"><span class="comment">(* below is better *)</span></span><br><span class="line"><span class="keyword">fun</span> len_2 <span class="literal">[]</span> = <span class="number">0</span></span><br><span class="line">  | len_2 (_ :: xs) = <span class="number">1</span> + len_2 xs</span><br></pre></td></tr></table></figure><h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>ML 中的异常和 datatype 非常相似。每定义一种新的异常，都可以认为是为一个叫做 <code>exn</code> 的 datatype 添加了新的 Constructor。</p><p><code>exception</code> 定义异常：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exception</span> <span class="type">MyException</span></span><br><span class="line"><span class="keyword">exception</span> <span class="type">MyParamException</span> <span class="keyword">of</span> <span class="built_in">int</span> * <span class="built_in">int</span> <span class="comment">(* exception can keep value *)</span></span><br></pre></td></tr></table></figure><p><code>raise</code> 抛出异常：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> my_mod(y, z) = <span class="keyword">if</span> z = <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">raise</span> <span class="type">MyParamException</span>(y, z) <span class="keyword">else</span> y mod z</span><br></pre></td></tr></table></figure><p><code>handle</code> 处理异常，这里有一个模板匹配，匹配不上会导致异常继续抛出：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x =  my_mod(<span class="number">3</span>, <span class="number">0</span>) <span class="keyword">handle</span> <span class="type">MyParamException</span>(y, z) =&gt; y + z | <span class="type">MyException</span> =&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><p>异常可以像值一样传递，因为它实际上和 datatype 类似。构造一个异常不会导致该异常被抛出：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exception</span> <span class="type">NumException</span> <span class="keyword">of</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">fun</span> throw_abs(e) =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">val</span> <span class="type">NumException</span>(x) = e <span class="keyword">in</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">raise</span> e <span class="keyword">else</span> <span class="keyword">raise</span> <span class="type">NumException</span>(~x) <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> abs_of_neg_3 = throw_abs(<span class="type">NumException</span>(~<span class="number">3</span>)) <span class="keyword">handle</span> <span class="type">NumException</span>(x) =&gt; x</span><br></pre></td></tr></table></figure><p>其中 <code>throw_abs</code> 的类型是 <code>fn : exn -&gt; &#39;a</code>。</p><h2 id="Tail-Recursion"><a href="#Tail-Recursion" class="headerlink" title="Tail Recursion"></a>Tail Recursion</h2><p>如果 $f$ 调用 $g$，但是 $f$ 的结果就是 $g$ 的结果而没有做任何变化和读取，就只是原封不动地传递回去了，这个情况下就是尾递归（不一定是在调用自己）。</p><p>看一下运行时栈的情况。如果写了两个不同的阶乘函数：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> fact n = <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">fun</span> fact_t n =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">fun</span> aux(m, acc) = <span class="keyword">if</span> m = <span class="number">0</span> <span class="keyword">then</span> acc <span class="keyword">else</span> aux(m - <span class="number">1</span>, m * acc) <span class="keyword">in</span> aux(n, <span class="number">1</span>) <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>第一个的情况下，因为 <code>fact</code> 调 <code>fact</code> 之后对返回值还要加以利用，所以不是尾递归。这种情况下，每次调用都会用掉一个栈帧，比使用循环效率低很多。</p><p>第二个的情况下，所有使用了 <code>aux</code> 的地方都是以尾递归的形式使用的。<strong>凡是这种情况，ML 会在运行时将新的 <code>aux</code> 的栈帧直接替换掉调用 <code>aux</code> 的那个函数的栈帧</strong>（毕竟这个函数做的唯一的事就是继续返回 <code>aux</code> 的返回值），这样一来栈空间占用就可以保持在一个较小的水平。只要使用了尾递归，即使是无限递归也不会导致栈爆掉。</p><h2 id="Accumulators-for-Tail-Recursion"><a href="#Accumulators-for-Tail-Recursion" class="headerlink" title="Accumulators for Tail Recursion"></a>Accumulators for Tail Recursion</h2><p>有一个经验性的法则可以把递归转换成尾递归。一般来说需要一个辅助函数和一个 accumulator 表示当前完成的工作，这个辅助函数的参数是原函数的参数加上额外的这个 accumulator。辅助函数的实现中，如果发现原函数对应的那些参数是递归基的情形就返回 accumulator，否则计算新的参数并直接调用辅助函数（就是说所有的计算最好在单个表达式中完成，并且表达式就是新被调用辅助函数的参数）。</p><p>例子如下，假设要翻转一个列表。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> rev_1 <span class="built_in">list</span> = <span class="keyword">case</span> <span class="built_in">list</span> <span class="keyword">of</span> </span><br><span class="line">    <span class="literal">[]</span> =&gt; <span class="literal">[]</span></span><br><span class="line">    | x :: xs =&gt; (rev_1 xs) @ [x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">fun</span> rev_2 <span class="built_in">list</span> =</span><br><span class="line">    <span class="keyword">let</span></span><br><span class="line">        <span class="keyword">fun</span> aux(<span class="built_in">list</span>, acc) = <span class="keyword">case</span> <span class="built_in">list</span> <span class="keyword">of</span></span><br><span class="line">            <span class="literal">[]</span> =&gt; acc</span><br><span class="line">            | x :: xs =&gt; aux(xs, x :: acc)</span><br><span class="line">    <span class="keyword">in</span> aux(<span class="built_in">list</span>, <span class="literal">[]</span>) <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>第一种写法不是尾递归，并且由于 <code>@</code> 操作需要复制第一个运算分量，实际上其复杂度是 $O(n^2)​$ 的。</p><p>第二种写法是尾递归，并且应用了上面的法则。复杂度是 $O(n)$ 的。似乎可以无脑套用法则。</p><h2 id="Perspective-on-Tail-Recursion"><a href="#Perspective-on-Tail-Recursion" class="headerlink" title="Perspective on Tail Recursion"></a>Perspective on Tail Recursion</h2><p>并非所有的递归都 <strong>适合</strong> 转换成尾递归。理论上，所有的递归确实可以写成尾递归，但是 accumulator 占用的空间可能和不适用尾递归时栈帧的大小差不多，这相当于自己实现了一个栈管理器。</p><hr><p>什么调用是一个尾调用是有严格的递归定义的。每个表达式都有一个 <strong>尾区域</strong>。例如：</p><ul><li>$\texttt{fun f p = e}$ 中的尾区域包括 $\texttt{e}$，不包括其它。</li><li>$\texttt{if e1 then e2 else e3}$ 中的尾区域包括 $\texttt{e2}$ 和 $\texttt{e3}$，不包括其它。</li><li>$\texttt{let b1 b2 ... bn in e end}$ 中的尾区域包括 $\texttt{e}$，不包括其它。</li></ul><p>给定了各个表达式的尾区域中，有一个规则：<strong>如果一个表达式不在尾区域中，那么它的任意子表达式也在尾区域中。</strong>递归地应用这些定义可以得到相对于每个表达式的尾区域。</p><p><strong>尾调用指的是位于尾区域中的调用。</strong>（这个说法中的尾区域是相对于某个表达式而言的，因为如果再深入看一点进入更小的子表达式，这个尾区域中的一个子集才是尾区域。）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> 编程语言理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part A) 笔记 2 Section 1</title>
      <link href="/2019/02/06/Programming-Languages-Part-A-%E7%AC%94%E8%AE%B0-2-Section-1/"/>
      <url>/2019/02/06/Programming-Languages-Part-A-%E7%AC%94%E8%AE%B0-2-Section-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Section-1"><a href="#Section-1" class="headerlink" title="Section 1"></a>Section 1</h1><h2 id="ML-Variable-Bindings-and-Expressions"><a href="#ML-Variable-Bindings-and-Expressions" class="headerlink" title="ML Variable Bindings and Expressions"></a>ML Variable Bindings and Expressions</h2><h3 id="一些语法"><a href="#一些语法" class="headerlink" title="一些语法"></a>一些语法</h3><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(* this is a comment *)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = <span class="number">1</span>;                          <span class="comment">(* variable binding *)</span></span><br><span class="line"><span class="keyword">val</span> y = <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">then</span> x <span class="keyword">else</span> <span class="number">0</span> - x; <span class="comment">(* condition expression *)</span></span><br><span class="line"><span class="keyword">val</span> z = abs y;                      <span class="comment">(* function call *)</span></span><br><span class="line"><span class="keyword">val</span> w = abs(z);                     <span class="comment">(* another style of function call *)</span></span><br></pre></td></tr></table></figure><p>注释和 variable binding 的语法如上。</p><h3 id="关于语言的知识"><a href="#关于语言的知识" class="headerlink" title="关于语言的知识"></a>关于语言的知识</h3><p>ML 中的每句 variable binding 都维护了一个 <strong>静态环境</strong>（不用运行）和一个 <strong>动态环境</strong>（需要运行）。</p><p>静态环境中有各个变量和表达式的类型的信息，动态环境中有它们的值的信息。静态环境的内容可以通过类型检查在运行前就得到，但是动态环境需要运行。</p><a id="more"></a><hr><p>语法（Syntax）是关于如何写出可解析程序的规则。ML 中的语义（Semantics）包括类型检查和执行两部分。每种不同的语句和表达式都有自己的语法和语义，语义一般包括类型检查语义和执行语义。对于 variable binding 而言，语义是</p><ul><li>检查类型，扩展静态环境；</li><li>运行，扩展动态环境。</li></ul><h2 id="Rules-for-Expressions"><a href="#Rules-for-Expressions" class="headerlink" title="Rules for Expressions"></a>Rules for Expressions</h2><h3 id="表达式与语句的三个要素"><a href="#表达式与语句的三个要素" class="headerlink" title="表达式与语句的三个要素"></a>表达式与语句的三个要素</h3><p>对于 ML 中的每个表达式、语句，下面这三个问题很重要：</p><ul><li><strong>Syntax</strong>：它的语法是什么？</li><li><strong>Type-Check Semantics</strong>：它如何执行类型检查？类型检查不一定是 <strong>检查</strong>，也包括求得表达式的“输出”类型。</li><li><strong>Evaluation Semantics</strong>：它如何执行、求值？</li></ul><p>ML 中，只有经过了 Type-Check 才能进行 Evaluation。</p><h3 id="一些表达式的例子"><a href="#一些表达式的例子" class="headerlink" title="一些表达式的例子"></a>一些表达式的例子</h3><p>表达式可以相互嵌套。套用上面的三个问题可以研究一些表达式。以下是一些例子。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量是很简单的表达式。</p><ul><li>Syntax：字母、数字、下划线组成。不以数字开头。</li><li>Type-Check Semantics：检查静态环境中是否存在该变量，若存在则类型已知，否则报错。（因为是将变量作为表达式在使用，所以若正确必然存在。）</li><li>Evaluation Semantics：从动态环境中取出值。</li></ul><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><ul><li>Syntax：$\texttt{if }e_1\texttt{ then }e_2\texttt{ else }e_3​$，其中 $e_1,e_2,e_3​$ 是表达式。</li><li>Type-Check Semantics：$e_1​$ 必须是 <code>bool</code>，$e_2​$ 和 $e_3​$ 和最后的返回值类型必须一致。</li><li>Evaluation Semantics：先计算 $e_1​$，若为真返回计算 $e_2​$ 的结果，否则返回计算 $e_3​$ 的结果。</li></ul><h3 id="unit-类型"><a href="#unit-类型" class="headerlink" title="unit 类型"></a><code>unit</code> 类型</h3><p>ML 中有一个特殊的 <code>unit</code> 类型，唯一的取值是 <code>()</code>，例如在加载一个文件的时候返回值就是这个。</p><h2 id="The-REPL-and-Errors"><a href="#The-REPL-and-Errors" class="headerlink" title="The REPL and Errors"></a>The REPL and Errors</h2><h3 id="REPL"><a href="#REPL" class="headerlink" title="REPL"></a>REPL</h3><p>REPL 的意思是 Read-Eval-Print-Loop，这是一种对语言的解释器。</p><h3 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h3><p>之前提到的三个要素中，每个地方都可能出错。对应不同种类的错误：</p><ul><li><strong>Syntax</strong>：语法错误会导致无法通过语法解析。</li><li><strong>Type-Check Semantics</strong>：类型检查错误会导致无法通过类型检查，故无法通过编译，但是可以完成语法解析。</li><li><strong>Evaluation Semantics</strong>：执行错误会导致运行时抛出异常，但是这种程序可以通过编译。</li><li><strong>逻辑错误</strong>：即使通过编译且运行正确，程序也不一定是对的。</li></ul><h2 id="Shadowing"><a href="#Shadowing" class="headerlink" title="Shadowing"></a>Shadowing</h2><p>Shadowing 指的是后面的变量绑定会覆盖掉前面的。ML 中没有赋值的说法，如果先 <code>val a = 10</code> 然后 <code>val a = 20</code>，实际上是存在两个变量的，但是第一个被覆盖掉了无法访问，而不是重新被赋值。</p><p>如果希望同一个名称访问出的变量是不同的变量需要用到这个特性。</p><h2 id="Functions-Informally"><a href="#Functions-Informally" class="headerlink" title="Functions Informally"></a>Functions Informally</h2><p>定义函数与使用：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> pow(x: <span class="built_in">int</span>, y: <span class="built_in">int</span>) = <span class="keyword">if</span> y = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> x * pow(x, y - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">fun</span> cube(x: <span class="built_in">int</span>) = pow(x, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> a = pow(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>函数体就是一个表达式。参数需要注明类型，但是返回值不需要。</p><p><code>pow</code> 使用了递归。所有需要用到循环的地方都可以使用递归加以解决。</p><h2 id="Functions-Formally"><a href="#Functions-Formally" class="headerlink" title="Functions Formally"></a>Functions Formally</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>Syntax：<code>fun x0(x1: t1, x2: t2, ... , xn: tn) = e</code>。</p><p>Type-check semantics：对于函数 <code>fun x0(x1: t1, x2: t2, ... , xn: tn) = e</code>，首先将 <code>x1</code> 设为 <code>t1</code> …… <code>xn</code> 设为 <code>tn</code> 以及 <code>x0</code> 设为 <code>t1 * t2 * ... * tn -&gt; t</code>，代入 $e​$ 检查是否相容。之所以也要将 <code>x0</code> 代入是因为可能发生递归调用。其中 <code>t</code> 将会由类型推断得到。检查完成后，<code>x0</code> 会被加入静态环境中。</p><p>Evaluation semantics：对于每个函数，完成声明后相当于一个值 <code>x0</code>，这个值对应的表达式还没有计算。当有其它表达式调用它的时候从动态环境中找到 <code>x0</code> 完成计算。</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>Syntax：<code>e0(e1, e2, ... , en)</code>。</p><p><em>一个语法糖是，当只有一个参数的时候可以不加括号。其它时候都要加。</em></p><p>Type-check semantics：检查 <code>e0</code> 的类型是 <code>t1 * t2 * ... * tn -&gt; t</code>，<code>e1</code> 到 <code>en</code> 的类型分别是 <code>t1</code> 到 <code>tn</code>。整个调用语句的返回类型是 <code>t</code>。</p><p>Evaluation semantics：在发生调用的时候有一个 <strong>当前的</strong> 环境，在当前环境中计算出 <code>e1</code> 到 <code>en</code>，将结果记为 <code>v1</code> 到 <code>vn</code>。由于经过了类型检查，<code>e0</code> 必然是函数，此时从 <strong>函数被定义时的环境</strong> 中扩展出一个新的环境，添加的内容为将 <code>x1</code> 到 <code>xn</code> 映射为 <code>v1</code> 到 <code>vn</code>，完成计算，然后返回 <strong>当前的环境</strong>。扩展环境这一步不能从当前环境扩展，而要从函数被定义时的环境进行扩展。至于这是为什么，以下是我的一些猜测：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">fun</span> get_x<span class="literal">()</span> = x</span><br><span class="line"><span class="keyword">val</span> x1 = get_x<span class="literal">()</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> x2 = get_x<span class="literal">()</span></span><br></pre></td></tr></table></figure><p>如果从当前环境进行扩展，<code>x2</code> 的值将会是 2，这是很让人困惑的。</p><h2 id="Pairs-and-Other-Tuples"><a href="#Pairs-and-Other-Tuples" class="headerlink" title="Pairs and Other Tuples"></a>Pairs and Other Tuples</h2><p>Tuple 即为元组。二元组为 Pair。以下讨论仅针对 Pair。</p><p>Syntax：<code>(e1, e2)</code>。</p><p>Type-check semantics：若 <code>e1</code> 类型为 <code>t1</code>，<code>e2</code> 类型为 <code>t2</code>，则 <code>(e1, e2)</code> 类型为 <code>t1 * t2</code>。</p><p>Evaluation semantics：若 <code>e1</code> 值为 <code>v1</code>，<code>e2</code> 值为 <code>v2</code>，则 <code>(e1, e2)</code> 值为 <code>(v1, v2)</code>，这个结果本身也是一种值。</p><p>如果想要从 Tuple 中取出某个分量可以这样做：<code>#2 (3, 4)</code> 将会取出第二个分量也就是 <code>4</code>，从 1 开始计数。</p><p>例如可以写出交换两个分量的函数：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> swap_1(pr: <span class="built_in">int</span> * <span class="built_in">bool</span>) = (#<span class="number">2</span> pr, #<span class="number">1</span> pr)</span><br><span class="line"><span class="keyword">fun</span> swap_2(i: <span class="built_in">int</span>, b: <span class="built_in">bool</span>) = (b, i)</span><br><span class="line"><span class="keyword">val</span> res_1 = swap_1((<span class="number">3</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="keyword">val</span> res_2 = swap_1(<span class="number">3</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> res_3 = swap_2((<span class="number">3</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="keyword">val</span> res_4 = swap_2(<span class="number">3</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><code>res_1</code> 和 <code>res_4</code> 是容易理解的。<code>res_2</code> 可以看作是省略了括号的调用，<code>res_3</code> 则完全不清楚为何可行。这四种调用方式看起来居然是一样的，后面会解释。</p><p>Tuple 可以有任意多的元素（编译时），并且可以进行嵌套。</p><h2 id="Introducing-Lists"><a href="#Introducing-Lists" class="headerlink" title="Introducing Lists"></a>Introducing Lists</h2><p>列表包含任意多同类型元素（运行时）。</p><p>使用 <code>::</code> 可以 append 元素：<code>3 :: [4, 5]</code> 的结果是 <code>[3, 4, 5]</code>。</p><p>使用 <code>null</code> 对列表进行判空，使用 <code>hd</code> 和 <code>tl</code> 取出列表的头和尾。</p><p>列表的类型和元素有关。如果元素是 <code>int</code>，列表的类型将会是 <code>int list</code>。空列表的类型是 <code>&#39;a list</code>，其中 <code>&#39;a</code> 是 $\alpha$。这个是某种通配的类型，例如 <code>null</code> 的类型就是 <code>&#39;a list -&gt; bool</code>，它可以接受任何类型的列表。</p><h2 id="List-Functions"><a href="#List-Functions" class="headerlink" title="List Functions"></a>List Functions</h2><p>列表可以作为函数的参数或者返回值。在这些情况下，如果函数需要访问或生成列表中的每个元素，唯一的办法就是使用递归。</p><h2 id="Let-Expressions"><a href="#Let-Expressions" class="headerlink" title="Let Expressions"></a>Let Expressions</h2><p>使用 <code>let</code> 表达式可以在一个表达式中引入新的 scope，这个 scope 中可以进行仅对表达式可见的绑定，除非被更小的 scope 覆盖掉。这个表达式的三个要素略去。</p><p>例如 <code>let val x = 3 in x * 2 end</code> 的值是 6（不要掉了 <code>let</code> 中的 <code>val</code>）。</p><h2 id="Nested-Functions"><a href="#Nested-Functions" class="headerlink" title="Nested Functions"></a>Nested Functions</h2><p><code>let</code> 表达式中可以存在任意的绑定，函数定义是一种绑定，所以结合起来就可以在函数 $f$ 中定义只对 $f$ 可见的函数。内层的函数依然可以访问外部的一些信息，例如 $f$ 的参数等。</p><h2 id="Let-and-Efficiency"><a href="#Let-and-Efficiency" class="headerlink" title="Let and Efficiency"></a>Let and Efficiency</h2><p>使用 <code>let</code> 表达式可以将某些需要递归计算的结果缓存下来，达到加速的目的。考虑下面两种求列表最大值的写法：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> range(left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, step: <span class="built_in">int</span>) = </span><br><span class="line">    <span class="keyword">if</span> left = right <span class="keyword">then</span> <span class="literal">[]</span> <span class="keyword">else</span> left :: range(left + step, right, step)</span><br><span class="line"></span><br><span class="line"><span class="keyword">fun</span> slow_max(xs: <span class="built_in">int</span> <span class="built_in">list</span>) = </span><br><span class="line">    <span class="keyword">if</span> null xs <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> null (tl xs) <span class="keyword">then</span> hd xs <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> hd xs &gt; slow_max(tl xs) <span class="keyword">then</span> hd xs <span class="keyword">else</span> slow_max(tl xs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">fun</span> fast_max(xs: <span class="built_in">int</span> <span class="built_in">list</span>) = </span><br><span class="line">    <span class="keyword">if</span> null xs <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> null (tl xs) <span class="keyword">then</span> hd xs <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">val</span> mtl = fast_max(tl xs) <span class="keyword">in</span> <span class="keyword">if</span> hd xs &gt; mtl <span class="keyword">then</span> hd xs <span class="keyword">else</span> mtl <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">(* for testing *)</span></span><br><span class="line">slow_max(range(<span class="number">0</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line">fast_max(range(<span class="number">0</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>第二种情况会快上很多。实际上第一种情况是指数级别的复杂度。</p><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>Options 允许一个值为空。</p><p>比如可空的 <code>int</code> 具有类型 <code>int option</code>。通过 <code>NONE</code> 构造空值（类型为 <code>&#39;a option</code>），通过 <code>SOME i</code> 构造一个具有值的 <code>int option</code>。使用 <code>isSome</code> 判断是否为空，使用 <code>valOf</code> 取出非空 Options 的值。</p><h2 id="Booleans-and-Comparison-Operations"><a href="#Booleans-and-Comparison-Operations" class="headerlink" title="Booleans and Comparison Operations"></a>Booleans and Comparison Operations</h2><h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p>使用 <code>andalso</code> 计算布尔值的且，使用 <code>orelse</code> 计算布尔值的或，使用 <code>not</code> 计算布尔值的非。且和或具有短路特性，因此 <code>andalso</code> 和 <code>orelse</code> 不是函数；<code>not</code> 是一个函数。</p><p>值得一提的是，所有能够将 <code>if ... then ... else</code> 作为语句的语言都不需要且、或、非这三个运算，它们的短路特性可以被那个表达式模拟出来。</p><h3 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h3><p>使用 <code>=</code>，<code>&lt;&gt;</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code> 对整数进行比较。浮点数不能使用等号或者不等号进行比较，这么做是语言强制保证数值正确性。</p><h2 id="Benefits-of-No-Mutation"><a href="#Benefits-of-No-Mutation" class="headerlink" title="Benefits of No Mutation"></a>Benefits of No Mutation</h2><p>ML 中的值都是不可变的。这么做的一个好处是，使用代码的人无法修改。如果可以修改就会出现需要区分两个变量到底是同一个引用还是具有相同值的不同引用的问题。因为现在无法修改，所以不管它们是同一个引用还是不同引用都无所谓了。</p><p>例如连接两个列表，如果使用某种快速的实现将 <code>x</code> 和 <code>y</code> 连接起来得到 <code>z</code>，假如可以修改，用户在使用 <code>z</code> 时就必须弄清楚这个修改是否会影响到 <code>x</code> 和 <code>y</code>。但是如果无法修改，用户就不会考虑这个问题。</p><h2 id="Java-Mutation"><a href="#Java-Mutation" class="headerlink" title="Java Mutation"></a>Java Mutation</h2><p><em>本节没有问题。</em></p><h2 id="Pieces-of-a-Language"><a href="#Pieces-of-a-Language" class="headerlink" title="Pieces of a Language"></a>Pieces of a Language</h2><p>对语言的学习可以分成五个部分：</p><ul><li>Syntax：语言的语法。</li><li>Semantics：语言的语义。</li><li>Idioms：一些惯用的模式和习惯。</li><li>Libraries：常用的库和包。</li><li>Tools：常用的工具，例如解释器、调试器、代码格式化工具等。</li></ul><p>作者建议学习语言的时候要把这五个部分在概念上分开，不要搅在一起学习。</p><p>作者的观点：其中 Syntax 只是一些 facts，比较无趣。Library 和 Tools 都是在要用的时候才用去学的。因此最重要的是 Semantics 和 Idiom，它们是掌握语言共性的途径。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> 编程语言理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Programming Languages (Part A) 笔记 1 Introduction</title>
      <link href="/2019/02/06/Programming-Languages-Part-A-%E7%AC%94%E8%AE%B0-1-Introduction/"/>
      <url>/2019/02/06/Programming-Languages-Part-A-%E7%AC%94%E8%AE%B0-1-Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>感谢 <a href="https://www.coursera.org/learn/programming-languages" target="_blank" rel="noopener">Coursera</a>。</p><blockquote><p>This is a challenging course that we hope will change the way you look at programming forever.</p></blockquote><h2 id="Welcome-Information"><a href="#Welcome-Information" class="headerlink" title="Welcome Information"></a>Welcome Information</h2><h3 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h3><p><em>本节没有问题。</em></p><h3 id="What-the-Course-is-About-Initial-Motivation"><a href="#What-the-Course-is-About-Initial-Motivation" class="headerlink" title="What the Course is About / Initial Motivation"></a>What the Course is About / Initial Motivation</h3><p>这门课主要是通过 Standard ML、Racket 和 Ruby 展示各种编程语言中的基本概念以及它们如何相互关联，并非学习这三门语言。</p><a id="more"></a><h3 id="Recommended-Background"><a href="#Recommended-Background" class="headerlink" title="Recommended Background"></a>Recommended Background</h3><p><em>本节没有问题。</em></p><hr><p>其它小节都没有问题。</p><h2 id="Software-Installation"><a href="#Software-Installation" class="headerlink" title="Software Installation"></a>Software Installation</h2><p>要安装的软件有 SML/NJ 和 Emacs（可选），在 Arch 下执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S smlnj</span><br></pre></td></tr></table></figure><p>可以安装 SML/NJ，使用 <code>smlnj</code> 命令启动。这样打开的解释器里面方向键无法使用，让人不爽，使用 socat 配合来启用方向键：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat READLINE EXEC:smlnj</span><br></pre></td></tr></table></figure><p>我不打算用 Emacs，用 VS Code 的话有个叫 Standard ML 的扩展（看下载量就感觉是个很小众的语言）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> 编程语言理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Networks and Deep Learning 笔记 4 Deep Neural Networks</title>
      <link href="/2019/02/01/Neural-Networks-and-Deep-Learning-%E7%AC%94%E8%AE%B0-4-Deep-Neural-Networks/"/>
      <url>/2019/02/01/Neural-Networks-and-Deep-Learning-%E7%AC%94%E8%AE%B0-4-Deep-Neural-Networks/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Neural-Networks"><a href="#Deep-Neural-Networks" class="headerlink" title="Deep Neural Networks"></a>Deep Neural Networks</h1><h2 id="Deep-Neural-Networks-1"><a href="#Deep-Neural-Networks-1" class="headerlink" title="Deep Neural Networks"></a>Deep Neural Networks</h2><h3 id="Deep-L-layer-neural-network"><a href="#Deep-L-layer-neural-network" class="headerlink" title="Deep L-layer neural network"></a>Deep L-layer neural network</h3><p>将网络层数加深，具有 $L$ 层的神经网络称为 L-layer 神经网络。输入层是第 0 层，但是计算层数的时候不计入总层数。一些记号如下（和之前的大致相同）：</p><ul><li>$n^{[k]}$ 是第 $k$ 层的神经元数目，故 $n^{[0]}$ 即样本的特征维数，对于二分类问题 $n^{[l]} = 1$。</li><li>$z^{[k]}$ 是第 $k$ 层神经元输出的未经过激活函数的值，多样本时为 $Z^{[k]}$。</li><li>$a^{[k]}$ 是第 $k$ 层神经元输出的经过激活函数的值，特别地 $a^{[0]}$ 是样本的特征，二分类问题中 $a^{[l]}$ 是 $\hat y$，多样本时为 $A^{[k]}$。</li><li>$g^{[k]}(x)$ 是第 $k$ 层的激活函数。</li><li>$W^{[k]}$ 是第 $k$ 层的权值，$b^{[k]}$ 是第 $k$ 层的偏移。</li></ul><h3 id="Forward-Propagation-in-a-Deep-Network"><a href="#Forward-Propagation-in-a-Deep-Network" class="headerlink" title="Forward Propagation in a Deep Network"></a>Forward Propagation in a Deep Network</h3><p>这节讲的东西和之前将正向传播几乎一致，没有什么好记录的。</p><p>不同层之间的计算无法完成并行化，如果一个网络层数很深也只能一层一层地算。</p><a id="more"></a><h3 id="Getting-your-matrix-dimensions-right"><a href="#Getting-your-matrix-dimensions-right" class="headerlink" title="Getting your matrix dimensions right"></a>Getting your matrix dimensions right</h3><ul><li>$W^{[k]}$ 的规模必然是 $n^{[k]}\times n^{[k - 1]}$。</li><li>$b^{[k]}$ 的规模必然是 $n^{[k]}\times 1$。</li><li>单样本时，$\vec z^{[k]}$ 和 $\vec a^{[k]}$ 规模为 $n^{[k]}\times 1$。</li><li>多样本时，$Z^{[k]}$ 和 $A^{[k]}$ 规模为 $n^{[k]}\times m$。</li><li>对于所有上述变量，$J$ 对它们的导数的规模都为它们自己的规模。</li></ul><h3 id="Why-deep-representations"><a href="#Why-deep-representations" class="headerlink" title="Why deep representations?"></a>Why deep representations?</h3><p>为什么要采用这么深的网络？</p><p>一个原因是随着层数的增加，网络可以识别越来越高层、抽象的特征，例如在识别音频的网络中，最开始的隐藏层可能识别的是音调的变化，随后开始识别是哪一个音，然后接下来的一层识别是哪个单词，再下来的一层识别是什么句子。</p><p>另一个原因是，有些数学函数可以用较深的但是每层的神经元较少的网络轻易实现，例如对很多个元素取异或，但是如果一定要用单隐层的网络实现的话会导致需要的神经元数目随这特征维数成指数上升（使用较深的神经网络时可能只是线性的）。</p><h3 id="Building-blocks-of-deep-neural-networks"><a href="#Building-blocks-of-deep-neural-networks" class="headerlink" title="Building blocks of deep neural networks"></a>Building blocks of deep neural networks</h3><p>神经网络的每一层都可以看作是一个构建神经网络的单元，对于较深的网络，这些单元在空间上呈现一种排列。由于层数较深，可能希望每层自己负责更新自己的参数，只知道它邻居的情况而不知道整体情况。这是可以做到的。对于 $l$ 层的每个单元，它将要完成这么一些操作：</p><ul><li><strong>正向传播过程中</strong>，上一层给定 $A^{[l - 1]}$，求出 $Z^{[l]}$ 进行缓存，求出 $A^{[l]}$ 并将 $A^{[l]}$ 传给下一层；</li><li><strong>反向传播过程中</strong>，下一层给定 $\displaystyle{\frac{\partial J}{\partial A^{[l]}}}$，计算 $\displaystyle{\frac{\partial J}{\partial A^{[l - 1]}}}$ 并传给上一层，计算 $J$ 对各参数的导数并更新相关参数。</li></ul><p>假定在计算过程中 $W^{[l]}$ 和 $b^{[l]}$ 都是可以访问到的。通过这样的功能隔离，只要注重于一层神经元是如何工作的即可搞清楚深度神经网络如何工作。</p><h3 id="Forward-and-Backward-Propagation"><a href="#Forward-and-Backward-Propagation" class="headerlink" title="Forward and Backward Propagation"></a>Forward and Backward Propagation</h3><p>此节是上一节的实现。正向传播没有好记录的，很显然。对于反向传播，计算公式如下：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial J}{\partial Z^{[l]}} &= \frac{\partial J}{\partial A^{[l]}}\odot {g^{[l]}}'(Z^{[l]}) \\\frac{\partial J}{\partial W^{[l]}} &= \frac{1}{m}\frac{\partial J}{\partial Z^{[l]}}(A^{[l - 1]})^T \\\frac{\partial J}{\partial b^{[l]}} &= \frac{1}{m}\texttt{np.sum(}\frac{\partial J}{\partial Z^{[l]}}\texttt{, axis=1, keepdims=True)} \\\frac{\partial J}{\partial A^{[l - 1]}} &= {W^{[l]}}^T \frac{\partial J}{\partial Z^{[l]}}\end{aligned}</script><p>可见对前向传播中的一些量的缓存是必要的。</p><p>计算出 $J$ 对 $W^{[l]}$ 和 $b^{[l]}$ 的导数后即可对参数进行更新。</p><h3 id="Parameters-vs-Hyperparameters"><a href="#Parameters-vs-Hyperparameters" class="headerlink" title="Parameters vs Hyperparameters"></a>Parameters vs Hyperparameters</h3><p>参数是神经网络可以学习到的变量，比如每层的权值和偏置。</p><p>超参数是需要人类给定的量，例如学习率、神经网络的层数、迭代次数、激活函数的选择等等。</p><p>在目前，超参数的选择本质是靠尝试和猜测，不过有一些稍微系统的尝试方法。对于不同的问题，最优的超参数可能不同；对于同样的问题，随着时间的推移，最优的超参数也可能发生变化。</p><h3 id="What-does-this-have-to-do-with-the-brain"><a href="#What-does-this-have-to-do-with-the-brain" class="headerlink" title="What does this have to do with the brain?"></a>What does this have to do with the brain?</h3><p>深度学习和人的大脑的相似性其实没多大，都是 <del>无良</del> 媒体的炒作。</p><p>主要的相似性在于：</p><ul><li>神经网络中单个神经元的工作模式和大脑中单个神经元的工作模式看上去类似；</li><li>单个神经元的工作成果无法解释，但是整个系统确实有效。</li></ul><hr><p>完。目前讲的好像都会，这个系列还有 4 个 course，希望能学到新的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Networks and Deep Learning 笔记 3 Shallow Neural Networks</title>
      <link href="/2019/02/01/Neural-Networks-and-Deep-Learning-%E7%AC%94%E8%AE%B0-3-Shallow-Neural-Networks/"/>
      <url>/2019/02/01/Neural-Networks-and-Deep-Learning-%E7%AC%94%E8%AE%B0-3-Shallow-Neural-Networks/</url>
      
        <content type="html"><![CDATA[<h1 id="Shallow-Neural-Networks"><a href="#Shallow-Neural-Networks" class="headerlink" title="Shallow Neural Networks"></a>Shallow Neural Networks</h1><h2 id="Shallow-Neural-Networks-1"><a href="#Shallow-Neural-Networks-1" class="headerlink" title="Shallow Neural Networks"></a>Shallow Neural Networks</h2><h3 id="Neural-Networks-Overview"><a href="#Neural-Networks-Overview" class="headerlink" title="Neural Networks Overview"></a>Neural Networks Overview</h3><p>在逻辑回归中，有 $z = \vec w^T \vec x + b$ 以及 $\hat y = a = \sigma(z)$（我猜 $a$ 表示 activation）。如果将得到的 $a$ 作为新的输入再进行类似的计算就可以得到更复杂的结果。如果在 $z = \vec w^T\vec x + b$ 中有多个 $\vec w$ 以及 $b$ 就可以得到一个向量作为输出，此时可以表示为 $\vec z = W\vec x + \vec b$。如果希望得到 $k$ 维的输出，只要 $W$ 的规模是 $k\times n$，$\vec b$ 的规模是 $k\times 1$ 即可。</p><p>在有多层的情况下实际上和全连接的神经网络比较类似了，记号上将第 $i​$ 层的参数用中括号括起来放在上标上，例如第一层的情况下就是：</p><script type="math/tex; mode=display">\begin{aligned}\vec z^{[1]} &= W^{[1]}x + \vec b^{[1]} \\\vec a^{[1]} &= \sigma(\vec z^{[1]})\end{aligned}</script><p>（使用中括号是为了和表达第 $i$ 个样本的时候使用圆括号区别。）</p><a id="more"></a><h3 id="Neural-Network-Representation"><a href="#Neural-Network-Representation" class="headerlink" title="Neural Network Representation"></a>Neural Network Representation</h3><p>关于神经网络如何数层数，对于一个要计算两次激活函数的神经网络，它有两层。输入、<strong>隐藏层</strong>、<strong>输出层</strong>。尽管输入可以看成是一个层但是一般不这么做。在这个两层的神经网络中，输入 $\vec x$ 可以看作是 $\vec a^{[0]}$。如果输出层只有一个神经元，则有：</p><script type="math/tex; mode=display">\begin{aligned}\vec z^{[1]} &= W^{[1]}\vec a ^{[0]} + \vec b^{[1]} \\\vec a^{[1]} &= \sigma(\vec z^{[1]}) \\z^{[2]} &= W^{[2]}\vec a ^{[1]} + \vec b^{[2]} \\a^{[2]} &= \sigma(z^{[2]}) \\\hat y&= a^{[2]}\end{aligned}</script><p>每层的变量的规模都容易确定。例如如果隐藏层有 $k$ 个神经元，$\vec z^{[1]}$ 的规模就是 $k\times 1$。</p><p>这种只有一个隐藏层的网络叫做 <strong>单隐层神经网络</strong>。</p><h3 id="Computing-a-Neural-Network-39-s-Output"><a href="#Computing-a-Neural-Network-39-s-Output" class="headerlink" title="Computing a Neural Network&#39;s Output"></a>Computing a Neural Network&#39;s Output</h3><p>还是上面的单隐层神经网络，这节主要是考虑如何计算这个网络。对于隐层中的每个神经元，它自己都做了一个类似逻辑回归的事情。每个神经元有自己独立的一个 $\vec w$ 和 $b$。在单个样本的情况下，对于第一个神经元，其参数为 $W^{[1]}_1$ 和 $\vec b^{[1]}_1$，中间结果为 $\vec z^{[1]}_1= W^{[1]}_1 \vec x + \vec b_1^{[1]}$ 是一个标量，施加 sigmoid 函数后得到输出，符号中的下标是表示第几个神经元。每个隐层神经元都做这样的事情，如果有 $k$ 个隐层神经元，会得到 $k$ 个标量输出，即一个 $k$ 维向量输出。</p><p>如果输出层神经元只有一个，这就相当于对一个有 $k$ 维特征的样本做逻辑回归。</p><p>可以将上面的过程写成矩阵的形式，这样便实现了向量化。注意样本是按照列进行堆叠的。</p><h3 id="Vectorizing-across-multiple-examples"><a href="#Vectorizing-across-multiple-examples" class="headerlink" title="Vectorizing across multiple examples"></a>Vectorizing across multiple examples</h3><p>上一节是单个样本的情况，在多个样本的情况下需要进行向量化。</p><p>得益于每个样本是按照列进行堆叠的约定，在对多样本进行向量化的时候只要将 $\vec x$ 直接替换为 $X$ 即可。对于每层的相关变量，只要把它从向量变成矩阵即可完成向量化。单隐层神经网络变成：</p><script type="math/tex; mode=display">\begin{aligned}A^{[0]} &= X \\Z^{[1]} &= W^{[1]}A^{[0]} + \vec b^{[1]} \\A^{[1]} &= \sigma(Z^{[1]}) \\Z^{[2]} &= W^{[2]}A^{[1]} + \vec b^{[2]} \\A^{[2]} &= \sigma(Z^{[2]}) \\\end{aligned}</script><p>对于 $A$ 矩阵而言，它的规模是 $k\times m$ 的，其中 $k$ 是自己所在的这一层的神经元数目，$m$ 是样本数目。$A_{ij}$ 表示的是第 $j$ 个样本在第 $i$ 个神经元下的输出。$Z$ 矩阵可以作类似的看待。</p><p>在记号上，第 $p$ 层的第 $q$ 个神经元在第 $r$ 个样本下的输出写作 $a^{<a href="r">p</a>}_q$。</p><h3 id="Explanation-for-Vectorized-Implementation"><a href="#Explanation-for-Vectorized-Implementation" class="headerlink" title="Explanation for Vectorized Implementation"></a>Explanation for Vectorized Implementation</h3><p>这节是在这名上述向量化的正确性，没有值得记录的。</p><h3 id="Activation-functions"><a href="#Activation-functions" class="headerlink" title="Activation functions"></a>Activation functions</h3><p>有不同的激活函数可供选择：</p><ul><li><strong>sigmoid</strong>：$\displaystyle{\sigma(x) = \frac{1}{1 + e^{-x}}}$</li><li><strong>hyperbolic tangent</strong>：$\displaystyle{\tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}}}$</li><li><strong>rectified linear unit</strong>：$\displaystyle{\text{ReLU}(x) = \max(x, 0)}$</li><li><strong>leaky ReLU</strong>：$\displaystyle{\text{LeakyReLU}(x) = \max(x, \alpha x)}$，其中 $\alpha$ 一般取 0.001</li></ul><p>tanh 就是 sigmoid 的平移和拉伸，值介于 -1 到 1 之间。一般来说，tanh 的性能明显强于 sigmoid，如果不是对值域有要求推荐无脑 tanh。使用 ReLU 可以显著增加运算速度，使用 leaky ReLU 的效果会比单纯的 ReLU 更好。tanh 和 sigmoid 在值较大的时候会出现导数接近零导致学习缓慢的情况，但是使用 ReLU 系列不会有这个问题。</p><h3 id="Why-do-you-need-non-linear-activation-functions"><a href="#Why-do-you-need-non-linear-activation-functions" class="headerlink" title="Why do you need non-linear activation functions?"></a>Why do you need non-linear activation functions?</h3><p>激活函数一般不使用线性函数。如果单纯使用线性函数会导致该层的网络和下一层网络在实际上只是一次线性变换，此时二者相当于只起了一层网络的作用。在单隐层神经网络的例子中，如果隐藏层使用线性激活函数会导致整个模型实际上就是一个朴素的逻辑回归模型。</p><p>在很罕见的情况下会使用到线性激活函数，此时一般是在整个网络的最后一层，并且要求输出的值域是整个实数域。</p><h3 id="Derivatives-of-activation-functions"><a href="#Derivatives-of-activation-functions" class="headerlink" title="Derivatives of activation functions"></a>Derivatives of activation functions</h3><ul><li><p>对于 sigmoid 函数，其导数为 $\sigma&#39;(x) = \sigma(x)(1 - \sigma(x))$。</p></li><li><p>对于 tanh 函数，其导数为 $\tanh&#39;(x) = 1 - \tanh^2(x)$。</p></li><li><p>对于 ReLU 函数，导数在自变量大于零时为 1，小于零时为 0，等于零时无定义。由于自变量等于零的概率为 0，可以将导数设置为一个值，0 或者 1 任意。</p></li><li><p>对于 Leaky ReLU 函数，导数在自变量大于零时为 1，小于零时为 $\alpha$，等于零时与 ReLU 类似处理。</p></li></ul><h3 id="Gradient-descent-for-Neural-Networks"><a href="#Gradient-descent-for-Neural-Networks" class="headerlink" title="Gradient descent for Neural Networks"></a>Gradient descent for Neural Networks</h3><p>这一节讲的是对神经网络的梯度下降。在单隐层的神经网络中，需要优化的有四个变量：$W^{[1]}, \vec b^{[1]}, W^{[2]}, \vec b^{[2]}$，代价函数是 $J(W^{[1]}, \vec b^{[1]}, W^{[2]}, \vec b^{[2]})$。</p><p>用 $n^{[0]}$ 表示输入层的每个样本的特征数，$n^{[1]}$ 表示隐藏层每个样本的中间特征的维度，$n^{[2]}$ 表示输出层的每个样本的维度，对于二分类任务，$n^{[2]} = 1$。此时四个变量的规模可以用这些来表示。</p><p>只要求得 $\displaystyle{\frac{\partial J}{\partial W^{[1]}}, \frac{\partial J}{\partial \vec b^{[1]}}, \frac{\partial J}{\partial W^{[2]}}, \frac{\partial J}{\partial \vec b^{[2]}}}$ 即可使用梯度下降的方式得到各个变量的最优值。</p><p>需要注意各变量应该随机初始化。</p><h3 id="Backpropagation-intuition"><a href="#Backpropagation-intuition" class="headerlink" title="Backpropagation intuition"></a>Backpropagation intuition</h3><p>这一节对各个导数做了推导。首先考虑单个样本的情况，然后考虑多个样本的情况。这里省去推导直接写出最后结论（我之前好像推过）：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial J}{\partial Z^{[2]}} &= A^{[2]} - Y \\\frac{\partial J}{\partial W^{[2]}} &= \frac{1}{m}\frac{\partial J}{\partial Z^{[2]}}(A^{[1]})^T = \frac{1}{m}(A^{[2]} - Y)(A^{[1]})^T \\\frac{\partial J}{\partial \vec b^{[2]}} &= \frac{1}{m}\texttt{np.sum(}\frac{\partial J}{\partial Z^{[2]}} \texttt{, axis=1, keepdims=True)} \\\frac{\partial J}{\partial Z^{[1]}} &= (W^{[2]})^T\frac{\partial J}{\partial Z^{[2]}}\odot {g^{[1]}}'(Z^{[1]}) \\\frac{\partial J}{\partial W^{[1]}} &= \frac{1}{m}\frac{\partial J}{\partial Z^{[1]}}X^T \\\frac{\partial J}{\partial \vec b^{[1]}} &= \frac{1}{m}\texttt{np.sum(}\frac{\partial J}{\partial Z^{[1]}} \texttt{, axis=1, keepdims=True)}\end{aligned}</script><p>其中 $g^{[i]}(x)$ 是第 $i$ 层的激活函数。</p><h3 id="Random-Initialization"><a href="#Random-Initialization" class="headerlink" title="Random Initialization"></a>Random Initialization</h3><p>在神经网络的初始化中，全部初始化为 0 是不行的。这样做会导致同一层中的所有神经元平权，因此不论经过多少论迭代，这些神经元计算的内容都是一样的，但是我们希望的是每个神经元不平权，这样才能提取出不同的特征。</p><p>在初始化时对于浅层的神经网络可以将权值初始化为一个较小的值，数量级大概在 $10^{-3} \sim 10^{-2}$ 之间。这么选择是因为其它的值可能在 sigmoid 这种激活函数下进入到导数几乎为 0 的区域导致学习困难。在网络较深的时候这个数量级可能表现不佳。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Networks and Deep Learning 笔记 2 Neural Networks Basics</title>
      <link href="/2019/02/01/Neural-Networks-and-Deep-Learning-%E7%AC%94%E8%AE%B0-2-Neural-Networks-Basics/"/>
      <url>/2019/02/01/Neural-Networks-and-Deep-Learning-%E7%AC%94%E8%AE%B0-2-Neural-Networks-Basics/</url>
      
        <content type="html"><![CDATA[<h1 id="Neural-Networks-Basics"><a href="#Neural-Networks-Basics" class="headerlink" title="Neural Networks Basics"></a>Neural Networks Basics</h1><h2 id="Logistic-Regression-as-a-Neural-Network"><a href="#Logistic-Regression-as-a-Neural-Network" class="headerlink" title="Logistic Regression as a Neural Network"></a>Logistic Regression as a Neural Network</h2><h3 id="Binary-Classification"><a href="#Binary-Classification" class="headerlink" title="Binary Classification"></a>Binary Classification</h3><p>课程中使用的符号：</p><ul><li>$m$ 表示数据集大小，$m_{train}$ 和 $m_{test}$ 分别表示训练集和测试集的大小。</li><li><p>$n$ 表示每个样本的特征向量的维数。</p></li><li><p>$X$ 表示整个训练集，<strong>每一列表示一个样本</strong>，相当于样本按照列进行堆叠，因此 $X$ 的规模是 $n\times m$ 的，据说这样表示更简单。</p></li><li>$Y$ 表示所有的标签，每一列表示一个样本，因此 $Y$ 的规模是 $1 \times m$ 的。</li></ul><h3 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h3><p>对于一个样本特征，逻辑回归用于得到这个样本对应的输出，不过这个输出被限制在了 0 到 1 的范围内，因此可以用来做一些类似二分类的事情。比如现在要对某个特征向量 $\vec x$ 进行二分类，希望得到一个输出 $\hat y$ 表示在当前特征为 $\vec x$ 的情况下真实输出为 1 的概率（二分类时这个输出是离散的，只有 0 和 1 两种情况，但是概率是连续的），可以选择 $\hat y = \vec w^T\vec x + b$ 这个模型（这时是线性回归），但是这样得到的值不一定在 0 到 1 之间，因此可以套上一个 sigmoid 函数 $\displaystyle{\sigma(x) = \frac{1}{1 + e^{-x}}}$，选择模型 $\hat y = \sigma(\vec w^T\vec x + b)$，此时为逻辑回归。</p><a id="more"></a><h3 id="Logistic-Regression-Cost-Function"><a href="#Logistic-Regression-Cost-Function" class="headerlink" title="Logistic Regression Cost Function"></a>Logistic Regression Cost Function</h3><p>为了找到逻辑回归中最好的 $\vec w$ 和 $b$，需要一个度量回归质量好坏的标准。对于单个的样本可以使用 <strong>loss function</strong> 完成这件事，使用 $L(\hat y, y)$ 描述二者之间的相近程度，这个值越小越好。尽管使用 $L(\hat y, y) = \frac{1}{2}(y - \hat y)^2$ 可以进行度量（称为平方误差），但是优化的时候这个定义会导致有多个局部最优解，故逻辑回归中一般不使用这种 loss function。一般选用的是 $L(\hat y, y) = -(y\log \hat y+ (1 - y)\log (1 - \hat y))$，当最小化这个函数的时候 $\hat y$ 会尽可能与 $y$ 相近（考虑到 $y$ 非 0 则 1，而 $\hat y$ 只可能在 0 到 1 之间）。</p><p>上述的度量是针对一个样本的，如果要对多个样本的回归质量进行度量要用到 <strong>cost function</strong>，符号是 $J(\vec w, b)$（注意自变量不是 $\hat y$ 和 $y$ 了）。它实际上就是多个样本的 loss function 的算术平均：</p><script type="math/tex; mode=display">J(\vec w, b) = \frac{1}{m}\sum\limits_{i = 1}^m L(\hat y_i, y_i) = -\frac{1}{m}\sum\limits_{i = 1}^m(y_i\log \hat y_i+ (1 - y_i)\log (1 - \hat y_i))</script><p>逻辑回归就是要找到最好的 $\vec w$ 和 $b$ 以最小化整个样本上的 cost function。</p><p>（中文翻译把 loss function 翻译为损失函数，cost function 翻译为代价函数。）</p><p>逻辑回归可以看成一个小的神经网络。</p><h3 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h3><p>为了最小化代价函数需要用到梯度下降，重复以下过程直到 $\vec w$ 和 $b$ 收敛至结果令人满意：</p><script type="math/tex; mode=display">\begin{aligned}\vec w &:=\vec w - \alpha\frac{\partial J(\vec w, b)}{\partial \vec w} \\b&:=b -\alpha\frac{\partial J(\vec w, b)}{\partial b}\end{aligned}</script><p>其中 $\alpha $ 称作学习率（大于零），它控制每次迭代时更新各参数的步长。可以注意到在很接近最优解的时候偏导可能很小，此时步长变得很小。</p><p>最后一件事是对 $\vec w$ 和 $b$ 选择初始值。在逻辑回归中，因为按照上述定义得到的代价函数只会有一个最优解，所以不管怎么样的初始化都会导致一样的结果，所以全部初始化为 0 就可以了。</p><h3 id="Derivatives"><a href="#Derivatives" class="headerlink" title="Derivatives"></a>Derivatives</h3><p><em>本节没有问题。</em></p><h3 id="More-Derivative-Examples"><a href="#More-Derivative-Examples" class="headerlink" title="More Derivative Examples"></a>More Derivative Examples</h3><p><em>本节没有问题。</em></p><h3 id="Computation-graph"><a href="#Computation-graph" class="headerlink" title="Computation graph"></a>Computation graph</h3><p>一个式子可以被组织成 <strong>计算图</strong> 的形式，计算图是一张有向无环图。它有一些没有前驱的结点，一般是各个变量；还有一个没有后继的结点，一般是输出值。前向计算这张计算图可以得到输出，如果反向的话就可以得到输出关于各个输入变量的导数。对于优化而言能够求得导数是很有用的。</p><h3 id="Derivatives-with-a-Computation-Graph"><a href="#Derivatives-with-a-Computation-Graph" class="headerlink" title="Derivatives with a Computation Graph"></a>Derivatives with a Computation Graph</h3><p>计算图中，最终输出的结果对某个输入变量的导数使用链式法则来求。通过计算图的前驱后继关系逆着往回一级一级地求即可。</p><h3 id="Logistic-Regression-Gradient-Descent"><a href="#Logistic-Regression-Gradient-Descent" class="headerlink" title="Logistic Regression Gradient Descent"></a>Logistic Regression Gradient Descent</h3><p>这节使用计算图对单个数据样本的情形求出损失函数对各系数的导数。</p><p>首先使用计算图进行建模，建立计算图时不一定要分解到最原子的操作，按照逻辑进行分解即可。输入是特征 $\vec x$ 的 $n$ 个分量，$\vec w$ 的 $n$ 个分量以及 $b$ 一共 $2n + 1$ 个结点，然后计算 $z = b + \sum\limits_{i = 1}^n \vec x_i\cdot \vec w_i$，然后计算 $\hat y = \sigma(z)$，然后计算损失函数 $L(\hat y, y) = -(y\log \hat y+ (1 - y)\log (1 - \hat y))$。求导得到</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial z}{\partial b} &= 1, \frac{\partial z}{\partial \vec x_i} = \vec w_i \\\frac{\partial \hat y}{\partial z} &=\frac{e^z}{\left(e^z+1\right)^2} = \hat y(1 - \hat y) \\\frac{\partial L}{\partial \hat y} &= -\frac{y-1}{1-\hat y}-\frac{y}{\hat y} \\\end{aligned}</script><p>乘起来得到</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial L}{\partial b} &= \frac{\partial L}{\partial \hat y}\cdot\frac{\partial\hat y}{\partial z}\cdot\frac{\partial z}{\partial b} \\&= \left(-\frac{y-1}{1-\hat y}-\frac{y}{\hat y}\right)\hat y(1- \hat y) \\&= \hat y - y \\&= \sigma\left(b + \sum\limits_{i = 1}^n \vec x_i\cdot \vec w_i\right) - y \\\frac{\partial L}{\partial \vec w_i} &= \frac{\partial L}{\partial \hat y}\cdot\frac{\partial\hat y}{\partial z}\cdot\frac{\partial z}{\partial \vec w_i} \\&= \left(-\frac{y-1}{1-\hat y}-\frac{y}{\hat y}\right)\hat y(1- \hat y) \vec x_i\\&= (\hat y - y) \vec x_i \\&= \left(\sigma\left(b + \sum\limits_{j = 1}^n \vec x_j\cdot \vec w_j\right) - y\right)\vec x_i \\\end{aligned}</script><p>把 sigmoid 函数的导数写成因变量的函数很有用。</p><h3 id="Gradient-Descent-on-m-Examples"><a href="#Gradient-Descent-on-m-Examples" class="headerlink" title="Gradient Descent on $m$ Examples"></a>Gradient Descent on $m$ Examples</h3><p>前一节是针对一个样本的情形。在有 $m$ 个样本的情况下，要优化的是代价函数 $J(\vec w, b)$，它实际上是各个损失函数的算术平均，所以有</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial J}{\partial L_i} &= \frac{1}{m} \\\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial J}{\partial b} &= \sum\limits_{j = 1}^{m}\left(\frac{\partial J}{\partial L_j}\cdot\frac{\partial L_j}{\partial \hat y_j}\cdot\frac{\partial\hat y_j}{\partial z_j}\cdot\frac{\partial z_j}{\partial b}\right) \\&= \frac{1}{m}\sum\limits_{j = 1}^{m}\left(\left(-\frac{y_j-1}{1-\hat y_j}-\frac{y_j}{\hat y_j}\right)\hat y_j(1- \hat y_j)\right) \\&= \frac{1}{m}\sum\limits_{j = 1}^{m}\left(\hat y_j - y_j\right)\\&= \frac{1}{m}\sum\limits_{j = 1}^{m}\left(\sigma\left(b + \sum\limits_{i = 1}^n \vec x_{ji}\cdot \vec w_i\right) - y_j \right)\\\end{aligned}</script><p>对 $w_i$ 的求导类似。</p><p>在使用代码实现时需要用到多个循环（对特征的一次循环、对样本的一次循环、对梯度下降的一次循环，至少三次），使用 <strong>向量化</strong> 的技术可以减少循环的出现次数，同时提高运行效率。</p><h2 id="Python-and-Vectorization"><a href="#Python-and-Vectorization" class="headerlink" title="Python and Vectorization"></a>Python and Vectorization</h2><h3 id="Vectorization"><a href="#Vectorization" class="headerlink" title="Vectorization"></a>Vectorization</h3><p>两个向量的内积可以使用 <code>numpy</code> 的 <code>dot</code> 函数完成，替代掉更慢的 for 循环。更快的原因是 CPU 会利用一些 SIMD 的特性加速运算。使用 GPU 对这种加速更加显著。</p><h3 id="More-Vectorization-Examples"><a href="#More-Vectorization-Examples" class="headerlink" title="More Vectorization Examples"></a>More Vectorization Examples</h3><p>一个矩阵左乘一个向量可以使用 <code>dot</code> 函数完成。</p><p>如果需要对矩阵/向量中的元素做逐元素的运算，有 <code>np.exp</code>、<code>np.log</code>、<code>np.maximum</code> 等函数可以使用。</p><h3 id="Vectorizing-Logistic-Regression"><a href="#Vectorizing-Logistic-Regression" class="headerlink" title="Vectorizing Logistic Regression"></a>Vectorizing Logistic Regression</h3><p>在逻辑回归的实现中利用向量化可以在不使用任何 for 语句的情况下计算整个数据集数据的输出。</p><p>用 <code>w</code> 表示 $\vec w$，<code>b</code> 表示 $b$，<code>xs</code> 表示整个数据集（规模应为 $n\times m$），那么对输出的中间计算可以直接写成 <code>np.dot(w.T, xs) + b</code>。其中用到了 numpy 中 <strong>广播</strong> 的特性，使得 <code>np.dot(x.T, xs)</code> 和 <code>b</code> 这两个规模不同的量可以相加。随后也可以使用向量化的方法对中间结果逐元素施加 sigmoid 函数。</p><h3 id="Vectorizing-Logistic-Regression-39-s-Gradient-Output"><a href="#Vectorizing-Logistic-Regression-39-s-Gradient-Output" class="headerlink" title="Vectorizing Logistic Regression&#39;s Gradient Output"></a>Vectorizing Logistic Regression&#39;s Gradient Output</h3><p>在逻辑回归的实现中使用向量化也能在反向计算导数时进行加速。</p><p>最后的实现应该只包含对迭代次数的 for 循环，其它所有的循环都应该能够被向量化。</p><h3 id="Broadcasting-in-Python"><a href="#Broadcasting-in-Python" class="headerlink" title="Broadcasting in Python"></a>Broadcasting in Python</h3><p>Python 中的广播特性可以让两个不同规模的矩阵进行原来要相同规模的矩阵才能进行的运算，不过这两个不同的规模也要满足一定的条件。</p><p>一些简单的原则：</p><ul><li>一个 $m\times n$ 的矩阵和 $m\times 1$ 的矩阵做二元运算时，$m\times 1$ 矩阵会按列重复 $n$ 次，形成 $m\times n$ 矩阵。</li><li>一个 $m\times n$ 的矩阵和 $1\times n$ 的矩阵做二元运算时，$1 \times n$ 矩阵会按行重复 $m$ 次，形成 $m\times n$ 矩阵。</li><li>一个列向量或者行向量和实数做二元运算时，实数会自动重复到和向量的规模一致。</li></ul><h3 id="A-note-on-python-numpy-vectors"><a href="#A-note-on-python-numpy-vectors" class="headerlink" title="A note on python/numpy vectors"></a>A note on python/numpy vectors</h3><p>这一节主要是对使用 numpy 时的一些建议。</p><p>建议不要使用 rank 为 1 的数组，这些数组既不是列向量也不是行向量，应该避免使用。总是显式地使用 $1\times n$ 或者 $n\times 1$ 的矩阵当做数学中的向量。</p><p>代码中可以考虑多写一些关于 shape 的断言语句。</p><h3 id="Quick-tour-of-Jupyter-iPython-Notebooks"><a href="#Quick-tour-of-Jupyter-iPython-Notebooks" class="headerlink" title="Quick tour of Jupyter/iPython Notebooks"></a>Quick tour of Jupyter/iPython Notebooks</h3><p><em>本节没有问题。</em></p><h3 id="Explanation-of-logistic-regression-cost-function"><a href="#Explanation-of-logistic-regression-cost-function" class="headerlink" title="Explanation of logistic regression cost function"></a>Explanation of logistic regression cost function</h3><p>为什么逻辑回归的损失函数和代价函数的形式是那个样子的？损失函数 $\hat y$ 实际上是给定了 $\vec x$ 的情况下 $y = 1$ 的概率，即 $\hat y = P(y = 1 | \vec x)$，此外 $1 - \hat y = P(y = 0 | \vec x)$。这可以写成：</p><script type="math/tex; mode=display">\begin{aligned}y = 1 &\Rightarrow P(y|\vec x) = \hat y \\y = 0 &\Rightarrow P(y|\vec x) = 1 - \hat y\end{aligned}</script><p>两种情况下，要最大化的都是 $P(y |\vec x)$，而它可以写成如下形式以统一 $y$：</p><script type="math/tex; mode=display">P(y | \vec x) = \hat y^{y}(1 - \hat y)^{1 - y}</script><p>这是要最大化的目标，给它套一个对数函数，要最大化的目标就变成了</p><script type="math/tex; mode=display">\log P(y|\hat x) = y\log \hat y + (1 - y)\log (1 - \hat y)</script><p>损失函数是这个函数取反，最大化这个目标就是最小化损失函数。</p><p>以上是损失函数的情况，对于多个样本的代价函数，在样本独立同分布的情况下，最大化的目标是</p><script type="math/tex; mode=display">P(y_1|\vec x_1)\cdots P(y_m|\vec x_m)</script><p>即</p><script type="math/tex; mode=display">\begin{aligned} & \log\left(P(y_1|\vec x_1)\cdots P(y_m|\vec x_m)\right) \\=& \log\prod\limits_{i = 1}^mP(y_i|\vec x_i) \\=& \sum\limits_{i = 1}^m\log P(y_i|\vec x_i) \\=& \sum\limits_{i = 1}^m\left(y_i\log\hat y_i + (1 - y_i)\log(1 - \hat y_i)\right) \\=& -\sum\limits_{i = 1}^mL(\hat y_i, y_i) \\=& -mJ(\vec w, b)\end{aligned}</script><p>最大化目标概率就是最小化代价函数 $J(\vec w, b)$。这是一个最大似然估计的过程，要选择最佳的 $\vec w$ 和 $b$ 使概率最大。</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Networks and Deep Learning 笔记 1 Introduction to Deep Learning</title>
      <link href="/2019/02/01/Neural-Networks-and-Deep-Learning-%E7%AC%94%E8%AE%B0-1-Introduction-to-Deep-Learning/"/>
      <url>/2019/02/01/Neural-Networks-and-Deep-Learning-%E7%AC%94%E8%AE%B0-1-Introduction-to-Deep-Learning/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction-to-Deep-Learning"><a href="#Introduction-to-Deep-Learning" class="headerlink" title="Introduction to Deep Learning"></a>Introduction to Deep Learning</h1><p>感谢 <a href="https://www.coursera.org/learn/neural-networks-deep-learning" target="_blank" rel="noopener">Coursera</a>。</p><h2 id="Welcome-to-the-Deep-Learning-Specialization"><a href="#Welcome-to-the-Deep-Learning-Specialization" class="headerlink" title="Welcome to the Deep Learning Specialization"></a>Welcome to the Deep Learning Specialization</h2><h3 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h3><p><em>本节没有问题。</em></p><h2 id="Introduction-to-Deep-Learning-1"><a href="#Introduction-to-Deep-Learning-1" class="headerlink" title="Introduction to Deep Learning"></a>Introduction to Deep Learning</h2><h3 id="What-is-a-neural-network"><a href="#What-is-a-neural-network" class="headerlink" title="What is a neural network?"></a>What is a neural network?</h3><p>对于有输入的特征以及输出的大量样本，神经网络可以很好地学习到其中的映射关系。</p><h3 id="Supervised-Learning-with-Neural-Networks"><a href="#Supervised-Learning-with-Neural-Networks" class="headerlink" title="Supervised Learning with Neural Networks"></a>Supervised Learning with Neural Networks</h3><p>监督学习是给定输入特征和输出，要求找到二者之间的对应关系。</p><p>卷积神经网络常用于图像数据，循环神经网络常用于序列数据。对于更复杂的数据可能要使用自定义的混合结构。</p><p><strong>结构化的数据</strong> 是基于数据库的数据，这种数据一般已经将每个样本的特征写成一个向量，其中每个分量的含义都是显然的，人类可理解的。<strong>非结构化的数据</strong> 例如图像、声音序列和文本序列，人类对这些数据的处理能力很强，但是计算机只有最近才逐渐有了较强的理解能力。</p><a id="more"></a><h3 id="Why-is-Deep-Learning-taking-off"><a href="#Why-is-Deep-Learning-taking-off" class="headerlink" title="Why is Deep Learning taking off?"></a>Why is Deep Learning taking off?</h3><p>传统方法在数据集规模上升时会出现性能不变的情况，因为这些算法不一定能处理大规模数据集的情况。用神经网络的方法，性能会随着神经网络的规模（隐藏层的神经元数目）上升，也随着数据集的规模上升。深度学习在近年来取得好结果的原因就是当下的数据规模更大了。不过当数据集规模较小的时候，性能更取决于提取的特征的质量，高质量特征在传统方法上可能优于低质量特征在神经网络方法上的应用。</p><p>很多算法上的创新使得神经网络运行得更快，例如激活函数从 sigmoid 更新到了 ReLU 之后。sigmoid 在某些区间上梯度几乎为零，学习进度很慢，但是 ReLU 对所有的正输入梯度都为 1。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 20</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-20/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-20/</url>
      
        <content type="html"><![CDATA[<h1 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h1><h2 id="代码生成器的主要任务"><a href="#代码生成器的主要任务" class="headerlink" title="代码生成器的主要任务"></a>代码生成器的主要任务</h2><p>代码生成器将中间表示转换到汇编语句。</p><p>三个主要任务：</p><ul><li>选择适当的目标机指令表示中间表示</li><li>对寄存器的分配和指派</li><li>确定指令的执行顺序</li></ul><h2 id="一个简单的目标机模型"><a href="#一个简单的目标机模型" class="headerlink" title="一个简单的目标机模型"></a>一个简单的目标机模型</h2><p>为了后续方便引入一个简单的汇编语言，它的指令有：</p><ul><li><code>LD x, y</code>：读入 <code>y</code> 至 <code>x</code></li><li><code>ST x, y</code>：将 <code>x</code> 写入 <code>y</code></li><li><code>OP x, y, z</code>：计算 <code>y OP z</code> 后存入 <code>x</code></li><li><code>BR l</code>：无条件跳转到 <code>l</code></li><li><code>Bcond c, l</code>：在满足条件 <code>c</code> 时跳转到 <code>l</code></li></ul><p>以及各种寻址方式。</p><h2 id="指令选择"><a href="#指令选择" class="headerlink" title="指令选择"></a>指令选择</h2><p>这一节主要是几个例子，表示对于给定的中间表示如何生成出对应的指令。显然没有什么好记录的。</p><h2 id="寄存器的选择"><a href="#寄存器的选择" class="headerlink" title="寄存器的选择"></a>寄存器的选择</h2><h3 id="寄存器分配"><a href="#寄存器分配" class="headerlink" title="寄存器分配"></a>寄存器分配</h3><p>当要为 <code>x = y op z</code> 分配寄存器的时候，调用 <code>getReg</code> 函数选择寄存器。</p><p>假设为 <code>y</code> 选出的寄存器为 $R_y$，如果其中存放的不是 <code>y</code>，就生成一条 <code>LD R_y, y</code>。对 <code>z</code> 也是同理。</p><p>现在 $R_y$ 和 $R_z$ 中存放的是正确的值，生成对应的汇编语句即可。</p><h3 id="使用到的数据结构"><a href="#使用到的数据结构" class="headerlink" title="使用到的数据结构"></a>使用到的数据结构</h3><p>为了实现 <code>getReg</code> 需要维护两张表。一张是记录每个寄存器中存放了哪些变量（一个寄存器中可能不止存放了一个变量，也可能存放了多个相同的变量），称为 <strong>寄存器描述符</strong>，另一张记录每个变量被存放在哪些位置（是寄存器、内存、栈等空间的组合），称为 <strong>地址描述符</strong>，第二张表可以在符号表中实现。</p><p>在基本块结束时，如果某个变量不在自己的内存区域中，需要生成一条保存语句。这个类似于缓存 dirty 的策略，可以加速程序运行。</p><h3 id="管理寄存器描述符和地址描述符"><a href="#管理寄存器描述符和地址描述符" class="headerlink" title="管理寄存器描述符和地址描述符"></a>管理寄存器描述符和地址描述符</h3><h4 id="LD-R-x-指令"><a href="#LD-R-x-指令" class="headerlink" title="LD R, x 指令"></a><code>LD R, x</code> 指令</h4><ol><li>修改 <code>R</code> 的寄存器描述符为只包含 <code>x</code>；</li><li>将 <code>R</code> 加入到 <code>x</code> 的地址描述符中；</li><li>将 <code>R</code> 从其它变量地址描述符中移除。</li></ol><h4 id="OP-R-x-R-y-R-z-指令"><a href="#OP-R-x-R-y-R-z-指令" class="headerlink" title="OP R_x, R_y, R_z 指令"></a><code>OP R_x, R_y, R_z</code> 指令</h4><ol><li>修改 <code>R_x</code> 的寄存器描述符为只包含 <code>x</code>，从其它寄存器描述符中删除 <code>x</code>。</li><li>修改 <code>x</code> 的地址描述符为只包含 <code>R_x</code>，从其它变量地址描述符中移除 <code>R_x</code>。</li></ol><hr><p>其它语句按照类似方式得到。</p><p>特别地，对于复制语句 <code>x = y</code> 只用分配一个寄存器 <code>R</code>，<code>R</code> 对应的寄存器描述符中可以既存放 <code>x</code> 也存放 <code>y</code>。</p><h2 id="寄存器选择函数-getReg-的设计"><a href="#寄存器选择函数-getReg-的设计" class="headerlink" title="寄存器选择函数 getReg 的设计"></a>寄存器选择函数 <code>getReg</code> 的设计</h2><p>要对一个变量选择寄存器时，按照如下流程：</p><ol><li>检查变量是否已经在某个寄存器中了，如果是，返回这个寄存器。（不管是读取还是写入都是对的！）</li><li>检查是否有空的寄存器，有则返回。</li><li>否则，计算出每个寄存器被使用后的“代价”，这个代价和每个寄存器中存放的变量数量以及后续的使用情况有关。选出代价最小的寄存器返回。</li></ol><p><code>getReg</code> 的输入应该是指令而不是变量，这样可以对形如复制语句的语句作特殊处理，为两个变量选择相同的寄存器。</p><p>有一些特殊的情况，例如 <code>x = y + z</code> 中如果确认了 <code>y</code> 在以后不会被使用，那么为 <code>x</code> 选择寄存器时那个 <strong>只存放了</strong> <code>y</code> 的寄存器对其而言是空寄存器。</p><h2 id="窥孔优化"><a href="#窥孔优化" class="headerlink" title="窥孔优化"></a>窥孔优化</h2><p>窥孔是一段对汇编程序的窗口，这个窗口可以滑动并对窗内的内容进行优化。窥孔优化的几个实例如下。</p><h3 id="冗余指令删除"><a href="#冗余指令删除" class="headerlink" title="冗余指令删除"></a>冗余指令删除</h3><p>窥孔中出现了冗余的指令，并且没有相应的标号，这段指令必然是顺着时，可以进行删减，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ST a, R0</span><br><span class="line">LD R0, a</span><br></pre></td></tr></table></figure><p>可以删除第二条读取。</p><p>有些代码是不可达的，例如紧跟在无条件跳转后的代码，这些代码也可以删除。</p><h3 id="控制流优化"><a href="#控制流优化" class="headerlink" title="控制流优化"></a>控制流优化</h3><p>如果一个跳转指令跳转到了一个无条件跳转指令，这两次跳转可以合并。</p><p>假设第一条语句是 <code>goto L1</code>，第二条指令是 <code>L1: goto L2</code>，合并后没有跳转到 <code>L1</code> 的指令，并且 <code>L1</code> 前是无条件跳转，则 <code>L1</code> 可以进一步被删除。</p><h3 id="代数优化"><a href="#代数优化" class="headerlink" title="代数优化"></a>代数优化</h3><p>利用代数恒等式可以删除形如 <code>x = x + 0</code> 或者 <code>x = x * 1</code> 之类的指令。</p><p>此外可以进行强度削弱，例如使用加法和位移代替乘法，使用乘倒数代替除以一个常数等。</p><h3 id="使用特殊指令"><a href="#使用特殊指令" class="headerlink" title="使用特殊指令"></a>使用特殊指令</h3><p>一些指令能够更好地利用硬件，由此可以实现加速。例如使用 <code>INC x</code> 代替 <code>x = x + 1</code> 等。</p><hr><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 19</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-19/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-19/</url>
      
        <content type="html"><![CDATA[<h1 id="代码优化-4"><a href="#代码优化-4" class="headerlink" title="代码优化-4"></a>代码优化-4</h1><h2 id="支配结点和回边"><a href="#支配结点和回边" class="headerlink" title="支配结点和回边"></a>支配结点和回边</h2><p><strong>支配</strong>：在流图中，如果从入口基本块结点（$ENTRY$）到某基本块结点 n 的所有路径都要经过基本块结点 m，则称结点 m 支配结点 n。每个结点都会支配自己。</p><p><strong>支配结点树</strong>：将所有的结点按照支配关系可以排列成一棵树，这棵树的任意一棵子树满足根结点支配子树中所有结点（包括自己）。</p><p><strong>直接支配结点</strong>：一个结点的直接支配结点是从入口结点到它自己的路径上最后一个支配它的结点。</p><h3 id="求解支配结点"><a href="#求解支配结点" class="headerlink" title="求解支配结点"></a>求解支配结点</h3><p>寻找支配结点是一个前向风格的数据流问题。将 $\mbox{In}[B]$ 表示 $B$ 入口处的支配结点集合，$\mbox{Out}[B]$ 表示出口处的支配结点集合，得到方程 $\mbox{Out}[ENTRY] = \{ENTRY\}$，$\mbox{Out}[B] = \mbox{In}[B] \cup \{B\}$ 以及 $\mbox{In}[B] = \cap_i\mbox{Out}[P_i]$，其中 $P_i$ 是 $B$ 的各个前驱结点。这个方程可以使用迭代的方式求解，即可得到各个结点的支配结点。</p><hr><p><strong>关于数据流问题的一些想法</strong>：目前已经看过了四个数据流问题，它们都是在求一个有向图上的各个结点的属性。共性是每个结点都可以关联两个属性：进入时的属性和离开时的属性。这两个属性之间的关系只由结点本身决定。给定了初始虚拟结点和终末虚拟结点的属性，并给出了每个结点的进入时的属性和其它结点离开时的属性的关系（或离开时的属性与其它结点进入时的属性的关系）后都可以通过迭代的方式求解。迭代的初始化的规律是，例如一个结点的进入时的属性是其它结点离开时的属性的交，则初始化为全集；若为并，则初始化为空集。</p><h3 id="回边"><a href="#回边" class="headerlink" title="回边"></a>回边</h3><p>如果结点 m 支配结点 n，但是 n 有一条指向 m 的边，这条边称为 <strong>回边</strong>。</p><h2 id="自然循环及其识别"><a href="#自然循环及其识别" class="headerlink" title="自然循环及其识别"></a>自然循环及其识别</h2><p>从流图中容易得到循环，但是找到适合优化的 <strong>自然循环</strong> 才是有意义的。</p><p>自然循环是满足以下性质的循环：</p><ul><li>有 <strong>唯一的</strong> 支配循环中其它结点的入口结点，称为首结点。（这个限制是希望循环有唯一的入口，对于优化过程而言可能存在循环不变量等条件。）</li><li>循环中至少存在一条回到入口结点的路径。</li></ul><p>对于一条回边，假设是 n 指向 m 的，可以得到一个自然循环。这个自然循环包括的结点有 m，以及所有不经过 m 到达 n 的结点（自然包括 n）。因为这些结点不经过 m 可以到达 n，而 n 可以直接到 m，所以可以看做是以 m 为首结点的自然循环。</p><p>为了找到所有的这样的结点，对于一条从 n 指向 m 的回边，n 必然在对应的自然循环中，n 的所有前驱也在自然循环中，这些前驱的前驱也应该在其中。依此类推，可以找到这条回边对应的自然循环的所有结点。</p><p>自然循环的性质：如果两个自然循环首结点不同，它们要么完全不相交，要么互相包含。对于第二种情况，相当于发生了循环嵌套。没有嵌套其它循环的循环称为 <strong>最内循环</strong>。如果两个循环具有相同的首结点，难以讨论最内循环时，可以考虑将两个循环合并进行讨论。</p><h2 id="删除全局公共子表达式和复制语句"><a href="#删除全局公共子表达式和复制语句" class="headerlink" title="删除全局公共子表达式和复制语句"></a>删除全局公共子表达式和复制语句</h2><h3 id="删除全局公共子表达式"><a href="#删除全局公共子表达式" class="headerlink" title="删除全局公共子表达式"></a>删除全局公共子表达式</h3><p>这个优化依赖于可用表达式分析。思路是对于 $x = y  + z$ 中的公共子表达式 $y + z$，将其转化为 $u = y + z, x= u$，后续过程中即可使用 $u$ 代替 $y + z$。</p><p>如果需要优化某个基本块中的 $x = y + z$，已知了 $y + z$ 是可用的，可以从这个基本块开始逆着流动方向进行搜索，找到所有离该基本块最近的计算了 $y + z$ 的语句，将这些语句替换为上述形式（全部使用一个变量 $u$ 来代替），然后对于 $x = y + z$ 而言就变成了 $x = u$。搜索过程中不能穿过任何计算了 $y + z$ 的块，同时应该不会出现对 $y$ 或者 $z$ 的定值，否则表达式应该是不可用的。搜索时不一定能在直接前驱中找到，可能要递归地搜索下去。</p><h3 id="删除复制语句"><a href="#删除复制语句" class="headerlink" title="删除复制语句"></a>删除复制语句</h3><p>对于一个复制语句 $x = y$，如果在 $x$ 的所有引用处，$x = y$ 这个表达式都是可用的，就可以使用 $y$ 代替 $x$ 从而消除复制语句。</p><p>如果需要删除掉某个复制语句 $x = y$，需要根据 $x$ 的定值-引用链找到所有对该变量的引用，然后查看在所有这些引用处是不是表达式都是可用的。如果都是可用的就可以删除复制语句并将所有的 $x$ 用 $y$ 代替。</p><h2 id="代码移动"><a href="#代码移动" class="headerlink" title="代码移动"></a>代码移动</h2><p>代码移动的目的是优化循环中冗余的计算。</p><h3 id="循环不变量计算"><a href="#循环不变量计算" class="headerlink" title="循环不变量计算"></a>循环不变量计算</h3><p>循环的 <strong>循环不变量</strong> 指的是在循环过程中值保持不变的量。</p><p>对于一个循环（循环在流图中就是若干个结点的集合），它的循环不变量可以用如下方式找出。对于一个语句，如果它将某个运算赋给一个变量，且运算分量是以下三种情况之一：</p><ul><li>运算分量是常数</li><li>运算分量的定值语句在循环外部</li><li>运算分量的到达定值语句是对循环不变量的定值（也就是说运算分量本身也是循环不变量）</li></ul><p>则被赋值的变量是循环不变量。</p><h3 id="代码外提"><a href="#代码外提" class="headerlink" title="代码外提"></a>代码外提</h3><p>为了实现代码外提，首先找到循环的首结点，然后引入一个 <strong>前置首结点</strong>。前置首结点与首结点的关系是，前置首结点只指向首结点，之前指向首结点的循环外结点指向前置首结点，循环内结点指向新的首结点。这样，前置首结点的内容只会被执行一次。</p><p>并非所有的循环不变量的计算都可以外提到前置首结点中，要满足以下条件：</p><ul><li>该计算过程所在的基本块支配了所有的循环出口结点（能够离开循环的结点），保证了离开循环前这条语句必然被执行过；</li><li>循环过程中没有其它语句对这个循环不变量赋值，保证了循环不变量在赋值后值总是固定的；</li><li>如果循环不变量是 $x$，则所有对 $x$ 的引用只能由该循环不变量的计算这个定值语句到达。</li></ul><p>在找到了所有的循环不变量，并且确定可以外提之后，建立各个循环不变量之间的依赖关系（一个循环不变量可能依赖其它循环不变量），将代码外提到前置首结点中。</p><h2 id="作用于归纳变量的强度削弱"><a href="#作用于归纳变量的强度削弱" class="headerlink" title="作用于归纳变量的强度削弱"></a>作用于归纳变量的强度削弱</h2><h3 id="归纳变量"><a href="#归纳变量" class="headerlink" title="归纳变量"></a>归纳变量</h3><p>循环的 <strong>归纳变量</strong> 指的是在循环中以固定步长变化的量。对归纳变量进行强度削弱主要是用加减代替乘法。<strong>归纳变量不是每轮循环都变化的，一轮循环中可能不变化或者变化多次（循环嵌套）。</strong></p><p>如果变量 $i$ 只有形如 $i = i + 2$ 这样的定值，称为 <strong>基本归纳变量</strong>。</p><p>如果变量 $j$ 的定值形如 $j = i\times a + b$，其中 $i$ 是基本归纳变量，称 $j$ 是 $i$ 族的归纳变量，以（族，步长，偏置）的形式关联一个三元组 $(i, a, b)$。</p><p>所有的归纳变量都可以关联这样的三元组。</p><h3 id="归纳变量计算"><a href="#归纳变量计算" class="headerlink" title="归纳变量计算"></a>归纳变量计算</h3><p>为了找到所有的归纳变量，第一步是找到所有的基本归纳变量。需要注意的是基本归纳变量中只要每次的步长是一个循环不变量即可，不一定要求是常量。</p><p>找到基本归纳变量后在循环中找到所有的只有一次定值的变量 $k$，假设其形式是 $k = c\times i + d$。</p><ul><li>如果 $i$ 是基本归纳变量，则 $k$ 是 $i$ 族的归纳变量，并且三元组容易确定。</li><li>如果 $i$ 不是基本归纳变量，并且是 $j$ 族的归纳变量，则 $k$ 的三元组可以确定。此时有额外的限制，循环中对 $i$ 的定值到对 $k$ 的定值之间不能有对 $j$ 的定值（因为要将 $k$ 写成 $i$ 的函数了），循环外对 $i$ 的定值不能到达 $k$（在循环中 $k$ 第一次被定值的时候如果依赖的 $i$ 的值是来自循环外的，就可能有问题）。</li></ul><p>这样可以找到所有的归纳变量，以及它们的三元组信息。</p><h3 id="强度削弱"><a href="#强度削弱" class="headerlink" title="强度削弱"></a>强度削弱</h3><p>对归纳变量的强度削弱是按族进行的。对于这些归纳变量总是可以分成若干不相交的族。对于每一族：</p><ol><li>对于每个具有不同三元组的归纳变量，建立一个变量 $t$。例如对于 $j = a\times i + b$，建立变量 $t$。</li><li>将对 $j$ 的赋值改成 $t$，在上一个例子中就是 $j = t$。</li><li>在每次基本归纳变量发生改变后，更新 $t$ 的值。例如 $i =  i + c$ 后面应该插入 $t = t + c\times a$。</li><li>为了保证 $t$ 具有正确的初值，在前置首结点的末尾插入 $t = a\times i + b$。</li></ol><p>可以看到强度削弱引入了新的归纳变量。</p><h2 id="归纳变量的删除"><a href="#归纳变量的删除" class="headerlink" title="归纳变量的删除"></a>归纳变量的删除</h2><h3 id="删除额外的复制语句"><a href="#删除额外的复制语句" class="headerlink" title="删除额外的复制语句"></a>删除额外的复制语句</h3><p>在对归纳变量进行强度削弱时，引入了新的复制语句，将一个新的归纳变量复制给了旧的归纳变量。由前面的代码优化知识可以知道这种复制语句有冗余的可能，可以考虑将其删除。</p><h3 id="删除用作测试的归纳变量"><a href="#删除用作测试的归纳变量" class="headerlink" title="删除用作测试的归纳变量"></a>删除用作测试的归纳变量</h3><p>对于仅用作测试（出现在条件中）的基本归纳变量，有时可以将其删除。如果 $i$ 是一个基本归纳变量，$j$ 是 $i$ 族的归纳变量，有 $j = a\times i + b\ (a &gt; 0)$，某个条件语句是 $i &gt; x$，则该条件等价于 $j &gt; a\times x + b$，替换完成后，有可能可以删除基本归纳变量 $i$。</p><p>另一种情况是条件中两个都是基本归纳变量，例如 $j_1 = a\times i_1 + b, j_2 = a\times i_2 + b\ (a &gt; 0)$，对于条件 $i_1 &gt; i_2$ 而言可以替换为 $j_1 &gt; j_2$。这样求三元组的后两个分量是相同的，如果三元组的后两个分量不同的话可能引入额外的计算从而得不偿失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 18</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-18/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-18/</url>
      
        <content type="html"><![CDATA[<h1 id="代码优化-3"><a href="#代码优化-3" class="headerlink" title="代码优化-3"></a>代码优化-3</h1><h2 id="活跃变量分析"><a href="#活跃变量分析" class="headerlink" title="活跃变量分析"></a>活跃变量分析</h2><p>在某个程序点上，如果存在某条执行路径，使得变量 $x$ 在该程序点上的值在路径上某处被引用，则称变量 $x$ 在该程序点处活跃。直观来说就是 $x$ 在以后会被用到。</p><p>活跃变量分析是逆向风格的数据流分析问题，它的一些应用：</p><ul><li><strong>删除无用赋值</strong>：一个变量在定值后，在基本块内不再被引用，并且在基本块出口处不活跃，则为无用赋值。</li><li><strong>为基本块分配寄存器</strong>：在寄存器已经完全分配出去后，如果需要新的寄存器可以优先使用存放了非活跃变量的寄存器；在基本块出口处，可以不保存出口处不活跃的变量。</li></ul><h3 id="传递函数与数据流方程"><a href="#传递函数与数据流方程" class="headerlink" title="传递函数与数据流方程"></a>传递函数与数据流方程</h3><p>用 $\mbox{In}[B]$ 表示 $B$ 入口处的活跃变量集合，$\mbox{Out}[B]$ 表示出口处的活跃变量集合，有传递函数 $\mbox{In}[B] = f_B(\mbox{Out}[B])$。</p><p>用 $def_B$ 表示 $B$ 中第一次出现是以定值形式出现的变量集合，$use_B$ 表示第一次出现是以引用形式出现的变量集合。显然 $B$ 中出现的变量必然属于其中之一。有 $f_B(x) = use_B\cup (x - def_B)$。$use_B,gen_B$ 容易从基本块中直接得到。</p><p><strong>活跃变量分析的数据流方程</strong>：在流图的最后使用 $EXIT$ 这个虚拟基本块，有 $\mbox{In}[EXIT] = \varnothing$，此外对于所有基本块有 $\mbox{In}[B] = use_B\cup (\mbox{Out}[B] - def_B)$，$\mbox{Out}[B] = \cup_i\mbox{In}[S_i]$，其中 $S_i$ 是 $B$ 的所有后继基本块。</p><p>该方程的计算和到达定值分析类似，也是迭代直到不变。</p><h3 id="定值-引用链"><a href="#定值-引用链" class="headerlink" title="定值-引用链"></a>定值-引用链</h3><p>和到达定值分析中不同，<strong>定值-引用链不是引用-定值链</strong>。一个定值能够到达的所有引用的集合称为该定值的定值-引用链。</p><p>在活跃变量分析的数据流方程中，如果将 $\mbox{Out}[B]$ 的含义定义为 $B$ 结尾处能够到达的引用的集合，就可以计算定值-引用链。</p><ul><li>如果 $B$ 中对 $x$ 的定值 $d$ 后在 $B$ 中没有其它对 $x$ 的定值，则 $d$ 的定值-引用链是 $d$ 后所有对 $x$ 的引用和 $\mbox{Out}[B]$ 中所有对 $x$ 的引用。</li><li>如果 $B$ 中对 $x$ 的定值 $d$ 后有其它对 $x$ 的定值，且第一个定值是 $d&#39;$，则 $d$ 的定值-引用链是 $d$ 和 $d&#39;$ 之间所有对 $x$ 的引用。</li></ul><h2 id="可用表达式分析"><a href="#可用表达式分析" class="headerlink" title="可用表达式分析"></a>可用表达式分析</h2><p>在某个程序点 $p$ 上，如果从流图的首结点开始到达 $p$ 的所有路径上，对表达式 $e$ 都进行了计算并且最后一次计算完成后没有重新对 $e$ 中分量定值，则 $e$ 在 $p$ 处是可用表达式。直观来说就是 $p$ 处不用重新计算 $e$。</p><p>可用表达式分析可以用来：</p><ul><li><strong>消除全局公共子表达式</strong>。</li><li><strong>进行复制传播</strong>，将赋值语句视作一种特殊的表达式，在某个程序点 $p$ 上，如果赋值语句 $e$ 为 $x = y$ 在 $p$ 处可用，则 $p$ 处对 $x$ 的使用可以用 $y$ 代替。</li></ul><h3 id="传递函数与数据流方程-1"><a href="#传递函数与数据流方程-1" class="headerlink" title="传递函数与数据流方程"></a>传递函数与数据流方程</h3><p>可用表达式分析是前向风格的数据流分析问题。用 $\mbox{In}[B]$ 表示 $B$ 入口处的可用表达式集合，用 $\mbox{Out}[B]$ 表示出口处的可用表达式集合，有传递函数 $\mbox{Out}[B] = f_B(\mbox{In}[B])$。</p><p>用 $gen_B$ 表示 $B$ 中生成的表达式集合，即计算了这个表达式并且后来没有对表达式中的分量重新定值；用 $kill_B$ 表示 $B$ 中杀死的表达式集合，即对表达式中的分量重新定值并且后来没有再计算过这个表达式。任一表达式只可能属于其中一个，但也可能都不属于。</p><p>对于给定的基本块可以计算出它的 $gen$ 和 $kill$：</p><ul><li>对于 $gen_B$，先初始化为空。顺次对于 $B$ 中的每条语句 $x = y + z$，将 $y + z$ 加入 $gen_B$ 中，然后将与 $x$ 有关的语句从 $gen_B$ 中删除。</li><li>对于 $kill_B$，先初始化为空。顺次对于 $B$ 中的每条语句 $x = y  + z$，将 $y + z$ 从 $kill_B$ 中删除，然后将与 $x$ 有关的语句加入到 $kill_B$ 中。</li></ul><p><strong>可用表达式分析的数据流方程</strong>：$\mbox{Out}[Entry] = \varnothing$，$f_B(x) = gen_B\cup (x - kill_B)$，以及 $\mbox{In}[B] = \cap_i\mbox{Out}[P_i]$，其中 $P_i$ 是 $B$ 的所有前驱。该方程的计算使用迭代，直到不变。迭代过程中每个基本块的 $\mbox{Out}$ 被设为程序中可能出现的所有表达式的集合，之所以不设为空集是因为空集在初始的若干次迭代中会导致计算缓慢，设置为全集可以更快地迭代到不变。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 17</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-17/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-17/</url>
      
        <content type="html"><![CDATA[<h1 id="代码优化-2"><a href="#代码优化-2" class="headerlink" title="代码优化-2"></a>代码优化-2</h1><h2 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h2><p>数据流分析是一种用来获取程序执行路径上的数据流信息的方法。分析过程会将每个程序点和一个 <strong>数据流值</strong> 关联起来。这个定义过于抽象，不要深究。什么是数据流我暂且认为是 <strong>表示各个变量的值的传递过程的信息</strong>。</p><p>数据流分析有 <strong>到达定值分析</strong>、<strong>活跃变量分析</strong> 和 <strong>可用表达式分析</strong> 这几种应用。</p><p>对于语句 $s$，使用 $\mbox{In}[s]$ 表示 $s$ 之前的数据流值，$\mbox{Out}[s]$ 表示 $s$ 之后的数据流值，随着 $s$ 的不同可以得到两者之间的函数 $\mbox{Out}[s] = f_s(\mbox{In}[s])$，这个函数称作 $s$ 的传递函数，这种风格的传递函数是前向传播风格，还有一种是 $\mbox{In}[s] = g_s(\mbox{Out}[s])$ 是逆向传播风格。对于基本块 $B$ 也有 $\mbox{In}[B]$ 和 $\mbox{Out}[B]$。</p><p>对于相邻的语句有 $\mbox{In}[s_{i+1}]  = \mbox{Out}[s_i]$，对于基本块 $B$，它的 $\mbox{In}[B]$ 是第一条语句 $s_1$ 的 $\mbox{In}[s_1]$，它的 $\mbox{Out}[B]$ 是最后一条语句 $s_n$ 的 $\mbox{Out}[s_n]$。对于前向风格的传递函数，有 $f_B = f_{s_n}\cdot f_{s_{n -1}}\cdots f_{s_2}\cdot f_{s_1}$；对于逆向风格的传递函数有 $g_B = g_{s_1}\cdot g_{s_{2}}\cdots g_{s_{n - 1}}\cdot g_{s_n}$。</p><h2 id="到达定值分析"><a href="#到达定值分析" class="headerlink" title="到达定值分析"></a>到达定值分析</h2><p>如果一条语句 $s$ 对变量 $x$ 赋值了，则称 $s$ 是 $x$ 的一个 <strong>定值</strong>。</p><p>如果存在某个路径，它以 $x$ 的某个定值 $s$ 开始，以某个程序点 $p$ 结束，且这条路径上没有对 $x$ 的其它定值，称定值 $s$ <strong>到达</strong> 程序点 $p$。</p><p>到达定值分析的一些应用：</p><ul><li><strong>检测循环中的不变量</strong>：一个循环中对某个变量进行了赋值，但是通过到达定值分析可能发现这个变量的值在每轮循环中都没有改变。</li><li><strong>常量合并</strong>：对某个变量 $x$ 的使用只有一个定值可以到达，并且这个定值是将某个常量赋给 $x$，则可以直接替换为这个常量。</li><li><strong>判断某个变量是否在被赋值前就被使用了</strong>。</li></ul><h3 id="生成与杀死定值"><a href="#生成与杀死定值" class="headerlink" title="生成与杀死定值"></a>生成与杀死定值</h3><p>一个定值语句会 <strong>生成</strong> 一个定值（就是它自己），同时会 <strong>杀死</strong> 其它所有对被赋值的变量的定值。</p><p>用 $gen_d$ 表示语句 $d$ 生成的定值的集合，用 $kill_b$ 表示杀死的定值的集合。则对于某个语句 $d$ 而言，其传递函数可以写成 $f_d(x) = gen_d\cup(x - kill_d)$（自变量 $x$ 的“类型”是一个数据流值，由此看来此应用下的数据流值是一些定值的集合）。</p><p>基本块的传递函数的形式一致：$f_B(x) = gen_B\cup(x - kill_B)$，其中 $kill_B = kill_1\cup kill_2\cup \cdots\cup kill_n$，$gen_B = gen_n\cup (gen_{n - 1} - kill_n)\cup(gen_{n - 2} - kill_{n - 1} - kill_{n})\cup\cdots\cup(gen_1-kill_2-\cdots -kill_n)$。</p><h3 id="到达定值的数据流方程"><a href="#到达定值的数据流方程" class="headerlink" title="到达定值的数据流方程"></a>到达定值的数据流方程</h3><p>对于一个程序，它的定值被以下方程约束：</p><ul><li>$\mbox{Out}[Entry] = \varnothing$，其中 $Entry$ 是在第一个基本块前的虚拟基本块。</li><li>$\mbox{Out}[B] = gen_B\cup(\mbox{In}[B] - kill_B)$，由传递函数的定义和计算方式得到，$gen_B$ 和 $kill_B$ 可以直接从 $B$ 中得到。</li><li>对于基本块 $B$，如果它的前驱为 $A_1,A_2,\cdots,A_n$，则 $\mbox{In}[B] = \cup_i A_i$。</li></ul><h2 id="到达定值方程的计算"><a href="#到达定值方程的计算" class="headerlink" title="到达定值方程的计算"></a>到达定值方程的计算</h2><p>以下算法可以计算出每个基本块 $B_i$ 的 $\mbox{In}[B_i]$ 和 $\mbox{Out}[B_i]$，假定每个基本块的生成集合和杀死集合已经得到。</p><ol><li>将包括 $Entry$ 块在内的所有基本块的 $\mbox{Out}$ 设置为空集。</li><li>对于除了 $Entry$ 的每个基本块，先使用 $\mbox{In}[B_i] = \cup_j A_{ij}$ 计算其 $\mbox{In}$（对于基本块 $B$，如果它的前驱为 $A_1,A_2,\cdots,A_n$，则 $\mbox{In}[B] = \cup_i A_i$），然后使用 $\mbox{Out}[B] = gen_B\cup(\mbox{In}[B] - kill_B)$ 计算 $\mbox{Out}$。完成后如果有任何基本块的 $\mbox{Out}$ 发生改变，则重复这一步直到没有改变。</li></ol><h3 id="引用-定值链"><a href="#引用-定值链" class="headerlink" title="引用-定值链"></a>引用-定值链</h3><p>对于一个基本块中的变量的每次引用，可以为其关联一个 <strong>引用-定值链</strong> 表示所有可以到达该引用的定值：</p><ul><li>如果这次引用前，基本块中已经有了对该变量的定值，则链中只有唯一元素就是最近的定值。</li><li>否则，链中元素是 $\mbox{In}[B]$ 中对该变量的定值的集合。</li></ul><p>（考虑到到达某个基本块的路径不止一条，链中可能有多个元素。）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 16</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-16/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-16/</url>
      
        <content type="html"><![CDATA[<h1 id="代码优化-1"><a href="#代码优化-1" class="headerlink" title="代码优化-1"></a>代码优化-1</h1><p>代码优化就是使程序运行更快、效率更高的对程序的等价变换。</p><h2 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h2><h3 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h3><p>基本块是一段连续的三地址指令序列，满足 <strong>控制流只能从序列首进入，只能从序列尾退出，序列中不会出现跳转和停机</strong>。</p><p>将一段程序划分为基本块的算法需要先确定 <strong>首指令</strong>，即作为某个基本块的第一条指令的指令。首指令可能是指令序列的第一条指令、跳转指令本身和紧接着跳转指令后的指令。首指令之间的指令片段即为一个基本块。</p><h3 id="流图-1"><a href="#流图-1" class="headerlink" title="流图"></a>流图</h3><p>流图是一张有向图，反映了控制流的转移。其结点对应着基本块，两个结点之间存在一条边当且仅当这两个结点对应的基本块存在可能的控制流转移。结点 M 指向结点 N 有可能是 M 在某种情况下会跳转向 N，也可能是 M 执行完了后不会跳转，但是会顺着进入 N。</p><h2 id="常用的代码优化方法（一）"><a href="#常用的代码优化方法（一）" class="headerlink" title="常用的代码优化方法（一）"></a>常用的代码优化方法（一）</h2><h3 id="优化分类"><a href="#优化分类" class="headerlink" title="优化分类"></a>优化分类</h3><p>按照优化的目标可以分为针对中间表示的 <strong>机器无关优化 </strong>和针对目标代码的 <strong>机器相关优化</strong>。</p><p>按照优化的范围可以分为针对单个基本块的 <strong>局部代码优化</strong> 和针对多个基本块的 <strong>全局代码优化</strong>。</p><h3 id="删除公共子表达式"><a href="#删除公共子表达式" class="headerlink" title="删除公共子表达式"></a>删除公共子表达式</h3><p>如果一个表达式中的子表达式之前计算过，下次遇到时表达式中的元素的值未改变，则称为公共子表达式，可以删去。</p><p>如果子表达式的上次计算是在同一个基本块中完成的，称为 <strong>局部公共子表达式</strong>，否则应该是在不同基本块中完成的，称为 <strong>全局公共子表达式</strong>。</p><p>一个重要的问题是如何识别公共子表达式。</p><h2 id="常用的代码优化方法（二）"><a href="#常用的代码优化方法（二）" class="headerlink" title="常用的代码优化方法（二）"></a>常用的代码优化方法（二）</h2><h3 id="删除无用代码"><a href="#删除无用代码" class="headerlink" title="删除无用代码"></a>删除无用代码</h3><p>有些代码是无用的，例如执行了公共子表达式删除后会引入一些复制语句如 <code>x = y</code>，复制传播就是尽可能使用 <code>y</code> 代替 <code>x</code>。</p><p>使用了复制传播后又有可能产生死代码，这种代码的执行结果永远不会被用到，可以直接删除。</p><h3 id="常量合并"><a href="#常量合并" class="headerlink" title="常量合并"></a>常量合并</h3><p>在编译时就识别出常量的表达式，并计算出结果替代这些表达式。</p><h3 id="代码移动"><a href="#代码移动" class="headerlink" title="代码移动"></a>代码移动</h3><p>对于循环，可以找到循环中有哪些量是在各循环间不会变动的，提到循环外面。</p><h3 id="强度削弱"><a href="#强度削弱" class="headerlink" title="强度削弱"></a>强度削弱</h3><p>使用执行更快的指令替代更慢的指令，例如使用 <code>lea</code> 和各种位移替代乘法。</p><h3 id="删除归纳变量"><a href="#删除归纳变量" class="headerlink" title="删除归纳变量"></a>删除归纳变量</h3><p>归纳变量指的是循环中的一些变量，在循环的过程中每轮循环后的改变量总是固定的。如果一个循环中有多个这样的变量并且变化步调一致，则可以删除到只剩一个。</p><h2 id="基本块的优化"><a href="#基本块的优化" class="headerlink" title="基本块的优化"></a>基本块的优化</h2><p>为了执行局部优化常常将基本块转化为一个有向无环图。这个图中每个结点会对应一个运算并且关联一个变量的列表，结点 M 指向结点 N 表示在某条语句中，M 关联的变量的计算依赖于 N 变量的值。</p><p>这个图是随着基本块的一条条语句逐渐建立起来的。每分析到一条语句（以 <code>x = y + z</code> 为例），首先在图中找到关联了 <code>x</code> 的结点，如果找到将 <code>x</code> 移出这个列表；然后在图中找到关联了 <code>y</code> 和 <code>z</code> 的结点，如果没有的话就创建关联了 <code>y_0</code> 或 <code>z_0</code> 的空结点表示初始值。然后看一下有没有某个结点已经表示了 <code>y</code> 和 <code>z</code> 的相加，如果有的话直接将 <code>x</code> 加入到对应的列表中， 否则创建新结点。可以注意到这样的性质：每个结点关联的列表是不相交的。这个列表称为 <strong>定值变量表</strong>。</p><p>有些变量在一个基本块后面还会被用到，称为 <strong>活跃变量</strong>。对于由基本块得到的图，如果某个结点的定制变量表中所有的变量都是非活跃的，并且这个结点不被依赖，则可将其删除；重复这个过程就可以删除一部分的无用代码。</p><p>这个图中有些结点会处于特殊的 <strong>杀死</strong> 状态，这种状态的产生可能是出现了形如 <code>x[y] = z</code> 的数组赋值，随后所有对 <code>x[w]</code> 的使用，即时之前已经计算过 <code>x[w]</code> 的值也不能视作是公共子表达式。当处理 <code>x[y] = z</code> 后需要杀死所有依赖于 <code>x</code> 的结点，这些结点无法使用定制变量表进行优化。</p><h3 id="图的信息和使用"><a href="#图的信息和使用" class="headerlink" title="图的信息和使用"></a>图的信息和使用</h3><p>从图中可以得到一些基本块的信息，例如哪些变量在赋值前被引用过；哪些计算结果可以在基本块外使用等。</p><p>使用这张图可以对基本块进行重组。由于每个结点关联了若干变量，但是它们的值是相同的，所以可以只计算出其中一个变量的值来。这个变量的选取依据是 <strong>尽量选取活跃的变量</strong>，其它的变量的值可以不求，直接使用这个变量代替；如果有多个活跃变量，应该使用赋值语句让其它变量和这个变量的值相同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 15</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-15/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-15/</url>
      
        <content type="html"><![CDATA[<h1 id="运行存储分配"><a href="#运行存储分配" class="headerlink" title="运行存储分配"></a>运行存储分配</h1><h2 id="运行存储分配概述"><a href="#运行存储分配概述" class="headerlink" title="运行存储分配概述"></a>运行存储分配概述</h2><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><p>在编译过程中需要对各种变量和结构进行内存的分配。如果这些结构的内存分配可以在编译阶段完成，这样的分配策略称为 <strong>静态分配</strong>，如果在编译时无法完成分配，需要在运行时进行确定则称为 <strong>动态分配</strong>。在动态分配时，可以进行 <strong>栈式内存分配</strong> 或 <strong>堆式内存分配</strong>。</p><h3 id="活动记录"><a href="#活动记录" class="headerlink" title="活动记录"></a>活动记录</h3><p>函数的每次执行称作一个 <strong>活动</strong>，<strong>活动记录</strong> 指的是函数每次执行时对应被分配的内存区域。这个概念应该是对栈帧的抽象。</p><p>活动记录中会存放实参、返回值、控制链（指向调用者的活动记录）、访问链（指向其它活动记录，后面会用到）、保存的状态、局部变量和临时变量。</p><p><strong>同一个函数的活动记录不一定是定长的</strong>，栈上也可以进行动态内存分配，此时一般要将变长数据放在最后面（栈顶）。这样分配的内存具有更好的 locality，并且清理的时候代价更小。</p><h2 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h2><p>有些语言（BASIC 和 FORTRAN）可以完全使用静态存储分配，只要：</p><ul><li>数组定长</li><li>过程无法递归调用（直接和间接都不行）</li><li>不能动态建立数据实体</li></ul><h3 id="顺序分配法"><a href="#顺序分配法" class="headerlink" title="顺序分配法"></a>顺序分配法</h3><p>这种分配方法比较简单，就是对每个函数指定一个固定大小、固定位置的区域。这些区域彼此不会相交。在运行时如果这个函数被调用这个区域就会作为它的工作内存。</p><h3 id="层次分配法"><a href="#层次分配法" class="headerlink" title="层次分配法"></a>层次分配法</h3><p>上面那种方法会有内存的浪费，这种分配方式需要分析出函数之间的调用关系，然后建立一棵调用树。因为禁止递归调用，所以这样的调用关系一定是无环的，可以形成一棵树。</p><p>随后给对应的函数分配内存区域，但是不同的函数的内存区域会相交，相交的这些内存区域对应的函数不会出现调用关系即可。例如如果两个函数在调用树中都只出现了一次并且是兄弟结点，就可以重叠分配。</p><h2 id="栈式存储分配"><a href="#栈式存储分配" class="headerlink" title="栈式存储分配"></a>栈式存储分配</h2><h3 id="活动树"><a href="#活动树" class="headerlink" title="活动树"></a>活动树</h3><p>活动树就是展示函数调用关系的树。</p><hr><p>在使用栈式存储分配的时候会有一个控制栈。运行时，每个活动在栈中都有自己的活动记录。大部分以函数为单位的语言都是这样进行分配的，例如 C。所以这里就不写栈式存储分配在运行时具体怎么操作的了。</p><p>在这样的分配方式下，活动记录的设计一般有如下的原则：</p><ul><li>在调用者和被调用者之间的传递的值会尽可能靠近两个活动记录的边界</li><li>固定长度的项目位于活动记录中间</li><li>变长的项目位于活动记录的最后</li><li>每个活动记录会有一个用来寻找该活动记录中局部变量的基指针，这个指针位于固定长度项目和变长项目边界上</li></ul><h2 id="调用序列和返回序列"><a href="#调用序列和返回序列" class="headerlink" title="调用序列和返回序列"></a>调用序列和返回序列</h2><p><strong>调用序列</strong> 是函数开始调用前进行的工作，<strong>返回序列</strong> 是函数调用完成后进行的收尾工作。这两种序列都是调用者和被调用者配合完成的。</p><h3 id="调用序列"><a href="#调用序列" class="headerlink" title="调用序列"></a>调用序列</h3><p>向添加被调函数的活动记录。</p><ul><li>调用者计算实参</li><li>调用者将返回地址放入被调函数保存的状态中、修改基址寄存器</li><li>被调用者保存寄存器值和其他状态信息、初始化局部变量、开始执行</li></ul><p>此外调用序列会建立 <strong>访问链</strong>，见下文。</p><h3 id="返回序列"><a href="#返回序列" class="headerlink" title="返回序列"></a>返回序列</h3><ul><li>被调用者将返回值放入自己活动记录的指定位置</li><li>被调用者恢复调用者的基址寄存器、通过返回地址返回到调用者</li><li>调用者获取返回值，继续执行</li></ul><h2 id="非局部数据的访问"><a href="#非局部数据的访问" class="headerlink" title="非局部数据的访问"></a>非局部数据的访问</h2><h3 id="嵌套深度"><a href="#嵌套深度" class="headerlink" title="嵌套深度"></a>嵌套深度</h3><p>有些语言可以在函数中继续定义函数，例如 Pascal。这种语言中，在函数 f 内部定义的函数 g 可以访问 f 中的局部变量，对于 g 来说这些变量就像是全局的变量一样。</p><p>对于最外层的函数，定义其嵌套深度为 1。如果 g 的定义在 f 中，则 g 的嵌套深度比 f 多 1。</p><h3 id="无嵌套语言的存储分配"><a href="#无嵌套语言的存储分配" class="headerlink" title="无嵌套语言的存储分配"></a>无嵌套语言的存储分配</h3><p>这样的语言变量只有全局和局部两种，全局变量放静态区域，局部变量使用动态内存分配即可。全局变量通过静态的地址访问，局部变量通过运行时活动记录对应的基地址进行访问。</p><h3 id="有嵌套语言的存储分配"><a href="#有嵌套语言的存储分配" class="headerlink" title="有嵌套语言的存储分配"></a>有嵌套语言的存储分配</h3><p>使用前面预留给每个活动记录的 <strong>访问链</strong> 可以实现过程嵌套的语言中内层函数对外层函数局部变量的访问。如果函数 f 内部定义了函数 g，则运行时，<strong>函数 g 的任意活动的访问链都指向最近的函数 f 的活动记录</strong>。</p><h3 id="如何建立访问链"><a href="#如何建立访问链" class="headerlink" title="如何建立访问链"></a>如何建立访问链</h3><p>如果函数 f 调用函数 g，可能有三种情况：</p><ul><li>f 的嵌套深度比 g 小（相当于外层调内层）：此时函数 g 必然在 f 中直接定义，只要在调用 g 时，将 g 的访问链设置为指向上一个活动记录即可。</li><li>f 的嵌套深度和 g 相同（同层函数或者直接递归）：此时直接复制访问链即可。</li><li>f 的嵌套深度比 g 大（相当与内层调外层）：此时 g 的访问链的设置需要 <strong>沿着访问链</strong> 进行查找（注意不是在活动栈中进行查找）。如果 f 的嵌套深度是 a，g 的嵌套深度是 b，只要沿着访问链走 (b - a + 1) 步就可以到达直接定义了 g 的函数。</li></ul><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>对于每个函数（也有可能是作用域）都需要建立一张单独的符号表。符号表中也可以存放指向这个函数中定义的其它函数的符号表的指针。符号表会有一个指针指向这个函数外部那个函数的符号表。</p><p>在定义符号时，如果当前符号表中存在同名符号，表示符号重定义，否则可以正常定义；在使用符号时，如果当前符号表中存在则可正常使用，否则应该查找外部的那个符号表中是否有对应的符号，可以一直这样查找下去。</p><h2 id="符号表的建立"><a href="#符号表的建立" class="headerlink" title="符号表的建立"></a>符号表的建立</h2><p>这个没什么好记录的，算法比较直接。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 14</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-14/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-14/</url>
      
        <content type="html"><![CDATA[<h1 id="中间代码生成-4"><a href="#中间代码生成-4" class="headerlink" title="中间代码生成-4"></a>中间代码生成-4</h1><h2 id="布尔表达式的回填"><a href="#布尔表达式的回填" class="headerlink" title="布尔表达式的回填"></a>布尔表达式的回填</h2><p>回填指的是在生成跳转语句之类的语句的时候要跳转的目标暂时不能确定，此时会将“生成的跳转语句在哪里”这个信息记录下来，在后续的翻译过程中在适当的时候重新填入跳转目标。</p><p><em>为什么会出现这样的技术，我个人的感觉是使用自底向上进行分析时对语法树的遍历实际上是一种后序遍历，这种遍历其实是不太灵活的（在写完了编译原理的作业后有了这种感觉，对于 ANTLR 来说显然 visitor 模式比 listener 模式具有更高的灵活性，如果采用 listener 模式的话估计也要用回填才能解决跳转目标的问题，但是使用 visitor 模式可以通过指定遍历顺序来避免掉这个问题）。为了能够在保证遍历顺序是一遍后序遍历的情况下生成正确的中间代码就需要引入这种看起来不太自然的技术。</em></p><p>这一节讲的是如何生成复合的布尔表达式，<del>对于这种复合的布尔表达式居然不是使用算符优先级计算出最后的布尔值，而是通过各种跳转来到达最后的目的地址。不是很理解为什么需要使用这么诡异的方式</del> 使用各种跳转来完成计算是为了实现短路求值。</p><p>对于布尔表达式中的每个子表达式，它都有两个综合属性 <code>FalseList</code> 和 <code>TrueList</code>，这是两个集合，元素分别是翻译过程中未填写跳转目标的那些语句的编号（<code>FalseList</code> 中存的是会往假出口跳转的那些语句的编号）。</p><p>一些例子及其解释：</p><ul><li>$B\rightarrow E_1\mbox{relop} E_2\{a_1\}$，其中 $a_1$ 动作为生成两条跳转（不指定目标），第一条在条件为真时执行，放入 $B$ 的 <code>TrueList</code> 中；第二条在条件为假时执行，放入 <code>FalseList</code> 中。注意 $E_1\mbox{relop}E_2$ 已经是“原子性”的了，不会为复合布尔表达式的一部分。</li><li>$B\rightarrow(B_1)\{a_1\}$，将 $B_1$ 的两个综合属性直接复制到 $B$ 中。</li><li>$B\rightarrow B_1 \mbox{ or } MB_2\{a_1\}, M\rightarrow \epsilon\{a_2\}$，其中 $a_2$ 动作是将下一条要生成的语句（实际上就是 $B_2$ 的第一条语句）的编号放在 $M$ 的某个综合属性 <code>quad</code> 中；$a_1$ 动作是将 $M$ 的 <code>quad</code> 属性填入 $B_1$ 的 <code>FalseList</code> 中（这样的话 $B_1$ 为假就会开始判定 $B_2$，并将 $B_1$ 和 $B_2$ 的 <code>TrueList</code> 合并作为 $B$ 的 <code>TrueList</code>（如果两个任意一个满足应该会跳转到 $B$ 的真出口），随后将 $B_2$ 的 <code>FalseList</code> 作为 $B$ 的 <code>FalseList</code>（注意如果执行到了 $B_2$ 的 <code>FalseList</code> 中的某个元素，则必然 $B_1$ 为假）。</li></ul><p>其它情况略去，大致思想就是上面那样。</p><h2 id="控制流语句的回填"><a href="#控制流语句的回填" class="headerlink" title="控制流语句的回填"></a>控制流语句的回填</h2><p>除了布尔表达式，凡是带有跳转的语句都可以使用到回填技术。</p><p>为此，需要对每个语句 $S$（可能是复合语句）设置一个综合属性 <code>NextList</code>，它是一个集合，元素是这个语句翻译出的中间表示的那些跳转指令中，需要跳转到 $S$ 的后续第一条指令的那些跳转指令的编号。</p><p>一些例子和解释：</p><ul><li>$S\rightarrow\mbox{if }B\mbox{ then }M_1S_1N\mbox{ else }M_2S_2\{a_1\}$，其中两个标记非终结符 $M$ 是将生成的下一条语句放入自己的 <code>quad</code> 综合属性中：这个是希望翻译条件跳转语句。$a_1$ 动作是将 $M_1$ 的 <code>quad</code> 填入 $B$ 的 <code>TrueList</code> 中，将 $M_2$ 的 <code>quad</code> 放入 $B$ 的 <code>FalseList</code> 中，将 $S_1,S_2,N$ 的 <code>NextList</code> 合并作为 $S$ 的 <code>NextList</code>。标记非终结符 $N$ 的动作是生成一条未指明目的的跳转语句，并放入自己的 <code>NextList</code> 中（防止 $S_1$ 运行完了之后又开始运行 $S_2$）。</li><li>$S\rightarrow \mbox{while }M_1B\mbox{ do }M_2S_1\{a_1\}$，其中两个标记非终结符 $M$ 是将生成的下一条语句放入自己的 <code>quad</code> 综合属性中：这个是希望翻译循环语句。$a_1$ 动作是将 $M_1$ 的 <code>quad</code> 填入 $S_1$ 的 <code>NextList</code> 中，将 $M_2$ 的 <code>quad</code> 填入 $B$ 的 <code>TrueList</code> 中，将 $B$ 的 <code>FalseList</code> 赋给 $S$ 的 <code>NextList</code>，随后生成一条跳向 $M_1$ 的 <code>quad</code> 的跳转指令。</li><li>$S\rightarrow S_1MS_2\{a_1\}$：两条语句如何进行操作，其实很简单的。$M$ 会生成一条语句放入自己的 <code>quad</code> 属性，$a_1$ 操作就是将 $M$ 的 <code>quad</code> 填入 $S_1$ 的 <code>NextList</code>，将 $S_2$ 的 <code>NextList</code> 作为 $S$ 的 <code>NextList</code>。</li></ul><h2 id="switch-语句的翻译"><a href="#switch-语句的翻译" class="headerlink" title="switch 语句的翻译"></a>switch 语句的翻译</h2><p>这节没什么新的地方，switch 语句的翻译有两种方案：</p><ul><li>逐个翻译各个 case。进入后依次判断各个 case 是否成立，如果成立的话就不跳转开始执行 case 对应的代码，否则跳转到下一个 case 进行判断。执行完对应的 case 后统一跳转到某个出口语句。</li><li>也是逐个翻译各个 case。但是进入后向跳转到一个集中化的专门负责选择 case 的地方，这个地方对各个 case 进行匹配，如果匹配跳转到对应的 case 代码，否则不跳转，匹配下一个 case。这样做有利于生成更加高效的 case 选择指令。</li></ul><h2 id="过程调用语句的翻译"><a href="#过程调用语句的翻译" class="headerlink" title="过程调用语句的翻译"></a>过程调用语句的翻译</h2><p>这节主要讲的就是在进行过程调用的时候可以维护一个参数的队列。对于计算出的每个参数（参数可能是以表达式的形式给出的，因此需要额外的计算代码），将这个参数压入队列中。当所有参数计算完毕后，从队列中取出所有的已计算参数，然后执行过程调用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 13</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-13/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-13/</url>
      
        <content type="html"><![CDATA[<h1 id="中间代码生成-3"><a href="#中间代码生成-3" class="headerlink" title="中间代码生成-3"></a>中间代码生成-3</h1><h2 id="控制流语句及其-SDT"><a href="#控制流语句及其-SDT" class="headerlink" title="控制流语句及其 SDT"></a>控制流语句及其 SDT</h2><p>控制流语句分为顺序语句、条件语句和循环语句。条件语句有 <code>if a then b</code> 和 <code>if a then b else c</code> 两种，循环语句格式为 <code>while a b</code>。构造其 SDT 时需要在条件语句的条件中引入条件为真和条件为假时应该跳转的地址；在循环语句的条件中引入条件继续满足和不再满足时应当跳转的地址。</p><h2 id="布尔表达式及其-SDT"><a href="#布尔表达式及其-SDT" class="headerlink" title="布尔表达式及其 SDT"></a>布尔表达式及其 SDT</h2><p>布尔表达式就是使用 <code>true</code>、<code>false</code>、两个表达式的比较和与或非以及括号构造出的表达式，最后的结果要么为真要么为假。如果布尔表达式只会被用于流程控制中，那么可以将整个表达式拆成多个运算过程，每个运算过程结束后都执行一次跳转。这样做会导致各种逻辑运算符不出现在翻译后的代码中，翻译后的代码使用小的条件语句来实现宏观的逻辑上的逻辑运算。<del>不过我觉得这种做法不好，它把布尔表达式和其它的算术表达式的统一性破坏掉了。</del> 这样处理的目的是实现短路求值，因此不能和普通的算术表达式作类似处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 12</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-12/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-12/</url>
      
        <content type="html"><![CDATA[<h1 id="中间代码生成-2"><a href="#中间代码生成-2" class="headerlink" title="中间代码生成-2"></a>中间代码生成-2</h1><h2 id="简单赋值语句的翻译"><a href="#简单赋值语句的翻译" class="headerlink" title="简单赋值语句的翻译"></a>简单赋值语句的翻译</h2><p>这节比较简单，讲的是如何将赋值语句翻译为三地址码的形式。唯一值得一提的是 <strong>增量翻译</strong> 的技术。如果翻译过程中有一个综合属性的计算有这样的特征：父结点的综合属性实际上就是各个子结点的综合属性拼接后在加上父结点的特定的信息，那么可以将这样的属性放在一个全局的地方来避免每次都要复制的情况。</p><h2 id="数组引用的翻译"><a href="#数组引用的翻译" class="headerlink" title="数组引用的翻译"></a>数组引用的翻译</h2><p>这节比较简单，主要就是计算出要访问的数组所在的地址。为了达到这个目的需要在一些非终结符中存入数组的类型（使用类型表达式）、首地址和偏移量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 11</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-11/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-11/</url>
      
        <content type="html"><![CDATA[<h1 id="中间代码生成-1"><a href="#中间代码生成-1" class="headerlink" title="中间代码生成-1"></a>中间代码生成-1</h1><p>中间代码生成重点在于各种语句如何进行翻译。下面两节面向的是声明语句的翻译。个人感觉这附近都是在说语法制导翻译的具体应用形式，没有多少理论上的东西了。</p><h2 id="类型表达式"><a href="#类型表达式" class="headerlink" title="类型表达式"></a>类型表达式</h2><p>为了知道声明语句如何翻译，需要搞清楚类型和类型表达式。</p><p>类型表达式实际上表示的就是一个特定的类型。平时在高级语言里面写的 <code>int a[50]</code> 这种实际上是一种语法糖，<code>a</code> 的类型是 <code>int[50]</code>，类型表达式就是要让 <code>int[50]</code> 这种表述更加底层。</p><p>基本类型都是类型表达式，也就是说 <code>int</code> 和 <code>void</code> 这种就是一个完整的类型表达式。</p><p>复合类型可以通过更加基础的类型表达式通过 <strong>类型构造符</strong> 得到，几个常用的类型构造符如下：</p><ul><li><strong>数组构造符</strong>：例如 <code>int[50][20]</code> 实际上对应着一个类型表达式 $array(50, array(50, int))$。</li><li><strong>指针构造符</strong>：例如 <code>int**</code> 实际上对应着一个类型表达式 $pointer(pointer(int))$。</li><li><strong>笛卡儿积构造符</strong>：我觉得这个构造符用于某些语言中的匿名元组，例如 <code>(int, bool)</code> 对应着 $int\times bool$，注意这个构造符在这里是中缀的。</li><li><strong>函数构造符</strong>：这个构造符接收两个类型表达式，得到一个新的类型表达式表示函数。比如 <code>function&lt;int(bool)&gt;</code> 对应着 $bool\rightarrow int$，如果有多个参数的话可以使用笛卡儿积打包。</li><li><strong>记录构造符</strong>：实际上就是结构体的构造符，使用若干笛卡儿积记录每个记录中域的名称和类型（不知道为什么要单独列出来）。</li></ul><p>通过这些构造符和基本类型基本上可以构造出语言中出现得了的类型了。</p><h2 id="声明语句的翻译"><a href="#声明语句的翻译" class="headerlink" title="声明语句的翻译"></a>声明语句的翻译</h2><p>对于声明语句，语义分析的目的就是找到声明的变量的名字、类型、宽度，并将这些信息存放到符号表中。在语义分析过程中还能够为这些声明出的变量提供相对地址，相对地址也存放在符号表中。</p><p>每当语义分析过程中发现了一个新的变量的时候就可以在符号表中分配新的入口了，这个分配过程可以看作是某种副作用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 10</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-10/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-10/</url>
      
        <content type="html"><![CDATA[<h1 id="语法制导翻译-3"><a href="#语法制导翻译-3" class="headerlink" title="语法制导翻译-3"></a>语法制导翻译-3</h1><p>以下两节讨论的是如何实现 L-SDD 对应的翻译过程。</p><h2 id="在递归的预测分析过程中进行翻译"><a href="#在递归的预测分析过程中进行翻译" class="headerlink" title="在递归的预测分析过程中进行翻译"></a>在递归的预测分析过程中进行翻译</h2><p>在之前使用递归对 LL 文法进行预测分析时，每个非终结符都对应一个过程，这个过程没有参数也没有返回值（实现上可能不是这样，但是逻辑上是这样的）。现在要实现 L-SDD 时，需要做一些修改：</p><ul><li><p>对于每个非终结符，它对应的过程现在会接收参数，参数为这个非终结符的继承属性。这个过程应该返回该终结符的综合属性。在之前的笔记中已经指出继承属性在非终结符分析前得出，综合属性在非终结符分析后得出，这么做是合理的。</p></li><li><p>在每个非终结符对应的过程内部，会以局部变量的形式维护要用到的所有属性（不管是不是自己的）。例如对于这个嵌入代码的产生式 $T\rightarrow F\{K.inh = F.val\}K\{T.val = K.syn\}$（其中 inh 表示继承属性，syn 表示综合属性，val 表示计算出的属性），转换为 $T$ 对应的过程就应该是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T(state) -&gt; Tval:</span><br><span class="line">    Fval = F(state)</span><br><span class="line">    Kinh = Fval</span><br><span class="line"></span><br><span class="line">    state_update(state)</span><br><span class="line"></span><br><span class="line">    Ksyn = K(state, Kinh)</span><br><span class="line">    Tval = Ksyn</span><br><span class="line"></span><br><span class="line">    state_update(state)</span><br><span class="line">    <span class="keyword">return</span> Tval</span><br></pre></td></tr></table></figure><p><code>state</code> 中存放的是当前的解析进度，可以看到这种实现方式几乎是在翻译 SDT，很直观。</p></li><li><p>在主函数中，解析初始符号得到初始符号对应的综合属性即可。此时翻译过程完成。</p></li></ul><p>这种实现方式还比较优雅。</p><h2 id="L-属性定义的自底向上翻译"><a href="#L-属性定义的自底向上翻译" class="headerlink" title="L-属性定义的自底向上翻译"></a>L-属性定义的自底向上翻译</h2><p>这里涉及的是如何使用 LR 分析技术解决 LL 文法对应的语言，因为自底向上翻译一般处理的是 LR 文法。</p><p>在 S-SDD 中使用自底向上翻译时，对应的状态栈和符号栈旁边会有一个属性栈。对于 L-SDD，也是如此。</p><p>对于一个 L-SDD，可以通过如下的转换使得所有的语义动作都位于产生式的末尾，这个过程会改写文法。例如对于 $A\rightarrow \{a_1\}B\{a_2\}$，引入产生式 $M\rightarrow \epsilon \{a_1&#39;\}$ 即可将原来的产生式变换到 $A\rightarrow MB \{a_2\}$。这个产生式的语义动作实际上完成了它替换掉的那个语义动作要做的事情。这样引入的非终结符称为 <strong>标记非终结符</strong>。当然想想就知道变化完了之后肯定不是 S-SDD，这是因为 $a_1&#39;$ 能够处理的操作比 $a_1$ 要少，$a_1$ 要处理的可能是计算 $B$ 的某个继承属性，但是变化完成后 $a_1&#39;$ 逻辑上不能访问到 $B$，它只能计算出 $M$ 的综合属性。但是因为这个产生式被专用，所以实现上可以让 $a_1&#39;$ 能够访问到 $B$，只不过不太干净罢了。</p><p>形式上来讲所有的语义动作都位于产生式的末尾了，就可以像 S-SDD 中那样操作，<strong>每次归约时执行语义动作</strong>。变换完成后，对于每个产生式都可以静态地（不依赖于具体的语言组成）写出每个产生式对应的执行过程（可以实际执行的对栈的操作）。需要注意的是，对于引入的标记非终结符，它对应的那个语义动作，会将该标记非终结符左边的那些符号的属性复制一下作为为自己的继承属性，并计算出一个综合属性。这个综合属性实际上就是标记非终结符右边的那个符号 $B$ 想要将计算的继承属性。因此如果后续的处理过程中需要用到 $B$ 的继承属性的话要找的是标记非终结符的综合属性。问题是每次是否都能找到呢？实际上 $M$ 就在 $B$ 的左边，因此实际实现和运行中这个综合属性一定能够轻松找到。</p><p>由于引入的标记非终结符推导出空串，所以标记非终结符进行归约是每次都是往栈里面压入了一个新的元素。实际上可以将这个压入的元素看作是某种存放了它右边那个符号的继承属性的特殊元素容器，当后面的符号要引用前面的符号的属性时，不管是继承属性（此时是对应标记非终结符的综合属性）还是综合属性（此时就是对应符号的综合属性）都能够找到。这样说就比较说得通了。</p><p>这一节因为没有看到代码实现，所以自己实际上只有概念和方法上的了解。一些细节的地方估计有疏漏。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 9</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-9/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-9/</url>
      
        <content type="html"><![CDATA[<h1 id="语法制导翻译-2"><a href="#语法制导翻译-2" class="headerlink" title="语法制导翻译-2"></a>语法制导翻译-2</h1><h2 id="语法制导翻译方案-SDT"><a href="#语法制导翻译方案-SDT" class="headerlink" title="语法制导翻译方案 SDT"></a>语法制导翻译方案 SDT</h2><p>语法制导翻译方案是在产生式右部嵌入了程序片段（语义动作）的 CFG。</p><p>S-SDD 和 L-SDD 可以在以下两种情况中轻易地使用 SDT 实现：</p><ul><li>文法可以使用 LR 分析技术，SDD 是 S 属性的</li><li>文法可以使用 LL 分析技术，SDD 是 L 属性的</li></ul><h3 id="使用-SDT-实现-S-SDD"><a href="#使用-SDT-实现-S-SDD" class="headerlink" title="使用 SDT 实现 S-SDD"></a>使用 SDT 实现 S-SDD</h3><p>S-SDD 使用的属性都是综合属性，对于每个产生式计算属性都是在计算产生式左部的符号的属性，只要将计算过程嵌入到整个产生式最右部即可。</p><p>例如对产生式 $T\rightarrow T_1\ast F$ 以及对应的语义规则 $T.val = T_1.val \times F.val$，在 SDT 中这个规则就是 $T\rightarrow T_1\ast F\{T.val = T_1.val \times F.val\}$。</p><p>使用 SDT 实现 S-SDD 时，如果对应的文法使用 LR 分析进行了语法分析，那么对应的语义属性的计算可以在语法分析过程中完成。使用 LR 分析时使用到了符号栈和状态栈，可以设置一个平行的 <strong>属性栈</strong> 用来存放符号栈中对应位置的符号的综合属性。因为 S-SDD 的特性，可以在语法分析过程中发生归约时计算处归约到的符号的综合属性，查看对应的语义规则，将属性栈中位于顶层的若干属性弹出，计算完毕后压入栈中即可。<strong>属性栈、符号栈、状态栈中的元素数目一般情况下是相同的。</strong></p><h3 id="使用-SDT-实现-L-SDD"><a href="#使用-SDT-实现-L-SDD" class="headerlink" title="使用 SDT 实现 L-SDD"></a>使用 SDT 实现 L-SDD</h3><p>L-SDD 使用的属性是综合属性或者受限的继承属性，对于每个产生式计算属性都是在计算产生式左部的符号的综合属性或者右部符号的继承属性，只要将计算过程嵌入到整个产生式右部相应位置即可。</p><p>如果这个语义规则计算的是产生式左部符号综合属性，就把语义规则嵌入到产生式末尾；如果这个语义规则计算的是右部某个符号 $A$ 的继承属性，那么它会依赖于产生式右部中位于该符号左边的符号的属性，因此可以将语义规则嵌入到 $A$ 的左边并紧邻 $A$。由于这个计算过程中可能还要依赖自己的属性，所以嵌入的时候要按照某种拓扑序进行嵌入。</p><p>例如对产生式 $T\rightarrow FT&#39;$ 和语义规则 $T&#39;.inh = F.val; T.val = T&#39;.syn$，在 SDT 中这个规则就是 $T\rightarrow F\{T&#39;.inh = F.val\}T&#39;\{T.val = T&#39;.syn\}$。</p><p>如果 L-SDD 的文法可以使用 LL 分析技术，那么它的 SDT 可以在 LL 语法分析过程或 LR 语法分析过程中实现。对应地有三种实现方式：</p><ul><li>在非递归的预测分析法中继行语义翻译</li><li>在递归的预测分析法中继行语义翻译</li><li>在 LR 分析过程中实现语义翻译</li></ul><h2 id="在非递归的预测分析过程中进行翻译"><a href="#在非递归的预测分析过程中进行翻译" class="headerlink" title="在非递归的预测分析过程中进行翻译"></a>在非递归的预测分析过程中进行翻译</h2><p>预测分析就是说在 LL 分析过程中往前看若干个符号就知道要使用哪个产生式。非递归的实现使用到了一个存放终结符和非终结符的栈。</p><p>为了使用非递归的预测分析技术实现 L-SDD，需要在栈中引入更多种类的元素，分别是 <strong>表示语义动作的元素</strong> 和 <strong>表示综合属性</strong> 的元素；此外，对于每个元素还需要一个结构来维护它的属性信息。对于以下的嵌有语义动作的产生式 $A\rightarrow\{a_1\}\beta_1\{a_2\}\beta_2\{a_3\}\beta_3\{a_4\}$，其中 $a_i$ 是动作，根据前面的原则，$a_1\cdots a_3$ 计算的是各自右边的符号的继承属性，而 $a_4$ 计算的是 $A$ 的综合属性。</p><p>现在假设栈顶存放的元素就是 $A$，并且根据预测分析，要使用的产生式就是上面的产生式，那么应该有这些元素被压入栈中（左边栈顶）：$\{a_1\}\rightarrow \beta_1\rightarrow \beta_{1,syn}\rightarrow\{a_2\} \rightarrow \beta_2\rightarrow \beta_{2, syn} \rightarrow \{a_3\} \rightarrow \beta_3\rightarrow \beta_{3, syn} \rightarrow \{a_4\}$。其中 $\beta_{i, syn}$ 表示计算 $\beta_i$ 的综合属性（如果需要的话），因为对于一个符号来讲它的综合属性应该是在解析完成后被求出，而继承属性应该在开始解析前被求出（它的解析过程中以它为左部的产生式会用到它的继承属性），这个顺序是科学的。</p><p>大体的思路其实和非递归预测分析的算法差不多，不同之处在于：</p><ul><li>当栈顶的符号是表示语义动作的元素时（如 $\{a_1\}$），执行这个语义动作然后弹出该元素。一个典型的动作会计算其它元素的属性。通过一些适当的设置可以让这个元素存放的是指向某个函数的指针从而让代码可以直接被执行，函数中会直接访问栈。</li><li>当栈顶的符号是表示综合属性的元素时（如 $\beta_{2, syn}$），弹出这个综合属性。<strong>但是</strong>，有些属性的计算会使用到这个综合属性，因此弹出前需要先把它的属性备份到那些语义动作元素中，这些语义动作元素应该位于栈中。具体是要备份到哪些语义动作元素中其实是静态的，它只依赖于这个符号被压入栈中时是随着哪一条产生式被压入的。例如，如果当前的栈顶符号是 $\beta_{2, syn}$ 并且正要出栈，那么会用到它的语义动作元素只可能是 $\{a_3\}$ 或者 $\{a_4\}$，把 $\beta_{2, syn}$ 对应的信息给它们就行了。这就使得这些表示综合属性的元素自己也存放某种策略性的东西来制导它们该如何退栈。</li><li>当栈顶符号是非终结符时（如 $A$），原来的操作是将它退栈并将要使用的产生式右部的符号压栈。但是右部符号中某些属性的计算可能依赖于这个退栈的非终结符的继承属性，因此需要和上一点一样做一些备份。不同的是需要将这个继承属性备份到还没有压入栈中的元素，也就是说可能需要某种压栈完成后再执行备份功能的机制。这个决策过程依然是静态的。</li><li>当栈顶符号是终结符时，正常操作。另外，其实如果产生式中有终结符，压栈的时候可以不压入对应的终结符对应的综合属性的元素，不过我觉得为了统一性可以这么搞。</li></ul><p>上面所说的静态，指的是给定了 SDT 后实际上就已经可以对于每个产生式（含嵌入代码）中的每个符号得到它出栈的时候应该执行的动作，和运行时得到的语言输入无关。</p><p>我觉得这个算法不太优雅，为啥一个栈里面会有几种不同元素还得动态改变操作的？希望剩下两个算法看着舒服点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 8</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-8/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-8/</url>
      
        <content type="html"><![CDATA[<h1 id="语法制导翻译-1"><a href="#语法制导翻译-1" class="headerlink" title="语法制导翻译-1"></a>语法制导翻译-1</h1><h2 id="语法制导翻译概述"><a href="#语法制导翻译概述" class="headerlink" title="语法制导翻译概述"></a>语法制导翻译概述</h2><h3 id="语法制导翻译思路"><a href="#语法制导翻译思路" class="headerlink" title="语法制导翻译思路"></a>语法制导翻译思路</h3><p>编译过程中经过词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成这些步骤。语义分析完成后需要某种中间表示作为中间代码生成的输入，如果这种中间表示就是中间代码的话，这两步可以合成一步叫做 <strong>语义翻译</strong>；语法分析的结果需要写成某种中间表示作为语义翻译的输入，如果这两步合成一起的话就叫做 <strong>语法制导翻译</strong>。</p><p>其实最关键的问题在于如何表示语义。语法制导翻译使用 CFG 引导对语言的翻译。CFG 中的每个文法符号（终结符和非终结符）都会有自己的 <strong>语义属性</strong>，这个属性实际上就是一种对语义的表示。语义属性的计算需要用到 <strong>语义规则</strong>，语义规则往往和产生式（这里有个牛逼名字叫 <strong>语法规则</strong>）关联在一起。</p><p>如果需要得到一个词法单元流的语义信息，应该先构建它的语法分析树，然后按照各个产生式对应的语义规则计算出每个结点中对应的符号的语义属性，这样做的话实际上每个结点都会具有自己的语义属性。</p><h3 id="语法制导定义和语法制导翻译方案简介"><a href="#语法制导定义和语法制导翻译方案简介" class="headerlink" title="语法制导定义和语法制导翻译方案简介"></a>语法制导定义和语法制导翻译方案简介</h3><p>语法制导定义（Syntax-Directed Definitions，SDD）是一套语法制导翻译的规则，它如上面描述的一样：</p><ul><li>对文法每个符号关联了若干个语义属性</li><li>对文法的每个产生式（语法规则）关联了若干个语义规则，这些语义规则将用来计算对应的产生式中符号的各个语义属性。</li></ul><p>表示上，对于一个符号 $X$ 的属性 $a$，使用 $X.a$ 来表示这个符号的属性。一个产生式中如果有多个同名符号会加下标以示区别。</p><p>一个示例是如下的文法以及对应的语义属性和语义规则（声明多个变量）：</p><script type="math/tex; mode=display">\begin{array}{cccc}\begin{aligned}D\rightarrow & TL             & L.type   & = T.type        \\T\rightarrow & \texttt{int}   & T.type   & = \texttt{int}  \\T\rightarrow & \texttt{real}  & T.type   & = \texttt{real} \\L\rightarrow & L_1, \mbox{id} & L_1.type & =  L.type\end{aligned}\end{array}</script><p>可以看到语法制导定义以一种 <strong>定义的形式</strong> 给出了各个符号的语义属性和这些属性的计算规则，但是具体怎么实现并没有说明。语法制导翻译方案（Syntax-Directed Translation Scheme，SDT）更进一步，在 SDD 的基础上将何时计算语义属性和计算方式以程序片段伪码（称作 <strong>语义动作</strong>）形式嵌入到了产生式中，使得 SDD 的实现方式被显式指明。</p><h2 id="语法制导定义-SDD"><a href="#语法制导定义-SDD" class="headerlink" title="语法制导定义 SDD"></a>语法制导定义 SDD</h2><h3 id="综合属性与继承属性"><a href="#综合属性与继承属性" class="headerlink" title="综合属性与继承属性"></a>综合属性与继承属性</h3><p>对于每个符号，在处于语法分析树上的某个结点时，它的属性的计算有可能会依赖于其它结点的属性或者自己的其它属性。</p><p>对于一个非终结符，在语法分析树上，如果它的某个属性的计算只依赖于它本身的属性值以及它的子结点的属性值，这样的属性称作 <strong>综合属性</strong>。终结符也可以有综合属性，但是这种综合属性是由词法分析器提供的，不是由语义规则计算得出。</p><p>对于一个非终结符，在语法分析树上，如果它的某个属性的计算只依赖于它本身的属性值以及它的父结点和兄弟结点的属性值，这样的属性称作 <strong>继承属性</strong>。终结符没有继承属性值，因为它所有的属性都是综合属性。</p><p>注意按照上面的定义一个属性不可能同时为综合属性和继承属性。综合属性和继承属性都是对结点说的，而不是对符号说的。</p><h3 id="其它一些定义"><a href="#其它一些定义" class="headerlink" title="其它一些定义"></a>其它一些定义</h3><p>在 SDD 中，语义规则可能含有 <strong>副作用</strong>，例如修改符号表或者打印了一些内容，不是纯粹的赋值计算语句。如果一个 SDD 的任意语义规则没有副作用，这个 SDD 称作是 <strong>属性文法</strong>。属性文法中的语法规则只使用其它的语义属性和常量来计算语义属性。</p><p>当使用 SDD 时，第一步先建立了语法分析树，如果这个时候将每个结点的语义属性计算出来直接写到语法分析树的结点上，此时的语法分析树就变成了 <strong>注释分析树</strong>，即结点带有语义属性的分析树。</p><h2 id="SDD-的求值顺序"><a href="#SDD-的求值顺序" class="headerlink" title="SDD 的求值顺序"></a>SDD 的求值顺序</h2><p>SDD 对文法中的符号定义了语义属性，对产生式关联了语义规则。如何使用这些语义规则计算语义属性？</p><p>如果将一个语法分析树上的所有结点的所有语义属性列出来，会得到很多的语义属性。它们之间的依赖关系会形成一张有向图，称作 <strong>依赖图</strong>。对这个图进行拓扑排序，如果排序存在的话按照这个顺序对语义属性进行计算即可。</p><p>特别地，如果所有的属性都是综合属性，可以自底向上依次计算。</p><p>依赖图的拓扑排序可能不存在。即使一个 SDD 的所有属性都是综合属性或者继承属性，拓扑排序也可能不存在。拓扑排序存在的充要条件是图中没有环。</p><p>对于一个给定的 SDD，难以确定这个 SDD 是否会在某种情况下产生有环的依赖图。但是通过适当设计 SDD 中的语义规则可以保证依赖图无环，并且还可以使语义属性的计算过程和语法分析结合在一起高效完成。这样的例子是 <strong>S-属性</strong> 和 <strong>L-属性</strong>。</p><h2 id="S-属性定义和-L-属性定义"><a href="#S-属性定义和-L-属性定义" class="headerlink" title="S-属性定义和 L-属性定义"></a>S-属性定义和 L-属性定义</h2><h3 id="S-属性定义"><a href="#S-属性定义" class="headerlink" title="S-属性定义"></a>S-属性定义</h3><p>如果一个 SDD 中所有的属性都是综合属性，这样的 SDD 称作是 S-SDD。S-SDD 中语义属性的计算可以自底向上计算得到，并且很容易在自底向上语法分析过程中实现。</p><h3 id="L-属性定义"><a href="#L-属性定义" class="headerlink" title="L-属性定义"></a>L-属性定义</h3><p>如果一个 SDD 中的每个属性要么是综合属性，要么是 <strong>受限的</strong> 的继承属性（下面会写具体限制），则这个 SDD 称作 L-SDD。限制条件为：</p><ul><li>可以依赖父结点属性，但是只能依赖父结点的继承属性而不能是其它属性。</li><li>可以依赖兄弟结点的属性，但是只能依赖产生式中位于自己左边的那些符号的属性。</li><li>可以依赖自己的属性，但是自己的属性不能产生循环依赖。</li></ul><p>其中不能依赖父结点的综合属性是因为父结点的综合属性会依赖子结点的属性，这可能造成循环依赖。</p><hr><p>这两种属性都可以保证依赖图中没有环出现。S-属性是特殊的 L-属性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 7</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-7/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-7/</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析-4"><a href="#语法分析-4" class="headerlink" title="语法分析-4"></a>语法分析-4</h1><h2 id="SLR-分析"><a href="#SLR-分析" class="headerlink" title="$SLR$ 分析"></a>$SLR$ 分析</h2><p>$SLR$ 分析是一种 $LR$ 语法的分析方式，相对于 $LR(0)$ 语法分析主要是多考虑了一个 Follow 集的问题从而避免掉了一部分的冲突。在 $LR(0)$ 分析中有可能出现这样的情况，某个状态中有两个项目 $E\rightarrow T\cdot$ 和 $T\rightarrow T\cdot a F$ 并且压入的符号是 $a$，这个时候产生了移入-归约冲突。但是 $LR(0)$ 分析并没有往前看符号，如果这个文法中， $a$ 不在 $E$ 的 Follow 集中，那么显然使用第一个产生式是没有意义的（因为归约后的 $E$ 后面不可能是 $a$），$SLR$ 分析改进了这一点，使得类似这样的冲突得以消解。</p><h3 id="SLR-分析的核心思路"><a href="#SLR-分析的核心思路" class="headerlink" title="$SLR$ 分析的核心思路"></a>$SLR$ 分析的核心思路</h3><p>对于一个状态集，如果有状态</p><script type="math/tex; mode=display">\begin{array}{cc}\begin{align}A_1 \rightarrow & \alpha_1\cdot a_1 \beta_1 \\\vdots \\A_m \rightarrow & \alpha_m\cdot a_m \beta_m \\B_1 \rightarrow & \gamma_1\cdot \\\vdots \\B_n \rightarrow & \gamma_n\cdot \\\end{align}\end{array}</script><p>并且已知 $\{a_1,\cdots,a_m\}, \mbox{Follow}(B_1), \cdots, \mbox{Follow}(B_n)$ 两两不交，那么对于输入的符号：</p><ul><li>若在 $\{a_1,\cdots,a_m\}$ 中，则可以进行相关的 <strong>移入操作</strong>。</li><li>若在 $\mbox{Follow}(B_k)$ 中，则可以进行相关的 <strong>归约操作</strong>。</li><li>否则报错。</li></ul><p>这个修改听上去简直就是废话，不过它解决了一部分的移入归约冲突。</p><h3 id="SLR-分析表构造过程"><a href="#SLR-分析表构造过程" class="headerlink" title="$SLR$ 分析表构造过程"></a>$SLR$ 分析表构造过程</h3><p>这段从 $LR(0)$ 分析表构造过程修改而来，区别在于 3 的第三条中对 $a$ 的来源有了更加严格的限制。</p><p>对一个文法构造对应的 $SLR$ 分析表：</p><ol><li>构造增广文法 $G$</li><li>得到 $G$ 的规范 $LR(0)$ 项集族 $C$</li><li>$C$ 中的每个项目集闭包就是自动机的一个状态 $I_i$，按如下规则求分析表：<ul><li>$\mbox{if }A\rightarrow\alpha\cdot a\beta\in I_i\mbox{ and Goto}(I_i, a)=I_j\mbox{ then Action}[i, a]=\mbox{s}_j$</li><li>$\mbox{if }A\rightarrow\alpha\cdot B\beta\in I_i\mbox{ and Goto}(I_i, B)=I_j\mbox{ then Goto}[i, B]=j$</li><li>$\mbox{if }A\rightarrow\alpha\cdot\in I_i\mbox{ and }A\neq S&#39;\mbox{ then }\forall a\in \mbox{Follow}(A), \mbox{Action}[i, a]=\mbox{r}_j$，其中 $j$ 是产生式 $A\rightarrow\alpha$ 的编号，$V_T$ 是所有终结符</li><li>$\mbox{if }S&#39;\rightarrow S\cdot\in I_i \mbox{ then Action}[i, $]=acc$</li><li>其它所有情况都设为 $err$</li></ul></li></ol><p><strong>如果一个文法构造完 $SLR$ 分析表后无冲突，称为 $SLR$ 文法。</strong></p><h2 id="LR-1-分析"><a href="#LR-1-分析" class="headerlink" title="$LR(1)$ 分析"></a>$LR(1)$ 分析</h2><p>如果仔细研究 $SLR$ 的处理方式就会发现它实际上是将可以归约的情况作了一些限制，使得有时移入-归约冲突被消除了，但是这种限制加上后之后依然是某种必要条件而不是充分条件（对于一个产生式，只有下一个符号是产生式左部符号的 Follow 集中的元素时才能进行归约，但是实际上这种归约也不一定正确）。实际上可以观察到在分析的过程中，某些条件下进行归约时，这个符号不仅需要在产生符号的 Follow 集中，而且要在某个特定的子集中。</p><p>$LR(1)$ 分析对这种情况做了改进。使用 $LR(1)$ 分析时每个项目还要加上一个额外的 <strong>展望符</strong>。例如对于 $A\rightarrow\alpha \cdot$ 这个项目加上了展望符 $b$，完整的产生式是 $A\rightarrow\alpha\cdot, b$，表示如果希望在下一步中进行归约，那么未移入的第一个终结符需要是 $b$。<strong>展望符是产生式左部符号 Follow 集的子集（一般是真子集）。</strong>一个 $LR(1)$ 符号的形式为 $A\rightarrow\alpha\cdot\beta, a$，其中 $a$ 是个终结符或者结束符 $$$，表示的是 <strong>当前状态下</strong> $A$ 后面需要紧跟的终结符（因为项目总是在一个项目集中，一个项目集对应自动机的一个状态，所以一个项目会有一个当前状态）。一些注解：</p><ul><li>$LR(n)$ 指的是展望符的长度为 $n$，不过一般 1 就够用了。</li><li>如果 $\beta\neq\epsilon$，那么展望符没有意义。</li><li>如果 $\beta=\epsilon$，那么只有在下一个符号是 $a$ 的时候才能进行归约。</li></ul><h3 id="LR-1-项目的等价性"><a href="#LR-1-项目的等价性" class="headerlink" title="$LR(1)$ 项目的等价性"></a>$LR(1)$ 项目的等价性</h3><p>对于一个待约项目 $A\rightarrow \alpha\cdot B\beta, a$，并且已经知道产生式 $B\rightarrow\gamma$，则项目的一个等价项目是 $B\rightarrow\cdot\gamma, b$，其中 $b\in\mbox{First}(\beta a)$。</p><p>其中展望符产生的原因是 $\beta\Rightarrow^\star\epsilon$ 时展望符应该为 $a$（这种情况下叫 <strong>继承</strong> 的展望符），否则应为 $\mbox{First}(\beta)$（<strong>自生</strong> 的展望符）。</p><p>如果两个项目集中除去展望符部分后相同，则这两个项目集是 <strong>同心</strong> 的。</p><h3 id="Closure，Goto-以及项集族的计算"><a href="#Closure，Goto-以及项集族的计算" class="headerlink" title="Closure，Goto 以及项集族的计算"></a>Closure，Goto 以及项集族的计算</h3><ul><li>Closure 的计算变成 $\mbox{Closure}(I) = I\cup\{[B\rightarrow\cdot\gamma, b]|[A\rightarrow a\cdot B\beta, a]\in\mbox{Closure}(I), B\rightarrow\gamma\in P, b\in\mbox{First}(\beta a)\}$</li><li>Goto 的计算变成 $\mbox{Goto}(I, X) = \mbox{Closure}(\{[A\rightarrow\alpha X\cdot \beta, a]|[A\rightarrow\alpha\cdot X \beta, a]\in I\})$</li><li>计算 $LR(1)$ 的项集族时初始状态为 $\mbox{Closure}([S&#39;\rightarrow\cdot S, $])$</li></ul><h3 id="分析表构造"><a href="#分析表构造" class="headerlink" title="分析表构造"></a>分析表构造</h3><p>这段从 $LR(0)$ 分析表构造过程修改而来，区别在于 3 的第三条中对 $a$ 的来源有了更加严格的限制。</p><p>对一个文法构造对应的 $LR(1)$ 分析表：</p><ol><li>构造增广文法 $G$</li><li>得到 $G$ 的规范 $LR(1)$ 项集族 $C$</li><li>$C$ 中的每个项目集闭包就是自动机的一个状态 $I_i$，按如下规则求分析表：<ul><li>$\mbox{if }[A\rightarrow\alpha\cdot a\beta, b]\in I_i\mbox{ and Goto}(I_i, a)=I_j\mbox{ then Action}[i, a]=\mbox{s}_j$</li><li>$\mbox{if }[A\rightarrow\alpha\cdot B\beta, b]\in I_i\mbox{ and Goto}(I_i, B)=I_j\mbox{ then Goto}[i, B]=j$</li><li>$\mbox{if }[A\rightarrow\alpha\cdot, a]\in I_i\mbox{ and }A\neq S&#39;\mbox{ then }\mbox{Action}[i, a]=\mbox{r}_j$，其中 $j$ 是产生式 $A\rightarrow\alpha$ 的编号</li><li>$\mbox{if }[S&#39;\rightarrow S\cdot, $]\in I_i \mbox{ then Action}[i, $]=acc$</li><li>其它所有情况都设为 $err$</li></ul></li></ol><p><strong>如果一个文法构造完 $LR(1)$ 分析表后无冲突，称为 $LR(1)$ 文法。</strong></p><h2 id="LALR-分析"><a href="#LALR-分析" class="headerlink" title="$LALR$ 分析"></a>$LALR$ 分析</h2><p>$LR(1)$ 分析法构造出来的状态太多，为了解决这个问题可以考虑将同心的项目集进行合并，这是 $LALR$ 分析法的由来。</p><p>合并了状态之后的自动机和 $LR(0)/SLR$ 分析法得到的自动机状态数相同，但是分析能力依然比它们要强。</p><p>具体操作过程是，如果经过 $LR(1)$ 分析后有两个状态是同心的，那么这两个状态会合并成一个状态（新的状态中的项是原有项的并），这个操作会递归进行下去，直到不可继续合并为止。一些注解：</p><ul><li>对状态进行了合并后，原来可能没有归约-归约冲突，但是合并后有可能产生。</li><li>对状态进行合并不会产生新的归约-移进冲突。</li><li>$LALR$ 分析可能会作多余的归约动作，但是不会产生错误的移进操作。</li><li>$LALR$ 分析得到的自动机和 $LR(0)$ 分析得到的自动机具有相同的形式（都具有展望符），同时和 $SLR$ 分析得到的自动机具有相同的大小。</li></ul><p>如果 $LALR$ 得到的自动机没有冲突，则文法称为 $LALR$ 文法。它的分析能力介于 $LR(1)$ 和 $SLR$ 之间。</p><h2 id="二义性文法的-LR-分析"><a href="#二义性文法的-LR-分析" class="headerlink" title="二义性文法的 $LR$ 分析"></a>二义性文法的 $LR$ 分析</h2><p>二义性文法不是 $LR$ 文法，但是这种文法表示简单，可以使用 $LR$ 分析技术进行分析。</p><p>构造出自动机后有些状态会出现冲突，会有多个产生式可以使用，此时如果通过结合性和优先级的限制可以选定使用哪个产生式。</p><p>例如在构造文法 $S\rightarrow iS|iSeS|a$ 的自动机（实际上这是个 if-else 的文法）时有个状态是 $S\rightarrow iS\cdot$ 与 $S\rightarrow iS\cdot eS$，此时如果读入 $e$ 就有移入-归约冲突，但是如果限制所有的 $e$ 都和最近的 $i$ 配对就可以解决这个问题，总是选择第二个产生式。</p><p>又如在构造四则运算的文法时如果出现某个状态是 $E\rightarrow E+E\cdot$ ，$E\rightarrow E\cdot +E$ 以及 $E\rightarrow E\cdot \ast E$，在读入加号或者乘号的时候有移入-归约冲突。如果限制乘号优先级大于加号、加号是左结合的，就可以在读入加号的时候总是选择第一个产生式，在读入乘号的时候总是选择第三个产生式。</p><p>尽管二义性文法可以使用 $LR$ 分析，但是应当节制使用。</p><h2 id="LR-分析中的错误处理"><a href="#LR-分析中的错误处理" class="headerlink" title="$LR$ 分析中的错误处理"></a>$LR$ 分析中的错误处理</h2><p>$LR$ 分析中有两种错误处理策略。</p><h3 id="恐慌模式错误恢复"><a href="#恐慌模式错误恢复" class="headerlink" title="恐慌模式错误恢复"></a>恐慌模式错误恢复</h3><p>在当前的状态下，如果发现读入的符号不能前往下一个状态，就表明出现了错误。此时在 <strong>状态栈</strong> 中从栈顶开始向下扫描，找到第一个在 Goto 表中有对应表项的状态 $s$，并从 Goto 表中选择一个表项。此时得到了一个非终结符 $A$，可以假装认为当前的错误如果没有发生的话，最后会归约到 $A$，因此此时可以将两个栈中后面的元素全部弹出，一直到栈顶为 $s$ 为止，并且使得两个栈中元素数目相同；随后不断扫描输入串，舍弃其中的符号，直到输入串中第一个符号在 Follow($A$) 中，此时认为 $A$ 已经归约完毕，将 $A$ 压入符号栈，并将 Goto($s$, $A$) 压入状态栈，然后继续处理。</p><h3 id="短语层次错误恢复"><a href="#短语层次错误恢复" class="headerlink" title="短语层次错误恢复"></a>短语层次错误恢复</h3><p>对于 Action 表中所有的 err 项，都建立一个独立的错误处理程序。此时已经细化到了在什么情况下出错，因此这些程序中可以提示具体的出错原因然后尝试修复这个错误。</p><p>在解析过程中，整个 Action 表中所有的情况都有对应的处理方式。对于非 err 的情况按照之前的方式处理即可，对于 err 的情况就执行对应的错误处理程序修复错误（一般是修改了两个栈）后继续进行语法分析。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 6</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-6/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-6/</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析-3"><a href="#语法分析-3" class="headerlink" title="语法分析-3"></a>语法分析-3</h1><h2 id="自底向上分析概述"><a href="#自底向上分析概述" class="headerlink" title="自底向上分析概述"></a>自底向上分析概述</h2><p>自底向上分析是从句型归约到开始符号，也是一种从句型得到分析树的方法。</p><p>自底向上分析一般采用最左归约的方式，此时对应的是最右推导。自底向上分析的通用框架是 <strong>移入-归约</strong> 分析。它的工作方式如下：</p><ol><li>首先对于要解析的词法单元流，维护了一个栈。</li><li>从左至右扫描输入串，将扫描到的元素逐个压入栈中。</li><li>如果在某个时刻，栈顶的若干个元素是某个产生式的右部，则可以进行一次归约。将这些元素弹出，替换为产生式的左部，然后重新压回栈中。然后重新运行这个检查，直到无法归约为止。这一步中被归约的符号串称作 <strong>句柄</strong>。<strong>句柄实际上是句型中的最左直接短语。</strong></li><li>如果串扫描完成后，栈中恰好剩下初始符号，则归约完成。</li></ol><p>这个方法实际上有问题，如果某两个产生式的右部存在后缀关系，就有可能选出错误的句柄。因此需要研究如何正确选择句柄。</p><h2 id="LR-分析法概述"><a href="#LR-分析法概述" class="headerlink" title="$LR$ 分析法概述"></a>$LR$ 分析法概述</h2><p>自底向上分析可以使用 $LR$ 文法，$LR$ 文法是最大的能够构造相应移入-归约语法分析器的文法类。$LR(k)$ 分析表示在最左归约过程中需要向前看 $k$ 个符号的归约方式。一般 $k = 1$ 或 $k = 0$。</p><p>在使用移入-归约技术时，句柄是逐步形成的，这可以使用一系列的整数来表示某种 <strong>状态</strong>。</p><h3 id="LR-分析表"><a href="#LR-分析表" class="headerlink" title="$LR$ 分析表"></a>$LR$ 分析表</h3><p>为了进行 $LR$ 分析需要使用 $LR$ 分析表，$LR$ 分析表的每一行代表一个状态（怎么确定见后面），每一列是一个符号（终结符、非终结符以及 $$$ 符号）。这张表会被拆分成两部分：列为终结符和 $$$ 时为 <strong>Action 表</strong>，列为非终结符时为 <strong>Goto 表</strong>。</p><p>进行 $LR$ 分析时要维护两个栈：状态栈和符号栈。</p><p>在 Goto 表中，每个元素是一个整数代表状态；在 Action 表中，每个元素是以下四种之一：</p><ul><li><code>acc</code>：表示解析完成且正确。</li><li><code>err</code>：解析出错。</li><li><code>sn</code>：表示应该执行 shift 动作，将扫描的当前单元压入符号栈中，将 <code>n</code> 压入状态栈中。</li><li><code>rn</code>：表示应该执行 reduce 动作，使用第 <code>n</code> 条产生式对当前符号栈的顶部进行归约，如果归约了 m 个符号就弹出 m 个状态。</li></ul><p>$LR$ 分析表的构造可使用 $LR(0)$ 分析、$SLR$ 分析、$LR(1)$ 分析或 $LALR$ 分析。</p><h3 id="LR-分析器的工作过程"><a href="#LR-分析器的工作过程" class="headerlink" title="$LR$ 分析器的工作过程"></a>$LR$ 分析器的工作过程</h3><p>正常情况下，符号栈中的元素个数和状态栈中相同。一般情况是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">status stack: st_0 st_1 st_2 st_3</span><br><span class="line">symbol stack: sy_$ sy_0 sy_1 sy_2</span><br><span class="line">token buffer: a_1 a_2 ... $</span><br></pre></td></tr></table></figure><p>初始情况下符号栈中只有 <code>sy_$</code>，状态栈中只有 <code>st_0</code>，输入串为完整的输入串加上 $$$ 符号，也符合上述情况。</p><p>根据当前状态栈栈顶，和输入串第一个元素在 Action 表中找到对应的元素，重复以下过程：</p><ul><li>若为接受或者拒绝则执行相应动作，退出循环。</li><li>若为移入操作则移入该元素并压入对应状态。</li><li>若为归约操作则进行归约，不要移入元素。弹出和归约符号数相同数目的状态。完成后，符号栈会比状态栈少一个元素，此时根据状态栈栈顶和符号栈栈顶在 Goto 表中找到对应的状态，将这个状态压入到状态栈中。（这个时候还能顺带着打一条产生式。）</li></ul><p>上述过程中将始终保持符号栈中的元素个数和状态栈中相同的性质。</p><h2 id="LR-0-分析"><a href="#LR-0-分析" class="headerlink" title="$LR(0)$ 分析"></a>$LR(0)$ 分析</h2><p>$LR(0)$ 分析是一种构造分析表的技术。</p><h3 id="产生式的项目"><a href="#产生式的项目" class="headerlink" title="产生式的项目"></a>产生式的项目</h3><p>前面提到句柄是逐渐产生的，对于每一个产生式，为了标记出当前这个产生式的解析状态，可以生成若干个 <strong>项目</strong>。对于有 $k$ 个元素的产生式，可以定义出 $k + 1$ 个项目。使用 $\cdot$ 来进行标记，例如 $A\rightarrow \alpha B\beta$ 可以产生 $A\rightarrow\cdot \alpha B\beta$、$A\rightarrow\alpha\cdot  B\beta$、$A\rightarrow \alpha B\cdot \beta$ 以及 $A\rightarrow\alpha B\beta\cdot$ 这四个项目。此外，对于空产生式也会产生一个项目。</p><p>根据圆点的位置和圆点后面是终结符还是非终结符可以将项目进行分类。如果后面是终结符，称为 <strong>移进项目</strong>；后面是非终结符称为 <strong>待约项目</strong>；后面没有符号（圆点在最后一个）符号后面称为 <strong>归约项目</strong>。</p><p>一个项目如果是另一个项目在接收一个符号后得到的，称后者为前者的 <strong>后继项目</strong>。</p><h3 id="增广文法"><a href="#增广文法" class="headerlink" title="增广文法"></a>增广文法</h3><p>对于一个文法 $G$，如果它的初始符号是 $S$，那么增加一个产生式 $S&#39;\rightarrow S$ 并将这个 $S&#39;$ 作为新的初始符号，得到的文法 $G&#39;$ 称为增广文法。这种文法的初始符号只有一个产生式。</p><p>对于增广文法，$S&#39;\rightarrow \cdot S$ 称为 <strong>初始项目</strong>，$S&#39;\rightarrow S\cdot$ 称为 <strong>接收项目</strong>。</p><h3 id="LR-0-自动机"><a href="#LR-0-自动机" class="headerlink" title="$LR(0)$ 自动机"></a>$LR(0)$ 自动机</h3><p>对于一个文法，在得到了增广文法后可以构造出所有产生式对应的所有项目。这些项目中有些是等价的（严格来说不是等价，因为不满足等价的三个条件，这里不严谨）。按照等价关系可以将这些项目划分为组，称作 <strong>项目集闭包</strong>（因为不严谨，实际上这个组并不是等价类），对于有 m 个产生式的文法可能只有不到 m 个项目集闭包。</p><p>所谓等价指的是，例如有两个产生式 $A\rightarrow B, B\rightarrow \alpha C$，由于解析到 $B$ 前时相当于解析到 $\alpha C$ 前，因此 $A\rightarrow\cdot B$ 和 $B\rightarrow\cdot \alpha C$ 实际上是等价的。</p><p>当得到了各个项目集闭包之后，实际上这个文法会对应一个自动机，自动机的状态就是这些项目集闭包，自动机的字符集就是所有的终结符与非终结符。（实际上也不是一个自动机，因为状态可以以非迁移的方式改变。）</p><h2 id="LR-0-分析表构造算法"><a href="#LR-0-分析表构造算法" class="headerlink" title="$LR(0)$ 分析表构造算法"></a>$LR(0)$ 分析表构造算法</h2><h3 id="计算项目集的-Closure-集"><a href="#计算项目集的-Closure-集" class="headerlink" title="计算项目集的 Closure 集"></a>计算项目集的 Closure 集</h3><p>一个项目集的 Closure 集指的是和它等价的所有项目的集合（这里的等价依然不严谨），实际上就是这个项目集的项目集闭包。</p><p>定义为 $\mbox{Closure}(I) = I\cup\{B\rightarrow\cdot\gamma|A\rightarrow\alpha\cdot B\beta\in\mbox{Closure}(I), B\rightarrow\gamma\in P\}$，其中 $P$ 是产生式集合。重复这个计算公式直到稳定，就算出了一个项目集的 Closure 集。</p><h3 id="计算项目集的-Goto-集"><a href="#计算项目集的-Goto-集" class="headerlink" title="计算项目集的 Goto 集"></a>计算项目集的 Goto 集</h3><p>前面说到 $LR(0)$ 对应的是一个自动机，这个自动机的一个状态对应一个项目集闭包，字符集是所有的符号。如何在知道一个状态和输入符号的情况下知道进入了哪个状态？手动计算的方法是该项目集闭包的每个项目，如果它的 $\cdot$ 后面跟的是输入符号的话，就计算处它的后继状态。所有的这样的后继状态并起来取一次闭包就行了。</p><p>定义为 $\mbox{Goto}(I, X) = \mbox{Closure}(\{A\rightarrow\alpha X\cdot\beta|A\rightarrow\alpha\cdot X\beta\in I\})$，其中 $I$ 为当前项目集闭包，$X$ 为输入符号。重复直到稳定。</p><h3 id="规范-LR-0-项集族"><a href="#规范-LR-0-项集族" class="headerlink" title="规范 $LR(0)$ 项集族"></a>规范 $LR(0)$ 项集族</h3><p>这个听起来很牛逼的名字实际上就是一个文法对应的自动机中所有可能出现的项目集闭包的集合。它代表了自动机可能有哪些状态。可以使用初始项目集闭包不断计算 Goto 集得到。</p><h3 id="分析表构造算法"><a href="#分析表构造算法" class="headerlink" title="分析表构造算法"></a>分析表构造算法</h3><p>对一个文法构造对应的 $LR(0)$ 分析表：</p><ol><li>构造增广文法 $G$</li><li>得到 $G$ 的规范 $LR(0)$ 项集族 $C$</li><li>$C$ 中的每个项目集闭包就是自动机的一个状态 $I_i$，按如下规则求分析表：<ul><li>$\mbox{if }A\rightarrow\alpha\cdot a\beta\in I_i\mbox{ and Goto}(I_i, a)=I_j\mbox{ then Action}[i, a]=\mbox{s}_j$</li><li>$\mbox{if }A\rightarrow\alpha\cdot B\beta\in I_i\mbox{ and Goto}(I_i, B)=I_j\mbox{ then Goto}[i, B]=j$</li><li>$\mbox{if }A\rightarrow\alpha\cdot\in I_i\mbox{ and }A\neq S&#39;\mbox{ then }\forall a\in V_T\cup\{$\}, \mbox{Action}[i, a]=\mbox{r}_j$，其中 $j$ 是产生式 $A\rightarrow\alpha$ 的编号，$V_T$ 是所有终结符</li><li>$\mbox{if }S&#39;\rightarrow S\cdot\in I_i \mbox{ then Action}[i, $]=acc$</li><li>其它所有情况都设为 $err$</li></ul></li></ol><h3 id="LR-0-分析中的冲突"><a href="#LR-0-分析中的冲突" class="headerlink" title="$LR(0)$ 分析中的冲突"></a>$LR(0)$ 分析中的冲突</h3><p>冲突指的是在自动机的某个状态中，读入下一个符号后有多种选择的情况。反映到分析表中就是某个状态对应的符号不只有一个条目。</p><p><strong>移入-归约冲突</strong>：在读入一个符号后，既可以选择移入也可以选择归约，例如某个状态中有两个项目 $E\rightarrow T\cdot$ 和 $T\rightarrow T\cdot a F$，在读入 $a$ 后就有问题。</p><p><strong>归约-归约冲突</strong>：在读入一个符号后需要归约，但是有多条可供选择的产生式。</p><p><strong>如果一个文法构造完 $LR(0)$ 分析表后无冲突，称为 $LR(0)$ 文法。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 5</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-5/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-5/</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析-2"><a href="#语法分析-2" class="headerlink" title="语法分析-2"></a>语法分析-2</h1><h2 id="First-集和-Follow-集的计算"><a href="#First-集和-Follow-集的计算" class="headerlink" title="First 集和 Follow 集的计算"></a>First 集和 Follow 集的计算</h2><h3 id="First-集的计算"><a href="#First-集的计算" class="headerlink" title="First 集的计算"></a>First 集的计算</h3><p>计算一个文法中各个非终结符的 First 集的方法是，<strong>不断应用以下规则，直到每个符号的 First 集稳定：</strong></p><ul><li><p>如果 $X$ 是终结符，则 $\mbox{First}(X) = \{X\}$。（引入这个的目的是方便后面的递归计算。）</p></li><li><p>如果 $X\rightarrow\epsilon$ 是 $X$ 的一个产生式，则 $\epsilon\in\mbox{First}(X)$。（为了计算的方便，这里是 $\rightarrow$ 而不是 $\Rightarrow$，也就是可以直接从生成式开始计算。）</p></li><li><p>如果 $X\rightarrow Y_1Y_2\cdots Y_n$ 是 $X$ 的一个产生式，则</p><ul><li>$\mbox{First}(Y_1)-\{\epsilon\}\subset\mbox{First}(X)$，去掉 $\epsilon$ 是因为后续的符号才能作为初始符号。</li><li>若 $\epsilon\in \mbox{First}(Y_1)$，则 $\mbox{First}(Y_2)-\{\epsilon\}\subset\mbox{First}(X)$。</li><li>若 $\epsilon\in \mbox{First}(Y_1)$ 且 $\epsilon \in \mbox{First}(Y_2)$，则 $\mbox{First}(Y_3)-\{\epsilon\}\subset\mbox{First}(X)$。</li><li>同上类推。</li></ul><p>如果某个符号是 $Y_k$ 的初始符号，并且 $Y_k$ 之前的非终结符都可以生成空串，那么这个初始符号也是 $X$ 的初始符号。此外，如果所有的 $Y_k$ 都可以生成空串，则 $\epsilon$ 也是 $X$ 的初始符号。</p><p>也可以单独为一个串 $X_1X_2\cdots X_n$ 计算 First 集，做法和为 $X\rightarrow Y_1Y_2\cdots Y_n$ 计算 First 集的方法类似。</p></li></ul><h3 id="Follow-集的计算"><a href="#Follow-集的计算" class="headerlink" title="Follow 集的计算"></a>Follow 集的计算</h3><p>计算一个文法中各个非终结符的 Follow 集的方法是，<strong>不断应用以下规则，直到每个符号的 Follow 集稳定</strong>：</p><ul><li>对于初始符号 $S$，有 $$\in\mbox{Follow}(S)$。</li><li>如果有产生式 $A\rightarrow \alpha B$，则 $\forall X\in \mbox{Follow}(A), X\in\mbox{Follow}(B)$。这是显然的。</li><li>如果有产生式 $A\rightarrow \alpha B\beta$ 且 $\epsilon\in \mbox{First}(\beta)$，则 $\forall X\in \mbox{Follow}(A), X\in\mbox{Follow}(B)$。这是显然的，但是还不够，见下一条。</li><li>如果有产生式 $A\rightarrow \alpha B\beta$，则 $\forall X\in \mbox{First}(\beta),X\neq\epsilon\Rightarrow X\in\mbox{Follow}(B)$。注意上一节已经定义了如何计算一个串的 First 集。</li></ul><h3 id="Select-集的计算"><a href="#Select-集的计算" class="headerlink" title="Select 集的计算"></a>Select 集的计算</h3><p>已在语法分析-1 中描述。</p><ul><li>$\epsilon \notin \mbox{First}(\alpha)\Rightarrow\mbox{Select}(A\rightarrow\alpha)=\mbox{First}(\alpha)$：如果一个串 $\alpha$ 无法推导出空串，那么当它作为产生式的右部时，只有这个串的串首终结符作为输入符号的时候才能考虑使用该产生式。</li><li>$\epsilon\in\mbox{First}(\alpha)\Rightarrow\mbox{Select}(A\rightarrow\alpha)=(\mbox{First}(\alpha)-\{\epsilon\})\cup\mbox{Follow}(A)$：如果一个串 $\alpha$ 可以产生空串，那么当它作为产生式的右部时，它的串首终结符或者产生式的左部的后继符号集总的元素作为输入符号时都可以使用该产生式。</li></ul><hr><p>在使用上面的算法进行计算的时候，Select 集依赖于 Follow 集，Follow 集依赖于 First 集。</p><p>在完成了计算后，如果这是一个 $LL(1)$ 文法，那么可以在构建预测分析器的时候可以建立 <strong>预测分析表</strong>。这个表的每一行代表不同的非终结符，每一列代表不同的输入符号，表中的每个元素是一个产生式。当进行语法分析时，只要查一下当前的非终结符和输入符号就可以确定唯一的产生式，这是因为 $LL(1)$ 文法具有相同非终结符 Select 集不相交的性质。</p><h2 id="递归的预测分析法"><a href="#递归的预测分析法" class="headerlink" title="递归的预测分析法"></a>递归的预测分析法</h2><p>递归的预测分析法在递归下降分析中通过使用预测分析表选择产生式。这个方法需要为每个非终结符根据产生式和预测分析表写一个方法。这里直接使用课件中用到的语言的文法：</p><script type="math/tex; mode=display">\begin{array}{cc}\begin{align*}\mbox{Program} &\rightarrow \texttt{program}\mbox{ DecList : Type ; StList } \texttt{end}\\\mbox{DecList} &\rightarrow id\mbox{ DecListN} \\\mbox{DecListN} &\rightarrow \mbox{,}id\mbox{ DecListN} | \epsilon \\\mbox{StList} &\rightarrow s\mbox{ StListN} \\\mbox{StListN} &\rightarrow \mbox{;}s\mbox{ StListN} | \epsilon \\\mbox{Type} &\rightarrow \texttt{real} | \texttt{int}\end{align*}\end{array}</script><p>（我估计这个文法得到的程序看上去会怪怪的，下面构造一个试试。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">program foo, bar : int;</span><br><span class="line">    foo += 1;</span><br><span class="line">    foo += bar;</span><br><span class="line">    bar ++;</span><br><span class="line">    foo + bar</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>嗯，这个语言看上去非常诡异，而且文法看着也不优雅。现在写一段 Python 程序作为例子，它可以检验一个 token 流是否能够被该文法生成（实际上检验完成后就可以给出分析树了）。</p><p>首先需要对每个非终结符写一个过程，每个过程的参数是当前 token 流的位置，一般没有返回值。副作用是将解析位置移到 token 流中下一个正确的位置，也就是所，当这样的一个过程结束的时候，解析位置应该处于下一个该过程解析的 <strong>最后一个符号的下一个位置</strong>。这样做的好处后面会分析。</p><p>首先定义一个 <code>TokenStatus</code> 类，记录处理进度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenStatus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tokens: List[str])</span>:</span></span><br><span class="line">        self.tokens = tokens</span><br><span class="line">        self.position = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这个文法一共有 6 个非终结符，每个终结符都会对应一个 <code>analyze_*</code> 函数，此外，整个分析过程会对应 <code>analyze</code> 函数。</p><p>首先是 <code>analyze</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze</span><span class="params">(tokens: List[str])</span>-&gt; bool:</span></span><br><span class="line">    token_status = TokenStatus(tokens)</span><br><span class="line">    analyze_program(token_status)</span><br><span class="line">    <span class="keyword">if</span> token_status.position != len(token_status.tokens):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Unexpected token.'</span>)</span><br><span class="line">    print(<span class="string">'Done.'</span>)</span><br></pre></td></tr></table></figure><p>然后是各个分析函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_program</span><span class="params">(token_status: TokenStatus)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> token_status.tokens[token_status.position] != <span class="string">'program'</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Unexpected token.'</span>)</span><br><span class="line"></span><br><span class="line">    token_status.position += <span class="number">1</span></span><br><span class="line">    analyze_dec_list(token_status)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> token_status.tokens[token_status.position] != <span class="string">':'</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Unexpected token.'</span>)</span><br><span class="line"></span><br><span class="line">    token_status.position += <span class="number">1</span></span><br><span class="line">    analyze_type(token_status)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> token_status.tokens[token_status.position] != <span class="string">';'</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Unexpected token.'</span>)</span><br><span class="line"></span><br><span class="line">    token_status.position += <span class="number">1</span></span><br><span class="line">    analyze_st_list(token_status)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> token_status.tokens[token_status.position] != <span class="string">'end'</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Unexpected token.'</span>)</span><br><span class="line"></span><br><span class="line">    token_status.position += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_dec_list</span><span class="params">(token_status: TokenStatus)</span>:</span></span><br><span class="line">    print(<span class="string">f'Get identifier "<span class="subst">&#123;token_status.tokens[token_status.position]&#125;</span>".'</span>)</span><br><span class="line"></span><br><span class="line">    token_status.position += <span class="number">1</span></span><br><span class="line">    analyze_dec_list_n(token_status)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_dec_list_n</span><span class="params">(token_status: TokenStatus)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> token_status.tokens[token_status.position] == <span class="string">','</span>:</span><br><span class="line">        token_status.position += <span class="number">1</span></span><br><span class="line">        print(<span class="string">f'Get identifier "<span class="subst">&#123;token_status.tokens[token_status.position]&#125;</span>".'</span>)</span><br><span class="line"></span><br><span class="line">        token_status.position += <span class="number">1</span></span><br><span class="line">        analyze_dec_list_n(token_status)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_st_list</span><span class="params">(token_status: TokenStatus)</span>:</span></span><br><span class="line">    print(<span class="string">f'Get statement "<span class="subst">&#123;token_status.tokens[token_status.position]&#125;</span>".'</span>)</span><br><span class="line"></span><br><span class="line">    token_status.position += <span class="number">1</span></span><br><span class="line">    analyze_st_list_n(token_status)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_st_list_n</span><span class="params">(token_status: TokenStatus)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> token_status.tokens[token_status.position] == <span class="string">';'</span>:</span><br><span class="line">        token_status.position += <span class="number">1</span></span><br><span class="line">        print(<span class="string">f'Get statement "<span class="subst">&#123;token_status.tokens[token_status.position]&#125;</span>".'</span>)</span><br><span class="line"></span><br><span class="line">        token_status.position += <span class="number">1</span></span><br><span class="line">        analyze_st_list_n(token_status)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_type</span><span class="params">(token_status: TokenStatus)</span>:</span></span><br><span class="line">    token = token_status.tokens[token_status.position]</span><br><span class="line">    <span class="keyword">if</span> token != <span class="string">'real'</span> <span class="keyword">and</span> token != <span class="string">'int'</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Unexpected token.'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">f'Get type "<span class="subst">&#123;token&#125;</span>".'</span>)</span><br><span class="line"></span><br><span class="line">    token_status.position += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后是测试部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tokens = [</span><br><span class="line">        <span class="string">'program'</span>,</span><br><span class="line">        <span class="string">'foo'</span>,</span><br><span class="line">        <span class="string">','</span>,</span><br><span class="line">        <span class="string">'bar'</span>,</span><br><span class="line">        <span class="string">':'</span>,</span><br><span class="line">        <span class="string">'int'</span>,</span><br><span class="line">        <span class="string">';'</span>,</span><br><span class="line">        <span class="string">'foo += 1'</span>,</span><br><span class="line">        <span class="string">';'</span>,</span><br><span class="line">        <span class="string">'foo += bar'</span>,</span><br><span class="line">        <span class="string">';'</span>,</span><br><span class="line">        <span class="string">'bar ++'</span>,</span><br><span class="line">        <span class="string">';'</span>,</span><br><span class="line">        <span class="string">'foo + bar'</span>,</span><br><span class="line">        <span class="string">'end'</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    analyze(tokens)</span><br></pre></td></tr></table></figure><p>运行这个程序将会输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Get identifier &quot;foo&quot;.</span><br><span class="line">Get identifier &quot;bar&quot;.</span><br><span class="line">Get type &quot;int&quot;.</span><br><span class="line">Get statement &quot;foo += 1&quot;.</span><br><span class="line">Get statement &quot;foo += bar&quot;.</span><br><span class="line">Get statement &quot;bar ++&quot;.</span><br><span class="line">Get statement &quot;foo + bar&quot;.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>课件中有一些实现上的细节没有说清楚，这里写一下：</p><ul><li>每个分析函数开始时，参数中的 <code>position</code> 应当对应处于该分析函数的串首终结符。</li><li>每个分析函数开始时，<code>position</code> 应当被修改为最后一个终结符的下一个位置。这样设计的原因是做到了左闭右开，否则的话对于空串的情况就很麻烦。如果设计成移动到终结符的位置，那么调用这个分析函数的函数就会主动将位置加一，但是如果产生式是空串呢，就要在分析函数返回前将位置减一，这样做不太优雅。</li><li>体现了 <strong>预测分析</strong> 的地方在于每个分析函数中会通过查看第一个非终结符决定具体调用哪个产生式，如果都没有的话会尝试调用 $\epsilon$ 产生式，还没有的话就报错了。</li></ul><p>总的来看整个程序写起来还是很套路的。</p><h2 id="非递归的预测分析法"><a href="#非递归的预测分析法" class="headerlink" title="非递归的预测分析法"></a>非递归的预测分析法</h2><p>非递归的预测分析法也叫 <strong>表驱动的预测分析</strong>，使用下推自动机来完成分析过程。非确定下推自动机（NPDA）可以表达所有的上下文无关语言。</p><p>尽管之前学的 NPDA 中会出现不能判定路径，但是因为此处可以“预览”一个 token，并且使用的是 $LL(1)$ 文法，所以实际上这个 NPDA 中状态的变迁是确定的。</p><p>NPDA 会维护一个栈，这个栈中初始有两个元素：栈顶的开始符号和栈底的结束符号 $$$（使用的是空栈结束的 NPDA？）。每次读到一个元素的时候</p><ul><li>如果当前栈顶是终结符且该终结符与读入元素相同，出栈，移动读位置。</li><li>如果当前元素是非终结符，根据读入元素选择出产生式，出栈，将产生式压入栈中（注意方向），不移动读位置（相当于预览）。</li></ul><p>依然使用上一节的文法，代码如下，先定义相关的数据结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SymbolType</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    TERMINAL = <span class="number">1</span></span><br><span class="line">    NONTERMINAL = <span class="number">2</span></span><br><span class="line">    VARIABLE = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenStatus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tokens: List[str])</span>:</span></span><br><span class="line">        self.tokens = tokens</span><br><span class="line">        self.position = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>其中 <code>SymbolType</code> 的 <code>VARIABLE</code> 是为了通配类似符号名和语句这样的非固定字符串。</p><p>预测分析函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze</span><span class="params">(tokens: List[str])</span>:</span></span><br><span class="line">    token_status = TokenStatus(tokens)</span><br><span class="line">    analyze_table = &#123;</span><br><span class="line">        <span class="string">'program'</span>: &#123;</span><br><span class="line">            <span class="string">'program'</span>: [</span><br><span class="line">                (SymbolType.TERMINAL, <span class="string">'program'</span>),</span><br><span class="line">                (SymbolType.NONTERMINAL, <span class="string">'dec_list'</span>),</span><br><span class="line">                (SymbolType.TERMINAL, <span class="string">':'</span>),</span><br><span class="line">                (SymbolType.NONTERMINAL, <span class="string">'type'</span>),</span><br><span class="line">                (SymbolType.TERMINAL, <span class="string">';'</span>),</span><br><span class="line">                (SymbolType.NONTERMINAL, <span class="string">'st_list'</span>),</span><br><span class="line">                (SymbolType.TERMINAL, <span class="string">'end'</span>)</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'dec_list'</span>: &#123;</span><br><span class="line">            <span class="literal">None</span>: [</span><br><span class="line">                (SymbolType.VARIABLE, <span class="string">'identifier'</span>),</span><br><span class="line">                (SymbolType.NONTERMINAL, <span class="string">'dec_list_n'</span>)</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'dec_list_n'</span>: &#123;</span><br><span class="line">            <span class="string">','</span>: [</span><br><span class="line">                (SymbolType.TERMINAL, <span class="string">','</span>),</span><br><span class="line">                (SymbolType.VARIABLE, <span class="string">'identifier'</span>),</span><br><span class="line">                (SymbolType.NONTERMINAL, <span class="string">'dec_list_n'</span>)</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">':'</span>: []</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'st_list'</span>: &#123;</span><br><span class="line">            <span class="literal">None</span>: [</span><br><span class="line">                (SymbolType.VARIABLE, <span class="string">'statement'</span>),</span><br><span class="line">                (SymbolType.NONTERMINAL, <span class="string">'st_list_n'</span>)</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'st_list_n'</span>: &#123;</span><br><span class="line">            <span class="string">';'</span>: [</span><br><span class="line">                (SymbolType.TERMINAL, <span class="string">';'</span>),</span><br><span class="line">                (SymbolType.VARIABLE, <span class="string">'statement'</span>),</span><br><span class="line">                (SymbolType.NONTERMINAL, <span class="string">'st_list_n'</span>)</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">'end'</span>: []</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'type'</span>: &#123;</span><br><span class="line">            <span class="string">'real'</span>: [(SymbolType.TERMINAL, <span class="string">'real'</span>)],</span><br><span class="line">            <span class="string">'int'</span>: [(SymbolType.TERMINAL, <span class="string">'int'</span>)]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stack = [(SymbolType.TERMINAL, <span class="string">'$'</span>), (SymbolType.NONTERMINAL, <span class="string">'program'</span>)]</span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> stack[<span class="number">-1</span>][<span class="number">0</span>] == SymbolType.TERMINAL <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">1</span>] == token_status.tokens[token_status.position]:</span><br><span class="line">            stack.pop()</span><br><span class="line">            token_status.position += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> stack[<span class="number">-1</span>][<span class="number">0</span>] == SymbolType.TERMINAL:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Unexpected token.'</span>)</span><br><span class="line">        <span class="keyword">elif</span> stack[<span class="number">-1</span>][<span class="number">0</span>] == SymbolType.VARIABLE:</span><br><span class="line">            print(<span class="string">f'Get variable typed <span class="subst">&#123;stack[<span class="number">-1</span>][<span class="number">1</span>]&#125;</span> with value <span class="subst">&#123;token_status.tokens[token_status.position]&#125;</span>'</span>)</span><br><span class="line">            stack.pop()</span><br><span class="line">            token_status.position += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> stack[<span class="number">-1</span>][<span class="number">0</span>] == SymbolType.NONTERMINAL:</span><br><span class="line">            nonterminal = stack[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">            stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="literal">None</span> <span class="keyword">in</span> analyze_table[nonterminal]:</span><br><span class="line">                stack.extend(analyze_table[nonterminal][<span class="literal">None</span>][::<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">elif</span> token_status.tokens[token_status.position] <span class="keyword">not</span> <span class="keyword">in</span> analyze_table[nonterminal]:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">'Unexpected token.'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                peek = token_status.tokens[token_status.position]</span><br><span class="line">                stack.extend(analyze_table[nonterminal][peek][::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Unexpected type.'</span>)</span><br><span class="line">    print(<span class="string">'Done.'</span>)</span><br></pre></td></tr></table></figure><p><code>analyze_table</code> 就是驱动整个程序的表，由文法得到。它是一个 <code>dict</code>，每个 key 都是文法中的非终结符，每个 value 又是一个 <code>dict</code>，这个 <code>dict</code> 的 key 是该终结符的所有产生式的 Select 集之并（根据不同的元素使用不同的产生式），每个 value 是一个 <code>list</code>。一个例外是 <code>None</code> 这个 key，因为要匹配的是非固定的字符串所以这里这样偷懒写了，实际中我估计要从 token 中取出相关的 token 类型信息，当然这里是没有的，不过因为 <code>dec_list</code> 和 <code>st_list</code> 的生成式唯一，这么搞也没 bug，意思到了就行。</p><p>运行这个程序，得到的输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Get variable typed identifier with value foo</span><br><span class="line">Get variable typed identifier with value bar</span><br><span class="line">Get variable typed statement with value foo += 1</span><br><span class="line">Get variable typed statement with value foo += bar</span><br><span class="line">Get variable typed statement with value bar ++</span><br><span class="line">Get variable typed statement with value foo + bar</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><hr><p>递归的预测分析方法和非递归的预测分析方法进行比较的话，递归的预测分析方法更加直观，效率低，难以自动生成；非递归的预测分析方法因为使用了 NPDA 可能不直观，但是对计算机更加友好。</p><p>使用预测分析进行语法分析的一般步骤：</p><ol><li>构造文法；</li><li>改造文法（消除二义性、左递归和回溯情况）；</li><li>求出各个生成式的 Select 集，这一步会需要先求出各个非终结符的 First 集和 Follow 集；</li><li>如果做完了之后通过 Select 集发现是 $LL(1)$ 文法，就可以构造预测分析表并选择一种实现方式进行实现。</li></ol><h2 id="预测分析中的错误处理"><a href="#预测分析中的错误处理" class="headerlink" title="预测分析中的错误处理"></a>预测分析中的错误处理</h2><p>在预测分析过程中如果碰到分析错误，有些情况下不一定要直接终止掉整个程序的运行，而可以从错误中恢复。</p><p>以下两种情况可以进行 <strong>错误检测</strong>：</p><ul><li>栈顶终结符与输入符号不匹配</li><li>栈顶非终结符与当前输入符号在预测分析表中没有条目（输入符号不在任何一个生成式的 Select 集中）</li></ul><p><strong>错误恢复</strong> 是在检测到错误后继续进行分析，错误恢复的一个策略是 <strong>恐慌模式</strong>。对应上面的两种检测到错误的情况，</p><ul><li><p>如果栈顶的终结符和输入符号不匹配，就直接弹出栈顶的终结符，继续运行。</p></li><li><p>对于每个非终结符，都可以设计一个叫做 <strong>同步词法单元</strong> 的集合，这个集合中的元素是终结符。如果栈顶的非终结符和输入符号不匹配，那么就不断跳过 token 流中的 token，直到</p><ul><li>遇到了在同步词法单元集合中的 token，此时就可以进行 <strong>同步</strong>，将栈顶的非终结符弹出，继续运行。</li><li>遇到了可以识别的 token，即该 token 与非终结符在预测分析表中对应的条目不为空，此时将继续运行分析过程，栈顶符号不出栈。</li></ul><p>这个方案的效果依赖于同步词法单元的选取，例如可以将该非终结符的 Follow 集中的元素作为同步词法单元的元素，在这个情况下，可以直观感受到这种错误恢复就是一致丢弃 token 直到可以进行下一个非终结符的分析。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 4</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-4/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-4/</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析-1"><a href="#语法分析-1" class="headerlink" title="语法分析-1"></a>语法分析-1</h1><h2 id="自顶向下分析概述"><a href="#自顶向下分析概述" class="headerlink" title="自顶向下分析概述"></a>自顶向下分析概述</h2><p>语法分析的目的就是根据已有的 token，在给定的文法下找到对应的分析树。我们至少有两个策略，一个是找到如何 <em>推导</em> 出这个词法单元串，另一个是找到这个词法单元串如何 <em>归约</em> 到初始符号，这两种做法分别叫做 <strong>自顶向下分析</strong> 和 <strong>自底向上分析</strong>。</p><p>使用自顶向下分析时，每一步中都要做两个选择，一个是 <strong>替换当前句型中的哪个非终结符</strong>，另一个是 <strong>将这个非终结符替换为哪个候选式</strong>（一个非终结符的多个产生式称为它的 <strong>候选式</strong>）。</p><h3 id="最左推导与最右推导"><a href="#最左推导与最右推导" class="headerlink" title="最左推导与最右推导"></a>最左推导与最右推导</h3><p>如果推导过程中总是将句型中最左边的非终结符替换为它的候选式，这样的推导过程称作是 <strong>最左推导</strong>，它的逆过程称为 <strong>最右归约</strong>（注意最右归约总是将最右边可以进行归约的部分进行归约）。一个文法通过最左推导得到的句型称为 <strong>最左句型</strong>。</p><p>同样的，可以定义 <strong>最右推导</strong>、<strong>最左归约</strong> 以及 <strong>最右句型</strong>。</p><p>当我们使用自底向上的分析时，会使用最左归约，因此最左归约过程又称为 <strong>规范归约</strong>，对应地，最右推导被称为是 <strong>规范推导</strong>。</p><p>给定一个句型，它的最左推导和最右推导都是唯一的。</p><h3 id="使用最左推导进行自顶向下分析"><a href="#使用最左推导进行自顶向下分析" class="headerlink" title="使用最左推导进行自顶向下分析"></a>使用最左推导进行自顶向下分析</h3><p>因为词法单元流是从左到右生成的，使用自顶向下分析时一般采用的是最左推导。工作方式如下</p><ul><li>使用最左推导，每次从当前的句型中选择最左边的非终结符进行推导（这解决了替换哪个终结符的问题）。</li><li>通过查看右边的若干个词法单元（通常是 1 个）来确定要推导为哪个候选式（这解决了替换为哪个候选式的问题，注意不一定总是可以一次成功）。</li><li>不断进行上述的过程，如果初始符号可以完全推导开，则表明语法分析成功，否则失败。当成功的时候得到的分析树就是需要的分析树。</li></ul><p>实现上要使用一个叫做 <strong>递归下降分析</strong> 的技术，这个技术叫这个名字估计就是因为分析树就是是以递归形式展开的，而展开的时候层数越多越往下。</p><p>递归下降分析中，我们需要为每个非终结符定义一个对应的 <strong>过程</strong>。这个过程的一般套路是这样的（假设我们要当前的非终结符是 $A$）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   选择 A 的一个产生式 A -&gt; X_1 X_2 X_3 ... X_k;</span><br><span class="line">   <span class="keyword">for</span> i in <span class="number">1.</span>.k &#123;</span><br><span class="line">        <span class="keyword">if</span> (X_i 是一个非终结符) &#123;</span><br><span class="line">            调用 X_i 对应的过程 X_i();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (X_i 等于当前的输入符号) &#123;</span><br><span class="line">            读取当前的输入符号;</span><br><span class="line">        &#125; esle &#123;</span><br><span class="line">            报错;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用初始符号对应的过程就可以对整个程序进行语法分析。</p><p>其中选择产生式这一步不一定正好就能一次选对。如果一次无法选对的话就需要进行 <strong>回溯</strong> 然后选择其它的候选式，这个过程会降低语法分析的效率。使用了回溯的分析器叫做不确定性分析器。</p><p>我们可以通过设计合适的文法来避免使用回溯。<strong>预测分析</strong> 是递归下降技术的一个特例，它是确定性的，它通过在词法单元流中向后看 $k$ 个符号来选择当前 <strong>正确</strong> 的候选式。使用了预测分析后可以避免回溯（因为每次都选择了正确的候选式），对应的文法称作是 $LL(k)$ 文法。通常来说 $k = 1$。</p><h2 id="文法转换"><a href="#文法转换" class="headerlink" title="文法转换"></a>文法转换</h2><p>有些文法在使用自顶向下分析时会遇到问题，有的问题来自于一个非终结符的候选式中存在前缀相同的候选式（导致如果向前看的个数少的话会不知道要选择哪个候选式），有的问题来自于 <strong>左递归的文法</strong> 会让分析器进入无限循环。</p><h3 id="提取左公因子"><a href="#提取左公因子" class="headerlink" title="提取左公因子"></a>提取左公因子</h3><p>对于第一个问题我们可以 <strong>提取左公因子</strong>。提取左公因子的算法接收一个文法，输出的是不含左公因子的等价文法。这个算法很简单，就是对于每个非终结符，找到它的两个含有非平凡左公因子的候选式并求出最长左公因子，然后提取出来。重复进行下去，直到所有的产生式都没有公因子为止。通用的形式为：</p><script type="math/tex; mode=display">A\rightarrow \alpha\beta_1|\alpha\beta_2|\cdots|\alpha\beta_n|\gamma_1|\gamma_2|\cdots|\gamma_m \\</script><p>被替换为</p><script type="math/tex; mode=display">A\rightarrow \alpha A'|\gamma_1|\gamma_2|\cdots|\gamma_m \\A'\rightarrow \beta_1|\beta_2|\cdots|\beta_n</script><h3 id="消除左递归文法"><a href="#消除左递归文法" class="headerlink" title="消除左递归文法"></a>消除左递归文法</h3><p>所谓的左递归文法指的是存在一个串 $\alpha$ 使得 $A\rightarrow^+ A\alpha$，也仅是经过若干步推导后，$A$ 可以推导出一个以自己开头的句型。如果这个推导过程一步就可以完成，那么称为是 <strong>直接左递归</strong>，否则如果需要多步推导是称为 <strong>间接左递归</strong>（零步推导是平凡的，不考虑）。</p><p><strong>对于一个简单的直接左递归产生式</strong>，可以将它转化成右递归产生式。对于产生式 $A\rightarrow A\alpha|\beta$，如果 $\alpha\neq\epsilon$ 且 $\beta$ 不以 $A$ 开头，那么这个产生式实际上等价于 $A\rightarrow\beta A&#39;;A&#39;\rightarrow\alpha A&#39;|\epsilon$。</p><p>更加一般的形式是：</p><script type="math/tex; mode=display">A\rightarrow A\alpha_1|A\alpha_2|\cdots|A\alpha_n|\beta_1|\beta_2|\cdots|\beta_m(\alpha_i\neq\epsilon, A\ \mbox{is not prefix of}\ \beta_j)</script><p>等价于</p><script type="math/tex; mode=display">A \rightarrow \beta_1A'|\beta_2A'|\cdots|\beta_mA' \\A' \rightarrow\alpha_1A'|\alpha_2A'|\cdots|\alpha_nA'|\epsilon</script><p>对于 <strong>间接左递归</strong> 的情况，可以考虑将一个产生式带入另一个产生式当中以破坏掉环形的产生式依赖关系，这样做了之后可以对其中一个产生式消除掉左递归，然后就不会有左递归出现了。</p><p>消除左递归的代价是引入新的非终结符和 $\epsilon$ 产生式。</p><h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="$LL(1)$ 文法"></a>$LL(1)$ 文法</h2><h3 id="S-文法"><a href="#S-文法" class="headerlink" title="S 文法"></a>S 文法</h3><p>S 文法又叫作 <strong>简单的确定性文法</strong>。它要求每个产生式必须以终结符开头，并且同一个非终结符的所有产生式的开头的终结符不能相同。S 文法的这个要求就使得 S 文法中的产生式不能包括 $\epsilon$ 产生式。S 文法可以很方便地构造出预测分析器。</p><h3 id="含有-epsilon-产生式的文法"><a href="#含有-epsilon-产生式的文法" class="headerlink" title="含有 $\epsilon$ 产生式的文法"></a>含有 $\epsilon$ 产生式的文法</h3><p><strong>对于每个非终结符</strong>，可以给它定义一个 <strong>后继符号集</strong>。后继符号集是终极符的集合，一个终结符 $a$ 如果在 $A$ 的后继符号集中，就必然有从初始符号 $S$ 开始的某个推导，使得 $S\Rightarrow^\star \alpha Aa\beta$，即 $a$ 需要在某个合法的句型中为 $A$ 的直接后继。特别地，如果 $A$ 在某个句型中是最后一个符号（后面没有任何终极符或非终结符），则 $$$（表示句子的结尾）也在 $A$ 的后继符号集中。$A$ 的后继符号集记作是 $A$ 的 Follow 集。</p><p><strong>对于每个产生式</strong>，可以定义产生式的 <strong>可选集</strong>。可选集是终极符或者非终结符的集合，一个符号 $x$ 如果在某个产生式的可选集当中，就表明如果当前正在从某个句型开始推导并且输入符号为 $x$，则可以选用这个产生式。可选集记作 Select 集。以下是两个例子：</p><ul><li>Select($A\rightarrow a\beta$) = $\{a\}$：只有在输入符号是 $a$ 的时候才可能选用这个产生式。</li><li>Select($A\rightarrow\epsilon$) = Follow($A$)：只要输入符号在 $A$ 的 Follow 集中就可以使用这个产生式。</li></ul><p>再看定义，所谓的 <em>输入符号</em> 指的是当 $A$ 是最左的符号，需要选择一个产生式进行推导时，我们要看 $A$ 右边的终结符决定使用哪个产生式。对于 $A$ 的每个产生式，只有这个终结符位于该产生式的 Select 集中时，我们才可能使用这个产生式。</p><p>通过引入这个概念可以方便引入含有 $\epsilon$ 产生式的文法，其中的一种叫做 <strong>q 文法</strong>，该文法要求每个产生式的右边要么是 $\epsilon$ 要么以不同的终极符开始；此外，同一个非终结符的所有产生式的 Select 集应该两两不交（这个好理解，如果某两个 Select 相交，那么对于交集中的某个元素，当它是输入符号时，就无法确定使用哪个产生式）。<strong>q 文法产生式不能以非终结符开始。</strong></p><h3 id="产生式可以以非终结符开始的文法"><a href="#产生式可以以非终结符开始的文法" class="headerlink" title="产生式可以以非终结符开始的文法"></a>产生式可以以非终结符开始的文法</h3><p><strong>对于每个串</strong>（一个串一般是个句型），我们可以定义 <strong>串首终结符集合</strong>。这个集合是终结符的集合，一个终结符 $a$ 如果在 $\alpha$ 的串首终结符集中，那么有 $\alpha \Rightarrow ^\star a\beta$。特别地，如果 $\alpha\Rightarrow^\star\epsilon$，则 $\epsilon$ 也在这个集合中。串首终结符集合称为 $a$ 的 First 集。</p><p>First 集、Follow 集和 Select 集的性质：</p><ul><li>$\epsilon \notin \mbox{First}(\alpha)\Rightarrow\mbox{Select}(A\rightarrow\alpha)=\mbox{First}(\alpha)$：如果一个串 $\alpha$ 无法推导出空串，那么当它作为产生式的右部时，只有这个串的串首终结符作为输入符号的时候才能考虑使用该产生式。</li><li>$\epsilon\in\mbox{First}(\alpha)\Rightarrow\mbox{Select}(A\rightarrow\alpha)=(\mbox{First}(\alpha)-\{\epsilon\})\cup\mbox{Follow}(A)$：如果一个串 $\alpha$ 可以产生空串，那么当它作为产生式的右部时，它的串首终结符或者产生式的左部的后继符号集总的元素作为输入符号时都可以使用该产生式。</li></ul><p>这两个性质还比较显然，上述的两个性质也可以看作是 Select 集的定义。</p><p>由此可以定义 $LL(1)$ 文法，其正式的定义如下。</p><p>如果 $G$ 是 $LL(1)$ 文法，当且仅当 $G$ 中的任意具有两个相同左部的生成式 $A\rightarrow\alpha|\beta$，满足以下三者之一：</p><ul><li>$\epsilon\notin\mbox{First}(\alpha),\epsilon\notin\mbox{First}(\beta),\mbox{First}(\alpha)\cap\mbox{First}(\beta) =\varnothing$。解释：如果 $\alpha$ 和 $\beta$ 都不能推导出空串，那么它们的串首符号集不能相交，否则，无法决定相交元素为输入符号时选择哪个产生式。</li><li>$\epsilon\in\mbox{First}(\alpha), \epsilon\notin\mbox{First}(\beta), \mbox{First}(\beta)\cap\mbox{Follow}(A)=\varnothing$。解释：如果 $\alpha$ 可以推导出空串，那么 $\beta$ 必须不能推导出空串。并且 $\beta$ 的串首符号集和 $A$ 的后继符号集不能相交，否则，当交集中的某个元素作为输入符号时，无法断决是使用 $\alpha$ 还是使用 $\beta$ 作为产生式。</li><li>$\epsilon\in\mbox{First}(\beta), \epsilon\notin\mbox{First}(\alpha), \mbox{First}(\alpha)\cap\mbox{Follow}(A)=\varnothing$。这个与上面的对偶。</li></ul><p>不可能出现 $\alpha$ 和 $\beta$ 都能推导出空串的情况。</p><p>$LL(1)$ 文法的同一个非终结符的多个产生式的 Select 集不会相交，因此还是可以构造出预测分析器。</p><hr><p>上面提到的三个文法都可以构造预测分析器，不过三个文法的方便程度依次增强。q 文法不支持产生式右部以非终结符开头，但是 $LL(1)$ 文法是可以的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 3</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-3/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是正则文法的更加紧凑的一个定义。</p><p>对于每个正则文法都能写出对应的正则表达式，反之亦然。</p><p>该节具体内容已熟悉，此处略去。</p><h2 id="正则定义"><a href="#正则定义" class="headerlink" title="正则定义"></a>正则定义</h2><p>所谓的正则定义是对一个正则表达式命名，方便后续的使用。</p><p>例如需要写出 C 语言中变量命名的正则表达式，它可以这样写出</p><script type="math/tex; mode=display">digit\rightarrow0|1|2|3|\cdots|8|9 \\letter\_\rightarrow a|b|c|\cdots|z|A|B|\cdots|Z|\_ \\symbol\rightarrow letter\_(digit|letter\_)^\star</script><p>可见使用正则定义后更加简明了。</p><h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h2><p>该节具体内容已熟悉，此处略去。</p><h2 id="有穷自动机的分类"><a href="#有穷自动机的分类" class="headerlink" title="有穷自动机的分类"></a>有穷自动机的分类</h2><p>有穷自动机分为确定有穷自动机和非确定有穷自动机，其中非确定有穷自动机分为能够带有 $\epsilon$ 转移的和不能带有 $\epsilon$ 转移两种，但是表达能力相同。</p><p>不论是哪种有穷自动机，它能够描述的语言总是正则语言。正则表达式、正则文法和有穷自动机的表达能力相同。</p><p>有穷自动机的具体内容已熟悉，此处略去。</p><h2 id="从正则表达式到有穷自动机"><a href="#从正则表达式到有穷自动机" class="headerlink" title="从正则表达式到有穷自动机"></a>从正则表达式到有穷自动机</h2><p>为了能够使用正则表达式，需要将它转化为确定有穷自动机（DFA），这个过程比较复杂，可以考虑先转化为非确定有穷自动机（NFA）。</p><p>正则表达式转化为 NFA 的过程已熟悉，此处略去。</p><h2 id="从-NFA-到-DFA-的转换"><a href="#从-NFA-到-DFA-的转换" class="headerlink" title="从 NFA 到 DFA 的转换"></a>从 NFA 到 DFA 的转换</h2><p>该节具体内容已熟悉，此处略去。转化方法可是使用 NFA 中集合的幂集的子集作为 DFA 的状态集合，这个方法叫做 <strong>子集构造法</strong>。</p><h2 id="识别单词的-DFA"><a href="#识别单词的-DFA" class="headerlink" title="识别单词的 DFA"></a>识别单词的 DFA</h2><p>这一节主要是 DFA 的例子。</p><p>在词法分析阶段使用到的工具可以就是 DFA。它可以进行错误检测。工作方式：让字符流通过这个 DFA，直到发生错误（慕课中的 DFA 不是每个状态都有所有的转移，和我学的 DFA 略有不同；一般来说 DFA 会有一个陷阱状态，发生错误指的就是进入了这个状态）。当发生了这个错误之后只能说明 DFA 解析出错，<strong>并不能说明程序本身有错</strong>。此时将读取字符的指针向前移动，一直定位到最后一个位于终止状态的字符，将这个字符以及它前面的所有字符判定为一个单词。不过，也有找不到这样的单词的情况，如果这发生了，就表明程序真的发生的错误，此时要进行 <strong>错误恢复</strong>。错误恢复的一个策略叫做 <strong>恐慌模式</strong>，这种模式将首先定位到上一个成功解析的单词的结尾，然后尝试不断跳过无法解析的字符，直到找到一个可以解析的字符为止，从此处开始解析。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 2</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计语言及其文法"><a href="#程序设计语言及其文法" class="headerlink" title="程序设计语言及其文法"></a>程序设计语言及其文法</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h3><p><strong>字母表</strong> 是一个有穷符号集合。例如 ASCII 字符集就是一个合法的字母表。</p><h3 id="字母表的运算"><a href="#字母表的运算" class="headerlink" title="字母表的运算"></a>字母表的运算</h3><ul><li><strong>乘积</strong>：两个字母表的乘积相当于这两个字母表作笛卡儿积。不过写成二元组的形式可能比较麻烦，一般直接连接起来当成串。</li><li><strong>幂</strong>：字母表的幂相当于自己和自己多次乘积。特别地，0 次幂得到的结果是只含空串的集合 $\{\epsilon\}$。</li><li><strong>正闭包</strong>：字母表的正闭包是使用字母表中元素构造出的长度大于 0 的字符串的集合。</li><li><strong>克林闭包</strong>：字母表的正闭包是使用字母表中元素构造出的长度大于等于 0 的字符串的集合，它比正闭包多了一个空串。</li></ul><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p>一个字母表的克林闭包中的元素称为这个字母表的串。</p><p>串有 <strong>前缀</strong> 和 <strong>后缀</strong> 的概念，和其它学科的定义类似。</p><h3 id="串上的运算"><a href="#串上的运算" class="headerlink" title="串上的运算"></a>串上的运算</h3><ul><li><strong>连接</strong>：两个串可以进行连接操作，依然得到一个串。空串是连接操作的单位元。</li><li><strong>幂</strong>：串的幂运算就是自己和自己连接，特别地，0 次幂会得到空串。</li></ul><h2 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h2><p>这玩意已经学过了，需要注意的是一个文法的产生式的左部不一定是一个单独的非终结符号，实际上它可以是一个串。之前用到的文法的产生式左边是单个的非终结符实际上只是上下文无关文法的性质。</p><h2 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h2><p>一个由终结符与非终结符组成的串，如果不断将这个串中出现在某个产生式左部的部分替换为右部，这个过程称为 <strong>推导</strong>。这个过程的逆过程成为 <strong>归约</strong>。推导的符号是 $\Rightarrow$，如果是 $n$ 步推导的话符号是 $\Rightarrow^n$，另外 0 步推导就是不推导。</p><p>一个文法的 <strong>句型</strong> 是这个文法从开始符号能够推导出的所有终结符与非终结符连接形成的串的集合，一个句型也可能是空串。如果一个句型中没有任何非终结符，这个句型称为是一个 <strong>句子</strong>。一个文法能够生成的所有句子的集合称作是这个文法的 <strong>语言</strong>。对语言我们可以定义一系列的运算（两个不同的语言指的是两个不同的文法推导出的语言）。</p><h2 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h2><p>在 Chomsky 文法分类体系下，文法被分为四类。</p><p>在不考虑空串的情况下，这四种文法之间存在的层级的真包含关系。</p><h3 id="0-型文法"><a href="#0-型文法" class="headerlink" title="0 型文法"></a>0 型文法</h3><p>最自由的文法，又称 <strong>无限制文法</strong>。它要求产生式的左边是一个终结符与非终结符构成的串（需要至少包含一个非终结符），右边是一个终结符与非终结符构成的串。此外没有更多限制。一个串是否属于某个 0 型文法只能被图灵机判定。</p><h3 id="1-型文法"><a href="#1-型文法" class="headerlink" title="1 型文法"></a>1 型文法</h3><p>在无限制文法的基础上，限制了产生式左边的长度必须小于等于右边的长度，其一般形式是 $\alpha A\beta\rightarrow \alpha\gamma\beta$，其中希腊字母表示终结符与非终结符构成的串，要求 $|A| \le |\gamma|$，这个要求实际上限制了 1 型文法不能有 $\epsilon$ 产生式。</p><p>这个文法又称为 <strong>上下文有关文法</strong>。</p><h3 id="2-型文法"><a href="#2-型文法" class="headerlink" title="2 型文法"></a>2 型文法</h3><p>2 型文法就是 <strong>上下文无关文法</strong>，产生式的一般形式是 $A\rightarrow\alpha$。上下文无关文法简称 CFG。</p><h3 id="3-型文法"><a href="#3-型文法" class="headerlink" title="3 型文法"></a>3 型文法</h3><p>3 型文法就是 <strong>正则文法</strong>，正则文法可以使用左线性文法和右线性文法表示，例如右线性文法的产生式的一般形式是 $A \rightarrow xB$ 或 $A\rightarrow x$，其中 $x$ 是终结符的串，$B$ 是一个非终结符。</p><h2 id="CFG-的分析树"><a href="#CFG-的分析树" class="headerlink" title="CFG 的分析树"></a>CFG 的分析树</h2><p>实际上上下文无关文法是程序中使用得最多的文法，上下文无关文法的推导过程可以表述为一棵分析树。</p><p>CFG 的分析树根结点总为开始符号，每个内部结点都是对文法产生式的一次应用。如果将分析树的所有的叶结点从左到右排列起来，得到的序列是整个文法的一个句型。这样的序列称为是分析树的 <strong>边缘</strong>。对于文法的每一个句型，必定存在一个分析树，使得该分析树的边缘是这个句型。</p><p>对于一个句型，它对应的分析树的任意一棵子树的边缘称作是这个句型的 <strong>短语</strong>。如果这棵子树的高度为 2，则这个短语进一步称作是 <strong>直接短语</strong>。</p><p>一个文法可能是二义性的，如果一个文法的某个句型对应两个以上的不同的分析树，这个文法就是二义性的。一个文法是否是二义的无法通过通用的算法加以判定，但是可以给出一个充分条件，一旦满足这个充分条件，这个文法就不是二义性的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理慕课笔记 1</title>
      <link href="/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2018/11/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>感谢 <a href="https://www.icourse163.org/course/HIT-1002123007?tid=1003246005" target="_blank" rel="noopener">中国大学 MOOC</a>。</p><h2 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h2><p>计算机语言分成 <strong>高级语言</strong>、<strong>汇编语言</strong> 和 <strong>机器语言</strong>。计算机只能执行机器语言。从汇编语言到机器语言的过程叫 <strong>汇编</strong>，从高级语言到汇编语言或直接到机器语言的过程叫 <strong>编译</strong>。</p><p>将高级语言写的源程序转换成可以运行的进程要经历 <strong>语言处理系统</strong>，编译器只是这个系统中的一环。语言处理系统的典型工作流程为</p><ol><li><strong>预处理器</strong> 将不同文件中源文件聚合到一起，并对宏进行操作；</li><li><strong>编译器</strong> 将处理后的源文件编译为汇编语言程序；</li><li><strong>汇编器</strong> 从汇编语言程序生成可重定位的机器代码（可重定位指在内存中的位置不固定）；</li><li><strong>链接器</strong> 会将多个可重定位程序和库连接起来，并处理外部地址（跨文件的引用）；</li><li><strong>加载器</strong> 会处理可重定位的地址，变成真实的地址，并将程序装入内存中。</li></ol><h2 id="编译系统的结构"><a href="#编译系统的结构" class="headerlink" title="编译系统的结构"></a>编译系统的结构</h2><p><strong>编译的本质是翻译，将源语言翻译到目标语言。</strong></p><p>假定我们要将一个句子中英文翻译到中文，我们会先尝试了解这个句子的意思，这个意思是独立于任何自然语言的，专业点来说这个叫做 <strong>中间语言表示</strong>。在这个例子中，为了得到中间语言表示我们需要进行 <strong>语义分析</strong>；为了进行语义分析需要知道句子中每个短语的成分，这个过程为 <strong>语法分析</strong>；为了进行语法分析还需要知道每个词的词性，这个过程为 <strong>词法分析</strong>。</p><p>一个典型的编译器的结构可以分成前端和后端。前端与源语言相关，将源语言翻译为中间表示；后端语言与目标语言相关，将中间表示翻译为目标语言。</p><h2 id="词法分析概述"><a href="#词法分析概述" class="headerlink" title="词法分析概述"></a>词法分析概述</h2><p>词法分析一般是编译的第一个阶段。</p><p>词法分析的主要任务是从左到右扫描扫描源程序字符，识别出各个单词，确定单词的类型，将它们转化成统一的内部表示 <strong>词法单元（token）</strong>。</p><p>每个 token 是一个二元组（种别码，属性值）。其中种别码用来表示这个 token 的类型，属性值作为额外数据进一步表明这个 token 的值。</p><p>扫描的过程中可能碰到五类 token，分别为</p><ul><li><strong>关键词</strong>，例如 <code>while</code>、<code>for</code> 这样的。它们的总量是可以枚举的，因此每个关键词都会得到一个种别码，并且属性值可以为空。例如 <code>while</code> 的 token 可能为 <code>&lt;WHILE, NONE&gt;</code>。</li><li>变量名、函数名等<strong>标识符</strong>，这种标识符的总量不可枚举。所有的标识符都是一种种别，例如一个变量 <code>arr</code> 的 token 可能为 <code>&lt;IDENTIFIER, a&gt;</code>（最简单的实现中，属性值的取值就是变量名）。</li><li><strong>常量</strong>，由于扫描的时候就可以确定常量的类型，尽管常量的取值不可枚举，但是可以按照常量的类型进行分类，并将常量的值作为属性。例如 <code>0.123</code> 的 token 可能为 <code>&lt;FLOAT, 0.123&gt;</code>。</li><li><strong>运算符</strong>，这个比较简单，和关键词类似，每个运算符都可以分配一个种别码，例如 <code>+</code> 的 token 可能为 <code>&lt;ADD, NONE&gt;</code>。</li><li><strong>界定符</strong>，这种符号一般是括号、花括号、等号这种作为语句的边界的符号，和运算符的处理类似，不需要属性值。</li></ul><p>进行了扫描后，字符流就可以转化为 token 流。</p><h2 id="语法分析概述"><a href="#语法分析概述" class="headerlink" title="语法分析概述"></a>语法分析概述</h2><p>语法分析一般是编译的第二个阶段。</p><p>语法分析的主要任务是根据词法分析器输出的 token 流识别出各类短语，构造 <strong>语法分析树（parse tree）</strong>。</p><p>语法分析树是一棵树，叶结点是各个 token，非叶结点表示的是短语的类型。token 组合起来会形成短语，短语组合起来会形成更大的短语，因此形成了树的形式。</p><p>语法分析的过程需要使用到语言的 <strong>文法</strong>，因为语法分析树的每棵子树中，子树的根结点和它的所有直接子结点正好对应文法中的一个生成式。</p><p>进行了语法分析后，token 流就被转化成了多棵语法分析树。</p><h2 id="语义分析概述"><a href="#语义分析概述" class="headerlink" title="语义分析概述"></a>语义分析概述</h2><p>语义分析的主要任务是收集语义相关的信息。这么说比较抽象，例子是高级语言的语句大多可以分成声明语句和命令语句，对于声明语句，语义分析的任务是收集标识符的属性信息，包括</p><ul><li><strong>种属</strong>：简单变量、符合变量（数组、结构体等）、函数等</li><li><strong>类型</strong>：整型、布尔型等</li><li><strong>存储的位置和长度</strong></li><li>如果是变量的话，变量的 <strong>值</strong></li><li><strong>作用域</strong></li><li>如果是函数的话，<strong>参数和返回值类型</strong></li></ul><p>这个过程中标识符会被存放到符号表中，符号表中维护了这些标识符的名称以及上述属性信息。</p><p>对于命令语句，语义分析可能会进行一些语义检查，例如</p><ul><li>变量或过程未定义就使用、或被重复定义</li><li>运算分量类型不匹配（数组与过程相加这样的错误）</li><li>操作符和操作数之间类型不匹配，例如<ul><li>数组下标不是整数</li><li>使用数组访问操作符访问非数组、使用过程调用操作符调用非过程</li><li>过程调用的参数类型或数目不匹配，或者返回值的类型错误</li></ul></li></ul><h2 id="中间代码生成及编译器后端概述"><a href="#中间代码生成及编译器后端概述" class="headerlink" title="中间代码生成及编译器后端概述"></a>中间代码生成及编译器后端概述</h2><h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>常用的中间表示有 <strong>三地址代码</strong> 和 <strong>语法结构树（syntax tree）</strong>。</p><p><em>语法结构树和前面提到的 parse tree 不是同一个概念。parse tree 是分析树，在语法分析过程后得到，而 syntax tree 是结构树，是一种中间表示。</em></p><h3 id="三地址码"><a href="#三地址码" class="headerlink" title="三地址码"></a>三地址码</h3><p>三地址码由类似汇编语言的指令序列构成，每个语句最多只包含三个操作数。</p><p>常用的三地址运算符有赋值、复制、条件跳转、无条件跳转、参数传递（类似汇编的 <code>push</code>）、过程调用（类似汇编的 <code>call</code>）、过程返回（类似汇编的 <code>ret</code>）、数组引用、数组赋值、地址及指针的操作等。</p><p>三地址码的表示有 <strong>四元式</strong>、<strong>三元式</strong> 和 <strong>间接三元式</strong>。</p><p>在四元式中，第一个分量指定语句类型，后三个分量分别是三个操作数，例如 <code>x = y + z</code> 的四元式为 <code>(+, y, z, x)</code>。</p><p>因为一句三地址码只能干一件事情，所以 <strong>三地址码序列唯一确定了程序的完成顺序</strong>。把一个三地址码的序列写出来的话，看上去的效果就跟汇编代码差不多。</p><h3 id="编译器后端"><a href="#编译器后端" class="headerlink" title="编译器后端"></a>编译器后端</h3><p>编译器在 <strong>目标代码生成</strong> 阶段会将中间表示翻译到目标语言，这个过程中的一个重要任务就是为变量分配合适的寄存器。</p><p>编译器可能会进行一些优化，优化可以在两个时间进行</p><ul><li><strong>机器无关代码优化</strong>，这个优化针对中间表示进行，在目标代码生成过程前完成</li><li><strong>机器相关代码优化</strong>，这个优化针对目标机器语言进行，在目标代码生成过程后完成</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust 学习笔记</title>
      <link href="/2018/11/10/Rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/11/10/Rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Rust-学习笔记"><a href="#Rust-学习笔记" class="headerlink" title="Rust 学习笔记"></a>Rust 学习笔记</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rustc --version</span></span><br><span class="line">rustc 1.30.0 (da5f414c2 2018-10-24)</span><br></pre></td></tr></table></figure><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><p>Rust 使用 cargo 进行项目管理。</p><ul><li>使用 <code>cargo</code> 建立一个新项目：<code>cargo new project_name --bin</code>。</li><li>使用 <code>cargo</code> 建立一个新模块：<code>cargo new module_name --lib</code>。</li><li>编译并运行： <code>cargo run</code>。</li><li>只编译：<code>cargo build</code>。</li><li>只检查是否能够通过编译：<code>cargo check</code>。</li><li>更新依赖：<code>cargo update</code>。</li><li>运行测试：<code>cargo test</code>。</li></ul><h3 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h3><ul><li>Rust 使用 <code>let</code> 声明变量，建议使用 <code>snake_case</code> 命名。</li><li>Rust 使用 <code>const</code> 声明常量，建议使用 <code>SCREAMING_SNAKE_CASE</code> 命名。</li><li>Rust 变量默认不可变，如果需要可变的话，需要加上 <code>mut</code>。</li></ul><p>Rust 具有 Shadowing 的特性，可以将声明一个与同作用域已经声明的变量名称相同的变量名。</p><a id="more"></a><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><ul><li>整数：<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code></li><li>浮点数：<code>f32</code>, <code>f64</code></li><li>布尔值：<code>bool</code></li><li>字符：<code>char</code>，使用 Unicode</li></ul><p>整数字面量中可以出现下划线 <code>_</code> 方便阅读，使用 <code>0x</code>, <code>0o</code>, <code>0b</code> 来切换进制。</p><h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><p>Rust 有元组和数组两种复合类型。</p><ul><li>元组索引使用 <code>.</code>，例如 <code>tup</code> 是一个元组，取出第一个元素为 <code>tup.0</code>。</li><li>元组支持解构 <code>let tup: (i32, bool) = (123, true); let (x, y) = tup;</code>。</li><li>数组是定长的，编译时确定长度，数组索引使用中括号。数组的类型标注示例 <code>let a: [i32; 5] = [1, 2, 3, 4, 5];</code>。</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>先区分 <strong>statement</strong> 和 <strong>expression</strong>。</p><p><em>注意 Rust 中的 expression 可以是大括号括起的若干 statement 加上一个 expression。可以写出这样的代码：<code>let y = {let x = 3; x + 1};</code>。</em></p><p>Rust 中函数定义使用 <code>fn</code>，需要为参数和返回值使用类型标注。函数命名建议 <code>snake_case</code>。</p><p>函数是一连串的 statement，外加最后的一个 expression，这个 expression 将会作为返回值返回。注意不要在最后一个 expression 后加上分号，否则会变成 statement。如果要提前返回，使用 <code>return</code>。最后一个 expression 使用 <code>return</code> 是不好的风格。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Rust 使用 <code>//</code> 作为单行注释，使用 <code>///</code> 对文档进行注释，使用 <code>//!</code> 对模块进行注释。后面两种注释内部使用 Markdown。</p><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><h4 id="if-expression"><a href="#if-expression" class="headerlink" title="if expression"></a><code>if</code> expression</h4><p>Rust 中的 <code>if</code> 是 expression，这说明你可以写出这样的代码：<code>let x = if condition_1 {1} else if condition_2 {2} else {3};</code>。</p><p>当然像其它语言一样控制流程也是可以的，注意 <code>if</code> 后面可以省掉括号。</p><h4 id="loop-无限循环"><a href="#loop-无限循环" class="headerlink" title="loop 无限循环"></a><code>loop</code> 无限循环</h4><p>Rust 使用 <code>loop</code> 进行无限循环，不能带任何条件。</p><h4 id="while-条件循环"><a href="#while-条件循环" class="headerlink" title="while 条件循环"></a><code>while</code> 条件循环</h4><p>Rust 使用 <code>while</code> 进行条件循环。和 <code>if</code> 一样不用带括号。</p><h4 id="for-容器遍历"><a href="#for-容器遍历" class="headerlink" title="for 容器遍历"></a><code>for</code> 容器遍历</h4><p>Rust 使用 <code>for ... in ...</code> 对容器进行遍历，并且只有这一种 <code>for</code> 循环语法。</p><h2 id="所有权系统"><a href="#所有权系统" class="headerlink" title="所有权系统"></a>所有权系统</h2><blockquote><p>所有权（系统）是 Rust 最独特的功能，其令 Rust 无需垃圾回收（garbage collector）即可保障内存安全。因此，理解 Rust 中所有权如何工作是十分重要的。</p></blockquote><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>Rust 不使用垃圾回收，也不要求程序员手动进行内存的分配和回收，而是通过所有权的概念管理内存。</p><p>Rust 中的每个（堆上的）值（例如 <code>String</code> 类型中实际存放字符串的内存）都有一个 <strong>所有者</strong>，并且 <strong>只可能有一个所有者</strong>。因为所有者总是在栈上，当所有者离开作用域的时候，值被销毁（例子中是内存被释放，由于只可能有一个所有者，这是安全的）。</p><p>此外 Rust 中有一个名叫 <code>Copy</code> 的 trait，实现了它的类型的行为与上述不同。如果一个类型是 <code>Copy</code> 的，那么它十有八九都是在栈上分配，和堆没有关系，这个时候就没有内存管理的问题了。实现了 <code>Copy</code> trait 的类型有所有的标量类型以及所有分量都是 <code>Copy</code> 的元组。</p><h4 id="移动——所有权转移"><a href="#移动——所有权转移" class="headerlink" title="移动——所有权转移"></a>移动——所有权转移</h4><p>为了保证每个堆上的值只有一个所有者，所有权会在不同的变量之间进行转移。拥有所有权的变量在所有权被转移后无法继续拥有所有权。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> b = a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(a); <span class="comment">// error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个变量，其中 <code>a</code> 先有所有权，随后通过一个赋值将所有权转移给了 <code>b</code>，这样在 <code>println!</code> 的时候不能再使用 <code>a</code> 了！在结尾的时候，<code>a</code> 没有对 <code>&quot;hello&quot;</code> 的所有权，所以不会发生什么；<code>b</code> 有所有权，这块内存会被释放。</p><h4 id="拷贝——所有权不转移"><a href="#拷贝——所有权不转移" class="headerlink" title="拷贝——所有权不转移"></a>拷贝——所有权不转移</h4><p>如果希望拷贝堆上的数据可以使用相应类型的拷贝方法。这种情况下所有权不会转移，而是堆上有两份相同的数据，它们拥有不同但是唯一的所有者。</p><h4 id="与函数和返回值有关的情况"><a href="#与函数和返回值有关的情况" class="headerlink" title="与函数和返回值有关的情况"></a>与函数和返回值有关的情况</h4><p>所有权的转移也可能发生在函数调用时（将所有权转移给了参数）和函数返回时（注意返回值总是以表达式存在的）。这说明一旦调用了一个函数并闯入了参数，如果这个函数没有返回参数，那么这个参数在函数调用结束的时候对应的堆内存就被回收了，函数调用完成后后面无法再使用之前传入的那个参数了！</p><h3 id="引用和借用"><a href="#引用和借用" class="headerlink" title="引用和借用"></a>引用和借用</h3><p><strong>引用</strong> 和 <strong>借用</strong> 实际上说的是同一个东西！所以后面只会提到 <strong>引用</strong>。</p><p>因为转移所有权看起来就很不方便（如果要写一个计算字符串长度的函数，将字符串传入函数后想重新得到所有权就要让函数返回来，同时要得到长度的话还要一个额外的返回值），所以有了引用的概念。</p><p>一个类型和它的引用类型是两种不同的类型，类型本身在离开作用域的时候会释放对应区域的内存，但是引用离开作用于的时候什么都不会发生。对下面的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>s</code> 的类型是 <code>&amp;String</code>，所以 <code>s</code> 离开作用域的时候不会发生任何事情。实际上，<code>s</code> 根本就没有对字符串的所有权。</p><p><strong>引用默认是不可变的，如果需要有可变的引用，要加上 <code>mut</code> 关键字</strong>。需要注意的是一个作用域中如果有一个可变引用，就不能再有其它的任何引用。这是 Rust 为了在编译时消除数据竞争问题做的设计。</p><p>使用 Rust 不会出现 <strong>悬垂引用</strong> 的问题，引用总是有效的，这个问题在编译阶段就已经被防止了，下面的代码不会通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h3><p>Rust 允许对堆上数据的一部分进行引用，例如字符串或者数组的一部分。</p><p>对 slice 进行引用的语法为 <code>let s = String::from(&quot;hello world!&quot;); let a = &amp;s[1..4];</code>。</p><p>这样的话 <code>s</code> 的类型为 <code>String</code> 而 <code>a</code> 的类型为 <code>&amp;str</code>。</p><p>这样做有一个额外的好处，如果我们写了一个函数，它接受一个 <code>&amp;String</code> 会返回一个 <code>&amp;str</code>，并且返回值与传入的参数有关，那么出于之前 <strong>有可变引用时只能有这一个引用</strong> 的约束，如下的 bug 是可以被避免的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;s);</span><br><span class="line">    s.clear(); <span class="comment">// error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其它语言中，<code>s.clear()</code> 的执行会导致 <code>word</code> 这个 <code>&amp;str</code> 失效，不过在 Rust 中，调用 <code>first_word</code> 时创建的 <code>&amp;s</code> 是不可变引用，而调用 <code>s.clear()</code> 时我们还要创建一个可变引用，这会在编译时报错。</p><p><em>为什么 <code>s.clear()</code> 要创建可变引用，因为这个函数的签名是 <code>pub fn clear(&amp;mut self)</code>。</em></p><p>OK，不过为啥有 <code>String</code> 和 <code>str</code> 的区别呢？我的理解是 <code>&amp;str</code> 是对内存中那一块连续区域的引用，而 <code>&amp;String</code> 是对字符串这个整体的引用，前者似乎更加底层。另外说一句，使用 <code>let a = &quot;hello world&quot;;</code> 的话 <code>a</code> 就直接是 <code>&amp;str</code> 了，这个字符串是直接在数据区的。这个字符串是无法更改的，即时使用了 <code>let mut a = &quot;hello world&quot;;</code> 也只是让 <code>a</code> 可以成为其它 <code>str</code> 的引用。如果引用了一个字符串，这个字符串的内容可变和自己还可以引用别的东西是有区别的！</p><p>数组也可以对 slice 进行引用，类型形如 <code>&amp;[i32]</code>。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>Rust 中的结构体可以分成三种：<strong>普通结构体</strong>、<strong>元组结构体</strong> 和 <strong>类单元结构体</strong>。</p><h3 id="普通结构体"><a href="#普通结构体" class="headerlink" title="普通结构体"></a>普通结构体</h3><p>和其它语言的结构体一样。命名推荐 <code>PascalCase</code>。</p><p>定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个实例（啧，这个代码看上去和 js 一样）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当字段名和已有的变量名相同时，可以省略：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望从已有的结构体创造新的结构体，只是改变其中的一些字段，有一个特殊的语法完成这件事：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">    active: user1.active,</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is equal to ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的几点：</p><ul><li>结构体没有实现 <code>Copy</code> trait，即时它所有的字段都是可 <code>Copy</code> 的，结构体本身也不是。</li><li>结构体不能对单独的几个字段设置 <code>mut</code>，只能整体设置。</li></ul><h3 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h3><p>元组结构体实际上就是对元组取名字以让它们具有不同的类型，元组结构体的字段没有名字。元组结构体也可以进行解构。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="类单元结构体"><a href="#类单元结构体" class="headerlink" title="类单元结构体"></a>类单元结构体</h3><p>类单元结构体没有任何字段。</p><h3 id="给结构体添加方法"><a href="#给结构体添加方法" class="headerlink" title="给结构体添加方法"></a>给结构体添加方法</h3><p>结构体可以拥有自己的方法，并且也可以拥有所谓的 <strong>关联函数</strong>。这个概念类似于 OOP 中的实例方法和静态方法。</p><p>结构体的方法都要放在一个 <code>impl</code> 块中，如果这个方法第一个参数是 <code>&amp;self</code> 或者是 <code>&amp;mut self</code>，则表明这个是实例的方法，否则它是一个静态的方法。一个结构体可以对应多个 <code>impl</code> 块。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define a impl block with a method</span></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define a impl block with a *associated function* (like a static method)</span></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width: size, height: size &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = Rectangle &#123; width: <span class="number">100</span>, height: <span class="number">200</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> b = a.area();</span><br><span class="line"><span class="keyword">let</span> c = Rectangle::square(<span class="number">300</span>);</span><br><span class="line"><span class="keyword">let</span> d = c.area();</span><br></pre></td></tr></table></figure><p>至于为什么要这么设计，我估计是方便对已有的结构体的方法进行扩展（类似 C# 中的扩展方法）。</p><h2 id="枚举和模式匹配"><a href="#枚举和模式匹配" class="headerlink" title="枚举和模式匹配"></a>枚举和模式匹配</h2><p>Rust 中的枚举和 C++ 中的不同，它并不是若干个可选值的集合，而是类似 Haskell 中的 Algebraic Data Type，每个可选值自己还能带一些数据。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举使用 <code>enum</code> 进行定义，推荐命名为 <code>PascalCase</code>。如下代码定义了一个枚举，可以看到它的每个元素可以额外附加一些数据，其中 <code>Move</code> 附加的数据是一个匿名结构体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举可以像结构体一样定义方法。</p><p>值得一提的一个枚举是 <code>Option</code> 枚举，它类似于 Haskell 中的 <code>Maybe</code>，两个元素分别是 <code>Some</code> 和 <code>None</code>。</p><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>我估计想获取 Rust 中的枚举的具体值只能使用模式匹配语法，这个也和 Haskell 类似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_info</span></span>(msg: &amp;Message) &#123;</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; <span class="built_in">println!</span>(<span class="string">"Quit"</span>),</span><br><span class="line">        Message::Move &#123; y, x &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"Move, &#123;&#125;, &#123;&#125;"</span>, x, y),</span><br><span class="line">        Message::Write(s) =&gt; <span class="built_in">println!</span>(<span class="string">"Write, &#123;&#125;"</span>, s),</span><br><span class="line">        Message::ChangeColor(a, b, c) =&gt; <span class="built_in">println!</span>(<span class="string">"ChangeColor, &#123;&#125;, &#123;&#125;, &#123;&#125;"</span>, a, b, c),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意其中 <code>Move {y, x}</code> 中的 <code>x</code> 和 <code>y</code> 名称一定要是结构体中定义的，但是顺序可以任意。</p><p>模式匹配中使用 <code>_</code> 作为通配符。</p><h3 id="if-let-语法糖"><a href="#if-let-语法糖" class="headerlink" title="if let 语法糖"></a><code>if let</code> 语法糖</h3><p><code>if let</code> 语法糖被用来处理只想处理一个枚举的一种情况和其它所有情况的情况。例如上面的例子中如果只希望对 <code>Move</code> 进行处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_info</span></span>(msg: &amp;Message) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Message::Move &#123;y, x&#125; = msg &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Move, &#123;&#125;, &#123;&#125;"</span>, x, y);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Not move message!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所见，<code>if let</code> 具有一个 <code>else</code> 分支。</p><h2 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h2><p>Rust 拥有一个好用的模块系统，并且有一个伴随着的测试系统。</p><h3 id="模块系统的定义"><a href="#模块系统的定义" class="headerlink" title="模块系统的定义"></a>模块系统的定义</h3><p>使用 <code>mod</code> 关键字定义模块，模块可以嵌套定义。模块和 crate 都推荐使用 <code>snake_case</code> 命名。</p><p>也可以只声明一个模块，而将定义放到其它的文件中。当你要这么干的时候，需要将整个模块按照某种特定的在文件系统中的格式组织起来。</p><p>使用 <code>pub</code> 关键字将模块中的内容标记为对外可见的。</p><h3 id="引用模块"><a href="#引用模块" class="headerlink" title="引用模块"></a>引用模块</h3><p>使用 <code>extern crate create_name;</code> 来引入外来的模块，使用 <code>use</code> 来将一个模块中的内容引入当前命名空间。</p><p><code>use</code> 可以跟：</p><ul><li><code>use a::series::of::nested_modules;</code></li><li><code>use TrafficLight::{Red, Yellow};</code></li><li><code>use TrafficLight::*;</code></li></ul><p>可以在 <code>use</code> 中使用 <code>super</code> 来访问上一级模块。</p><h2 id="通用集合类型"><a href="#通用集合类型" class="headerlink" title="通用集合类型"></a>通用集合类型</h2><p>Rust 提供了一些常见的集合类型，例如 <code>Vec</code>、<code>String</code> 和 <code>HashMap</code>。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Rust 的错误可以分成两种：可恢复的错误和不可恢复的错误。</p><p>对于不可恢复的错误，使用 <code>panic!</code> 宏会使程序结束。如果程序带有调试信息，还会打印调用栈。</p><p>对于可恢复的错误，一般是使用 <code>Result</code> 将其包装起来，<code>Result</code> 的定义是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般使用模式匹配处理。每个 <code>Result</code> 都有一个 <code>unwrap</code> 方法，这个方法可以在 <code>Result</code> 正常的时候返回值，错误的时候调用 <code>panic!</code>；也有一个 <code>expect</code> 方法，这个方法与 <code>unwrap</code> 类似，不过可以指定 <code>panic!</code> 的内容。</p><p>错误可以继续传播上去，让更高层的函数进行处理。这样的函数返回类型一般是 <code>Result</code>。在这样的函数中可以使用 <code>?</code> 操作符来简化样板代码。当在这样的一个函数中调用一个返回值为 <code>Result</code> 的函数时，如果调用最后加上了 <code>?</code>，那么在成功时会拿到成功的值，失败时会直接返回包装于 <code>Result</code> 中的错误，并且是直接将得到的错误返回。</p><h2 id="泛型、trait、生命周期"><a href="#泛型、trait、生命周期" class="headerlink" title="泛型、trait、生命周期"></a>泛型、trait、生命周期</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>Rust 中可以定义泛型函数。下面这个例子暂时无法通过编译，只是用来举例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以为结构体和枚举定义泛型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当为泛型结构体定义方法时，<code>impl</code> 后面也要加上类型参数。这是因为可以为一些单独的类型参数作特殊处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only Point&lt;f32&gt; can get distance_from_origin</span></span><br><span class="line"><span class="keyword">impl</span> Point&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">distance_from_origin</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.powi(<span class="number">2</span>) + <span class="keyword">self</span>.y.powi(<span class="number">2</span>)).sqrt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，<code>impl</code> 后面的类型参数并不总是和方法签名中的类型参数一致：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mixup</span></span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h3><p>前面说过泛型的第一个例子无法通过编译，因为不是所有的所有的类型都能够比大小（不具有偏序关系）。</p><p>能够比较大小是一个 trait，类似于其它语言中的接口。</p><p>通过 <code>trait</code> 关键字定义 trait，推荐使用 <code>PascalCase</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summarizable</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summary</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个表示 <code>Summarizable</code> trait 要求实现 <code>summary</code> 方法，你可以为这个方法制定一个默认实现，这个实现可能会被重载；默认实现可以调用 trait 中的其它方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summarizable</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">author_summary</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summary</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"(Read more from &#123;&#125;...)"</span>, <span class="keyword">self</span>.author_summary())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现一个 trait，使用 <code>impl</code> 关键字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summarizable <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summary</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;, by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以在 <code>NewsArticle</code> 上调用 <code>summary</code> 方法了。</p><p>Trait 的一大作用是在写泛型的时候对类型参数进行约束，使用下面的语法进行约束：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T must implement Summarizable</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summarizable&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summary());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if you need to implement multiple trait</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: T, u: U) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外也可以将约束信息放在函数后面，这样可能具有更高的可读性：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: T, u: U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更高级的用法：例如定义了一个泛型的结构体，希望在这个结构体的类型参数满足某些 trait 时让结构体有额外的方法，可以这样进行约束：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T, y: T) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cmp_display</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is x = &#123;&#125;"</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is y = &#123;&#125;"</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样所有的 <code>Pair</code> 都具有 <code>new</code> 方法，但是只有实现了 <code>Display</code> 和 <code>PartialOrd</code> 的 <code>Pair</code> 具有 <code>cmp_display</code> 方法。</p><p>另外，如果一个类型实现了某种 <code>trait</code>，可以对这个类型实现一些方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，所有实现了 <code>Display</code> trait 的类型都会具有 <code>ToString</code> 方法。这个比上面更抽象，上面的例子是，如果 <code>T</code> 实现了 <code>Display</code>，<code>Pair&lt;T&gt;</code> 会怎么样；而这个例子是，如果 <code>T</code> 实现了 <code>Display</code>，<code>T</code> 会怎么样。</p><h3 id="生命周期与引用有效性"><a href="#生命周期与引用有效性" class="headerlink" title="生命周期与引用有效性"></a>生命周期与引用有效性</h3><h4 id="函数的生命周期注解"><a href="#函数的生命周期注解" class="headerlink" title="函数的生命周期注解"></a>函数的生命周期注解</h4><p>C++ 中有时会写出这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *a;</span><br><span class="line">    [&amp;]() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">b</span><span class="params">(<span class="string">"Hello, world!"</span>)</span></span>;</span><br><span class="line">        a = &amp;b;</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这份代码运行起来是错的，因为 <code>a</code> 实际上指向了一个已经被释放掉的内存。这个问题在 Rust 中不会出现，Rust 的解决方案是，每个引用都会有自己的生命周期，一个引用的生命周期是这个引用被声明到自己离开作用域。显然每个引用的生命周期是可以在编译时确定的，Rust 要求 <strong>一个引用不能引用生命周期比自己短的变量</strong>，否则编译失败。上面的例子中就是出现了这种情况所以会出问题。</p><p>如果我们要写一个函数，它接受两个字符串的引用，返回更长的那个字符串的引用，可能会想这么写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个是有问题的，传入的两个参数 <code>x</code> 和 <code>y</code> 的生命周期和返回值的生命周期之间的关系是不知道的，但是 Rust 需要这个信息来保证安全性。因此我们要手动引入生命周期信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用这个函数的时候，生命周期变量 <code>&#39;a</code> 会被实际生命周期代替，事实上，它会成为 <code>x</code> 以及 <code>y</code> 二者生命周期中更短的那一个。于是，这个函数的返回值的生命周期也是 <code>x</code> 以及 <code>y</code> 中更短的那一个，这样当引用结果的时候，只能是被生命周期比和 <code>x</code> 以及 <code>y</code> 中生命周期更短的那一个还要短的变量所引用，也就没有上述的问题了。</p><p>此外，Rust 禁止返回悬垂引用，下面的代码无法通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">String</span>::from(<span class="string">"really long string"</span>);</span><br><span class="line">    result.as_str()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>结构体中如果存放了引用，也需要使用生命周期进行标记，如下。对于这种结构体，实现方法时也要带上生命周期：</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些情况下，方法的生命周期可以省略。这三种情况是：</p><ul><li>所有的引用参数都具有自己的生命周期。</li><li>方法只有一个引用参数和一个引用返回值，它们两个生命周期相同。</li><li>方法有一个 <code>&amp;self</code> 并且所有的引用返回值的生命周期都和它相同。</li></ul><p>最后，Rust 中有一个特殊的生命周期叫做 <code>&#39;static</code>，表示像全局变量这种 <strong>静态的</strong> 生命周期。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>将一个函数标记为需要测试的，在函数签名上方加上 <code>#[test]</code> 标记。</p><p>将一个模块标记为需要测试的，在模块上方加上 <code>#[cfg(test)]</code> 标记。这个标记将会告诉编译系统只有在需要测试的时候才进行编译。</p><p>在测试的函数中，使用 <code>assert!</code>、<code>assert_eq!</code> 和 <code>assert_ne!</code> 等宏来进行检查；在函数上添加 <code>#[should_panic]</code> 或更详细的 <code>#[should_panic(expected = &quot;infomation_here&quot;)]</code> 来标记这个函数运行中应当 panic。</p><h2 id="函数式语言功能"><a href="#函数式语言功能" class="headerlink" title="函数式语言功能"></a>函数式语言功能</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>Rust 中的匿名函数语法为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> get_max = |vec: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;| &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> max = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> vec &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; &amp;max &#123;</span><br><span class="line">            max = *i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> max_v = get_max(&amp;v);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Max of v is &#123;&#125;"</span>, max_v);</span><br></pre></td></tr></table></figure><p>其中类型标注不是必须的，只有编译器无法推断的时候才需要。另外如果函数只有一行的话，可以省略花括号：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> double = |x| x * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"double of 3 is &#123;&#125;"</span>, double(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>匿名函数可以访问到环境中的变量，如果希望将所有权移交给匿名函数，在参数列表前加上 <code>move</code> 关键字。</p><p>匿名函数可能实现了 <code>Fn</code>、<code>FnOnce</code> 和 <code>FnMut</code> 这三个 trait 中的若干个，区别在于 <code>Fn</code> 获取环境中不可变引用；<code>FnMut</code> 获取环境中可变引用；<code>FnOnce</code> 获取环境中变量的所有权。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>一般使用 <code>iter</code> 方法获得一个容器的不可变引用迭代器，使用 <code>iter_mut</code> 获得可变引用迭代器，使用 <code>into_iter</code> 获得返回所有权的迭代器。</p><p>迭代器都实现了 <code>Iterator</code> trait，实现了这个 trait 的类型都具有 <code>next</code> 方法可以得到下一个值，包装在 <code>Option</code> 中。当遍历完成时，返回 <code>None</code>。如果要实现自己的 <code>Iterator</code>，只用实现 <code>Iterator</code> trait 以及 <code>next</code> 方法。</p><p>迭代器的方法一般分成两种，一种是类似 <code>sum</code> 这样的执行一次就会消耗掉迭代器的，另一种是 <code>map</code> 这样的会产生一个新的迭代器的（Rust 中迭代器是惰性的，没有使用前不会进行求值）。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="Box-lt-T-gt"><a href="#Box-lt-T-gt" class="headerlink" title="Box&lt;T&gt;"></a><code>Box&lt;T&gt;</code></h3><p>使用 <code>Box&lt;T&gt;</code> 可以将一个标量类型放在堆上：<code>let a = Box::new(3);</code>，操作后堆上有 3，同时栈上有一个指向 3 的指针。</p><p>使用 <code>Box&lt;T&gt;</code> 的目的可能是定义递归结构。如果递归结构在栈上分配，编译器不知道这个结构的大小，是不可能做到的。</p><h3 id="Deref-trait"><a href="#Deref-trait" class="headerlink" title="Deref trait"></a><code>Deref</code> trait</h3><p><code>Deref</code> trait 要求实现 <code>deref</code> 方法，实现了这个 trait 后，一个智能指针可以像普通引用那样被使用。如果智能指针为 <code>p</code>，那么 <code>*p</code> 实际上执行的是 <code>*(p.deref())</code>。</p><h3 id="Drop-trait"><a href="#Drop-trait" class="headerlink" title="Drop trait"></a><code>Drop</code> trait</h3><p>实现了 <code>Drop</code> trait 的变量在离开作用域的时候会做一些事情，具体的是这个 trait 要求实现的 <code>drop</code> 方法。这个方法不能手动调用，不过，可以使用 <code>std::mem::drop</code> 函数来手动清理一个智能指针。</p><h3 id="Rc-lt-T-gt"><a href="#Rc-lt-T-gt" class="headerlink" title="Rc&lt;T&gt;"></a><code>Rc&lt;T&gt;</code></h3><p><code>Rc&lt;T&gt;</code> 是引用计数的指针。</p><ul><li>使用 <code>Rc::new</code> 创建第一个引用。</li><li>使用 <code>Rc::clone</code> 对其它引用进行克隆。</li><li>使用 <code>Rc::strong_count</code> 获得当前强引用计数。</li></ul><p>==下次从智能指针这一章开始看（重看）==</p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程课程项目博客-集成与测试</title>
      <link href="/2018/10/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2-3/"/>
      <url>/2018/10/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2-3/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程课程项目博客-集成与测试"><a href="#软件工程课程项目博客-集成与测试" class="headerlink" title="软件工程课程项目博客-集成与测试"></a>软件工程课程项目博客-集成与测试</h1><p>这是对一个为期一周的开发活动的个人总结。这个开发活动的主要目的是让我们熟悉持续集成以及了解一些基本的测试的概念并进行实践。</p><h2 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h2><ul><li><strong>单元测试</strong>：单元测试是对程序中的最小单元的功能正确性的验证。使用 Python 的话最小单元就是函数，单元测试要检测的就是这些函数。就我的感觉而言，通过单元测试我们可以预先定义出这个函数的正确行为应该是什么，于是在以后对这个函数进行的改动都可以保证正确，这会在以后的改动过程中让我们更有信心。不过，因为这次的作业时间确实较短而且逻辑不复杂，这个效果可能不是很明显。</li><li><strong>功能测试</strong>：按我的理解，单元测试更多的是站在代码的角度上说的，而功能测试更多是站在业务的角度上说的。单元测试是检查负责抢票的处理函数在一个人在已经抢过的情况下再次抢票能够正确处理，而功能测试则直接要求一个人只能抢一张票，至于背后的实现它是不关心的。通过功能测试我们可以保证自己的系统能够满足用户的需求，而不仅仅是“能够正确地工作”。</li><li><strong>性能测试</strong>：性能测试就是对服务器处理能力的考验。抢票这个功能从名称上看来就是需要服务器在某些情况下能够处理大量数据的。通过使用性能测试我们能够知道服务器最大能够处理多大量的数据，这样在应对一些极端情况之前我们就能知道能不能扛得住从而提前做决定，减小损失。</li></ul><p>通过这些测试我们就拥有了一个评价代码质量的标准，能够让自己对代码的表现有更加精确的预期。</p><a id="more"></a><h2 id="关于持续集成"><a href="#关于持续集成" class="headerlink" title="关于持续集成"></a>关于持续集成</h2><p>持续集成是指频繁地将分支代码合并到主分支中，并触发相应的检查以提前暴露错误。我们的项目中使用了持续集成，而且我也确实在某次提交中感受到了这个概念的意义，那次提交中因为我在做测试的时候有一个奇怪的假定导致这个测试只有在单独跑我的测试的时候才能成功，如果没有持续集成的话可能这个测试就会被当成是正确的代码进入主分支。尽管这是测试代码，但依然能够说明持续集成的意义——将程序中的 bug 更加容易的暴露出来。</p><p>持续集成的流程一般是提交、测试、构建、再次测试和部署。通过这种标准化的流程，可以设计出一些通用的持续集成工具进行自动化，从而让开发者只关注提交之前的编码过程，这样便可以近乎免费地享受到持续集成带来的好处。</p><h2 id="对意义的一些思考"><a href="#对意义的一些思考" class="headerlink" title="对意义的一些思考"></a>对意义的一些思考</h2><p>遵守这些流程到底有多大意义呢？它带来的好处是否胜过了为了遵守它而付出的代价？我并没有在真实的大型项目的开发中使用这些流程，目前只是在一个只用一个星期就能完成的项目中使用到了，因此可能没法准确地给出它的意义，但是这无妨我做一些思考。</p><p>如果单纯地是要做出一个简单的产品，就是要拼速度，那么使用这一套流程显然是杀鸡用牛刀了。不过如果是要开发一个相当复杂的项目，就必须考虑到工程学上的一些事情。而在软件工程中这些流程显然可以有效提高代码质量，而且它们的特点是越早写出来，就越能长久地享受到这些流程带来的好处，并且后续的这些好处是没有成本的。稍微大型一点、开发时间长一点、开发人员多一点的项目都应该按实际情况适当选用一些这些流程来确保自己的项目的质量。尽管我们的小项目中它们的好处表现不明显，但是想想就会发现，如果我们要在若干个月后再来继续开发，那么拥有已经写好的测试和一个能够自动进行构建和集成的系统是很有好处的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编课程大作业博客——编码 x86 指令</title>
      <link href="/2018/10/09/%E6%89%8B%E5%86%99%E6%B1%87%E7%BC%96%E5%99%A8-2/"/>
      <url>/2018/10/09/%E6%89%8B%E5%86%99%E6%B1%87%E7%BC%96%E5%99%A8-2/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编课程大作业博客——编码-x86-指令"><a href="#汇编课程大作业博客——编码-x86-指令" class="headerlink" title="汇编课程大作业博客——编码 x86 指令"></a>汇编课程大作业博客——编码 x86 指令</h1><p>在上一篇中我们研究了 PE 的结构，其中最麻烦的段是 .text 段。如果已经知道了汇编代码，如何构造这个 .text 段？这涉及到如何编码 x86 指令。</p><p><a href="http://www.c-jump.com/CIS77/CPU/x86/lecture.html" target="_blank" rel="noopener">Encoding Real x86 Instructions</a> 这篇页面简单讲了一下如何对 x86 指令进行编码，对我们的任务来说应该够了。这篇博客是对该页面的学习记录。</p><h2 id="x86-机器码的整体结构"><a href="#x86-机器码的整体结构" class="headerlink" title="x86 机器码的整体结构"></a>x86 机器码的整体结构</h2><p>一条 x86 的指令在编码后会有各种部分，如果将所有可选的部分写到一起，最高可以有十六字节。不过，并不是所有部分都是必要的，实际上 x86 不会有超过十五字节的指令。</p><p>回到将所有可选部分写到一起那一步，这十六个字节的结构如下：</p><ul><li><strong>最高四个字节</strong>：Prefix Bytes，实际可能有零到四个字节，这些前缀会影响操作的结果。</li><li><strong>次高四个字节</strong>：这四个字节编码了指令以及指令的工作方式（opcode + Mod-Reg-R/M + SIB，后面会写）。</li><li><strong>次低四个字节</strong>：这四个字节编码了 displacement [<a href="https://stackoverflow.com/questions/13329611/x86-x64-add-displacement-addressing" target="_blank" rel="noopener">1</a>]，displacement 用于寻址。这四个字节不会全部使用，可能会用到零个、一个、两个或四个字节。</li><li><strong>最低四个字节</strong>：这四个字节编码了 immediate data。这四个字节不会全部使用，可能会用到零个、一个、两个或四个字节。</li></ul><p>对于次高四个字节，还可以进一步细分：</p><ul><li>最高的两个字节，编码 opcode，可能会使用其中的一个或两个字节。</li><li>接下来的一个字节称为 <em>Mod-Reg-R/M</em> 字节，这个字节指明了寻址模式和操作数的大小。只有指令需要寄存器或者内存的操作数的时候才会使用这个字节。</li><li>接下来的一个字节称为 SIB（Scaled Indexed Byte）。如果指令使用了 scaled indexed memory addressing，就会用到这个字节。具体是什么后面会写。</li></ul><p>不是所有的字节都会被用到（实际上大部分字节都不会被用到）。我们会先了解次高四个字节。</p><a id="more"></a><h2 id="opcode-的编码"><a href="#opcode-的编码" class="headerlink" title="opcode 的编码"></a>opcode 的编码</h2><p>opcode 可能占用一个或两个字节，它的编码方式如下：</p><ul><li>对于使用了一个字节的指令，这个字节就编码了指令的类型。</li><li>对于使用了两个字节的指令，第一个字节总是 0x0F，这个字节称为 <em>opcode expansion prefix byte</em>。第二个字节则会实际编码指令的类型。</li></ul><p>这样的编码方式保证了有 512 条指令可以使用。不过 x86 没有使用完。<a href="http://www.c-jump.com/CIS77/reference/Instructions_by_Opcode.html" target="_blank" rel="noopener">这个页面</a> 可以从 opcode 检索对应的指令，[这个页面] 可以从指令检索对应的 opcode。</p><h2 id="Mod-Reg-R-M-字节与-SIB-的编码"><a href="#Mod-Reg-R-M-字节与-SIB-的编码" class="headerlink" title="Mod-Reg-R/M 字节与 SIB 的编码"></a>Mod-Reg-R/M 字节与 SIB 的编码</h2><p>在这一节前需要先知道 x86 寻址的一些东西。当数据不是常数时，CPU 要在某个地方取出数据，而数据要么在寄存器中，要么在内存中。寄存器只要知道名字就能访问，而内存还需要知道具体的地址，这个地址又存在哪里呢？最一般的格式是 <code>base + scale * index + displacement</code> 的形式，可以假想我们需要取出某个结构体数组中的某一个元素的某个域，这样四个量都会起作用，其中 <code>base</code> 表示基地址（可以假想成首元素的地址），这个基地址存在于寄存器中；<code>scale</code> 可以想象成每个结构体的大小，不过，x86 规定它的取值只能是 1、2、4、8 中的一个；<code>index</code> 表示下标，存在于寄存器中；<code>displacement</code> 表示偏移量，可以想象成需要取出的那个域在整个结构体中的位置，这个量就是机器码中的“次低四个字节”。</p><p>以上谈的是从地址中获取数据，另外数据还可能直接存在于寄存器中，这两种情况我们可以统一看待。那么，Mod-Reg-R/M 字节和 SIB 的编码就决定了，对于一个指令它将会从哪里，以怎样的方式获取数据。</p><p>当然，不是每次获取数据都要要上面那么麻烦，很多时候我们只希望：</p><ul><li>直接以一个寄存器中的值作为地址</li><li>以一个寄存器中的值作为地址，加上一个已知的偏移</li><li>直接从寄存器中读取值</li><li>直接用一个已知的值作为地址</li></ul><p>这几种情况下，我们不会使用 scaled indexed memory addressing，因此可以省去 SIB 这个字节。但是如果需要使用之前说的复杂的寻址方式的话就必须用上。</p><h3 id="Mod-Reg-R-M-字节编码"><a href="#Mod-Reg-R-M-字节编码" class="headerlink" title="Mod-Reg-R/M 字节编码"></a>Mod-Reg-R/M 字节编码</h3><p>Mod-Reg-R/M 占一个字节：</p><ul><li>最高两位（7、6）为 MOD，指定了寻址方式。</li><li>次高三位（5、4、3）为 REG，指定了一个通用寄存器，这个寄存器既不存 <code>base</code> 也不存 <code>index</code>，而是作为指令的 source 或者 destination（具体是 source 还是 destination 看对应的指令）。</li><li>最低三位（2、1、0）为 R/M，指定了寻址时使用的存放 <code>base</code> 的寄存器。</li></ul><p>以上说的只是一般规律，存在例外。</p><p>先看 REG，它一共有八个值，对应不同的寄存器。随着指令的数据大小不同也对应着不同的寄存器：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>REG 值</strong></th><th style="text-align:center"><strong>寄存器</strong>（数据大小为 8 位）</th><th style="text-align:center"><strong>寄存器</strong>（数据大小为 16 位）</th><th style="text-align:center"><strong>寄存器</strong>（数据大小为 32 位）</th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">AL</td><td style="text-align:center">AX</td><td style="text-align:center">EAX</td></tr><tr><td style="text-align:center">001</td><td style="text-align:center">CL</td><td style="text-align:center">CX</td><td style="text-align:center">ECX</td></tr><tr><td style="text-align:center">010</td><td style="text-align:center">DL</td><td style="text-align:center">DX</td><td style="text-align:center">EDX</td></tr><tr><td style="text-align:center">011</td><td style="text-align:center">BL</td><td style="text-align:center">BX</td><td style="text-align:center">EBX</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">AH</td><td style="text-align:center">SP</td><td style="text-align:center">ESP</td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">CH</td><td style="text-align:center">BP</td><td style="text-align:center">EBP</td></tr><tr><td style="text-align:center">110</td><td style="text-align:center">DH</td><td style="text-align:center">SI</td><td style="text-align:center">ESI</td></tr><tr><td style="text-align:center">111</td><td style="text-align:center">BH</td><td style="text-align:center">DI</td><td style="text-align:center">EDI</td></tr></tbody></table></div><p>注意 REG 指定的寄存器和数据有关，与寻址没有关系。</p><p>前面已经说过，在不使用 scaled indexed memory addressing 的情况下可以仅使用 Mod-Reg-R/M 字节进行寻址。我们已经看过了 REG，它与寻址没有关系。</p><p>对于 MOD：</p><div class="table-container"><table><thead><tr><th style="text-align:center">MOD 值</th><th style="text-align:center">寻址方式</th></tr></thead><tbody><tr><td style="text-align:center">00</td><td style="text-align:center">大部分情况下是将 R/M 指定的寄存器中的值作为地址进行寻址</td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">启用一字节长度的 displacement，基址为 R/M 指定的寄存器</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">启用四字节长度的 displacement，基址为 R/M 指定的寄存器</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">直接将 R/M 指定的寄存器中的值作为值</td></tr></tbody></table></div><p>从上面可以看到 R/M 是用来指定寄存器的，它具有三位，编码寄存器的方式与 REG 编码寄存器的方式相同。另外可以看到使用 Mod-Reg-R/M 时存在一些例外情况，这是因为需要能够启用 scaled indexed memory addressing 的模式，以及开启 displacement-only 的模式（没有基址，直接以寄存器中的值作为地址进行寻址）。</p><p>为了标记出这些例外，可以将 MOD 和 R/M 所有的 32 种组合枚举出来。例外情况使用黑体标出：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>MOD 值</strong></th><th style="text-align:center"><strong>R/M 值</strong></th><th style="text-align:center"><strong>寻址方式</strong></th></tr></thead><tbody><tr><td style="text-align:center">00</td><td style="text-align:center">000</td><td style="text-align:center"><code>[eax]</code></td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">000</td><td style="text-align:center"><code>[eax + displacement_8]</code></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">000</td><td style="text-align:center"><code>[eax + displacement_32]</code></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">000</td><td style="text-align:center">直接从 AL / AX / EAX 中获得值</td></tr><tr><td style="text-align:center">00</td><td style="text-align:center">001</td><td style="text-align:center"><code>[ecx]</code></td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">001</td><td style="text-align:center"><code>[ecx + displacement_8]</code></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">001</td><td style="text-align:center"><code>[ecx + displacement_32]</code></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">001</td><td style="text-align:center">直接从 CL / CX / ECX 中获得值</td></tr><tr><td style="text-align:center">00</td><td style="text-align:center">010</td><td style="text-align:center"><code>[edx]</code></td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">010</td><td style="text-align:center"><code>[edx + displacement_8]</code></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">010</td><td style="text-align:center"><code>[edx + displacement_32]</code></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">010</td><td style="text-align:center">直接从 DL / DX / EDX 中获得值</td></tr><tr><td style="text-align:center">00</td><td style="text-align:center">011</td><td style="text-align:center"><code>[ebx]</code></td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">011</td><td style="text-align:center"><code>[ebx + displacement_8]</code></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">011</td><td style="text-align:center"><code>[ebx + displacement_32]</code></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">011</td><td style="text-align:center">直接从 BL / BX / EBX 中获得值</td></tr><tr><td style="text-align:center">00</td><td style="text-align:center">100</td><td style="text-align:center"><strong>scaled indexed memory addressing 模式，无 displacement 或 32 位 displacement-only</strong></td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">100</td><td style="text-align:center"><strong>scaled indexed memory addressing 模式，8 位 displacement</strong></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">100</td><td style="text-align:center"><strong>scaled indexed memory addressing 模式，32 位 displacement</strong></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">100</td><td style="text-align:center">直接从 AH / SP / ESP 中获得值</td></tr><tr><td style="text-align:center">00</td><td style="text-align:center">101</td><td style="text-align:center"><strong>displacement-only 模式</strong></td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">101</td><td style="text-align:center"><code>[ebp + displacement_8]</code></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">101</td><td style="text-align:center"><code>[ebp + displacement_32]</code></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">101</td><td style="text-align:center">直接从 CH / BP / EBP 中获得值</td></tr><tr><td style="text-align:center">00</td><td style="text-align:center">110</td><td style="text-align:center"><code>[esi]</code></td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">110</td><td style="text-align:center"><code>[esi + displacement_8]</code></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">110</td><td style="text-align:center"><code>[esi + displacement_32]</code></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">110</td><td style="text-align:center">直接从 DH / SI / ESI 中获得值</td></tr><tr><td style="text-align:center">00</td><td style="text-align:center">111</td><td style="text-align:center"><code>[edi]</code></td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">111</td><td style="text-align:center"><code>[edi + displacement_8]</code></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">111</td><td style="text-align:center"><code>[edi + displacement_32]</code></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">111</td><td style="text-align:center">直接从 BH / DI / EDI 中获得值</td></tr></tbody></table></div><p>对上表的一些注解：</p><ul><li><code>displacement_8</code> 指的是 8 位 displacement，32 位类似。</li><li>使用 8 位 displacement 只用一个 displacement 字节，更加短小。</li><li>对于 MOD = 11，R/M = 000 这种情况，具体使用哪个寄存器依赖于指令的不同。一般来说一组中指令中会有一个位来标记使用 8 位寄存器还是 32 位寄存器，如果需要用到 16 位寄存器则要启用 Prefix Bytes（最高四个字节）。</li><li>MOD = 00，R/M = 101 这个情况下，如果确实希望使用 <code>[ebp]</code> 方式寻址，可以考虑使用 <code>[epb + displacement_8]</code> 并将 displacement 设置为 0。</li></ul><p>下面来看 scaled indexed memory addressing 模式。</p><h3 id="SIB-编码"><a href="#SIB-编码" class="headerlink" title="SIB 编码"></a>SIB 编码</h3><p>SIB 用来使用 <code>base + scale * index + displacement</code> 这种复杂的寻址方式。</p><p>SIB 是紧随着 Mod-Reg-R/M 后的一个字节（只有需要的时候才会出现）：</p><ul><li>最高两位（7、6）编码了 <code>scale</code>，<code>scale</code> 只能在四个可选值中选择。</li><li>次高三位（5、4、3）通过指定寄存器的方式编码了 <code>index</code>。</li><li>最低三位（2、1、0）通过指定寄存器的方式编码了 <code>base</code>。</li></ul><p>具体地：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>最高两位编码 <code>scale</code></strong></th><th style="text-align:center"><strong><code>scale</code> 的值</strong></th></tr></thead><tbody><tr><td style="text-align:center">00</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">8</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">次高三位编码 <code>index</code></th><th style="text-align:center"><code>index</code> 的寄存器</th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">EAX</td></tr><tr><td style="text-align:center">001</td><td style="text-align:center">ECX</td></tr><tr><td style="text-align:center">010</td><td style="text-align:center">EDX</td></tr><tr><td style="text-align:center">011</td><td style="text-align:center">EBX</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center"><strong>不合法</strong> （可能是为了方便以后扩展）</td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">EBP</td></tr><tr><td style="text-align:center">110</td><td style="text-align:center">ESI</td></tr><tr><td style="text-align:center">111</td><td style="text-align:center">EDI</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">最低三位编码 <code>base</code></th><th style="text-align:center"><code>base</code> 的寄存器</th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">EAX</td></tr><tr><td style="text-align:center">001</td><td style="text-align:center">ECX</td></tr><tr><td style="text-align:center">010</td><td style="text-align:center">EDX</td></tr><tr><td style="text-align:center">011</td><td style="text-align:center">EBX</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">ESP</td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">EBP（<strong>例外见注解</strong>）</td></tr><tr><td style="text-align:center">110</td><td style="text-align:center">ESI</td></tr><tr><td style="text-align:center">111</td><td style="text-align:center">EDI</td></tr></tbody></table></div><p><strong>注解</strong>：在最低位为 101 时，存放了 <code>base</code> 的寄存器一般是 EBP。但是为了支持在 scaled indexed memory addressing 中的 displacement-only 格式，如果这个时候 MOD 的值是 00，那么将没有存放基址的寄存器（认为基址为 0）。如果此时 MOD 的值是 01 或者 10，则正常使用 EBP。</p><p>Mod-Reg-R/M 与 SIB 结合的几个例子：</p><ul><li>MOD = 00，EAX 作为 <code>base</code>，EBX 作为 <code>index</code>，<code>scale</code> 为 8：<ul><li>SIB = 11 011 000</li><li>地址为 <code>eax + ebx * 8</code>（MOD = 00 指定了没有 <code>displacement</code>）</li></ul></li><li>MOD = 10，EAX 作为 <code>base</code>，EBX 作为 <code>index</code>，<code>scale</code> 为 8：<ul><li>SIB = 11 011 000</li><li>地址为 <code>eax + ebx * 8 + displacement</code>，其中 <code>displacement</code> 有 32 位。</li></ul></li><li>MOD = 00，启用 scaled indexed memory addressing 下的 displacement-only 格式，EBX 作为 <code>index</code>，scale 设为 8：<ul><li>SIB = 11 011 101</li><li>地址为 <code>ebx * 8 + displacement</code>，其中 <code>displacement</code> 有 32 位。</li></ul></li></ul><h2 id="加法指令编码的例子"><a href="#加法指令编码的例子" class="headerlink" title="加法指令编码的例子"></a>加法指令编码的例子</h2><p>从 <a href="http://www.c-jump.com/CIS77/reference/Instructions_by_Mnemonic.html" target="_blank" rel="noopener">这张表</a> 中可以看到 add 指令对应的 opcode 有很多，主要是为了支持不同的操作数大小和类型，它们有没有规律？</p><p>如果不涉及到常量（immediate value）的话，实际上只有四个 add 指令，opcode 对应的是 0、1、2、3。</p><p>很多指令都像 add 这样对于不同的操作数和类型有多种 opcode，一般来说它们的 opcode 会有相同的前缀，然后有第 1 位指定方向（寄存器是 source 还是 destination），第 0 位指定大小（8 位还是 32 位，对于 16 位要开启 Prefix Bytes）。</p><p>下面几个例子会用到之前学到的编码方式的知识，这些例子暂时不涉及到 immediate value。在以下的这些例子中，形如 <code>mem8</code> 的表示的不一定就是地址，也可能是一个寄存器。</p><h3 id="ADD-CL-AL"><a href="#ADD-CL-AL" class="headerlink" title="ADD CL, AL"></a><code>ADD CL, AL</code></h3><p>查表知这是 <code>add reg8, reg8</code> 形式，opcode 为 02；不涉及到寻址，所以 MOD 取 11；由于 opcode 为 02 指定了大小，所以 REG 和 R/M 会各自指定一个寄存器。但是哪个对应哪个呢？</p><p>一般来说，指令的第 1 位指定方向（对于向 ADD 这样的指令），如果这一位是 1，就说明 REG 指定的寄存器是 destination，如果这一位是 0，则为 source。</p><p>我们使用的 opcode 是 02，这一位是 1，故 REG 是 destination，例子中的 destination 是 CL，所以 REG 应该取 001；source 是 AL 由 R/M 指定，R/M 取 000。</p><p>综上只要使用两个字节，指令对应的机器码为 0x02, 0b11001000 即 0x02C8。</p><p>不过，它也可以认为是 <code>add mem8, reg8</code> 形式，这个 opcode 是 00；REG 是 source。这个情况下 MOD 取 11，REG 取 000，R/M 取 001，对应的机器码是 0x00，0b11000001 即 0x00C1。这和上面的机器码都是合法的，实际上所有的两个操作数都是寄存器的指令都有这种情况。</p><h3 id="ADD-ECX-EAX"><a href="#ADD-ECX-EAX" class="headerlink" title="ADD ECX, EAX"></a><code>ADD ECX, EAX</code></h3><ul><li>看成 <code>add mem32, reg32</code>：opcode 为 01，REG 是 source。MOD 取 11，REG 取 000，R/M 取 001，机器码为 0x01C1。</li><li>看成 <code>add reg32, reg32</code>：opcode 为 03，REG 是 destination。MOD 取 11，REG 取 001，R/M 取 000，机器码为 0x03C8。</li><li>看成 <code>add reg32, mem32</code>：opcode 为 03，REG 是 destination。MOD 取 11，REG 取 001，R/M 取 000，机器码为 0x03C8。</li></ul><h3 id="ADD-EDX-lt-addr32-gt"><a href="#ADD-EDX-lt-addr32-gt" class="headerlink" title="ADD EDX, &lt;addr32&gt;"></a><code>ADD EDX, &lt;addr32&gt;</code></h3><p>这里的 <code>&lt;addr32&gt;</code> 指的是一个 32 位常数地址。</p><p>看成 <code>add reg32, mem32</code>，opcode 为 03，REG 是 destination。现在要使用 displacement-only，因此 MOD 取 00，R/M 取 101；destination 为 EDX，故 REG 取 010。机器码为 0x0315<code>&lt;addr32&gt;</code>。需要注意的是这个 <code>addr32</code> 应该使用小端序进行编码。</p><h3 id="ADD-EDI-EBX"><a href="#ADD-EDI-EBX" class="headerlink" title="ADD EDI, [EBX]"></a><code>ADD EDI, [EBX]</code></h3><p>这个是将寄存器中的内容作为地址寻址。</p><p>看成 <code>add reg32, mem32</code>，opcode 为 03，REG 是 destination。MOD 取 00，R/M 取 EBX 对应的即 011，REG 取 EDI 对应的即 111，故机器码为 0x033B。</p><h3 id="ADD-EAX-ESI-displacement-8"><a href="#ADD-EAX-ESI-displacement-8" class="headerlink" title="ADD EAX, [ESI + displacement_8]"></a><code>ADD EAX, [ESI + displacement_8]</code></h3><p>这是简单的寻址，不涉及 SIB，使用 8 位 displacement，假设 displacement 是 0x55。</p><p>看成 <code>add reg32, mem32</code>，opcode 为 03，REG 是 destination。MOD 取 01，R/M 取 ESI 对应的即 110，REG 取 EAX 对应的即 000，故机器码为 0x034655。</p><h3 id="ADD-EBX-EBP-displacement-32"><a href="#ADD-EBX-EBP-displacement-32" class="headerlink" title="ADD EBX, [EBP + displacement_32]"></a><code>ADD EBX, [EBP + displacement_32]</code></h3><p>这是简单的寻址，不涉及 SIB，使用 32 位 displacement，假设 displacement 是 0x12345678。</p><p>看成 <code>add reg32, mem32</code>，opcode 为 03，REG 是 destination。MOD 取 10，R/M 取 EBP 对应的即 101，REG 取 EBX 对应的即 011，故机器码为 0x039D78563412。（注意小端序。）</p><h3 id="ADD-EBP-displacement-32-EAX-1"><a href="#ADD-EBP-displacement-32-EAX-1" class="headerlink" title="ADD EBP, [displacement_32 + EAX * 1]"></a><code>ADD EBP, [displacement_32 + EAX * 1]</code></h3><p>这个寻址会涉及到 SIB，使用 32 位 displacement，假设 displacement 为 0x12345678。</p><p>看成 <code>add reg32, mem32</code>，opcode 为 03，REG 是 destination。MOD 取 00，R/M 取 100 以打开 scaled indexed memory addressing，REG 取 EBP 对应的即 101；对于 SIB，<code>scale</code> 取 1，<code>index</code> 取 EAX，<code>base</code> 取 101 以打开 displacement-only。这样的话机器码应该是 0x03, 0b00101100, 0b00000101, 0x78563412 即 0x032C0578563412。</p><h3 id="ADD-ECX-EBX-EDI-4"><a href="#ADD-ECX-EBX-EDI-4" class="headerlink" title="ADD ECX, [EBX + EDI * 4]"></a><code>ADD ECX, [EBX + EDI * 4]</code></h3><p>这个寻址会涉及到 SIB，不使用 displacement。</p><p>看成 <code>add reg32, mem32</code>，opcode 为 03，REG 是 destination。MOD 取 00，R/M 取 100 以打开 scaled indexed memory addressing，REG 取 ECX 对应的即 001；对于 SIB，<code>scale</code> 取 4，<code>index</code> 取 EDI，<code>base</code> 取 EBX。这样的话机器码应该是 0x03, 0b00001100, 0b10111011 即 0x030CBB。</p><h2 id="含有常量的指令的加法指令编码"><a href="#含有常量的指令的加法指令编码" class="headerlink" title="含有常量的指令的加法指令编码"></a>含有常量的指令的加法指令编码</h2><p>以上的例子都没有涉及到常量，如果要编码 <code>mov eax, 0</code> 这样的代码怎么做呢？</p><p>含有 immediate 的加法指令的 opcode 是 04、05、80、81 或 83。其中 04、05 比较特殊。因为 <code>mov eax, const</code> 这种语句使用频率较高，所以 x86 为它们提供了捷径，这样编码可以少使用一个字节。抛开这两个捷径不谈，对于 80、81 和 83，在编码时有几条规则：</p><ul><li>如果这是一个加法指令并且 opcode 最高位为 1，则这是一个含有 immediate 的加法指令。</li><li>因为 immediate 不可能是 destination，所以没有必要设置方向位；destination 总由 R/M 决定，而 REG 的值应该固定为 000（其它一些指令可能会使用这个作为扩展）。</li><li>现在空出来的方向位成为 sign extension bit。对于操作 8 位数据的指令，这个位会被忽略；对于操作 16 位或 32 位数据的指令，这个位决定了 immediate 的大小：如果该位是 0 则表示 immediate 和操作数据大小相同，否则 immediate 将只有 8 位（一个字节）表示 8 位带符号整数。（将一个较小的数加到 32 位数上实际上很常用。）</li></ul><h2 id="Prefix-Bytes"><a href="#Prefix-Bytes" class="headerlink" title="Prefix Bytes"></a>Prefix Bytes</h2><p>Prefix Bytes 可以改变指令的行为。一个指令最多可以含有四个 Prefix，每个 Prefix 都为一个字节。可用的 Prefix 以及它们的含义：</p><ul><li><strong>0xF0</strong>：保证该指令对于共享内存有独享权，直到指令执行完成。</li><li><strong>0xF3</strong>：重复指令，执行 ECX 指定的次数次。或者在 EFLAGS 的 ZF 位为零的时候停止执行。</li><li><strong>0xF2</strong>：在 EFLAGS 的 ZF 位不为零的时候停止执行。</li><li><strong>0x2E</strong>：不使用指令默认的段寻址，使用 CS 段。</li><li><strong>0x36</strong>：不使用指令默认的段寻址，使用 SS 段。</li><li><strong>0x3E</strong>：不使用指令默认的段寻址，使用 DS 段。</li><li><strong>0x26</strong>：不使用指令默认的段寻址，使用 ES 段。</li><li><strong>0x64</strong>：不使用指令默认的段寻址，使用 FS 段。</li><li><strong>0x65</strong>：不使用指令默认的段寻址，使用 GS 段。</li><li><strong>0x66</strong>：改变使用的数据长度，从 32 位切换到 16 位。</li><li><strong>0x67</strong>：改变使用的地址长度，从 32 位切换到 16 位。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>如何编码 x86 指令：<a href="http://www.c-jump.com/CIS77/CPU/x86/lecture.html" target="_blank" rel="noopener">http://www.c-jump.com/CIS77/CPU/x86/lecture.html</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件工程课程大作业博客——数据传输方式的选取</title>
      <link href="/2018/10/08/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2-2/"/>
      <url>/2018/10/08/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程课程大作业博客——数据传输方式的选取"><a href="#软件工程课程大作业博客——数据传输方式的选取" class="headerlink" title="软件工程课程大作业博客——数据传输方式的选取"></a>软件工程课程大作业博客——数据传输方式的选取</h1><p><strong>一些考虑</strong>：前端打算使用 Vue 来做界面，所以后端不用进行模板渲染，只用向前端发送裸的数据就可以了。</p><p>目前的打算是，前端渲染每个页面的时候会向后端发起两次请求，使用的是两个略有差异的 url。第一次请求的时候，服务器会发送一个类似模板的文件（而不管 url 的一些细节），这个文件会向服务器发起第二次请求，服务器会根据第二次的 url 中的参数返回数据，让客户端上的模板文件进行渲染。</p><p>比如用户想要得到比赛 2 的评论 4，第一次的 url 可能是 /contests/2/comments/4，服务器会返回一个 comment_template.html，但是上面没有任何数据，这个文件中的 js 会根据当前的 url 发起第二次请求，url 可能为 /api/contests/2/comments/4，这次请求会返回实际数据。</p><p>数据传输的方式可以采用某种应用层上的协议来简化开发。目前备选的方案有 REST、GraphQL 和 gRPC。</p><a id="more"></a><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><h3 id="REST-描述"><a href="#REST-描述" class="headerlink" title="REST 描述"></a>REST 描述</h3><h4 id="REST-介绍与约定"><a href="#REST-介绍与约定" class="headerlink" title="REST 介绍与约定"></a>REST 介绍与约定</h4><blockquote><p><strong>表现层状态转换</strong>（REST，英文：<strong>Representational State Transfer</strong>）是 <a href="https://zh.wikipedia.org/w/index.php?title=Roy_Thomas_Fielding&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Roy Thomas Fielding</a>博士于 2000 年在他的博士论文 <a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2#cite_note-Fielding-Ch5-1" target="_blank" rel="noopener">[1]</a> 中提出来的一种<a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank" rel="noopener">万维网</a><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">软件架构</a>风格，目的是便于不同软件 / 程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">超文本传输协议 (HTTP)</a> 之上而确定的一组约束和属性，是一种设计提供万维网络服务的<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">软件构建风格</a>。匹配或兼容于这种架构风格 (简称为 REST 或 RESTful) 的网络服务，允许客户端发出以<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6" target="_blank" rel="noopener">统一资源标识符</a>访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质 (interoperability)。相对于其它种类的网络服务，例如 SOAP 服务则是以本身所定义的操作集，来访问网络上的资源。</p><p>目前在三种主流的 <a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1" target="_blank" rel="noopener">Web 服务</a>实现方案中，因为 REST 模式与复杂的 <a href="https://zh.wikipedia.org/wiki/SOAP" target="_blank" rel="noopener">SOAP</a> 和 <a href="https://zh.wikipedia.org/wiki/XML-RPC" target="_blank" rel="noopener">XML-RPC</a> 相比更加简洁，越来越多的 web 服务开始采用 REST 风格设计和实现。例如，<a href="https://zh.wikipedia.org/wiki/Amazon.com" target="_blank" rel="noopener">Amazon.com</a> 提供接近 REST 风格的 Web 服务运行图书查询；<a href="https://zh.wikipedia.org/wiki/%E9%9B%85%E8%99%8E" target="_blank" rel="noopener">雅虎</a>提供的 Web 服务也是 REST 风格的。</p></blockquote><p>REST 英文为 Representational State Transfer，是一种风格而不是框架。REST 提出者对这种风格的约定：</p><ul><li><p><strong>Uniform Interface</strong>：这个约定定义了服务端和客户端之间的统一接口，使得两端解耦，可以独立进行开发，它具体有四个约定。</p><ul><li><strong>Resource-Based</strong>：资源可以总是可以使用 URI 访问到；<strong>资源本身</strong> 和服务器向客户端发送的 <strong>表现信息</strong>（representation）概念上分离。表现信息的格式可能是 HTML、XML 或 JSON。</li><li><strong>Manipulation of Resources Through Representations</strong>：客户端在拿到了表现信息后，如果有足够的权限，应该具有 <strong>足够的信息来修改或删除</strong> 服务器上资源的状态。</li><li><strong>Self-descriptive Messages</strong>：返回的信息应该能够自解释地指出该如何处理本信息。例如来自服务器的信息应该告诉客户端自己能否被缓存。</li><li><strong>Hypermedia as the Engine of Application State (HATEOAS)</strong>：客户端通过 Request Body、Query String 参数、 Request Header 和请求的 URI 来传递状态；服务端通过 Response Body、Response Code 和 Response Header 来传递状态。此外，如果必要，服务端的响应中应该包含一些指向其它 API 的链接，让用户能在不查阅资料的情况下知道下一步能够做什么。</li></ul></li><li><p><strong>Stateless</strong>：REST API 的设计应该是无状态的。与此形成对比的是 Session 的概念，Session 可以让我们在多个不同的请求中保持某种状态，服务器知道这些请求实际上是同一次会话，服务器要知道这件事情是有代价的，它需要维护一个状态。但是 REST API 的设计应该做到服务端不维护状态，客户端要自行维护状态，客户端的每次请求应该包含足够多的信息，让服务端能在不保存状态的情况下处理这个请求。为了做到这一点客户端要向服务端传递某种信息来标记当前的状态（或者状态转换的信息）。当服务端处理了这个请求后，它应该将当前的状态返回给客户端。服务端的这种特性类似于函数式编程中的纯函数。当服务端采用了 Stateless 的原则后可以很好地提高可扩展性，同时方便负载均衡。</p><p>这里有个概念是 <strong>资源的状态</strong> 和 <strong>客户端的状态</strong>，不要搞混。另外有些情况下服务端将不得不保存某种状态，例如用户认证和 API 调用限制，这是对 Stateless 约定的违约。</p></li><li><p><strong>Cacheable</strong>：服务端传给客户端的信息应该总是指出这个信息是否可缓存，不论是显性的还是隐性的。</p></li><li><p><strong>Client-Server</strong>：客户端的代码应该和服务端的代码分离，做到在接口不变的情况下任意替换客户端和服务端都可以正常工作。这样客户端不用关心数据在服务端上的存储，服务端不用关心客户端的状态。</p></li><li><p><strong>Layered System</strong>：客户端应该无法分辨出它连接的是一个服务端的终端还是某个中介。这样的设计让中介能够提供负载均衡和分层缓存的功能，此外也能提供一些安全性的功能。</p></li><li><p><strong>Code on Demand</strong>：这是一个可选的约定。服务端应该可以向客户端发送一些可执行的代码来扩展客户端功能，例如 JavaScript 脚本。</p></li></ul><h4 id="REST-API-设计中的一些推荐实践"><a href="#REST-API-设计中的一些推荐实践" class="headerlink" title="REST API 设计中的一些推荐实践"></a>REST API 设计中的一些推荐实践</h4><h5 id="使用-HTTP-Verb-来让请求更有意义"><a href="#使用-HTTP-Verb-来让请求更有意义" class="headerlink" title="使用 HTTP Verb 来让请求更有意义"></a>使用 HTTP Verb 来让请求更有意义</h5><ul><li>使用 GET 读取资源</li><li>使用 PUT 更新资源（替换式的更新）</li><li>使用 PATCH 更新资源（增量式的更新）</li><li>使用 DELETE 移除资源</li><li>使用 POST 创建资源</li></ul><p>注意使用 GET 时严禁资源发生改变。</p><p>注意，一般将 GET、PUT、DELETE 设计成幂等的操作（实际上 DELETE 某种意义上不幂等，第二次调用和第一次调用的响应码不一样），而将 PATCH 和 POST 设计成不幂等的操作。</p><h5 id="提供合理的资源名"><a href="#提供合理的资源名" class="headerlink" title="提供合理的资源名"></a>提供合理的资源名</h5><p>资源名基本上就是 URL，URL 的设计应该具有好的可理解性，能够让访问者看到 URL 就知道自己在干什么。一些建议的命名规则：</p><ul><li>在获取资源时，使用 URL 而不是 query string。Query string 设计出来是为了 filter 而不是查找的。</li><li>善用 URL 的层次性来表现资源本身的结构。</li><li>设计 URL 时优先考虑客户端的体验而不是对存储数据的友好型。</li><li>URL 应该由名词构成，资源仅由名词标记，使用 HTTP Verb 来指明行为。名词统一使用复数形式。不要出现结构性的描述，一个例子是 customers 要优于 customer_list。</li><li>URL 全小写，使用下划线或减号连接单词。</li><li>URL 越短越好，分节越少越好。</li></ul><h5 id="使用-HTTP-响应码指明状态"><a href="#使用-HTTP-响应码指明状态" class="headerlink" title="使用 HTTP 响应码指明状态"></a>使用 HTTP 响应码指明状态</h5><p>服务端发送给客户端的响应应该使用状态码指明这次请求的状态。例如资源创建成功时应该返回 201 而不是传统的 200。推荐的返回码：</p><div class="table-container"><table><thead><tr><th>HTTP Verb</th><th>CRUD</th><th>对集合的操作</th><th>对集合中某一项的操作</th></tr></thead><tbody><tr><td>POST</td><td>创建</td><td>201</td><td>404，409</td></tr><tr><td>GET</td><td>读取</td><td>200</td><td>200，404</td></tr><tr><td>PUT</td><td>更新（全部替换）</td><td>405（不能对集合进行更新，除非故意）</td><td>200，204，404</td></tr><tr><td>PATCH</td><td>更新（增量替换）</td><td>405（不能对集合进行更新，除非故意）</td><td>200，204，404</td></tr><tr><td>DELETE</td><td>删除</td><td>405（不能对集合进行删除，除非故意）</td><td>200，404</td></tr></tbody></table></div><p>在上面的表中，对集合的操作相应的 url 类似 /customers，对集合中某一项的操作的 url 类似 /customers/123。另外，创建一个记录应该使用集合所在的 url。创建的例子是 POST  <a href="http://www.example.com/customers" target="_blank" rel="noopener">http://www.example.com/customers</a>，不带参数，服务端会选择一个参数（例子中是 customer 的 id），创建后将新纪录的 url 返回给客户端。</p><p>不过，我在 <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014735944539193ab2edd2740f44a79efb438a05e83727000" target="_blank" rel="noopener">其他地方</a> 看到了不同的内容，这种观点认为 REST 是比 HTTP 更加高级的协议，不应该使用 HTTP 的状态码，滥用会导致客户端软件无法区分操作的结果和响应的结果。除了 200 表示正常和 400 表示异常之外其它的所有状态码应该由 web 框架处理。</p><h5 id="设计的时候的粒度顺序"><a href="#设计的时候的粒度顺序" class="headerlink" title="设计的时候的粒度顺序"></a>设计的时候的粒度顺序</h5><p>先设计针对细粒度资源的 API，后设计针对粗粒度资源的 API。从前者到后者更加容易，反过来就很蛋疼。</p><h5 id="考虑连通性"><a href="#考虑连通性" class="headerlink" title="考虑连通性"></a>考虑连通性</h5><p>服务器返回给客户端的内容应该包含了指向其它 API 的连接。这是对 HATEOAS 约定的体现。例如对于进行了分页的服务，返回的数据中应该包含第一页、最后一页、前一页和后一页的连接。</p><h3 id="REST-实践"><a href="#REST-实践" class="headerlink" title="REST 实践"></a>REST 实践</h3><p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001473590199114b8523ba038dd4359a16ad0bbd3c8a1f2000" target="_blank" rel="noopener">这篇文章</a> 举了一个 REST API 编写的例子。</p><h3 id="REST-总结"><a href="#REST-总结" class="headerlink" title="REST 总结"></a>REST 总结</h3><p>在 REST API 中，服务端指定了一些特定的 URL，客户端能通过这些 URL 对服务端的资源进行增删改查。</p><h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><h3 id="GraphQL-描述"><a href="#GraphQL-描述" class="headerlink" title="GraphQL 描述"></a>GraphQL 描述</h3><h4 id="应用场景与简介"><a href="#应用场景与简介" class="headerlink" title="应用场景与简介"></a>应用场景与简介</h4><p>GraphQL 通过自己定义的一套语言，它有一套完整的类型系统，通过定义一个 Schema 来定义数据的结构层次。查询和修改能都自定义地在这个结构层次中进行选择。</p><p>举个例子，对于竞赛平台应用来说，如果有十个比赛，每个比赛有十个评论，假设有个功能要获取所有的评论的话，使用 REST 可能会这么进行：</p><ol><li>获取所有比赛的列表：GET /api/contests</li><li>对于每个比赛，获取这个比赛下所有评论的列表：GET /api/contests/<em>contest_id</em>/comments</li><li>对于每个评论，获取这个评论：GET /api/contests/<em>contest_id</em>/comments/<em>comment_id</em></li></ol><p>这样一共要进行 111 次请求。当然可以设计一个 api 专门负责这种事情，但是当前端有新的需求的时候又会出现这样的问题。通过使用 GraphQL 可以解决这种问题，它的思路是：</p><p>在服务端定义一个 Schema：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  contests: [Contest]</span><br><span class="line">  contest(id: Int!): Contest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Contest &#123;</span><br><span class="line">  id: Int</span><br><span class="line">  name: String</span><br><span class="line">  comments: [Comment]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Comment &#123;</span><br><span class="line">  id: Int</span><br><span class="line">  content: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后前端进行查询。例如要实现我们的需求，只需要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query allComments &#123;</span><br><span class="line">  contests &#123;</span><br><span class="line">    comments &#123;</span><br><span class="line">      content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将返回一个 JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"contests"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"comments"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"content"</span>: <span class="string">"太巨了"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"content"</span>: <span class="string">"太强了"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"comments"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"content"</span>: <span class="string">"我好菜啊"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"comments"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"content"</span>: <span class="string">"带带我"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"content"</span>: <span class="string">"巨佬！"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"comments"</span>: []</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了这以外还有其它高级的功能。关键在于只需要一次请求就可以得到数据，而且数据的结构是可以被前端自定义的（选择哪些数据要，哪些数据不要），后端返回的数据也正好是前端需要的数据。</p><h4 id="GraphQL-的特性"><a href="#GraphQL-的特性" class="headerlink" title="GraphQL 的特性"></a>GraphQL 的特性</h4><p>这是 GraphQL 的 <a href="https://graphql.github.io/learn/" target="_blank" rel="noopener">文档</a>。GraphQL 是一个标准而不是实现。</p><p>GraphQL 具有以下的一些特性：</p><ul><li>可以只查询的对象的某些特定的域，以及域的域。返回的 JSON 的结构和查询的结构一致。</li><li>查询可以带参数，这可以用来执行诸如 filter 和单位转换之类的功能。</li><li>可以给查询定义别名，在一次请求中进行多次查询。</li><li>查询使用的语言可以通过片段进行复用。</li><li>查询使用的语言可以定义变量，变量可以通过外部语言传入。</li><li>可以通过 directive 来动态改变查询的结构，而不用修改查询使用的语言。</li><li>可以对内容进行修改。</li></ul><p>GraphQL 具有一个类型系统，其类型系统的特性如下：</p><ul><li>GraphQL 中的对象的每个域可以拥有参数。</li><li>标量类型为 Int、Float、String、Boolean、ID。标量类型是查询时的叶结点。</li><li>支持枚举类型。</li><li>支持两种复杂的类型：中括号表示列表，感叹号表示非 null。</li><li>有 interface 的概念。</li><li>有 union 的概念（可以认为是多个类型实现了一个空的 interface）。</li></ul><p>通过 interface 等概念可以实现类似 OOP 中多态的查询。</p><p>此外，GraphQL 自己可以对查询语句进行错误检查，还具有内省等功能。</p><h3 id="GraphQL-实践"><a href="#GraphQL-实践" class="headerlink" title="GraphQL 实践"></a>GraphQL 实践</h3><p>这是一个简单的运行在 Koa 上的 GraphQL 服务：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router: <span class="built_in">any</span> = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> graphqlHTTP: <span class="built_in">any</span> = <span class="built_in">require</span>(<span class="string">'koa-graphql'</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; buildSchema, GraphQLSchema &#125; <span class="keyword">from</span> <span class="string">'graphql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过以下语句建立 Schema</span></span><br><span class="line"><span class="comment">// 其中 Query 表示的是支持的查询的根结点名称</span></span><br><span class="line"><span class="comment">// Contest 和 Comment 是自定义的结构</span></span><br><span class="line"><span class="keyword">let</span> schema: GraphQLSchema = buildSchema(<span class="string">`</span></span><br><span class="line"><span class="string">   type Query &#123;</span></span><br><span class="line"><span class="string">     contests: [Contest]</span></span><br><span class="line"><span class="string">     contest(id: Int!): Contest</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   type Contest &#123;</span></span><br><span class="line"><span class="string">     id: Int</span></span><br><span class="line"><span class="string">     name: String</span></span><br><span class="line"><span class="string">     comments: [Comment]</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   type Comment &#123;</span></span><br><span class="line"><span class="string">     id: Int</span></span><br><span class="line"><span class="string">     content: String</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个假数据库</span></span><br><span class="line"><span class="keyword">let</span> database: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; = [</span><br><span class="line">    &#123; id: <span class="number">0</span>, name: <span class="string">'Coding Contest'</span>, comments: [&#123; id: <span class="number">0</span>, content: <span class="string">'太巨了'</span> &#125;, &#123; id: <span class="number">1</span>, content: <span class="string">'太强了'</span> &#125;] &#125;,</span><br><span class="line">    &#123; id: <span class="number">1</span>, name: <span class="string">'Another Contest'</span>, comments: [&#123; id: <span class="number">0</span>, content: <span class="string">'我好菜啊'</span> &#125;] &#125;,</span><br><span class="line">    &#123; id: <span class="number">2</span>, name: <span class="string">'Yet Another Contest'</span>, comments: [&#123; id: <span class="number">0</span>, content: <span class="string">'带带我'</span> &#125;, &#123; id: <span class="number">1</span>, content: <span class="string">'巨佬！'</span> &#125;] &#125;,</span><br><span class="line">    &#123; id: <span class="number">3</span>, name: <span class="string">'Contest With No Comments'</span>, comments: [] &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些函数被称作是 resolver，表示的是当要查询 Query 中的查询时该如何处理</span></span><br><span class="line"><span class="comment">// 实际中应该要连接到数据库</span></span><br><span class="line"><span class="keyword">const</span> root: <span class="built_in">any</span> = &#123;</span><br><span class="line">    contests: (args: <span class="built_in">any</span>): <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> database;</span><br><span class="line">    &#125;,</span><br><span class="line">    contest: (args: <span class="built_in">any</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> database.filter(<span class="function"><span class="params">contest</span> =&gt;</span> contest.id === args.id)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app: Koa = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router: <span class="built_in">any</span> = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.all(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">    schema: schema,</span><br><span class="line">    rootValue: root,</span><br><span class="line">    graphiql: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><p>运行起来后，可以在 localhost:4000/graphql 中看到一个可交互的页面，左边可以输入查询语句。</p><p>例如希望查找 id 为 0 的比赛的标题，以及它的所有的评论的内容，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query myQuery &#123;</span><br><span class="line">  contest(id: 0) &#123;</span><br><span class="line">    name</span><br><span class="line">    comments &#123;</span><br><span class="line">      content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"contest"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Coding Contest"</span>,</span><br><span class="line">      <span class="attr">"comments"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"content"</span>: <span class="string">"太巨了"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"content"</span>: <span class="string">"太强了"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际应用中，前端可以通过向 localhost:4000/graphql 这个 url post 数据来获得想知道的结果。一般只用这一个入口就足够了。</p><h3 id="GraphQL-总结"><a href="#GraphQL-总结" class="headerlink" title="GraphQL 总结"></a>GraphQL 总结</h3><p>GraphQL 可以使用自定义的语言结构化描述数据的存储，在前端可以按需一次性获取所有想得到的数据，后端也不用频繁更改代码。</p><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><h3 id="gRPC-描述"><a href="#gRPC-描述" class="headerlink" title="gRPC 描述"></a>gRPC 描述</h3><p>RPC 指远程过程调用，通过这种技术可以让一台计算机上的进程通过网络调用另一个计算机上的某个函数，对于调用者来说，可以做到看上去就像是调用了本地的一个函数一样。</p><p>Protocol Buffer 是一种将结构化的数据序列化的手段，能将数据序列化成二进制形式，这种形式在传输和效率上有较大的优势。</p><p>gRPC 是一套 RPC 框架，底层使用 Protocol Buffer 传输数据。</p><p>在使用 gRPC 时，需要先写一个协议式的文件，这个文件一般以 .proto 作为后缀名。在 Protocol Buffer 技术中，这个文件将会声明一些结构，通过使用一个编译工具可以从这些结构生成对应语言的类或者结构，并且自带一些访问器。例如假设目标语言是 C++，并且我们希望能序列化一个人的信息，那么应该在 proto 文件中定义一个叫 <code>Person</code> 的 message，进行编译后会得到一份 C++ 代码，含有 <code>Person</code> 类。这个类能够方便地与当前的开发任务结合起来。</p><p>gRPC 对 proto 文件进行了扩展，可以在上面声明 service，service 中可以进一步声明 rpc。rpc 就是一个远程调用的函数，它的参数可能是多个 message 或者 message 流，返回值也可以是 message 或者 message 流。在选择了服务端和客户端的语言后，就可以生成对应的代码并在两端进行开发。</p><p>gRPC 框架具有一些其它的功能，例如身份验证和错误处理等等。</p><h3 id="gRPC-实践"><a href="#gRPC-实践" class="headerlink" title="gRPC 实践"></a>gRPC 实践</h3><p>见官方文档 <a href="https://grpc.io/docs/tutorials/basic/node.html#example-code-and-setup" target="_blank" rel="noopener">https://grpc.io/docs/tutorials/basic/node.html#example-code-and-setup</a>。</p><h3 id="gRPC-总结"><a href="#gRPC-总结" class="headerlink" title="gRPC 总结"></a>gRPC 总结</h3><p>个人认为这个框架比较底层，不适合敏捷的开发（如果需要加功能的话较比较麻烦），适合于 C/S 架构的软件开发而不适合于 B/S 架构的软件开发，或者适用于服务器集群的开发，总之我感觉不适合放在客户端上跑。而且从这种框架的设计来看似乎是需要追求很高的性能才会用到。另外，原生的 gRPC 客户端也需要具有 Node 环境，不过也有 <a href="https://github.com/improbable-eng/grpc-web" target="_blank" rel="noopener">grpc-web</a> 这样的框架可以支持在浏览器上实现 gRPC 客户端。</p><p>gRPC 的优势在于传输的数据小。不过都已经在开发 B/S 架构的东西了估计这点优势算不上什么。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>对比一下这几个框架/约定，以及与我们的任务的联系：</p><ul><li>REST：一种 API 设计风格，语义比较明确。不过对于每种需求都要开辟一些 url，比较繁琐。</li><li>GraphQL：一个框架，适用于请求者对数据格式要求比较灵活的场景。对于我们的任务来说可能稍显复杂，因为使用这套框架需要前后端都对这项技术有所了解，此外我们的网站不一定需要对数据格式有高灵活性的要求。不管它只要写一次就能适用于各种要求这个功能很诱人。</li><li>gRPC：这个基本上可以不用考虑了，它适合于比较重的应用之间的协作，强调的是高性能和低延迟。</li></ul><p>我们可能最终决定使用 GraphQL。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.restapitutorial.com/" target="_blank" rel="noopener">https://www.restapitutorial.com/</a></li><li><a href="https://www.graphql.com/" target="_blank" rel="noopener">https://www.graphql.com/</a></li><li><a href="https://grpc.io/" target="_blank" rel="noopener">https://grpc.io/</a></li><li><a href="https://github.com/improbable-eng/grpc-web" target="_blank" rel="noopener">https://github.com/improbable-eng/grpc-web</a></li><li><a href="https://jozdoo.github.io/rest/2016/09/22/REST-HATEOAS.html" target="_blank" rel="noopener">https://jozdoo.github.io/rest/2016/09/22/REST-HATEOAS.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2</a></li><li><a href="https://medium.com/codingthesmartway-com-blog/creating-a-graphql-server-with-node-js-and-express-f6dddc5320e1" target="_blank" rel="noopener">https://medium.com/codingthesmartway-com-blog/creating-a-graphql-server-with-node-js-and-express-f6dddc5320e1</a></li><li><a href="https://nordicapis.com/when-to-use-what-rest-graphql-webhooks-grpc/" target="_blank" rel="noopener">https://nordicapis.com/when-to-use-what-rest-graphql-webhooks-grpc/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编课程大作业博客——熟悉 PE 格式</title>
      <link href="/2018/10/06/%E6%89%8B%E5%86%99%E6%B1%87%E7%BC%96%E5%99%A8-1/"/>
      <url>/2018/10/06/%E6%89%8B%E5%86%99%E6%B1%87%E7%BC%96%E5%99%A8-1/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编课程大作业博客——熟悉-PE-格式"><a href="#汇编课程大作业博客——熟悉-PE-格式" class="headerlink" title="汇编课程大作业博客——熟悉 PE 格式"></a>汇编课程大作业博客——熟悉 PE 格式</h1><p>汇编的大作业选题是拿汇编写一个汇编器。我们希望得到的结果是输入一个 asm 文件能够编译出来一个直接能运行的 exe 文件，支持一些简单的语法就可以了，没必要搞得很复杂（比如支持宏之类的）。</p><p>Windows 下能直接运行的文件格式为 exe，exe 又能细分为几种：</p><blockquote><p>EXE 是在 OS/2、MS-DOS 和 Windows 系统中通用的可执行文件的扩展名，包括以下几种主要的文件格式：</p><ul><li><p>DOS 可执行文件：最简单的可执行文件格式，可以在 DOS 和 Windows 中运行。它通过在文件头添加 ASCII 字符串 “MZ”（16 进制中表示为 4D5A）来标识。“MZ” 是 MS-DOS 开发者之一的马克 · 茨柏克沃斯基（Mark Zbikowski）的姓名首字母缩写。</p></li><li><p>16 位新可执行文件：通过在文件头添加 ASCII 字符串 “NE” 来标识。它只能运行在 Windows 和 OS/2 系统，而不能在 DOS 下运行。</p></li><li><p>16/32 位混合式线性可执行文件：通过在文件头添加 ASCII 字符串 “LE” 来标识。它仅用来在 Windows 3.x 和 Windows 9x 中替代 VxD 驱动。</p></li><li><p>32 位线性可执行文件：通过在文件头添加 ASCII 字符串 “LX” 来标识。运行在 OS/2 2.0 以及更高版本中，也可用于某些 DOS 扩展。</p></li><li><p>32 位可执行文件：这是最复杂也是目前最流行的可执行文件格式，通过在文件头添加 ASCII 字符串 “PE” 来标识。它主要运行于 Windows 95 和 Windows NT 以及更高版本的 Windows 中，也可在 BeOS R3 中运行。在文件头部可见字符串 “PE..L”（hex code: 504500004C）。</p></li><li><p>64 位可执行文件：与前一种类似，但使用支持 64 位的中央处理器。因此它仅能在 64 位的 Windows 系统中运行，譬如 Windows XP 64-Bit Edition 和 Windows Server 2003 64-Bit Edition。在文件头部可见字符串 “PE..d†”（hex code: 504500006486）。</p></li></ul></blockquote><p>我们要做的是倒数第二种，这种格式称作 PE（Portable Executable）格式。因为只要做一个简单的汇编器就可以了，也没有必要对 PE 格式了解太深，够用就行。</p><a id="more"></a><h2 id="PE-格式"><a href="#PE-格式" class="headerlink" title="PE 格式"></a>PE 格式</h2><h3 id="生成一个-PE-格式的-exe-文件"><a href="#生成一个-PE-格式的-exe-文件" class="headerlink" title="生成一个 PE 格式的 exe 文件"></a>生成一个 PE 格式的 exe 文件</h3><p>为了搞清楚 PE 格式到底是怎么样的，可以用 masm 写一个简单的程序，然后编译成 exe。</p><p>masm 程序的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">; main.asm</span><br><span class="line"></span><br><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include g:\masm32\include\windows.inc</span><br><span class="line">include g:\masm32\include\kernel32.inc</span><br><span class="line">include g:\masm32\include\masm32.inc</span><br><span class="line">include g:\masm32\include\msvcrt.inc</span><br><span class="line">includelib g:\masm32\lib\kernel32.lib</span><br><span class="line">includelib g:\masm32\lib\masm32.lib</span><br><span class="line">includelib g:\masm32\lib\msvcrt.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">    myWord byte &quot;%d + %d = %d&quot;, 0</span><br><span class="line">.code</span><br><span class="line"></span><br><span class="line">main proc</span><br><span class="line">    mov eax, 1</span><br><span class="line">    mov ebx, 2</span><br><span class="line">    mov ecx, eax</span><br><span class="line">    add ecx, ebx</span><br><span class="line">    invoke crt_printf, addr myWord, eax, ebx, ecx</span><br><span class="line">    invoke ExitProcess, 0</span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">end main</span><br></pre></td></tr></table></figure><p>编译使用的脚本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BuildSingleAsm.ps1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">param</span>([string]<span class="variable">$FileNameNoExt</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$FileNameNoExt</span> <span class="nomarkup">-eq</span> <span class="string">""</span>) &#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">"No file name given!"</span>;</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Remove-Item</span> -Path <span class="string">"<span class="variable">$FileNameNoExt</span>.obj"</span> -ErrorAction SilentlyContinue;</span><br><span class="line"><span class="built_in">Remove-Item</span> -Path <span class="string">"<span class="variable">$FileNameNoExt</span>.exe"</span> -ErrorAction SilentlyContinue;</span><br><span class="line">G:\masm32\bin\ml.exe /c /Zd /coff <span class="string">"<span class="variable">$FileNameNoExt</span>.asm"</span>;</span><br><span class="line">G:\masm32\bin\link.exe /SUBSYSTEM:CONSOLE <span class="string">"<span class="variable">$FileNameNoExt</span>.obj"</span>;</span><br></pre></td></tr></table></figure><p>执行 <code>./BuildSingleAsm -$FileNameNoExt main</code> 得到 main.exe。</p><p>执行 <code>Format-Hex main.exe</code> 得到 main.exe 的十六进制表示，应该能看到下面这种结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">           00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</span><br><span class="line"></span><br><span class="line">00000000   4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00  MZ</span><br><span class="line">00000010   B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  ¸.......@.......</span><br><span class="line">00000020   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000030   00 00 00 00 00 00 00 00 00 00 00 00 B0 00 00 00  ............°...</span><br><span class="line">00000040   0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68  ..º..´.Í!¸.LÍ!Th</span><br><span class="line">00000050   69 73 20 70 72 6F 67 72 61 6D 20 63 61 6E 6E 6F  is program canno</span><br><span class="line">00000060   74 20 62 65 20 72 75 6E 20 69 6E 20 44 4F 53 20  t be run in DOS</span><br><span class="line">00000070   6D 6F 64 65 2E 0D 0D 0A 24 00 00 00 00 00 00 00  mode....$.......</span><br><span class="line">00000080   5D 5C 6D C1 19 3D 03 92 19 3D 03 92 19 3D 03 92  ]\mÁ.=..=..=.</span><br><span class="line">00000090   97 22 10 92 1E 3D 03 92 E5 1D 11 92 18 3D 03 92  &quot;..=.å...=.</span><br><span class="line">000000A0   52 69 63 68 19 3D 03 92 00 00 00 00 00 00 00 00  Rich.=.........</span><br><span class="line">000000B0   50 45 00 00 4C 01 03 00 AD 87 B8 5B 00 00 00 00  PE..L...­¸[....</span><br><span class="line">000000C0   00 00 00 00 E0 00 0F 01 0B 01 05 0C 00 02 00 00  ....à...........</span><br><span class="line">000000D0   00 04 00 00 00 00 00 00 00 10 00 00 00 10 00 00  ................</span><br><span class="line">000000E0   00 20 00 00 00 00 40 00 00 10 00 00 00 02 00 00  . ....@.........</span><br><span class="line">000000F0   04 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00  ................</span><br><span class="line">00000100   00 40 00 00 00 04 00 00 00 00 00 00 03 00 00 00  .@..............</span><br><span class="line">00000110   00 00 10 00 00 10 00 00 00 00 10 00 00 10 00 00  ................</span><br><span class="line">00000120   00 00 00 00 10 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000130   10 20 00 00 3C 00 00 00 00 00 00 00 00 00 00 00  . ..&lt;...........</span><br><span class="line">00000140   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000150   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000160   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000170   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000180   00 00 00 00 00 00 00 00 00 20 00 00 10 00 00 00  ......... ......</span><br><span class="line">00000190   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000001A0   00 00 00 00 00 00 00 00 2E 74 65 78 74 00 00 00  .........text...</span><br><span class="line">000001B0   2C 00 00 00 00 10 00 00 00 02 00 00 00 04 00 00  ,...............</span><br><span class="line">000001C0   00 00 00 00 00 00 00 00 00 00 00 00 20 00 00 60  ............ ..`</span><br><span class="line">000001D0   2E 72 64 61 74 61 00 00 8E 00 00 00 00 20 00 00  .rdata...... ..</span><br><span class="line">000001E0   00 02 00 00 00 06 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000001F0   00 00 00 00 40 00 00 40 2E 64 61 74 61 00 00 00  ....@..@.data...</span><br><span class="line">00000200   0D 00 00 00 00 30 00 00 00 02 00 00 00 08 00 00  .....0..........</span><br><span class="line">00000210   00 00 00 00 00 00 00 00 00 00 00 00 40 00 00 C0  ............@..À</span><br><span class="line">00000220   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000230   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000240   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000250   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000260   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000270   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000280   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000290   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000002A0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000002B0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000002C0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000002D0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000002E0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000002F0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000300   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000310   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000320   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000330   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000340   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000350   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000360   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000370   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000380   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000390   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000003A0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000003B0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000003C0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000003D0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000003E0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000003F0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000400   B8 01 00 00 00 BB 02 00 00 00 8B C8 03 CB 51 53  ¸....»....È.ËQS</span><br><span class="line">00000410   50 68 00 30 40 00 FF 15 08 20 40 00 83 C4 10 6A  Ph.0@.... @.Ä.j</span><br><span class="line">00000420   00 E8 00 00 00 00 FF 25 00 20 40 00 00 00 00 00  .è.....%. @.....</span><br><span class="line">00000430   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000440   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000450   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000460   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000470   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000480   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000490   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000004A0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000004B0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000004C0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000004D0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000004E0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000004F0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000500   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000510   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000520   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000530   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000540   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000550   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000560   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000570   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000580   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000590   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000005A0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000005B0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000005C0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000005D0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000005E0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000005F0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000600   5C 20 00 00 00 00 00 00 78 20 00 00 00 00 00 00  \ ......x ......</span><br><span class="line">00000610   4C 20 00 00 00 00 00 00 00 00 00 00 6A 20 00 00  L ..........j ..</span><br><span class="line">00000620   00 20 00 00 54 20 00 00 00 00 00 00 00 00 00 00  . ..T ..........</span><br><span class="line">00000630   82 20 00 00 08 20 00 00 00 00 00 00 00 00 00 00   ... ..........</span><br><span class="line">00000640   00 00 00 00 00 00 00 00 00 00 00 00 5C 20 00 00  ............\ ..</span><br><span class="line">00000650   00 00 00 00 78 20 00 00 00 00 00 00 9B 00 45 78  ....x ......x</span><br><span class="line">00000660   69 74 50 72 6F 63 65 73 73 00 6B 65 72 6E 65 6C  itProcess.kernel</span><br><span class="line">00000670   33 32 2E 64 6C 6C 00 00 81 02 70 72 69 6E 74 66  32.dll...printf</span><br><span class="line">00000680   00 00 6D 73 76 63 72 74 2E 64 6C 6C 00 00 00 00  ..msvcrt.dll....</span><br><span class="line">00000690   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000006A0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000006B0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000006C0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000006D0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000006E0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000006F0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000700   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000710   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000720   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000730   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000740   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000750   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000760   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000770   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000780   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000790   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000007A0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000007B0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000007C0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000007D0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000007E0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000007F0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000800   25 64 20 2B 20 25 64 20 3D 20 25 64 00 00 00 00  %d + %d = %d....</span><br><span class="line">00000810   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000820   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000830   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000840   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000850   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000860   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000870   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000880   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000890   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000008A0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000008B0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000008C0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000008D0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000008E0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000008F0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000900   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000910   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000920   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000930   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000940   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000950   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000960   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000970   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000980   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000990   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000009A0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000009B0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000009C0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000009D0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000009E0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000009F0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><p>下面的部分会对这个文件进行解析。</p><h3 id="PE-格式概览"><a href="#PE-格式概览" class="headerlink" title="PE 格式概览"></a>PE 格式概览</h3><p>PE 文件的大致格式是两部分：第一部分是头，用来描述可执行文件本身的一些信息以及结构；第二部分则是具有实质性内容的段（sections），里面存放着代码和静态数据。</p><p>在我们的例子中，0x0 到 0x400 是头，0x400 到 0xa00（文件结尾）是各段。其中 0x400 到 0x600 是代码段（.text），0x600 到 0x800 是只读数据段（.rdata），0x800 到 0xa00 是数据段（.data）。</p><p>这些段的末尾都充满了 0，这是因为各段（包括头）都需要对齐存储。默认对齐的大小是 0x200 也就是 512 字节。默认生成的头在一个对齐单元中放不下，所以需要两个。剩下的各段尽管都很小，但还是需要至少一个对齐单元也就是 512 字节的空间，多出来的部分就用 0 填充了。</p><h3 id="PE-格式的头"><a href="#PE-格式的头" class="headerlink" title="PE 格式的头"></a>PE 格式的头</h3><p>PE 格式的头部可以进一步分成三部分，按照顺序分别是 DOS Stub 头部、PE 头部和记录后面各段的信息的段表（Section Table）。</p><h4 id="DOS-Stub-头部"><a href="#DOS-Stub-头部" class="headerlink" title="DOS Stub 头部"></a>DOS Stub 头部</h4><p>在我们的例子中，DOS Stub 头部位于 0x0 到 0xb0。</p><p>PE 格式中 DOS Stub 头部的设计是为了能够在旧的系统上跑新的程序。当然新程序的功能是没办法发挥出来的，但是有了这个设计之后可以让提示无法运行的出错信息更加友好。</p><p>如果采用全新的不兼容旧版本的设计，那么旧版本报错会报告无法解析这个可执行文件；如果采用兼容的设计，那么旧系统可以识别这种格式（中的一部分），并按照它的理解运行，它将会运行一段占坑代码，这段代码一般是提示用户无法运行为新系统设计的程序。占坑代码是编译器生成的，用户也可以手动指定。</p><p>我们例子中的 DOS Stub 头部可以进一步地被分成两份：位于 0x0 到 0x40 的 DOS MZ 头部和位于 0x40 到 0xb0 的占坑代码（Stub）。对于新的系统来说，它会解析完了 DOS MZ 头部后直接跳过占坑代码运行实际的程序；对于旧系统来说则会运行占坑代码，提示用户无法运行。</p><p>为了简单起见，在写汇编器的过程中不用特意生成占坑代码，把这些地方全部设成 0 就好了。占坑代码的长度不是固定的，不过目前不要去改动它的长度。可以试一下将 0x40 到 0xb0 这部分的数据全部改成 0，你会发现整个程序依然可以正常运行（在 Windows 10 上）。</p><p>现在只用研究 0x0 到 0x40 的 DOS MZ 头部就可以了，这部分的长度是固定的，它的含义可以在 winnt.h 这个文件中找到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>对于 PE 来说，真正有用的域只有 <code>e_magic</code> 和 <code>e_lfanew</code> 两个。剩下的那些域可以直接设成 0，在较新的系统上不会影响运行，你可以在其它地方找到这些域是干嘛的。</p><p><code>e_magic</code> 是一个 magic number，固定为 0x5a4d，表示 Ascii 表示下的 &quot;MZ&quot; 字符串（看到的数据是 4D 5A 是大小端的问题，本文使用的常量都是逻辑上的量，也即是说和的存放的顺序总是相反的，后面不再指出）。</p><p><code>e_lfanew</code> 是 PE 头部在整个 exe 文件中的偏移。DOS MZ 头部大小为 64 字节，例子中占坑程序大小为 112 字节，所以 PE 头部的偏移是 176 字节也就是 0xb0。</p><p>因此，可以将整个 DOS Stub 头部改成如下形式，只保留最基本的部分（只有 6 个字节），而不会影响程序的运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">           00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</span><br><span class="line"></span><br><span class="line">00000000   4D 5A 00 00 00 00 00 00 00 00 00 00 00 00 00 00  MZ..............</span><br><span class="line">00000010   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000020   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000030   00 00 00 00 00 00 00 00 00 00 00 00 B0 00 00 00  ............°...</span><br><span class="line">00000040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000050   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000060   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000070   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000080   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000090   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000000A0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><h4 id="PE-头部"><a href="#PE-头部" class="headerlink" title="PE 头部"></a>PE 头部</h4><p>跟随着 DOS Stub 头部的是 PE 头部，例子中的范围是 0xb0 到 0x1a8。PE 头部可以进一步细分为 PE 头部签名、COFF 文件头和“可选头”。</p><p>在 winnt.h 中可以找到这个头部的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><h5 id="PE-头部签名"><a href="#PE-头部签名" class="headerlink" title="PE 头部签名"></a>PE 头部签名</h5><p>我们的例子中，是 0xb0 到 0xb4。</p><p>这是长度为 4 字节的 magic number，它的含义应该为 &quot;PE\0\0&quot; 这个字符串，所以值固定为 0x00004550。</p><h5 id="COFF-文件头"><a href="#COFF-文件头" class="headerlink" title="COFF 文件头"></a>COFF 文件头</h5><p>我们的例子中，是 0xb4 到 0xc8。</p><p>COFF 文件头的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// File header format.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p>一项项看：</p><ul><li><code>Machine</code>：目标机器的编号，详见 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#machine-types" target="_blank" rel="noopener">这里</a>。我们要生成的是 <code>IMAGE_FILE_MACHINE_I386</code>，因此固定为 0x14c。</li><li><code>NumberOfSections</code>：有多少个段，我们的例子中有三个段，所以为 0x3。</li><li><code>TimeDateStamp</code>：时间戳，这里可以全部填零，表示一个无实际意义的时间，不会影响运行。</li><li><code>PointerToSymbolTable</code>：符号表的指针，一般用于调试，我们没有这个东西，设置成零。</li><li><code>NumberOfSymbols</code>：符号数量，一般用于调试，我们没有这个东西，设置成零。</li><li><code>SizeOfOptionalHeader</code>：“可选头”的大小，我们的例子中可选头的大小是 224 字节，即 0xe0。</li><li><code>Characteristics</code>：实际上是比特集合，表示可执行文件的一些额外信息，你可以在 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#characteristics" target="_blank" rel="noopener">这里</a> 找到详细的解释。尽管示例中生成的是 0x10f，实际上我们只需要打开 <code>IMAGE_FILE_EXECUTABLE_IMAGE</code> 这一个就行，所以可以设定为 0x2。</li></ul><h5 id="可选头"><a href="#可选头" class="headerlink" title="可选头"></a>可选头</h5><p>我们的例子中，是 0xc8 到 0x1a8。</p><p>尽管这玩意叫可选头，但是可以说是必需的了。这个头部中包含了更多的信息。以下是 winnt.h 中的定义，对应的结构是 <code>IMAGE_OPTIONAL_HEADER32</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Directory format.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Optional header format.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>它被划分为标准域和 NT 附加域。标准域指的是和 UNIX 的 COFF 格式中公共的那一部分，不过实际上只是名字一样罢了。NT 附加域就是 Windows 自己附加的一些域。下面来一项项地看这些域是什么意思，重要的加粗标记。里面如果写了可以设为 0，大部分情况是系统希望得到一个具体的值，但是设成 0 并没有观测到异常发生。</p><p>在介绍这个结构体之前需要知道一些概念。操作系统回将整个可执行程序文件加载到进程的内存空间中，但是文件的 0x0 不一定正好放到了内存空间的 0x0 处，实际上，它是由加载器决定的。比如，如果被加载到了 0x400000 处，那么位于文件中的 0x10 处的内容应该被加载到了内存空间的 0x400010 处（这也不一定，内存中的对齐和文件中的对齐不一样，不过依然可以在加载之前知道文件中的某处内容在加载完成后相对于文件开头的偏移）。这里有一个概念叫 RVA（Relative Virtual Address），表示的是文件中的某个内容加载进内存后，相对于文件开头的内容加载进内存的地址的偏移，这个值可以在加载前确定（根据文件的相关头信息可以计算），但不一定等于这个内容在文件中的位置。</p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#optional-header-image-only" target="_blank" rel="noopener">这里</a> 有更详尽的解释。</p><p>标准域：</p><ul><li><strong><code>Magic</code></strong>：标记这是什么映像（可能为普通可运行程序、ROM 映像等）。我们设定为 0x10b。</li><li><code>MajorLinkerVersion</code>：linker 主版本，可以设为 0。</li><li><code>MinorLinkerVersion</code>：linker 副版本，可以设为 0。</li><li><code>SizeOfCode</code>：代码段的大小。不过实际上你懒得设也可以直接设成 0，不会出事。</li><li><code>SizeOfInitializedData</code>：初始化的数据段的大小，可以设成 0，不会出事。</li><li><code>SizeOfUninitializedData</code>：未初始化的数据段的大小，可以设成 0，不会出事。</li><li><strong><code>AddressOfEntryPoint</code></strong>：程序入口点的 RVA（就是程序从哪里开始运行），在我们的例子中应该是代码段的第一句话也就是代码段的 RVA。代码段在文件中位于 0x400，但是内存中有自己的对齐策略，应该填 0x1000，后面可以看到这个值是如何被计算的。（实际上，生成的代码要求内存以 4KB 也就是 0x1000 进行分页，因为第一页要存 PE 头，所以 RVA 为 0x0 到 0x1000 存放了 PE 头，故代码段的 RVA 是 0x1000。）</li><li><code>BaseOfCode</code>：内存中代码段的开始部分的 RVA，可以设置为 0。</li><li><code>BaseOfData</code>：内存中数据段的开始部分的 RVA，可以设置为 0。</li></ul><p>NT 附加域：</p><ul><li><strong><code>ImageBase</code></strong>：程序希望被加载到内存中的哪个地方。默认为 0x400000。最好不要改。</li><li><strong><code>SectionAlignment</code></strong>：内存中每段对齐的大小，默认是体系结构的页面大小（典型地，4KB，这表明一个段至少会用掉 4KB 内存）。</li><li><strong><code>FileAlignment</code></strong>：可执行文件中每段对齐的大小，不能比 <code>SectionAlignment</code> 还大。典型地，512B。</li><li><code>MajorOperatingSystemVersion</code>：OS 主版本号，可设 0。</li><li><code>MinorOperatingSystemVersion</code>：OS 副版本号，可设 0。</li><li><code>MajorImageVersion</code>：程序主版本号，可设 0。</li><li><code>MinorImageVersion</code>：程序副版本号，可设 0。</li><li><strong><code>MajorSubsystemVersion</code></strong>：子系统主版本号，经测试，不可设为 0。</li><li><code>MinorSubsystemVersion</code>：子系统副版本号，可设 0。</li><li><strong><code>Win32VersionValue</code></strong>：<strong>被保留，必须为零。</strong></li><li><strong><code>SizeOfImage</code></strong>：整个程序加载进内存后占内存的大小，需要考虑对齐。在我们的例子中，是 16KB（PE 头占一页，三段各占一页，共四页），所以是 0x4000。</li><li><strong><code>SizeOfHeaders</code></strong>：可执行文件中所有头部加起来的大小，需要考虑对齐。在我们的例子中头的位置是 0x0 到 0x400 故为 0x400。</li><li><code>CheckSum</code>：一个校验和，但是算法未公开，设为 0。</li><li><strong><code>Subsystem</code></strong>：运行这个程序需要的子系统，在 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#windows-subsystem" target="_blank" rel="noopener">这里</a> 找一个合适的值。对于我们的任务自然是使用控制台就好了，设为 0x3。</li><li><code>DllCharacteristics</code>：不需要，可以设为 0。</li><li><code>SizeOfStackReserve</code>：保留栈大小（虚拟内存中栈使用的上限），可以设为 0。（存疑，作为备选可以设为 1MB。）</li><li><code>SizeOfStackCommit</code>：提交栈大小（装载后系统分配的实际栈的大小，当不够用的时候每次分配一页，直到达到保留栈的上限），可以设为 0。（存疑，作为备选可以设为 4KB。）</li><li><code>SizeOfHeapReserve</code>：保留堆大小，可以设为 0。（存疑，作为备选可以设为 1MB。）</li><li><code>SizeOfHeapCommit</code>：提交堆大小，可以设为 0。（存疑，作为备选可以设为 4KB。）</li><li><code>LoaderFlags</code>：<strong>被保留，必须为零。</strong></li><li><code>NumberOfRvaAndSizes</code>：下一项是一个数组（最大容量固定为 16），这个值决定了下一项的数组中的元素个数，一般为 16 即 0x10。</li><li><code>DataDirectory</code>：这个是一个数组，每个元素是 <code>IMAGE_DATA_DIRECTORY</code>。</li></ul><p>对 <code>IMAGE_DATA_DIRECTORY</code> 和 <code>DataDirectory</code> 的解释：</p><p>每个 <code>IMAGE_DATA_DIRECTORY</code> 都具有两个域：一个地址和一个大小，实际上，每个 <code>IMAGE_DATA_DIRECTORY</code> 都指向了一个数组，因此 <code>DataDirectory</code> 一共指向了 16 个数组。这 16 个元素的含义分别是什么可以在 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#optional-header-data-directories-image-only" target="_blank" rel="noopener">这里</a> 找到，对于我们的任务而言只要关注 Import Table 这一项就可以了，它表示的是我们从外部导入了哪些函数（我们用到了 <code>crt_printf</code> 以及 <code>ExitProcess</code>）。Import Table 在整个数组中是第 1 个元素（从 0 开始数），现在这里填什么先不确定，等会填上。至于其它的 15 个元素都用不上，可以全部填成 0。</p><p>这个等会填上的内容实际上是这样的，因为它指向了另一个数组，而这个数组保存了导入函数的信息，一般这个数组应该位于 .idata 段（导入数据段），但是从生成的接过来看似乎存在 .rdata 段（只读数据段）也可以。不过这都不是很严重的问题。</p><p>到这里可选头的部分就完成了。可选头的大小是固定的。</p><h4 id="Section-Table"><a href="#Section-Table" class="headerlink" title="Section Table"></a>Section Table</h4><p>PE 头的后面是段表（奇怪的中文翻译）。我们的例子中段表位于 0x1a8 到 0x220，每段占用 40 字节。从 0x220 到 0x400 是补齐的 0。之前的头部信息中已经含有了段数信息。</p><p>每一段的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Section header format.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SIZEOF_SHORT_NAME              8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>依次是：</p><ul><li><code>Name</code>：八个字节，段的名称。我们的例子中分别是 .text、.data 和 .rdata。</li><li><code>Misc</code>：一个联合体，不过需要填成这个段加载完成后在内存中占用的空间大小。（但是根据编译的情况来看似乎是实际未对齐的大小？）</li><li><code>VirtualAddress</code>：该段的 RVA。</li><li><code>SizeOfRawData</code>：该段在文件中的大小，需要考虑对齐。我们的例子中，对 .text 来说是 0x200。</li><li><code>PointerToRawData</code>：该段在文件中的偏移，在我们的例子中对 .text 来说是 0x400。</li><li><code>PointerToRelocations</code>：对于可执行程序应该设为 0，详见 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#section-table-section-headers" target="_blank" rel="noopener">这里</a>。</li><li><code>PointerToLinenumbers</code>：对于可执行程序应该设为 0，详见 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#section-table-section-headers" target="_blank" rel="noopener">这里</a>。</li><li><code>NumberOfRelocations</code>：对于可执行程序应该设为 0，详见 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#section-table-section-headers" target="_blank" rel="noopener">这里</a>。</li><li><code>NumberOfLinenumbers</code>：对于可执行程序应该设为 0，详见 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#section-table-section-headers" target="_blank" rel="noopener">这里</a>。</li><li><code>Characteristics</code>：比特集合，主要是对这个段的一些描述，详见 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#section-table-section-headers" target="_blank" rel="noopener">这里</a>。</li></ul><p>我们的例子中，对于最后一个：</p><ul><li>代码段应该打开 <code>IMAGE_SCN_CNT_CODE</code>、<code>IMAGE_SCN_MEM_EXECUTE</code> 和 <code>IMAGE_SCN_MEM_READ</code> 即 0x60000020。</li><li>只读数据段应该打开 <code>IMAGE_SCN_CNT_INITIALIZED_DATA</code>、<code>IMAGE_SCN_MEM_READ</code> 即 0x40000040</li><li>数据段应该打开 <code>IMAGE_SCN_CNT_INITIALIZED_DATA</code>、<code>IMAGE_SCN_MEM_READ</code> 和 <code>IMAGE_SCN_MEM_WRITE</code> 即 0xC0000040。</li></ul><hr><p>以上部分完成了整个 PE 文件中的头部分，剩下的只剩各段的介绍了。为了简单起见只介绍例子中有的三个段，其它的段可以在 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#special-sections" target="_blank" rel="noopener">这里</a> 找到说明。注意这些段是 Windows 预置的，但是程序也可以定义自己的段。</p><h3 id="PE-格式的段"><a href="#PE-格式的段" class="headerlink" title="PE 格式的段"></a>PE 格式的段</h3><h4 id="text-段"><a href="#text-段" class="headerlink" title=".text 段"></a>.text 段</h4><p>这个段里面的内容就是代码，我们的例子中有用的部分是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00000400   B8 01 00 00 00 BB 02 00 00 00 8B C8 03 CB 51 53  ¸....»....È.ËQS</span><br><span class="line">00000410   50 68 00 30 40 00 FF 15 08 20 40 00 83 C4 10 6A  Ph.0@.... @.Ä.j</span><br><span class="line">00000420   00 E8 00 00 00 00 FF 25 00 20 40 00 00 00 00 00  .è.....%. @.....</span><br><span class="line">00000430   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><p><a href="https://onlinedisassembler.com/odaweb/" target="_blank" rel="noopener">这个网站</a> 可以在线进行反汇编。将平台设置为 i386 后得到如图的结果：</p><img src="/2018/10/06/手写汇编器-1/snipaste_20181006_205748.png"><p>可以看到基本上就是我们写的源码。既然要做一个汇编器，一部分内容就是要从源码变成 .text 这样的格式。我估计只要做一下转换就可以了，如果语法不是很复杂的话。</p><h4 id="rdata-段"><a href="#rdata-段" class="headerlink" title=".rdata 段"></a>.rdata 段</h4><p>这个段涉及到导入的函数的表，所以比较复杂。详细的解释可以在 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#the-idata-section" target="_blank" rel="noopener">这里</a> 找到，此处简单写一下，整体分析思路来自于 <a href="https://bbs.pediy.com/thread-48590.htm" target="_blank" rel="noopener">这篇博客</a>。</p><p>大体的结构是这样的：</p><ul><li>首先导入的时候会用到多个 dll，我们有一个数组叫 Import Directory Table 来记录这些 dll，例子中我们使用了 2 个 dll 分别是 kernel32.dll 和 mscvrt.dll，那么 Import Directory Table 应该有三项，其中最后一项内容全部为 0，标记结尾。Import Directory Table 中的每一项占用 20 字节，每一项称为 Import Directory Entry，具有 5 个域，每个域有 4 个字节。</li><li>对于每个 dll，我们还有一个表来存从这个 dll 中导入了哪些函数，这个表称为 Import Lookup Table，如果从某个 dll 中导入了 3 个函数，那么对应的 Import Lookup Table 有四个元素，最后一个元素全为 0 标记结尾。Import Lookup Table 中每个元素为一个 DWORD。</li><li>最后，还需要一个 Name Table 来存导入的 dll 的名字和函数的名字。</li></ul><p>结构上，.rdata 段开始后马上是 Import Address Table（后面会写），然后马上是 Import Directory Table，然后是所有的 Import Lookup Table，然后是 Name Table。</p><p>现在让我们构造一个 .rdata 段出来。在 .rdata 段中，最开始是一个 Import Address Table，这个表中的内容应该与 Import Lookup Table 中的内容完全一致。我们待会会看到 Import Lookup Table 的内容，因此这里先空着。具体空多少呢？Import Lookup Table 中的每一项对应一个函数，我们导入了两个函数，来自两个不同的 dll。每个 dll 的 Import Lookup Table 有两项（其中一个是全零），因此所有的 Import Lookup Table 有 4 项，需要先空出 4 个 DWORD 也就是 16 字节。</p><p>然后紧接着就是 Import Directory Table，它的每一项是 Import Directory Entry。Import Directory Entry 的结构如下：</p><ul><li>Import Lookup Table RVA：这个 dll 对应的 Import Lookup Table 的 RVA。</li><li>Time/Date Stamp：一个时间戳，可以设置为零。</li><li>Forwarder Chain：不了解，但是可以设置为零。</li><li>Name RVA：这个 dll 对应的字符串的 RVA。后面会将这个 dll 的字符串放在 .rdata 中。</li><li>Import Address Table RVA (Thunk Table)：这个 dll 对应的 Import Address Table 的 RVA，也就是之前留空的部分。</li></ul><p>研究我们的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">           00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</span><br><span class="line"></span><br><span class="line">00000600   5C 20 00 00 00 00 00 00 78 20 00 00 00 00 00 00  \ ......x ......</span><br><span class="line">00000610   4C 20 00 00 00 00 00 00 00 00 00 00 6A 20 00 00  L ..........j ..</span><br><span class="line">00000620   00 20 00 00 54 20 00 00 00 00 00 00 00 00 00 00  . ..T ..........</span><br><span class="line">00000630   82 20 00 00 08 20 00 00 00 00 00 00 00 00 00 00   ... ..........</span><br><span class="line">00000640   00 00 00 00 00 00 00 00 00 00 00 00 5C 20 00 00  ............\ ..</span><br><span class="line">00000650   00 00 00 00 78 20 00 00 00 00 00 00 9B 00 45 78  ....x ......x</span><br><span class="line">00000660   69 74 50 72 6F 63 65 73 73 00 6B 65 72 6E 65 6C  itProcess.kernel</span><br><span class="line">00000670   33 32 2E 64 6C 6C 00 00 81 02 70 72 69 6E 74 66  32.dll...printf</span><br><span class="line">00000680   00 00 6D 73 76 63 72 74 2E 64 6C 6C 00 00 00 00  ..msvcrt.dll....</span><br><span class="line">00000690   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><p>(0x660 那一行结尾应该有 Ex 字符，不知道是不是因为前面有奇怪的字符导致没有显示出来。)</p><ol><li>0x600 到 0x610 是 Import Address Table，目前我们应该只知道 0x600 到 0x608 属于第一个 dll，0x608 到 0x610 属于第二个 dll。</li><li>随后，因为有 2 个 dll，故 Import Directory Table 有三项，从 0x610 到 0x64c。其中 0x638 到 0x64c 是全零的那一项。研究 0x610 到 0x624 这一项，第一个 DWORD 是 0x204c 是一个 RVA，在文件中对应的是 0x64c 指向的是第一个 dll 对应的 Import Lookup Table。随后的两个 DWORD 都是 0，第四个 DWORD 是 0x206a 是一个 RVA，在文件中对应的是 0x66a 指向 kernel32.dll 这个字符串；最后一个 DWORD 是 0x2000 是一个 RVA，对应文件中的 0x600，指向的是这个 dll 对应的 Import Address Table。可以验证一下，从 0x600 和 0x64c 开始的 8 个字节是一样的。具体是什么见下一段。</li></ol><p>Import Directory Table 搞清楚了，下面就是 Import Lookup Table。每个 Import Lookup Table 对应一个 dll，因此这里一共有两个。每个 Import Lookup Table 的每一项是一个 32 位的数，<a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#import-lookup-table" target="_blank" rel="noopener">这里</a> 有它的解释，在我们的任务中，只需要让最高位为 0，同时低 31 位是这一项对应的那个函数对应在 Name Table 中的项的 RVA 就可以了。看第一个，它的范围是 0x64c 到 0x654，其中 0x650 到 0x654 是全零标记结尾，因此这个 dll 中的那个函数对应的项是位于 0x64c 到 0x650 的数据 0x205c，这是一个 RVA，换成文件位置是 0x65c，这个地方的数据是 Name Table 中的一项，我们马上会看到。</p><p>到此为止我们构造出了 Import Lookup Table，也就可以填上 Import Address Table 的坑了。最后只剩下 Name Table 了。Name Table 的构造方式看起来是这样的：对于每个 dll 都可以构造出来一项，这项长度不定；将所有 dll 构造出来的项直接连接起来即可。对于每个 dll，这一项的构造是这样的：将 dll 的名字放在最后，然后之前对于每个要导入的函数，都按照以下格式构造一个二进制串：</p><ul><li>两个字节的 index，用来从 dll 中找到这个函数。我们可以将这个值设置为 0 强行让它进行按名字的在 dll 导出列表的二分查找。</li><li>函数的名称，注意要以空字符结尾。</li><li>如果结尾不是偶数，则补一个零字节将其对齐到偶数边界。</li></ul><p>如此，.rdata 中的内容就被构造出来了。</p><p>但是我们在 <a href="#可选头">可选头的最后</a> 挖的坑还没有填上，这里差一个 RVA 和一个大小。当时这里要填的是导入表的 RVA，即 Import Directory Table，显然是要填 0x2010；至于大小，这个表中有三项，每项 20 字节，一共 60 字节即 0x3c。</p><h4 id="data-段"><a href="#data-段" class="headerlink" title=".data 段"></a>.data 段</h4><p>这个段里面存静态的数据（全局变量等）。没有其它的信息，要使用的时候都是通过指针得到这些变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000800   25 64 20 2B 20 25 64 20 3D 20 25 64 00 00 00 00  %d + %d = %d....</span><br><span class="line">00000810   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000820   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><hr><p>到此为止我们就解析完了整个 PE 文件。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zh.wikipedia.org/wiki/EXE%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/EXE%E6%A0%BC%E5%BC%8F</a></li><li><a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format</a></li><li><a href="https://bbs.pediy.com/thread-48590.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-48590.htm</a></li><li><a href="http://www.cnblogs.com/li0803/archive/2010/11/15/1877951.html" target="_blank" rel="noopener">http://www.cnblogs.com/li0803/archive/2010/11/15/1877951.html</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件工程课程大作业博客——后端技术的选取</title>
      <link href="/2018/10/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2-1/"/>
      <url>/2018/10/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程课程大作业博客——后端技术的选取"><a href="#软件工程课程大作业博客——后端技术的选取" class="headerlink" title="软件工程课程大作业博客——后端技术的选取"></a>软件工程课程大作业博客——后端技术的选取</h1><h2 id="一些考虑"><a href="#一些考虑" class="headerlink" title="一些考虑"></a>一些考虑</h2><p>考虑到后端的生态丰富程度和开发速度，只能从 Python 和 NodeJS 中选择。为了有更强的类型系统决定使用 TypeScript。</p><p>Web 框架打算使用 Koa，但是 Koa 本身还是比较底层，Egg.js 是对 Koa 的进一步封装，主要是引入了对 Koa 的自定义扩展的功能以及引入了一个更加强大的插件功能，暂时计划就用这个框架。</p><h2 id="Egg-js-的一些概念"><a href="#Egg-js-的一些概念" class="headerlink" title="Egg.js 的一些概念"></a>Egg.js 的一些概念</h2><p>主要是对这个框架的一个 overview。</p><a id="more"></a><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a><code>Application</code></h3><p><code>Application</code> 是一个全局的对象，整个 Web 应用中只会有一个。它可以用来发出某些事件的信号，作为开发者可以监听这些信号。</p><h3 id="Context、Request、Response"><a href="#Context、Request、Response" class="headerlink" title="Context、Request、Response"></a><code>Context</code>、<code>Request</code>、<code>Response</code></h3><p><code>Request</code> 封装了一次 HTTP 请求、<code>Response</code> 封装了一次 HTTP 响应。<code>Context</code> 将一次 HTTP 请求和它对应的响应封装了起来。此外可能需要创建一个匿名的 <code>Context</code>，则是可以做到的。</p><h3 id="Controller、Service"><a href="#Controller、Service" class="headerlink" title="Controller、Service"></a><code>Controller</code>、<code>Service</code></h3><p><code>Controller</code> 用来决定对于给定的请求（经过路由后）返回什么页面。这个过程中的逻辑可以进行抽象，抽象出来负责业务的那一部分成为 <code>Service</code>。</p><p>编写自己的 <code>Controller</code> 和 <code>Service</code> 时推荐的搞法是写一个类。</p><h3 id="Cookie、Session"><a href="#Cookie、Session" class="headerlink" title="Cookie、Session"></a><code>Cookie</code>、<code>Session</code></h3><p>和 HTTP 中的一样。可以通过在 <code>Controller</code> 中从 <code>Context</code> 来获取。</p><h3 id="Helper、Config"><a href="#Helper、Config" class="headerlink" title="Helper、Config"></a><code>Helper</code>、<code>Config</code></h3><p><code>Helper</code> 的实例含有一些 utility 函数，整个应用中的 utility 函数都应该被放到 <code>Helper</code> 中方便被复用。</p><p>Egg.js 推崇配置和代码分离，业务和框架的配置都应该被放到 <code>Config</code> 对象中。</p><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a><code>Logger</code></h3><p>Egg.js 提供了一个比较强大的日志系统，使用 <code>Logger</code> 类进行使用。</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>Egg.js 基于 Koa，它们都通过使用中间件栈来增强功能。在 Egg.js 中可以容易地编写出一个中间件，也能比较方便地在应用、框架或者路由中使用中间件。Egg.js 可以直接使用 Koa 的中间件生态。所有的中间件都具有一些通用的配置。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>使用路由可以将不同的请求导向不同的 <code>Controller</code>。路由也能完成一部份路径解析的功能，Egg 中可以使用路由解析 url 中的参数、对 url 进行分节并将传入 <code>Controller</code>，也能直接应用正则表达式进行解析。此外路由还能完成重定向的功能。</p><p>需要注意的是如果后面打算用 RESTful 的设计的话，Egg 在路由上提供了一些更加简单的方法。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>Egg 还提供了：</p><ul><li><strong>插件</strong>：插件与中间件不同，可以把插件看作是对 Egg 本身功能的增强，例如国际化等。</li><li><strong>定时任务</strong>：框架有时需要做一些独立于任何连接的操作，这可以通过定时任务来完成。</li><li><strong>框架扩展</strong>：方便在 <code>Application</code>、<code>Context</code>、<code>Request</code> 和 <code>Response</code> 上添加方便自己的函数。</li><li><strong>启动自定义</strong>：方便在框架开启时完成自定义的一些操作。</li></ul><h2 id="开发中的一些概念"><a href="#开发中的一些概念" class="headerlink" title="开发中的一些概念"></a>开发中的一些概念</h2><p>与 Egg 配套的 egg-bin 模块能够辅助进行开发，它含有应用启动设置、单元测试、覆盖率测试和调试相关的一些功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搞懂异步</title>
      <link href="/2018/09/06/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%9E%E6%87%82%E5%BC%82%E6%AD%A5/"/>
      <url>/2018/09/06/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%9E%E6%87%82%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="从零开始搞懂异步"><a href="#从零开始搞懂异步" class="headerlink" title="从零开始搞懂异步"></a>从零开始搞懂异步</h1><p>之前小学期学 NodeJS 的时候就被异步搞得很头疼，过几天的 Python 自学报告就打算写异步编程了。现在我打算从最基础的地方开始弄懂异步和与其相关的一些概念。</p><h2 id="阻塞与非阻塞、同步与异步、并发与并行"><a href="#阻塞与非阻塞、同步与异步、并发与并行" class="headerlink" title="阻塞与非阻塞、同步与异步、并发与并行"></a>阻塞与非阻塞、同步与异步、并发与并行</h2><ul><li><strong>阻塞</strong>：程序的某个线程进行了某个调用后如果这个线程要等着运行结果，则称为线程被阻塞。（虽然 CPU 可以把它换下来，但是这个线程依然是阻塞的。）</li><li><strong>非阻塞</strong>：程序的某个线程进行了某个调用后不等结果出来继续运行，则称为非阻塞。</li><li><strong>同步</strong>：进行了某个调用后，这个调用不是立即返回的，可能需要等一段时间，一旦调用返回就得到了希望得到的记过，则称这种情况为同步调用。</li><li><strong>异步</strong>：进行了某个调用后，这个调用立即返回，但是返回值不是希望得到的内容的全部。过一段时间之后可能通过回调等方式处理了真正要得到的记过，这种情况称为异步调用。</li><li><strong>并发</strong>：设计上能够有同时处理多件事情的能力，宏观上这些事情是同时在做的，但是实际不见得就是物理上同时处理的。</li><li><strong>并行</strong>：物理上同时做多件事情。</li></ul><p>按我的理解，阻塞/非阻塞描述的是程序的状态，同步/异步描述的是接口的行为，并发是一种能力，并行是一种现象。</p><p>只有同步阻塞、同步非阻塞（某种基于轮询的搞法）、异步这三种组合。</p><p>另外我见到一个说法是同步是不同程序单元进行通信来协调一致的状态，异步是不同程序单元可以不通信就能完成任务的状态。为什么我们需要异步，因为异步可以实现非阻塞。</p><p>深究这些定义可能没什么卵用。</p><a id="more"></a><h2 id="异步编程的演化"><a href="#异步编程的演化" class="headerlink" title="异步编程的演化"></a>异步编程的演化</h2><p>造成阻塞的原因大部分是等待 IO，如果 IO 是异步的那么阻塞会少很多。</p><p><a href="http://aju.space/2017/07/31/Drive-into-python-asyncio-programming-part-1.html" target="_blank" rel="noopener">深入理解 Python 异步编程 (上)</a> 这篇博客从头解释了各种异步的实现，最后引出了 Python 中的 asyncio。这一节是对这篇博客的整理，博客中是以下载十篇网页作为例子的。为了简单起见我不打算写代码。</p><h3 id="朴素的同步阻塞"><a href="#朴素的同步阻塞" class="headerlink" title="朴素的同步阻塞"></a>朴素的同步阻塞</h3><p>发起 HTTP 请求，等待响应，响应后，等待接收所有数据，接收完成后，一篇网页就下好了。这样干十次，就把事情干完了，但是是最慢的。</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>开多个进程干上面一次下载要干的事情，每个进程下不同的网页。这样其实没有本质的区别，如果 CPU 的核数和进程数一样多的话，实际上还是有大量的时间被浪费了。（如果 CPU 的核数少的话可以通过换进程来让 IO 和运算重叠。）</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>开多个线程干上面一次下载要干的事情，每个线程下不同的网页。这个和多进程的区别在于：</p><ol><li>对 OS 来说，多线程的切换开销更小。</li><li>然而由于 GIL 锁的存在，多线程并行是不可能的。</li><li>不过，某个线程如果碰到了阻塞操作的话，会运行另一个线程。</li></ol><hr><p>总之，Python 中如果是计算密集型的，用多进程；IO 密集型的，用多线程。</p><h3 id="轮询非阻塞"><a href="#轮询非阻塞" class="headerlink" title="轮询非阻塞"></a>轮询非阻塞</h3><p>如果发起 HTTP 这个接口有非阻塞的版本，那么可以调用之后开始轮询，一般会通过更新了某个状态来知道事情干完了没有。不过如果没有更好的事情可以干并且只进行了一个调用的话，这样做的时间和同步阻塞几乎没差别。如果发了多个请求，然后轮着轮询的话，效率会好一点。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>回调说的是在发起请求的时候顺带传一个函数，请求处理完毕之后调用这个函数。具体怎么实现，操作系统将 IO 操作进行了封装，比如 IO 操作完成是一个 <strong>事件</strong>，当程序把所有的准备工作都干完了之后（调用了一堆异步的接口等着回调）会开启一个 <strong>事件循环</strong>，这个事件循环会不断取出事件进行处理，比如抽到一个 IO 操作完成的事件就会调用对应的回调函数。<strong>如果没有新的事件的话就会阻塞。</strong>操作系统的这种机制称为 select。（可以通过搜索 epoll/kqueue 来获得更多信息。）</p><p>使用回调时，只用一个线程就能搞定所有这一切。</p><hr><p><strong>回调的缺点</strong>：主要是层次过多（回调套回调）时结构复杂，此外回调中要保留这个回调要用到的一些状态；另外，回调一旦出错很难处理。这些问题让回调不是那么好用。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>所谓线协程，是一组互相协作的程序单元（一个例子是两个会相互调度（而不是调用）的函数）。这样每个程序单元维护自己的状态是容易的，并且它们之间的切换不用经过 OS 内核，代价很小。厉害的是它解决掉了前述中回调的诸多缺点。然而只要使用异步，总是不可避免回调的，不过协程可以让回调对程序员透明。</p><p>Python 中存在生成器，生成器可以保存自己的状态，可以暂时暂停执行然后恢复，这不依赖于线程或进程的切换。于是可以使用生成器来做协程。</p><p>定义以下几个类：</p><ul><li><code>Future</code>：这个类存放某个操作未来的结果，一旦结果被得到，就会调用事先加入其中的回调函数。</li><li><code>Task</code>：这个类存放一个协程（本质上，是一个生成器），同时它有一个步进函数，步进函数需要传入一个 <code>Future</code>，其功能如下：<ul><li>将这个 <code>Future</code> 的结果传入生成器，并得到生成器的下一个生成结果。生成器的下一个生成结果经过设计，正好是一个空的 <code>Future</code>。</li><li>为刚刚得到的这个 <code>Future</code> 添加一个“完成回调”，具体就是把自己传给自己这个 <code>Task</code> 的步进函数。<br>另外，<code>Task</code> 的构造函数需要传入自己要维护的协程，并且会将这个协程运行到第一次 <code>yield</code> 的地方（通过调用步进实现）。</li></ul></li></ul><p>然后定义那些协程（生成器的时候）注意两点：</p><ul><li>每次 <code>yield</code> 返回一个空的 <code>Future</code></li><li>当要进行某个会阻塞的操作时，先构建一个空 <code>Future</code>，然后使用其非阻塞版本，将其完成的回调设置为“填充刚刚构造的空 <code>Future</code>”，然后 <code>yield</code> 出去。</li></ul><p>当把所有能干的非阻塞的事情干完之后，开启事件循环，现在来观察会发生什么：</p><p>首先曾经构造过了一些 <code>Task</code>，这些 <code>Task</code> 中维护的协程应该已经运行到了各自第一次 <code>yield</code> 的地方，并且它们内部都有个空的 <code>Future</code>。然后，假设某个阻塞操作终于完成了，此时事件循环捕捉到这个信号，运行了其上的回调函数。这个回调是什么，是“填充刚刚构造的空 <code>Future</code> 的结果”，因此会触发 <code>Future</code> 被“完成回调”，而这个“完成回调”是之前运行步进时添加的“把自己传给自己这个 <code>Task</code> 的步进函数”，因此现在的情况是，返回值放在了 <code>Future</code> 中，正在运行的是 <code>Task</code> 的步进，步进会“将这个 <code>Future</code> 的结果传入生成器”，于是协程中拿到了返回值，进行适当操作后，再次调用某阻塞函数然后 <code>yield</code> 出来一个空 <code>Future</code>，回到了步进函数中，步进函数又“为刚刚得到的这个 <code>Future</code> 添加一个‘完成回调’，具体就是把自己传给自己这个 <code>Task</code> 的步进函数。”，这一步进行完之后回到了事件循环。如此反复，直到事情干完（细节不写了）。</p><p>这些内容看上去应该很蛋疼，仿照原博客写了一个简单的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_WRITE, EVENT_READ</span><br><span class="line"></span><br><span class="line">selector = DefaultSelector()</span><br><span class="line">num_urls = <span class="number">20</span></span><br><span class="line">num_todo = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = <span class="literal">None</span></span><br><span class="line">        self.done_callback = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        self.result = result</span><br><span class="line">        <span class="keyword">if</span> self.done_callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.done_callback(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gen)</span>:</span></span><br><span class="line">        self.gen = gen</span><br><span class="line">        new_future = Future()</span><br><span class="line">        self.run_to_next(new_future)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_to_next</span><span class="params">(self, future)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            next_future = self.gen.send(future.result)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        next_future.done_callback = self.run_to_next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.socket = socket()</span><br><span class="line">        self.socket.setblocking(<span class="literal">False</span>)</span><br><span class="line">        self.response = <span class="string">b''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> num_todo</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.socket.connect((self.url, <span class="number">80</span>))</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        f = Future()</span><br><span class="line">        selector.register(self.socket.fileno(), EVENT_WRITE, <span class="keyword">lambda</span>: f.set_result(<span class="literal">None</span>))</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">        selector.unregister(self.socket.fileno())</span><br><span class="line">        self.socket.send(<span class="string">f'GET / HTTP/1.0\r\nHost: <span class="subst">&#123;self.url&#125;</span>\r\n\r\n'</span>.encode(<span class="string">'ascii'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            f = Future()</span><br><span class="line">            selector.register(self.socket.fileno(), EVENT_READ, <span class="keyword">lambda</span>: f.set_result(self.socket.recv(<span class="number">4096</span>)))</span><br><span class="line">            chunk = <span class="keyword">yield</span> f</span><br><span class="line">            selector.unregister(self.socket.fileno())</span><br><span class="line">            <span class="keyword">if</span> chunk:</span><br><span class="line">                self.response += chunk</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num_todo -= <span class="number">1</span></span><br><span class="line">                print(<span class="string">'done'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_urls):</span><br><span class="line">        crawler = Crawler(<span class="string">'example.com'</span>)</span><br><span class="line">        Task(crawler.download())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> num_todo &gt; <span class="number">0</span>:</span><br><span class="line">        events = selector.select()</span><br><span class="line">        <span class="keyword">for</span> key, mask <span class="keyword">in</span> events:</span><br><span class="line">            callback = key.data</span><br><span class="line">            callback()</span><br></pre></td></tr></table></figure><p>可以看到，一个线程就能搞定所有的一切，并且出现回调的地方，写法都是固定的，没有出现嵌套的情况。这就是协程的好处。但是这样写代码太丑了，而且还是要自己手动处理一些底层的事情（比如维护时间队列）。</p><p>首先可以将所有的 <code>yield</code> 全部换成 <code>yield from</code>，这么做的一个好处是可以将这些协程与普通的生成器区分开，并且方便将一长串带有 <code>yield</code> 的代码转换成若干个函数。Python 中已经有一个 asyncio 库来封装上面代码中的大部分内容。</p><h4 id="生成器协程"><a href="#生成器协程" class="headerlink" title="生成器协程"></a>生成器协程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(url)</span>:</span></span><br><span class="line">    resp = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.get_event_loop().run_in_executor(<span class="literal">None</span>, <span class="keyword">lambda</span>: requests.get(url))</span><br><span class="line">    print(<span class="string">'done'</span>)</span><br><span class="line">    <span class="keyword">return</span> resp.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tasks = [download(<span class="string">'http://www.example.com'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure><h4 id="原生协程"><a href="#原生协程" class="headerlink" title="原生协程"></a>原生协程</h4><p>既然每次写协程都要加 <code>@asyncio.coroutine</code> 和 <code>yield from</code>，为啥不做成关键字呢？Python 后来引入了 <code>async</code> 来标记协程，用 <code>await</code> 来等待一个协程运行完毕。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(url)</span>:</span></span><br><span class="line">    resp = <span class="keyword">await</span> asyncio.get_event_loop().run_in_executor(<span class="literal">None</span>, <span class="keyword">lambda</span>: requests.get(url))</span><br><span class="line">    print(<span class="string">'done'</span>)</span><br><span class="line">    <span class="keyword">return</span> resp.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tasks = [download(<span class="string">'http://www.example.com'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://aju.space/2017/07/31/Drive-into-python-asyncio-programming-part-1.html" target="_blank" rel="noopener">深入理解 Python 异步编程 (上)</a></li><li><a href="https://zhuanlan.zhihu.com/p/20953544" target="_blank" rel="noopener">谈谈 python 的 GIL、多线程、多进程</a></li><li><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别？</a></li><li><a href="http://lotabout.me/2017/understand-python-asyncio/" target="_blank" rel="noopener">理解 Python asyncio</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算几何学习笔记 4</title>
      <link href="/2018/09/03/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/"/>
      <url>/2018/09/03/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/</url>
      
        <content type="html"><![CDATA[<h1 id="计算几何学习笔记——Voronoi-图"><a href="#计算几何学习笔记——Voronoi-图" class="headerlink" title="计算几何学习笔记——Voronoi 图"></a>计算几何学习笔记——Voronoi 图</h1><blockquote><p>todo</p></blockquote><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Voronoi-图的概念"><a href="#Voronoi-图的概念" class="headerlink" title="Voronoi 图的概念"></a>Voronoi 图的概念</h3><p>只考虑二维的情况，设想平面上有一系列的点，这些点被称作 site。在平面上任取一个点，这个点到所有 site 的距离中必然有一个最近的，对这个点来说这个 site 是离它最近的 site。对于每个 site，它周围总会有一小块区域，使得对这个区域中的每个点，这个 site 都是离这个点最近的 site，这样的区域称作是这个 site 的 cell。</p><p>总的来看，给定了一些 site 之后，它们对应得到的 cell 就会平铺满整个平面，这样的到的图称作是 Voronoi 图。cell 的边称作是 Voronoi 边，Voronoi 边的交点称作是 Voronoi 点。</p><h3 id="Voronoi-图的一些性质"><a href="#Voronoi-图的一些性质" class="headerlink" title="Voronoi 图的一些性质"></a>Voronoi 图的一些性质</h3><p>考虑平面上只有两个点的情况，这个时候整个 Voronoi 图就只有一条直线，将整个平面分成两个半平面。</p><p>如果给定了若干个 site，数学上可以通过以下方法来求得其中某个 site $S$ 对应的 cell。只要遍历除了 $S$ 之外的所有 site，求出属于 $S$ 的那个半平面，然后将这些半平面取交集即可。由于半平面是凸的，交运算保持凸性，所以 Voronoi 图中所有的 cell 都是凸的。</p><p>Voronoi 边上的点，到与它相邻的 cell 对应的 site 的距离相等。在 Voronoi 点上的点有类似的性质。</p><p>Voronoi 边可能是线段、射线或者直线。</p><p>其它的一些性质：</p><ul><li><strong>非空性</strong>：任何一个 site 一定具有非空的 cell。</li><li><strong>空圆性</strong>：对于 cell 内部的点，以它为圆形，以这个点到对应 site 的距离作为半径作圆，那么这个圆内部是空的（不包含其它所有的 site）；对于在 Voronoi 边而不在 Voronoi 点上的点，按这种方法作出的圆内部是空的，但是圆上会有两个点；对于在 Voronoi 点上点，按这个方法作出的圆内部是空的，圆上有至少三个点。</li></ul><h3 id="Voronoi-图的空间复杂度"><a href="#Voronoi-图的空间复杂度" class="headerlink" title="Voronoi 图的空间复杂度"></a>Voronoi 图的空间复杂度</h3><p>对于 $n$ 个 site 构成的 Voronoi 图，其空间复杂度可以这样推导：</p><p>首先要将 Voronoi 图转换成一张平面图，为此引入位于无穷远处的点，并将所有延伸至无穷远处的线都连接到这个点上。这样 Voronoi 图会被转换成平面图，且只有一个强连通分量。平面图中每一个面都至少有三条边（我发现这个好像只在 Voronoi 点的度数为三的情况下成立，不过实际情况中一般也就是这样），由此可以得到这个平面图中边数和面数的关系（一个不等式），再带入欧拉公式。</p><p>最后的结论是 Voronoi 图的边数和面数都是 $O(n)$ 的。</p><h2 id="Voronoi-图的表示与存储"><a href="#Voronoi-图的表示与存储" class="headerlink" title="Voronoi 图的表示与存储"></a>Voronoi 图的表示与存储</h2><h3 id="平面剖分"><a href="#平面剖分" class="headerlink" title="平面剖分"></a>平面剖分</h3><p>Voronoi 图实际上是平面剖分的一种特殊情况。如果将平面图嵌入到一张平面上，即对于平面图的每一个点都在平面上为其安排一个位置，这样所有的点都是对应的，并且平面上与平面图中的边对应的边是不相交的，这样就得到了平面的一个剖分。Voronoi 图是平面剖分的一种特例。</p><p>Fáry&#39;s theorem 指出，如果一个平面图在完成嵌入后，某些边是弯的才能完成这个嵌入，那么一定存在一种嵌入方式，使得所有的边都是直的。这个定理在引入了无穷原点（正如上面做的那样）的时候很有用。</p><p>存储 Voronoi 图时（以及其它平面剖分的情况）需要使用一种叫 DCEL 的数据结构（Doubly Connected Edge List），它的好处是能在常数时间（严格说来应该是线性的，不过一个顶点关联的边和一个面关联的边一般不是很多）内找到一个顶点关联的所有边以及一个面周围的所有边。</p><h3 id="DCEL-数据结构"><a href="#DCEL-数据结构" class="headerlink" title="DCEL 数据结构"></a>DCEL 数据结构</h3><p>DCEL 可以用来存一个平面图在平面上的嵌入情况。它的思路是将一条边分解成两条半边，每条半边都具有自己的方向并且方向相反。对于一个面片来说，围绕它的所有的边在它那一侧的所有的半边应该是按照某个约定的方向旋转的（不妨设置为逆时针）。DCEL 需要维护三张表：边表、点表和面表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HalfEdge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Identifier      Id;                 <span class="comment">// 这条半边的编号</span></span><br><span class="line">    HalfEdge*       TwinHalfEdge;       <span class="comment">// 这条半边的孪生半边，即和它方向相反的那一条</span></span><br><span class="line">    Vertex*         OriginVertex;       <span class="comment">// 这条半边的起始顶点</span></span><br><span class="line">    Face*           IncidentFace;       <span class="comment">// 这条半边对应的面片，约定为左边那一个</span></span><br><span class="line">    HalfEdge*       PrevHalfEdge;       <span class="comment">// 对应面片中，这条半边的前驱</span></span><br><span class="line">    HalfEdge*       NextHalfEdge;       <span class="comment">// 对应面片中，这条半边的后继</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Identifier      Id;                 <span class="comment">// 顶点编号</span></span><br><span class="line">    <span class="keyword">double</span>          X;                  <span class="comment">// 顶点坐标</span></span><br><span class="line">    <span class="keyword">double</span>          Y;                  <span class="comment">// 顶点坐标</span></span><br><span class="line">    HalfEdge*       IncidentHalfEdge;   <span class="comment">// 与它关联的一条半边，约定为从这个顶点出发的半边中的任意一条</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Face</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Identifier      Id;                 <span class="comment">// 面片编号</span></span><br><span class="line">    HalfEdge*       IncidentHalfEdge;   <span class="comment">// 与它关联的一条半边，约定为环绕这个面片的半边中的任意一条</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一些操作举例：</p><ul><li><strong>给定一个面片，得到与它关联的所有边</strong>：找到它的 <code>IncidentHalfEdge</code>，从这个边开始不断访问 <code>NextHalfEdge</code> 即可（形成了环形链表）。</li><li><strong>给定一个顶点，得到与它关联的所有边</strong>：找到它的 <code>IncidentHalfEdge</code>，访问之，访问它的孪生后继，孪生后继的孪生后继，依次类推。</li></ul><h2 id="Voronoi-图的求解"><a href="#Voronoi-图的求解" class="headerlink" title="Voronoi 图的求解"></a>Voronoi 图的求解</h2><h3 id="复杂度下界估计"><a href="#复杂度下界估计" class="headerlink" title="复杂度下界估计"></a>复杂度下界估计</h3><p>为了得到一个能够实际发挥作用的 Voronoi 图，除了要得到这个图本身之外，应该还需要得到它的相应的结构，例如得到它的 DCEL 结构，否则不认为求解出了 Voronoi 图。</p><p>排序问题可以归约到一维 Voronoi 图问题，或者二维 Voronoi 图问题。由此知道 Voronoi 图的求解不会比 $O(n\log n)$ 更快。</p><p>如果输入的点的序列按照某个方向排序了，也不会有比 $O(n\log n)$ 更快的算法。与凸包算法不同，凸包是一个所谓的 <em>组合结构</em> 而 Voronoi 图则是一个 <em>几何结构</em>。凸包在仿射变换下依然是凸包，但是一个点集经过仿射变换后的 Voronoi 图和原来的 Voronoi 图具有本质的差别，这是为什么给定了按某方向排序的点列后无法加速算法的原因。</p><p>下面可以对这个问题进行更加严谨的分析。</p><h4 id="epsilon-closeness-问题"><a href="#epsilon-closeness-问题" class="headerlink" title="$\epsilon$ closeness 问题"></a>$\epsilon$ closeness 问题</h4><p>给定 $n$ 个未经排序的数和一个 $\epsilon$，询问这 $n$ 个数中间隔最小的那两个数的间隔是否小于 $\epsilon$。这个问题是最小间隔问题的决策版本，但是即便如此，这个问题的复杂度的下界依然是 $O(n\log n)$。</p><h4 id="将-epsilon-closeness-问题转换成从某方向排序好的点构造-Voronoi-图的问题"><a href="#将-epsilon-closeness-问题转换成从某方向排序好的点构造-Voronoi-图的问题" class="headerlink" title="将 $\epsilon$ closeness 问题转换成从某方向排序好的点构造 Voronoi 图的问题"></a>将 $\epsilon$ closeness 问题转换成从某方向排序好的点构造 Voronoi 图的问题</h4><p>对于给定的若干个数（未经排序）放在横轴上，按照给定这些数的顺序将其抬升一个高度。如果这个数是第 $i$ 个给出的，就提高为 $\displaystyle{\frac{i\epsilon}{n}}$。这样我们就得到了 $n$ 个平面上的点，它们按照纵轴方向有序。如果使用某种算法构造出了 Voronoi 图，则我们可以在线性时间（存疑）内得到所有与横轴相交的那些 cell，并且它们是按照横轴方向排序的。</p><p>现在，将这些平面点再次变换回横轴上，有两种情况：</p><ul><li>所有的点都位于自己的 cell 中，这个时候我们实际上完成了对这些横轴点的排序；</li><li>有些点不位于自己的 cell 中，假设这个点在横轴上是 $A$ 点，它所在的那个 cell 的 site 在横轴上的点为 $B$ 点，则有 $AB &lt; \epsilon$。</li></ul><p>不管是哪种情况，我们都在线性时间内将 $\epsilon$ closeness 问题转换成从某方向排序好的点构造 Voronoi 图的问题。于是 Voronoi 图即使在给定的点按照某个方向排序的情况下，复杂度也不会低于 $O(n\log n)$。</p><h4 id="对偶的问题"><a href="#对偶的问题" class="headerlink" title="对偶的问题"></a>对偶的问题</h4><p>给定了平面点集的 Voronoi 图，要求这个 Voronoi 图对应的 site 在某个方向上的投影的排序，复杂度不会比 $O(n\log n)$ 更低。</p><h3 id="Naive-算法"><a href="#Naive-算法" class="headerlink" title="Naive 算法"></a>Naive 算法</h3><p>Naive 算法的复杂度是 $O(n^3)$ 的，并且无法给出 DCEL 结构。它的思路是逐点构造 cell。对于每一个点，它的初始 cell 为整个平面，然后对于除了它以外的所有点，都会将它的 cell 削减掉一部分。每考虑外部的一个点，它和当前 cell 的求交需要 $O(n)$ 才能完成，而要考虑的外部点是 $O(n)$ 个的，所以求出一个真正的 cell 需要 $O(n^2)$ 的时间，这还只得到了一个点的 cell，我们一共有 $O(n)$ 个点，所以需要的总时间是 $O(n^3)$ 的。</p><h3 id="增量构造算法"><a href="#增量构造算法" class="headerlink" title="增量构造算法"></a>增量构造算法</h3><p>如果已经知道了 $n$ 个点的 Voronoi 图，则可以方便地在添加了一个点的情况下知道这 $n + 1$ 个点的 Voronoi 图。增加了一个点后，你可以在线性时间内（起码我能想到的最快是这么多）找到这个点位于哪个面片中，因此也就找到了这个面片对应的 site。然后连一条新增点与找到的 site 的垂直平分线。有些算法在给定了 DCEL 结构后能够在 $O(\log n)$ 的时间内得到一条直线与一个凸多边形的相交情况，使用这种算法，找到一个垂直平分线与那个 site 对应的 cell 的边界的交点，然后这个交点位于 Voronoi 边上，所以可以得到另一边（考虑孪生半边，或者直接考虑这两个相邻的 cell）的那个 site，再次作这个新 site 与新增的点的垂直平分线，用 $O(\log n)$ 的时间找到下一个交点，依次推进下去，可以构造出一个封闭的图形出来。构造出来的这个封闭图形就是新增点的 cell。这个构造将在 $O(n\log n)$ 的时间内完成，不幸的是真的有些情况会达到这个最坏情况。每新增一个点，就要用 $O(n\log n)$ 的时间，于是一共要用 $O(n^2\log n)$ 的时间得到 $n$ 个点的 Voronoi 图。</p><blockquote><p>todo</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算几何学习笔记 3</title>
      <link href="/2018/09/03/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/"/>
      <url>/2018/09/03/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<h1 id="计算几何学习笔记——画廊问题与三角剖分问题"><a href="#计算几何学习笔记——画廊问题与三角剖分问题" class="headerlink" title="计算几何学习笔记——画廊问题与三角剖分问题"></a>计算几何学习笔记——画廊问题与三角剖分问题</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li><strong>星形多边形</strong>：这样的多边形具有一个核，从核向任意一个顶点连线，连线都不会和边有交点。注意星形多边形不一定是凸多边形。</li><li><strong>简单多边形</strong>：这样的多边形任意不相邻的两条边不相交（也不搭接）。</li><li><strong>正交多边形</strong>：如果多边形的所有边都平行于两个方向，并且这两个方向是垂直的，那么这个多边形为正交多边形。</li><li><strong>内对角线</strong>：多边形的对角线，且这样的对角线与其它边没有交点。</li></ul><p>在平面上，三角剖分问题有两种。一种是对于一个给定的（可能带洞的）多边形，如何将它分解为若干个不重合的以它的顶点为顶点的三角形的并；另一个是对于给定的点集如何进行结构化（以后可能会写）。这篇中所有的三角剖分问题都是指前一种。画廊问题是对三角剖分问题的一个引入。</p><h2 id="画廊问题"><a href="#画廊问题" class="headerlink" title="画廊问题"></a>画廊问题</h2><p>平面上的画廊问题指对于一个给定的多边形，问需要几盏灯可以将它完全照亮（或者要几个摄像头可以无死角覆盖，大概就是这种表述）。</p><p>灯的种类有很多种，比如有的灯可以随处摆放，有的灯只能放在角落，有的灯可以覆盖整个墙面。无论是哪种灯，对于一个给定的多边形要求出灯数最少的覆盖方案，这个问题是 NP 的，即使已知这个多边形是正交多边形也是 NP 的。</p><p>不过对于给定的 n 边形，我们可以估计出要使用的灯数的上界和下界，下界显然是 1（考虑星形多边形），上界则为 n/3。首先 n 边形总是可以使用 n 盏灯照亮，只要在每个顶点上都放一盏灯即可。对于这个给定的 n 边形对其进行三角剖分，会得到一个平面图，每个孔都是三角形的。如果原来的多边形没有孔的话（有孔也成立，但是证明过程略去），则可以对这个平面图进行了三染色，染色完成之后必然有一种颜色的顶点数不超过 n/3，在所有这样的顶点上放上灯即可。三染色的可行性使用对偶图说明，这样的平面图的对偶图是一棵树，随便从上面哪个点开始，先将对应的那个三角形染色，然后沿着树染掉其它的即可。另一方面，确实可以对于任意的 n 构造出需要 n/3 这么多盏灯的多边形。对于正交多边形，这个上界可以进一步减小到 n/4。</p><h2 id="三角剖分问题"><a href="#三角剖分问题" class="headerlink" title="三角剖分问题"></a>三角剖分问题</h2><h3 id="带洞简单多边形的三角剖分可行性"><a href="#带洞简单多边形的三角剖分可行性" class="headerlink" title="带洞简单多边形的三角剖分可行性"></a>带洞简单多边形的三角剖分可行性</h3><h4 id="耳朵与嘴巴"><a href="#耳朵与嘴巴" class="headerlink" title="耳朵与嘴巴"></a>耳朵与嘴巴</h4><p>对于多边形上的一个点 $P$，它必然存在两个相邻的点。将这三个点连接起来会得到一个三角形。如果这个三角形内部存在某个多边形的其它顶点，则称这个三角形为脏的。如果这个三角形不是脏的并且完全位于多边形内部，称 $P$ 为多边形的一个耳朵；如果这个三角形不是脏的并且完全位于多边形外部，称 $P$ 为多边形的一个嘴巴。</p><h4 id="双耳定理"><a href="#双耳定理" class="headerlink" title="双耳定理"></a>双耳定理</h4><p>对任何一个多于三个顶点的简单多边形，它一定存在至少两个耳朵。（貌似需要这个多边形不带洞？）</p><h4 id="带洞多边形的全序关系"><a href="#带洞多边形的全序关系" class="headerlink" title="带洞多边形的全序关系"></a>带洞多边形的全序关系</h4><p>对所有带洞的多边形，可以定义出一个全序关系。只要任意两个多边形 $P_1, P_2$ 能进行比较即可：</p><ol><li>若 $P_1$ 的洞比 $P_2$ 多，则 $P_1 &gt; P_2$。</li><li>否则，若 $P_1$ 的边比 $P_2$ 多，则 $P_1 &gt; P_2$。</li><li>否则，$P_1 = P_2$。</li></ol><h4 id="可行性说明"><a href="#可行性说明" class="headerlink" title="可行性说明"></a>可行性说明</h4><p>使用数学归纳法。最小的多边形是三角形可以进行三角剖分。对于任意一个多边形，如果所有比它小的多边形都可以进行三角剖分，那么总是找到它的一个向外凸的点 $P$，如果这个点是耳朵，则切割下来，这样得到了一个更小的多边形；如果这个点不是耳朵，也就是说有其它点位于 $P$ 及其邻点构成的三角形中，那么将 $P$ 与这些在三角形内部的点中离 $P$ 的两个邻边连线最远的那个点连接起来，这样就会得到一个或多个更小的多边形（例如会将一个多边形切成两个，或者将一个洞与外部打通从而少了一个洞）。不管怎么样，多边形的规模更小了，由数学归纳法知带洞的多边形的三角剖分总是可行的。</p><h3 id="不带洞简单多边形的三角剖分算法"><a href="#不带洞简单多边形的三角剖分算法" class="headerlink" title="不带洞简单多边形的三角剖分算法"></a>不带洞简单多边形的三角剖分算法</h3><h4 id="单调多边形"><a href="#单调多边形" class="headerlink" title="单调多边形"></a>单调多边形</h4><p>一段折线称作链，如果存在某个方向，使得这个折线在这个方向上的投影满足“投影点在这个方向上的排布顺序和点在折线上的连接顺序一致”的话，称这个链为单调链，换句话说就是这个链可以作为某个函数的图像。为了简单起见，称那个用来投影的方向为单调方向。</p><p>如果一个多边形由两条单调链拼接而成，并且这两条链的单调方向相同，这称这个多边形是单调多边形。例如，如果单调方向是水平方向的话，则一个单调多边形可以由上下两条单调链构成。</p><p>给定一个多边形，可以在线性时间内判定这个多边形是不是单调的，并且还能给出它所有的单调方向。不过三角剖分问题用不到这么好的性质。</p><hr><p>对任意不带洞的简单多边形的三角剖分分成两步，第一步要将这个多边形划分成若干个不相交的单调多边形，并且这些多边形的单调方向都是竖直方向的。这一步需要对顶点进行排序，所以复杂度最低也是 $O(n \log n)$。第二步需要对每个单调多边形进行三角剖分，这一步中，因为单调多边形两条链的顺序关系已经给出，可以在线性时间内给出这个单调多边形的三角剖分。总的来说需要 $O(n\log n)$ 的时间。下面先写单调多边形如何进行三角剖分，然后再写如何将多边形划分成若干个单调多边形。</p><h4 id="单调多边形的三角剖分"><a href="#单调多边形的三角剖分" class="headerlink" title="单调多边形的三角剖分"></a>单调多边形的三角剖分</h4><p>根据上面的描述，现在这个单调多边形的单调方向是竖直的，于是必然存在一个最顶端的点 $T$ 以及一个最底端的点 $B$。此外，所有的点都具有纵坐标并且已经被排序了（或者可以由线性时间得到）。现在假想有一条扫描线从上到下进行扫描，并且有一个栈记录了所有没有完全被三角剖分的点。现在这个扫描线开始扫描。当扫描到最顶端的点时，将这个点压栈。当扫描到第二高的点时，将这个点压栈。正常情况下，栈中应该总有至少两个元素。对于其它一般的情况：</p><ul><li>当扫描到一个点，此时栈中只有一个点（表明这个点是当前的最高点，但不一定是 $T$ 因为采用了减而治之的策略），则将这个点压栈；</li><li>当扫描到一个点，这个点和栈顶对应的点处于相同的单调链上：<ul><li>如果刚扫描到的这个点、栈顶对应的点、次栈顶对应的点三个点张成的角在多边形内部的那一部分大于平角，则将刚刚扫描到的点压栈；</li><li>如果刚扫描到的这个点、栈顶对应的点、次栈顶对应的点三个点张成的角在多边形内部的那一部分小于平角，则：<ol><li>将刚扫描到的这个点、栈顶对应的点、次栈顶对应的点这三个点拼接成一个三角形；</li><li>弹出栈顶，回到检查是否大于平角那一步，按照是否大于平角进行相应处理；如果弹出栈顶后，整个栈中只剩下一个元素了，那么弹出这个元素，并让刚扫描到的点作为栈底。此时发生了问题规模的缩减；</li></ol></li></ul></li><li>当扫描到一个点，这个点和栈顶对应的点处于不同的单调链上时，存下此时的栈顶记作 $T$，随后按照栈的顺序不断弹出元素并进行三角形拼接，直到只剩栈底。然后弹出栈底，让 $T$ 做栈底，让这个刚扫描到的元素进栈，此时发生了问题规模的缩减；</li></ul><p>最后一个元素按照处于不同单调链上进行处理。这样就可以将一个单调多边形进行三角剖分。</p><h4 id="不带洞简单多边形划分为单调多边形"><a href="#不带洞简单多边形划分为单调多边形" class="headerlink" title="不带洞简单多边形划分为单调多边形"></a>不带洞简单多边形划分为单调多边形</h4><p>这一节的问题是将任意一个不带洞的简单多边形划分为单调多边形，为了方便处理以及方便后续的处理，这些单调多边形的单调方向应该都是竖直的。</p><p>先考虑为什么会出现不是单调多边形的情况，这些都是因为多边形中出现了这样的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.../\...   \      /</span><br><span class="line">../  \..   .\    /.</span><br><span class="line">./    \.   ..\  /..</span><br><span class="line">/      \   ...\/...</span><br></pre></td></tr></table></figure><p>分别称为石笋和钟乳石，其中圆点表示在多边形的内部。如果不是这样的结构，那么必然是单调下降或者单调上升的。我们只考虑左边的那种情况，如果在所有出现了这个情况的地方，我们都能将尖点和位于其上方的某个点连接起来对多边形进行划分，这样就能消去所有的这样的结构，随后只要能够消去所有的右边的情况就能完成将多边形划分为单调多边形了。</p><p>如何消掉所有的石笋结构？使用一根扫描线从上到下扫描，并且维护一些梯形以及这些梯形的某个上端点（三角形可以认为是特殊的梯形）。梯形和梯形的上端点应该配对维护，这些梯形的作用是，在扫描过程中如果碰到了石笋结构，就找到石笋的尖点所处的那个梯形，然后将尖点和梯形对应的那个上端点连接起来，这样就消掉了一个尖点。初始情况下没有任何梯形，在整个扫描的过程中，一共只会碰到六类点，这些点位于下图示例中拐弯的地方（圆点表示在多边形的内部）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   /\    \....../  .\      /.   .../\...   \      /</span><br><span class="line">  /..\    \..../   ..\    /..   ../  \..   .\    /.</span><br><span class="line"> /....\    \../    ../    \..   ./    \.   ..\  /..</span><br><span class="line">/......\    \/     ./      \.   /      \   ...\/...</span><br><span class="line"></span><br><span class="line">   A        B        C      D       E          F</span><br></pre></td></tr></table></figure><p>后面将这些线段拐弯处的点称作是“拐点”。</p><ul><li>A：建立一个新的梯形（本质上是三角形），将拐点作为梯形对应的上端点；</li><li>B：将对应的梯形（本质上是三角形）以及上端点移除；</li><li>C：移除拐点以上的的梯形以及端点，将拐点以下的部分作为新的梯形进行维护，并将拐点作为端点；</li><li>D：移除拐点以上的的梯形以及端点，将拐点以下的部分作为新的梯形进行维护，并将拐点作为端点；</li><li>E：（这是一个石笋）将尖点和尖点所在的梯形对应的端点连接起来，移除上方的梯形，将其分裂为两个梯形（左下部分和右下部分），将尖点作为这两个梯形的端点。</li><li>F：（这是一个钟乳石）将左上方的梯形和右上方的梯形都移除，将它们合并为下方的大梯形，并让尖点作为这个梯形的端点。</li></ul><p>这样扫描到最后，就会发现所有的石笋已经被消除了。如何消掉钟乳石慕课中并没有讲，我认为可以对已经分开的多边形从下到上再跑一次扫描，这样就可以消掉所有的钟乳石了。经过这两个过程后，这个无洞的多边形就被划分为若干个单调方向为竖直方向的单调多边形了。</p><p><strong>复杂度的分析</strong>：可以看到扫描过程对于每个点，因为要执行查找、删除或者合并梯形等操作，通过使用二叉树可以让这个过程在对数时间内完成，所以这一步总计花费 $O(n\log n)$；此外开始的时候要对所有点进行排序，排序的代价为 $O(n\log n)$，于是总的复杂度应该是 $O(n\log n)$。</p><h4 id="总的分析"><a href="#总的分析" class="headerlink" title="总的分析"></a>总的分析</h4><p>总体来看，第一大步的时间为 $O(n\log n)$，第二大步的时间为 $O(n)$，整个三角剖分时间为 $O(n\log n)$。然而这个时间不是最好的，最好可以在线性时间内完成对任意不带洞简单多边形的三角剖分，但是实现起来很困难。实际应用中 $O(n\log n)$ 已经足够了。</p><h2 id="三维不同于二维的一些情况"><a href="#三维不同于二维的一些情况" class="headerlink" title="三维不同于二维的一些情况"></a>三维不同于二维的一些情况</h2><p>在三维的情况下，会发生一些有趣的事情，比如：</p><ul><li>对一个三维体的三角剖分（剖分成四面体）的时候，可能不存在任何剖分方案，也可能存在一些剖分方案使得最后剖分出来的四面体数目不相同。</li><li>三维情况下的画廊问题，存在一些情况使得即使在每个顶点处放置一盏灯都无法覆盖整个画廊。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算几何学习笔记 2</title>
      <link href="/2018/09/01/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2018/09/01/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="计算几何学习笔记——几何求交问题"><a href="#计算几何学习笔记——几何求交问题" class="headerlink" title="计算几何学习笔记——几何求交问题"></a>计算几何学习笔记——几何求交问题</h1><p>这一篇的内容是几何求交。</p><h2 id="基础算法和理论"><a href="#基础算法和理论" class="headerlink" title="基础算法和理论"></a>基础算法和理论</h2><h3 id="Element-Uniqueness-问题"><a href="#Element-Uniqueness-问题" class="headerlink" title="Element Uniqueness 问题"></a>Element Uniqueness 问题</h3><p>给定若干个实数，它们之中有没有重复的元素？一个直观的想法是先对其排序然后做一个线性的判定，这会耗费 $O(n\log n)$ 的时间。可以证明，这个时间已经是这个问题的最好能达到的时间了。</p><h3 id="Integer-Element-Uniqueness-问题"><a href="#Integer-Element-Uniqueness-问题" class="headerlink" title="Integer Element Uniqueness 问题"></a>Integer Element Uniqueness 问题</h3><p>即使将 Element Uniqueness 问题中的实数换成整数，最优时间不会发生改变。</p><h3 id="Minimal-Gap-问题"><a href="#Minimal-Gap-问题" class="headerlink" title="Minimal Gap 问题"></a>Minimal Gap 问题</h3><p>给定若干个实数（未排序），求这些实数中间隔最小的两个实数的间隔是多少。直观的想法是排序然后线性判定，复杂度是 $O(n\log n)$，实际上这也是最优的解法，因为 Element Uniqueness 问题可以归约到这个问题。</p><h3 id="Maximal-Gap-问题"><a href="#Maximal-Gap-问题" class="headerlink" title="Maximal Gap 问题"></a>Maximal Gap 问题</h3><p>给定若干个实数（未排序），求这些实数中间隔最大的两个实数的间隔是多少（这两个实数中不能再含有其它实数）。与上面的问题不同，通过使用哈希可以让这个问题的复杂度仅为 $O(n)$。</p><h3 id="判定两个线段是否相交"><a href="#判定两个线段是否相交" class="headerlink" title="判定两个线段是否相交"></a>判定两个线段是否相交</h3><p>给定平面上的两个线段，它们是相交的当且仅当对于任意个线段，另一个线段都的两个端点都在这个线段的异侧。因此只要运行四次 <code>ToLeftTest</code> 就可以判定两个线段是否相交。注意之运行两次是不够的，因为可能会遇到一条线段的延长线交于另一条线段，但是线段本身不相交的情况。</p><h2 id="区间相交判定"><a href="#区间相交判定" class="headerlink" title="区间相交判定"></a>区间相交判定</h2><p>给定一些一维的区间，判定它们两两之间是否有交。暴力做法是 $O(n^2)$ 的，但是这个不是下界。</p><p>将所有区间的左端染成一种颜色，再将右端染成另一种颜色，然后对所有的端点进行排序。排序完成后，从左到右检查各个点的颜色，如果出现了连续两个点颜色一样的情况说明某两个区间相交了，否则它们必定没有相交。（因为没有出现这种情况一定是 LRLRLRLR 这样的模式，对于第一个 R 它只能和第一个 L 配对，如此递推下去即可。）复杂度取决于排序复杂度，为 $O(n\log n)​$。</p><p>Integer Element Uniqueness 可以归约到这个问题，所以最好只能做到 $O(n\log n)$。</p><h2 id="线段相交判定与枚举"><a href="#线段相交判定与枚举" class="headerlink" title="线段相交判定与枚举"></a>线段相交判定与枚举</h2><p>这里只考虑线段相交枚举的情形。在给定 $n$ 条线段后，枚举出所有相交线段对的时间为 $O(n\log n + I)$，其中 $I$ 是交点的个数（输出敏感性）。Element Uniqueness 问题可以归约到这个问题，所以线段相交判定的时间复杂度最好只能做到 $O(n\log n)$，但是 $I$ 最高可以到 $\Theta(n^2)$，所以综合时间复杂度最好是 $O(n\log n + I)$。</p><h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3><p>逐对枚举线段，检查相交情况。时间复杂度 $O(n^2)$。</p><h3 id="Bentley–Ottmann-算法（BO-算法）"><a href="#Bentley–Ottmann-算法（BO-算法）" class="headerlink" title="Bentley–Ottmann 算法（BO 算法）"></a>Bentley–Ottmann 算法（BO 算法）</h3><p>$O(n\log n + I)$ 是最好的情况，但是实现起来较复杂。BO 算法是一个简单的但是性能足够好的算法。</p><p>设想所有的线段已经给定，然后使用一条竖直的扫描线从左到右扫描这些线段来判定交点。在扫描的过程中有些地方是比较重要的，分别是：</p><ul><li>某条线段的左端点位于此竖直线上（线段开始）</li><li>某条线段的右端点位于此竖直线上（线段结束）</li><li>某两条线段的交点位于此竖直线上（线段相交）</li></ul><p>实际上只有这些地方是重要的，其它所有地方都不会对算法产生任何本质的影响，因此扫描实际上只用扫描这么多个有限点即可，这些点的数量是 $O(n^2 + I)$。</p><p>不过实际中我们只知道线段的左端点和右端点，线段的交点是不知道的，需要在扫描的过程中求出。可以注意到这样一个事实：每在扫描线处于某个地方时，它会和若干条线段相交，此时这些线段可以依照和扫描线的交点的高度进行排序。每次两个线段的交点出现前的一个小区间中，这两个线段在按照与扫描线交点排序的时候是相邻的。根据这个性质，我们就可以描述 BO 算法了。</p><p>首先需要一个队列用来维护那些需要让扫描线停下来重点检查的地方，因为交点未知，所以需要能够动态地插入元素到这个队列中，因此应该是一个优先队列。然后需要一个词典维护扫描线在某处时，按照相交纵坐标排序的那些线段，考虑到有时候会在某个位置插入一条线（线段开始），或者发生两条线段的调换（线段相交），这个结构应该使用有序的 map 结构，比如平衡二叉搜索树。</p><p>算法描述如下：</p><ol><li>使用所有线段的左端点和右端点初始化优先队列（横坐标越小的，越靠左）</li><li>只要优先队列不为空：<ol><li>从优先队列中取出第一个元素</li><li>找到与这个元素关联的线段，在扫描线状态中更新相关的信息，具体地：<ul><li>如果是线段开始，则将对应线段插入扫描线状态中</li><li>如果是线段结束，则将对应线段移出扫描线状态</li><li>如果是线段相交，则交换两条对应线段的位置</li></ul></li><li>当完成了上一步之后，某些线段的相邻关系发生了改变。只要是原来不相邻，而现在相邻了的，都做一下这两条线段的相交检测。如果相交了，就计算出交点，并将这个交点加入到优先队列中</li></ol></li><li>此时所有相交情况已检测到</li></ol><p>复杂度的分析：优先队列的最大需要处理的量是 $O(n\log n + I)$，每次处理耗费 $O(\log S)$ 的时间，其中 $S$ 是优先队列的大小。而 $S \leq n\log n + I$，于是 $O(\log S) = O(\log(n\log n + I)) = O(\log(n\log n + n^2)) = O(\log n)$。平衡二叉树的每一步的操作总是 $O(\log n)$ 的。总的来看，时间复杂度是 $O((n\log n + I)\log n)$。在某些极端的情况下这个算法可能比暴力算法还要差，但是这种情况一般不会发生；当交点数比较少的时候，算法的性能还不错。</p><h2 id="凸多边形相交判定——Dobkin-and-Kirkpatrick-算法"><a href="#凸多边形相交判定——Dobkin-and-Kirkpatrick-算法" class="headerlink" title="凸多边形相交判定——Dobkin and Kirkpatrick 算法"></a>凸多边形相交判定——Dobkin and Kirkpatrick 算法</h2><p>Dobkin and Kirkpatrick 算法能在 $O(\log n)$ 时间内判定给定的两个凸多边形是否有相交。这个算法的论文在 <a href="https://www.sciencedirect.com/science/article/pii/0304397582901207" target="_blank" rel="noopener">这里</a>。如果一个多边形严格位于另一个多边形内部，也认为它们相交了。</p><p>这个算法思路可以描述如下：对于任意的一个凸多边形，总是可以找到它的最上的点和最下的点。这两个点将多边形的所有边分成两部分，一部分向在左边并向左凸，另一部分在右边并向右凸，分别将其成为 <em>左链</em> 和 <em>右链</em>。对于左链，从其最高点和最低点向右引两条射线；对于右链，从其最高点和最低点向左引两条射线；仍保持左链和右链的名称不变。在后面的叙述中，所有的左链和右链都是包含两个无穷射线的。</p><p>对于任意给定的两个凸多边形 $P_1$ 和 $P_2$，它们相交当且仅当 $P_1$ 的左链和 $P_2$ 的右链相交，并且 $P_1$ 的右链和 $P_2$ 的左链相交。其它所有的情况都是两个多边形不相交的，因此如果有算法对于给定的一条左链和一条右链判定它们是否有交点的话就能解决凸多边形相交判定的问题。</p><p>这个算法采取减而治之的策略。首先先找到左链和右链两者中间的那一根线段，然后根据这两条线段的位置关系决定下一步：</p><ul><li>如果这两条线段本身就是相交的，那么两条链自然也是相交的；</li><li>如果两条线段自身不相交，那么就求出它们的交点。根据两条线段和交点的位置关系，可以将两条链中的一条或者两条去掉一半（就是说可以安全地忽略掉这中间的一半，而不影响最后结论），去掉之后再补上缺失的射线，随后递归地进行两条链的相交判定。</li></ul><p>上面的内容只是对思路的描述。经过这样的处理之后问题规模至多为原来的 $\frac{3}{4}$，于是复杂度应为 $T(n) = T(\frac{3}{4}n) + O(1) \Rightarrow T(n) = \log n$。在不断缩减问题的规模之后，会退化到比较平凡的情况，这种情况下可以直接求解。</p><p>问题在于如何根据交点和线段的相对位置决定忽略掉哪条链的哪一部分。按照论文的描述，这个事情是这样完成的：</p><p>首先选取两条链的中间的线段，并将它们延长。它们会交于一点（不幸平行的话，换一条线段）。假设左链选出的中间线段是左上右下倾斜的，右链选出的中间线段是右上左下倾斜的，那么延长线会将平面划分成是个区域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">\                       /</span><br><span class="line"> \                     /</span><br><span class="line">  \                   /</span><br><span class="line">   \                 /</span><br><span class="line">    \       LR      /</span><br><span class="line">     \             /</span><br><span class="line">      \           /</span><br><span class="line">       \         /</span><br><span class="line">        \       /</span><br><span class="line">         \     /</span><br><span class="line">          \   /</span><br><span class="line">           \ /</span><br><span class="line">    R       /      L</span><br><span class="line">           / \</span><br><span class="line">          /   \</span><br><span class="line">         /     \</span><br><span class="line">        /       \</span><br><span class="line">       /         \</span><br><span class="line">      /           \</span><br><span class="line">     /             \</span><br><span class="line">    /               \</span><br><span class="line">   /      Empty      \</span><br><span class="line">  /                   \</span><br><span class="line"> /                     \</span><br><span class="line">/                       \</span><br></pre></td></tr></table></figure><p>（这张图和论文中的记号不一样，左右和它定义是反的。）其中，左链只可能在 L 区和 LR 区，右链只可能出现在 R 区和 LR 区，因此两个链是否相交只取决于它们在 LR 区中是否相交。将左链选出的中间线段记作 $l$，右链选出的中间线段记作 $r$，左链中保留 $l$ 上端点以上的部分，并补充从 $l$ 上端点开始向右的射线，将这个新的左链记作 $L&#39;$，同理得到 $R&#39;$。</p><ul><li>如果 $l$ 上端点不在 LR 区中，那么左链与右链相交当且仅当 $L&#39;$ 与右链相交；</li><li>如果 $r$ 上端点不在 LR 区中，那么左链与右链相交当且仅当 $R&#39;$ 与左链相交；</li><li>如果 $l,r$ 的 <strong>两个端点</strong> 都在 LR 区中，但是 $r$ 下端点比 $l$ 下端点要低，那么左链与右链相交当且仅当左链与 $R&#39;$ 和 $r$ 并起来之后的链相交，这里的“并”会去掉中间补充的射线。</li></ul><p>这样就能每次稳定地去掉一部分了。</p><h2 id="凸多边形相交区域构造"><a href="#凸多边形相交区域构造" class="headerlink" title="凸多边形相交区域构造"></a>凸多边形相交区域构造</h2><p>给定两个凸多边形，如何构造出它们相交的部分？按照凸性对交运算的封闭性，相交部分应该也是凸的。</p><h3 id="边追赶算法"><a href="#边追赶算法" class="headerlink" title="边追赶算法"></a>边追赶算法</h3><p>边追赶算法首先从两个多边形中取出两条边，然后让这两条边沿着多边形的某个方向前进，相互追赶。边的前进指的是让这条边的后继替代当前这条边成为正在研究的边。一个直观的算法描述如下：</p><p>先找到两条已经相交的边，让它们成为正在研究的边。让其中一条边前进，直到与另一条正在研究的边相交；此时让另一条正在研究的边前进，直到与之前正在研究的边相交。如此交替进行，直到找到所有的交点。</p><p>然而实际上具体要前进哪一条边貌似没这么简单……具体说来要根据两条边的末尾的端点在两条边的左右侧的信息以及两条边的叉乘在纸面内还是纸面外这两个信息决定具体推进哪一条边。</p><h3 id="扫描线算法"><a href="#扫描线算法" class="headerlink" title="扫描线算法"></a>扫描线算法</h3><p>使用与之前类似的扫描线的算法也能解决这个问题。本质上我们是要找到所有线段的交点，使用扫描线时问题可以大幅简化，这是因为一个凸多边形和一条直线最多只能有 2 个交点，所以同一时刻扫描线只会和四个线段有交。另外优先队列也可以省掉（然而我并不知道是怎么做到的，似乎只用维持几个事件点就可以了？），每处理一个交点只要 $O(1)$ 的时间。</p><hr><p>以上两个算法的时间复杂度都是 $O(m + n)$ 的，其中 $m$ 和 $n$ 分别是两个多边形的边数。</p><h2 id="半平面求交问题"><a href="#半平面求交问题" class="headerlink" title="半平面求交问题"></a>半平面求交问题</h2><p>给定了若干个半平面，如何求出它们的交？排序问题可以归约到这个问题上，所以这个问题的复杂度最好只能做到 $O(n\log n)$。这个问题的求解可以使用分治来做，即先求出两个一半的问题然后求这两个广义凸多边形的交（广义凸多边形指某条边可先外无限延伸，两个广义凸多边形的交可以使用前述算法得出）。复杂度是 $T(n) = 2T(\frac{n}{2}) + O(n)$ 即 $T(n) = O(n\log n)$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算几何学习笔记 1</title>
      <link href="/2018/08/31/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2018/08/31/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算几何学习笔记——平面凸包问题"><a href="#计算几何学习笔记——平面凸包问题" class="headerlink" title="计算几何学习笔记——平面凸包问题"></a>计算几何学习笔记——平面凸包问题</h1><p>基本来自学堂在线上的 <a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+70240183x_1+sp/about" target="_blank" rel="noopener">计算几何慕课</a>。这一篇的内容是平面凸包问题。</p><h2 id="基础算法和理论"><a href="#基础算法和理论" class="headerlink" title="基础算法和理论"></a>基础算法和理论</h2><h3 id="判定平面上一个点在有向直线的左边还是右边（ToLeftTest）"><a href="#判定平面上一个点在有向直线的左边还是右边（ToLeftTest）" class="headerlink" title="判定平面上一个点在有向直线的左边还是右边（ToLeftTest）"></a>判定平面上一个点在有向直线的左边还是右边（<code>ToLeftTest</code>）</h3><p>使用矢量叉乘，如果有向直线的向量为 $\overrightarrow{AB}$，要判定的点是 $C$，则可以通过 $\overrightarrow{AB}\times\overrightarrow{AC}$ 的竖坐标符号来确定 $C$ 在 $\overrightarrow{AB}$ 的哪一侧。这个叉乘可以写成 $\left|\begin{array}{ccc}<br>\vec i &amp; \vec j &amp; \vec k \\<br>x_B - x_A &amp; y_B - y_A &amp; z_B - z_A \\<br>x_C - x_A &amp; y_C - y_A &amp; z_C - z_A \\<br>\end{array}\right|$，但目前只关心其结果竖坐标的值，并且知道 $z_A = z_B = z_C = 0$，即只关心 $\left|\begin{array}{ccc}<br>0 &amp; 0 &amp; 1 \\<br>x_B - x_A &amp; y_B - y_A &amp; 0 \\<br>x_C - x_A &amp; y_C - y_A &amp; 0 \\<br>\end{array}\right| = \left|\begin{array}{cc}<br>x_B - x_A &amp; y_B - y_A \\<br>x_C - x_A &amp; y_C - y_A \\<br>\end{array}\right| = \left|\begin{array}{ccc}<br>x_A &amp; y_A &amp; 1 \\<br>x_B &amp; y_B &amp; 1 \\<br>x_C &amp; y_C &amp; 1 \\<br>\end{array}\right|$ 这个行列式。如果这个行列式为正表示 $C$ 在 $\overrightarrow{AB}$ 坐标，反之在右边；如果为零，三点共线。</p><h3 id="判定平面上一个点是否在给定的三角形中（InTriangleTest）"><a href="#判定平面上一个点是否在给定的三角形中（InTriangleTest）" class="headerlink" title="判定平面上一个点是否在给定的三角形中（InTriangleTest）"></a>判定平面上一个点是否在给定的三角形中（<code>InTriangleTest</code>）</h3><p>连续三次调用 <code>ToLeftTest</code>，如果上次三次返回的结果都相同则表示在其中，否则不在其中。这种情况下，三条边的调用顺序可以是任意的。</p><h3 id="判定平面上一个点是否在给定的凸多边形中（InConvexPolygonTest）"><a href="#判定平面上一个点是否在给定的凸多边形中（InConvexPolygonTest）" class="headerlink" title="判定平面上一个点是否在给定的凸多边形中（InConvexPolygonTest）"></a>判定平面上一个点是否在给定的凸多边形中（<code>InConvexPolygonTest</code>）</h3><p>思路和 <code>InTriangleTest</code> 类似，如果是凸 n 边形就连续调用 n 次 <code>ToLeftTest</code>，看每次调用的结果是不是都是相同的。</p><h2 id="极点算法"><a href="#极点算法" class="headerlink" title="极点算法"></a>极点算法</h2><p>构成凸包的顶点称作极点。极点算法基于这样的事实：所有的极点都满足一个性质，即可以找到经过这个极点的一条直线，使所有的点都位于这条直线的同侧。一个等价的描述是，任取三个点围成一个三角形，如果某个点在这个三角形内部，则这个点必然不是极点。</p><p>极点算法操作是：</p><ol><li>将所有点标记为潜在极点</li><li>遍历所有的三角形，对于每一个三角形：<ol><li>遍历所有不构成这个三角形的潜在极点</li><li>判断潜在极点是否在这个三角形内，如果在，移除其潜在极点身份</li></ol></li><li>所有剩下的潜在极点即为真实极点</li></ol><p>遍历三角形的复杂度是 $O(n^3)$ 的，整个算法的复杂度是 $O(n^4)$ 的。</p><h2 id="极边算法"><a href="#极边算法" class="headerlink" title="极边算法"></a>极边算法</h2><p>构成凸包的边称作极边。极边算法基于这样的事实：所有的点都位于某条边的同侧，当且仅当这条边为极边。</p><p>极边算法的操作是：</p><ol><li>将所有的点标记为潜在非极点</li><li>遍历两两点之间的所有连线，对于每一条这样的连线：<ol><li>遍历每个不属于这两个端点之外的点，判定在这条连线的左边还是右边</li><li>如果在上一步中，所有的结果都是相同的，则表明这条连线是极边，选取的两个端点是极点，将它们标记</li></ol></li><li>所有被标记为极点的点即为真实极点</li></ol><p>遍历连线的复杂度是 $O(n^2)$，整体复杂度 $O(n^3)$。</p><h2 id="增量扩展极点算法"><a href="#增量扩展极点算法" class="headerlink" title="增量扩展极点算法"></a>增量扩展极点算法</h2><p>这个算法通过不断修改已知极点集合来得到最后的真实极点集合，策略是减而治之。</p><p>给定了若干个点后，如果已经知道了其中前 $n$ 个点对应的凸包 $C$，那么前 $n + 1$ 个点对应的凸包可以在 $C$ 的基础上得出。首先要知道第 $n$ 个点 $P$ 是在 $C$ 内还是在 $C$ 外；如果在 $C$ 外则表示要修改凸包，即修改极点集，要知道需要删去哪些点，增加哪些点。这两种情况可以统一处理。增量式修改凸包的过程中新增的极边称作切边，切边中处于原始凸包上的极点成为切点。</p><p>凸包的边总是环状的，由此可以将当前的极点按照逆时针方向排序（这个操作不用实际进行，因为可以维护这个序列）。这样对于每个点都有一个前驱，一个后继。研究 $P$ 和 $C$ 的关系的时候，只要对极点序列中每个极点 $Q$，以及其前驱 $Q_p$ 和后继 $Q_n$ 进行如下检测：连接 $P,Q$ 得到 $PQ$（注意有方向），判定 $Q_p$ 和 $Q_n$ 在 $PQ$ 的左边还是右边，不考虑退化到共线的情况，可能的组合只有四种：</p><ul><li>左-左：$Q$ 点是一个切点（保留）</li><li>左-右：$Q$ 点应该被抛弃</li><li>右-左：$Q$ 点应该被保留</li><li>右-右：$Q$ 点是一个切点（保留）</li></ul><p>增量扩增极点的算法可以描述如下：初始时构建一个简单的凸包，随后对于每个没有被考虑过的点应用上面判定过程。如果判定过程中没有检测到切点，表明这个点处于已知凸包内部，可以继续考虑下一个；如果出现的切点，则根据判定知道的保留与舍弃情况，更新极点集合即可。</p><p>每扩增一个新的点复杂度都是和当前凸包的大小有关的，不会超过 $O(n)$，总体复杂度为 $O(n^2)$。</p><h2 id="增量扩展极边算法"><a href="#增量扩展极边算法" class="headerlink" title="增量扩展极边算法"></a>增量扩展极边算法</h2><p>这个算法又称 Jarvis March 算法，同属于减而治之。它的思路是不断扩展出新的极边（真实的）直到形成闭环。首先确定一个真实的极点，然后沿着逆时针的方向，找到下一个极点，连成极边，再找到下一个极点，连成极边。以此类推，直到最后形成闭环。</p><p>第一件事是要找到一个极点，实际上将这些点投影到一条直线上后，位于最外端的点总是极点。如果投影后有重合，则将这些某方向上投影重合的点投影到正交的方向上，此时位于外端的点必然是极点了。依据这种搞法，可以找到初始的极点。</p><p>第二件事是已知一个极点，要找到下一个极点。为此，遍历除了自己（记作 $P$）之外的所有点，我们希望找到一个“右转角度最大”的点（注意此时在逆时针寻找），设当前的候选点是 $Q$，如果找到一个点发现它在 $PQ$ 右边，则用它取代 $Q$，一直做下去，知道所有点都遍历完，此时的 $Q$ 就是下一个极点。如果这个点和最开始找到的初始极点相同，这产生闭环，算法结束。</p><p>每扩展一条极边，复杂度为 $O(n)$，设最后的凸包一共有 $m$ 条极边，这总的复杂度是 $O(mn)$。这个复杂度具有输出敏感性，因此大多数情况下会比 $O(n^2)$ 性能要好。</p><h2 id="Graham-Scan-算法"><a href="#Graham-Scan-算法" class="headerlink" title="Graham Scan 算法"></a>Graham Scan 算法</h2><p>平面凸包的问题复杂度存在下界。排序问题可以归约到平面凸包的问题上，因此平面图包问题的复杂度最好只能做到 $O(n\log n)$。Graham Scan 就是这样的复杂度的算法。</p><p>Graham 算法的过程如下：首先选择一个极点（选取方式同前），然后选取一个极轴，并保证这个极轴是一条极边，这一步需要线性的时间。然后对于所有的点，按照对这个极点的极角从小到大进行排序，这一步需要 $O(n\log n)$ 的时间，由于极轴的选取，所有的极角应该都是小于 $\pi$ 的。</p><p>现在已经获得了一个顶点的顺序，然后维护一个潜在的极点序列（按照逆时针方向排布的），初始情况下这个序列中只有两个元素：初始的极点和极角最小的那个点。然后：</p><ol><li>从排好序的顶点中取出第一个；</li><li>查看选出的顶点是否在潜在极点序列中的倒数第二个、最后一个连成的有向直线的左边。如果是，则将其加入潜在极点序列中；否则，不断退出潜在极点序列中的最后一个元素，直到前述性质符合。</li></ol><p>当没有可取的顶点时，潜在的极点序列即为按照逆时针方向排布的真实极点序列。尽管看起来算法的复杂度是 $O(n^2)$ 的，因为可能要退出元素，但是可以证明最后总的复杂度依然是线性的。所以 Graham 算法复杂度主要在排序上，整体复杂度 $O(n \log n)$。</p><p>Graham 算法有一个变种。Graham 的瓶颈在于排序，如果给定的数据已经按照某个方向排序好了的话，就可以做到线性的时间复杂度。不妨假定说给的数据已经按照 x 轴坐标排好了，那么在 +y 轴无限远的地方假定出一个点来，将这个点与给定的所有顶点连线，应该会得到一系列的向上的平行线。因为数据已经按照 x 轴排好序了，所以可以认为它们按对虚拟点的极角排好序了。只要跑一遍 Graham 算法就能得到一个包含了上虚拟点的凸包，去掉上虚拟点后得到的实际是所谓的“下凸”。类似地，在 -y 轴无穷远处假定一个下虚拟点，干一样的事情，就能得到“上凸”。上凸和下凸合并起来就是最后的凸包。</p><h2 id="基于分治的凸包算法——合并线性不可分凸包"><a href="#基于分治的凸包算法——合并线性不可分凸包" class="headerlink" title="基于分治的凸包算法——合并线性不可分凸包"></a>基于分治的凸包算法——合并线性不可分凸包</h2><p>凸包问题可以使用基于分治的算法求解。设想要求的是一些点的凸包，如果将这些点随机分成两组，各自求出自己的凸包然后合并成大凸包就可以了。设要合并的两个凸包分别为 $C_1$ 和 $C_2$，并且有它们按照逆时针方向排列的极点序列。首先在 $C_1$ 内部随机选出一个点 $P$，这个点的可以通过在 $C_1$ 中随机找出一个由极点构成的三角形取重心得到，用时 $O(1)$。然后判断一下 $P$ 点是否在 $C_2$ 中。</p><p>如果 $P$ 在 $C_2$ 中，那么使用二路归并将两个按照逆时针方向排列的极点序列归并起来即可，归并完成后使用 Graham 生成新的凸包。这种情况下时间为 $O(n + m)$，其中 $n$ 是 $C_1$ 的极点数，$m$ 是 $C_2$ 的极点数。</p><p>如果 $P$ 不在 $C_2$ 中，那么问题就是 $C_2$ 中的已经排好序的极点对 $P$ 来说没有排好序，此时模仿“增量扩展极点算法”，找到它对 $C_2$ 的切线并割掉一定不会出现在追踪的凸包中的那些点，此时剩下的点对于 $P$ 来说就是排好序的了，仿照上面的情况生成凸包即可。时间也是线性的。</p><p>总时间满足 $T(n) = 2T(\frac{n}{2}) + \Theta(n)$，于是 $T(n) = O(n\log n)$。</p><h2 id="基于分治的凸包算法——合并线性可分凸包"><a href="#基于分治的凸包算法——合并线性可分凸包" class="headerlink" title="基于分治的凸包算法——合并线性可分凸包"></a>基于分治的凸包算法——合并线性可分凸包</h2><p>除了上面一种分治方法外还有一种分治方法，两种方法的差异在于如何进行分割，对应地，合并的时候的策略不同。如果要合并的两个凸包是线性可分的，那么合并时有一个简单的方法。实际操作时，不妨先对所有点按照 x 轴坐标进行排序（如果已经排好了就可以省略这一步），然后求出左一半的凸包和右一半的凸包（递归进行），另外还需要维护每个凸包的最左点和最右点。然后只要合并这两个小凸包即可。</p><p>两个小凸包应该存在两条公切线，一条在上一条在下。可以如下求解：</p><ol><li>将左边小凸包的最右点和右边小凸包的最左点连接起来，称这个连线为“桥”。</li><li>以桥的左端为轴，不断提升右边，直到检测到切线。（仿照增量扩展极点算法中的检测思路）</li><li>再以桥的右端为轴，不断提升左边，直到检测到切线。（仿照增量扩展极点算法中的检测思路）</li><li>反复重复以上两步，直到两边都不能提升。此时的桥即为上公切线。类似地，可以求出下公切线。</li></ol><p>去掉位于公切线中的点即得到新的凸包的极点序列。</p><hr><p>总结下来，平面凸包问题的复杂度最好是 $O(n\log n)$，如果有一些特殊情况的话还可以进一步降到 $O(n)$。有些算法结合了上面一些算法的优点，例如有一个自适应的算法可以在保证性能不低于 Graham Scan 的同时还存在对输出的敏感性，在好的情况下能像 Jarvis March 一样快。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS184.1X 计算机图形学学习笔记 (3)</title>
      <link href="/2018/08/28/CS184-1X-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/"/>
      <url>/2018/08/28/CS184-1X-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<h1 id="CS184-1X-计算机图形学学习笔记-3"><a href="#CS184-1X-计算机图形学学习笔记-3" class="headerlink" title="CS184.1X 计算机图形学学习笔记 (3)"></a>CS184.1X 计算机图形学学习笔记 (3)</h1><p>光线追踪及其实现。</p><h2 id="光线追踪算法"><a href="#光线追踪算法" class="headerlink" title="光线追踪算法"></a>光线追踪算法</h2><p>如果需要显示一些物体（比如三角形），可以使用光栅化的算法来显示：对于每个物体计算出该物体应该显示的位置，然后利用深度缓冲等手段来判断哪个物体显示在最前面，最后完成渲染。这是现在主流的实时渲染手段，不过因为其原理导致不同物体之间的相互影响比较难表现出来。</p><p>另一种算法是光线追踪，它的思路不是遍历物体而是遍历像素。对于每个要显示的像素，利用光路可逆的性质从摄像机向这个像素发出一条光线，这条光线打到物体上后根据物体的相关物理性质决定出光线的颜色，如有必要，对反射光线继续进行追踪，最后叠加它们的颜色。光线追踪算法易于实现，能够容易地表现倒影、阴影等效果（所谓的全局光照），但是效率不如光栅化，一般拿来做离线渲染。</p><p>这里写一个简单的光线追踪的纯 CSharp 实现，主要参考了 <a href="http://www.cnblogs.com/miloyip/archive/2010/03/29/1698953.html" target="_blank" rel="noopener">光线追踪入门</a> 这篇博客。</p><a id="more"></a><h2 id="光线追踪的原理"><a href="#光线追踪的原理" class="headerlink" title="光线追踪的原理"></a>光线追踪的原理</h2><p>光线追踪中没有 OpenGL 那么多的坐标系，只用一个世界坐标系就可以了。在这个世界中摆好要渲染的物体，然后就可以开始渲染了。因为是要得到一张图片，可以认为我们的眼睛是通过一个“窗口”在观察这个世界，这个窗口在世界坐标系中的位置是可以确定的。如果将这个窗口划分成细密的网格，从眼睛向每个网孔中发出一条光线，跟踪这条光线得到它的颜色，将这个颜色作为网孔的颜色。当所有的网孔都具有一个颜色之后，这个窗口的图像也就确定了，这就是最后得到的图像。另外从发射要追踪的光线的算法可以知道这样的到的正是透视投影。</p><p>现在的问题就是如何确定一条光线的颜色。光线是射线，可以使用起点和方向两个参数来进行描述。对于每一个基础的图元或者结构，它们都应该具有以下的特点：</p><ul><li>能用较少的参数描述</li><li>对于给定的一条光线，能判断这根光线是否与其相交</li><li>对于给定的一条与其相交的光线，能给出交点的坐标和法线</li></ul><p>满足这几条特点之后就很容易计算出一条跟定的光线与该结构相交的结果。对于任意一条光线，遍历所有的基础图元，找到与它相交的最近的那个点，将这个点的颜色作为该光线的颜色（如果始终没有交点自然是黑色的）。这个点的颜色的确定和之前使用 OpenGL 中冯氏光照模型的算法类似，不过有一些改进：</p><ul><li>将这个最近的交点和所有的光源做一次遮挡的检测，如果被挡住就认为该光源对该交点的颜色没有影响（假装这个光源不存在，以此实现阴影效果），否则按照光照模型计算出光照（环境光、漫反射光、镜面反射光）。</li><li>每个图元的材质中会带有一个反射值，描述这个物体对光的反射程度，如果有一定的反射的话，就通过法线和探测光线的方向确定出新的探测光线（即反射的探测光线），再次应用这个算法得到新的探测光线的颜色，将两者混合即可得到最后的实际颜色。</li></ul><p>从第二条改进中可以看到光线追踪是一个递归的过程，实际中为了终止这个递归可以设计最大的递归层数，或者在某次反射探测光线对最后结果几乎没有影响时停下。</p><h2 id="实现过程的记录"><a href="#实现过程的记录" class="headerlink" title="实现过程的记录"></a>实现过程的记录</h2><h3 id="创建光线"><a href="#创建光线" class="headerlink" title="创建光线"></a>创建光线</h3><p>光线（本质是射线）就是一个点以及一个方向。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Ray</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ray</span>(<span class="params">Vector3 origin, Vector3 direction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Origin = origin;</span><br><span class="line">        Direction = direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 Origin &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Vector3 Direction &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建材质"><a href="#创建材质" class="headerlink" title="创建材质"></a>创建材质</h3><p>材质记录了一个物体的光学上的一些属性，包括环境光颜色、漫反射颜色、镜面反射颜色、自发光颜色、光泽度和反光度。处于简单考虑只做了纯色的材质。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Material</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Material</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        Color ambient, Color diffuse, Color specular, Color emission,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> shininess, <span class="keyword">float</span> reflectivity</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Ambient = ambient;</span><br><span class="line">        Diffuse = diffuse;</span><br><span class="line">        Specular = specular;</span><br><span class="line">        Emission = emission;</span><br><span class="line">        Shininess = shininess;</span><br><span class="line">        Reflectivity = reflectivity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Color Ambient &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Color Diffuse &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Color Specular &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Color Emission &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> Shininess &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> Reflectivity &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建光照"><a href="#创建光照" class="headerlink" title="创建光照"></a>创建光照</h3><p>这是一个抽象类，主要是为不同类型的光照提供一个统一的接口。光照本身具有漫反射颜色和镜面反射颜色两个属性（与材质的相关颜色进行调制），同时不同的光照对于衰减的计算和是否存在光照的判定都不尽相同；此外每个光照应该能对给定的点计算出光线的方向，方便计算反射颜色。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Light</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Light</span>(<span class="params">Color diffuse, Color specular</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Diffuse = diffuse;</span><br><span class="line">        Specular = specular;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Color Diffuse &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Color Specular &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">HasLightOn</span>(<span class="params">Vector3 point, World world</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">GetAttenuation</span>(<span class="params">Vector3 point</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Vector3 <span class="title">GetLightVector</span>(<span class="params">Vector3 point</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个基础上实现了方向光、点光以及聚光。后面两种光具有独特的衰减属性。</p><h3 id="创建实体"><a href="#创建实体" class="headerlink" title="创建实体"></a>创建实体</h3><p>实体是需要被渲染的物体的抽象。它的一个重要函数就是根据给定的一条光线，判定是否相交，如果相交要能得到交点处的信息。实体都具有一个材质属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entity</span>(<span class="params">Material entityMaterial</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EntityMaterial = entityMaterial;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Material EntityMaterial &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> HitResult <span class="title">GetHitResult</span>(<span class="params">Ray ray</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HitResult</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HitResult</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Hit = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HitResult</span>(<span class="params">Vector3 hitPoint, Vector3 hitNorm</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Hit = <span class="literal">true</span>;</span><br><span class="line">            HitPoint = hitPoint;</span><br><span class="line">            HitNorm = hitNorm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">bool</span> Hit &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Vector3 HitPoint &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Vector3 HitNorm &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>球是一个具体的实体，它可以被简单实现如下。求解交点坐标只用解一个二次方程即可，需要注意的是对于使用参数方程描述的光线来说，只有参数大于零的时候才是真正的交点。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SphereEntity</span> : <span class="title">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SphereEntity</span>(<span class="params">Material entityMaterial, Vector3 center, <span class="keyword">float</span> radius</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">entityMaterial</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Center = center;</span><br><span class="line">        Radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Vector3 Center &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> Radius &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> HitResult <span class="title">GetHitResult</span>(<span class="params">Ray ray</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> a = ray.Direction.LengthSquared();</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">2</span> * Vector3.Dot(ray.Origin - Center, ray.Direction);</span><br><span class="line">        <span class="keyword">var</span> c = (ray.Origin - Center).LengthSquared() - Math.Pow(Radius, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">var</span> delta = b * b - <span class="number">4</span> * a * c;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> HitResult &#123;Hit = <span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> root1 = (<span class="keyword">float</span>) (-b - Math.Sqrt(delta)) / (<span class="number">2</span> * a);</span><br><span class="line">        <span class="keyword">var</span> root2 = (<span class="keyword">float</span>) (-b + Math.Sqrt(delta)) / (<span class="number">2</span> * a);</span><br><span class="line">        <span class="keyword">var</span> hitPoint1 = ray.Origin + root1 * ray.Direction;</span><br><span class="line">        <span class="keyword">var</span> hitPoint2 = ray.Origin + root2 * ray.Direction;</span><br><span class="line">        <span class="keyword">if</span> (root1 &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HitResult</span><br><span class="line">            &#123;</span><br><span class="line">                Hit = <span class="literal">true</span>,</span><br><span class="line">                HitPoint = hitPoint1,</span><br><span class="line">                HitNorm = Vector3.Normalize(hitPoint1 - Center)</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">if</span> (root2 &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HitResult</span><br><span class="line">            &#123;</span><br><span class="line">                Hit = <span class="literal">true</span>,</span><br><span class="line">                HitPoint = hitPoint2,</span><br><span class="line">                HitNorm = Vector3.Normalize(hitPoint2 - Center)</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HitResult &#123;Hit = <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建世界"><a href="#创建世界" class="headerlink" title="创建世界"></a>创建世界</h3><p>世界负责维护所有的实体以及光源，并且对颜色进行计算。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">World</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> Epsilon = <span class="number">0.0001f</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Entity&gt; Entities &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;Entity&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Light&gt; Lights &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;Light&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是一些用来判定给定射线和线段与实体是否相交的函数，这些函数会在光源的实现中被使用到。这里的做法是遍历所有的实体来调用它们的 <code>GetHitResult</code> 方法，效率比较低。可使用各种空间分割树对空间进行分割，然后用这些光线去测试，这样可以不用遍历所有的实体，如果实体很多的话就可以提高效率。<code>GetHitResult</code> 本身也可以进行这种优化。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsBlockedByEntity</span>(<span class="params">Ray ray</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> entity <span class="keyword">in</span> Entities)</span><br><span class="line">        <span class="keyword">if</span> (entity.GetHitResult(ray).Hit)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsBlockedByEntity</span>(<span class="params">Vector3 pointA, Vector3 pointB</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = pointA;</span><br><span class="line">    <span class="keyword">var</span> direction = pointB - pointA;</span><br><span class="line">    <span class="keyword">var</span> distanceSquared = Vector3.DistanceSquared(pointA, pointB);</span><br><span class="line">    <span class="keyword">var</span> ray = <span class="keyword">new</span> Ray(origin, direction);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> entity <span class="keyword">in</span> Entities)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> hitResult = entity.GetHitResult(ray);</span><br><span class="line">        <span class="keyword">if</span> (hitResult.Hit &amp;&amp; Vector3.DistanceSquared(hitResult.HitPoint, origin) &lt; distanceSquared)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后完成对给定点计算光照颜色的函数。这个函数不考虑反射，单纯使用修改后的 Phong 光照模型进行计算，并且忽略那些没有照到这里的光源。这个函数和 OpenGL 中手动进行计算光照差不多。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Color <span class="title">GetColorOnEntity</span>(<span class="params">Entity.HitResult hitResult, Entity entity, Ray ray</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> emission = entity.EntityMaterial.Emission;</span><br><span class="line">    <span class="keyword">var</span> ambient = entity.EntityMaterial.Ambient;</span><br><span class="line">    <span class="keyword">var</span> finalColor = emission.Add(ambient);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// in case of precision issue</span></span><br><span class="line">    <span class="keyword">var</span> checkPoint = hitResult.HitPoint + Epsilon * hitResult.HitNorm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> light <span class="keyword">in</span> Lights)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!light.HasLightOn(checkPoint, <span class="keyword">this</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> lightVec = light.GetLightVector(hitResult.HitPoint);</span><br><span class="line">        <span class="keyword">var</span> lightReflect = Vector3.Reflect(lightVec, hitResult.HitNorm);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> attenuation = light.GetAttenuation(hitResult.HitPoint);</span><br><span class="line">        <span class="keyword">var</span> diffuse = light.Diffuse.Moderate(entity.EntityMaterial.Diffuse);</span><br><span class="line">        <span class="keyword">var</span> specular = light.Specular.Moderate(entity.EntityMaterial.Specular);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> diffuseCoef =</span><br><span class="line">            Math.Max(Vector3.Dot(-Vector3.Normalize(hitResult.HitNorm), Vector3.Normalize(lightVec)), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">var</span> specularCoef =</span><br><span class="line">            Math.Max(Vector3.Dot(Vector3.Normalize(lightReflect), -Vector3.Normalize(ray.Direction)), <span class="number">0</span>);</span><br><span class="line">        specularCoef = (<span class="keyword">float</span>) Math.Pow(specularCoef, entity.EntityMaterial.Shininess);</span><br><span class="line">        <span class="keyword">var</span> lightColor = diffuse.Multiply(diffuseCoef).Add(specular.Multiply(specularCoef));</span><br><span class="line">        finalColor = finalColor.Add(lightColor.Multiply(attenuation));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> finalColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后完成对于给定的一条光线计算出这条光线应该是什么颜色的函数。这个函数会递归调用自己直到达到最大递归深度。它的思路就是找到最近的交点，使用前面一个函数计算颜色，然后递归一下计算反射的光线的颜色，最后进行调制。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Color <span class="title">GetColor</span>(<span class="params">Ray ray, <span class="keyword">int</span> maxDepth</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxDepth == <span class="number">0</span>) <span class="keyword">return</span> Color.Black;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> minDistanceSquared = <span class="keyword">float</span>.MaxValue;</span><br><span class="line">    Entity.HitResult realHitResult = <span class="literal">null</span>;</span><br><span class="line">    Entity realHitEntity = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> entity <span class="keyword">in</span> Entities)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> hitResult = entity.GetHitResult(ray);</span><br><span class="line">        <span class="keyword">var</span> distanceSquared = Vector3.DistanceSquared(hitResult.HitPoint, ray.Origin);</span><br><span class="line">        <span class="keyword">if</span> (!hitResult.Hit || !(distanceSquared &lt; minDistanceSquared)) <span class="keyword">continue</span>;</span><br><span class="line">        minDistanceSquared = distanceSquared;</span><br><span class="line">        realHitResult = hitResult;</span><br><span class="line">        realHitEntity = entity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (realHitResult == <span class="literal">null</span>) <span class="keyword">return</span> Color.Black;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> baseColor = Color.Black;</span><br><span class="line">    <span class="keyword">var</span> reflectedColor = Color.Black;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (realHitEntity.EntityMaterial.Reflectivity &lt;= <span class="number">1</span> - <span class="keyword">float</span>.Epsilon)</span><br><span class="line">        baseColor = GetColorOnEntity(realHitResult, realHitEntity, ray);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (realHitEntity.EntityMaterial.Reflectivity &gt;= <span class="keyword">float</span>.Epsilon)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// in case of precision issue</span></span><br><span class="line">        <span class="keyword">var</span> direction = Vector3.Reflect(ray.Direction, realHitResult.HitNorm);</span><br><span class="line">        <span class="keyword">var</span> origin = realHitResult.HitPoint + Epsilon * Vector3.Normalize(realHitResult.HitNorm);</span><br><span class="line">        <span class="keyword">var</span> reflectedRay = <span class="keyword">new</span> Ray(origin, direction);</span><br><span class="line"></span><br><span class="line">        reflectedColor = GetColor(reflectedRay, maxDepth - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> baseColor.Multiply(<span class="number">1</span> - realHitEntity.EntityMaterial.Reflectivity).Add(</span><br><span class="line">        reflectedColor.Multiply(realHitEntity.EntityMaterial.Reflectivity)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetColorOnEntity</code> 和 <code>GetColor</code> 都有一个 trick，因为浮点数的精度问题，有时候对于判定是否相交以及交点会出现一些问题。例如一束检测光打在球上，算出来一个交点，现在要知道这个交点和某个光源是否没有东西拦着。数学上，这个交点应该是在球面上的，但是浮点截断后可能进入到了球的内部，这个时候判定相交就会出问题。解决方案是在所有可能出现这种问题的地方都把交点移一下，移动的方向自然是交点处法线的方向。我觉得这个方法看上去不是很优雅，不过行之有效而且简单。</p><p>最后是渲染整张图片：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Image&lt;Rgba32&gt; <span class="title">GetRenderedImage</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 cameraPosition, Vector3 cameraDirection, Vector3 cameraUpside,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">float</span> verticalFov, <span class="keyword">float</span> aspect, <span class="keyword">int</span> verticalResolution</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> screenCenterPosition = cameraPosition + cameraDirection;</span><br><span class="line">    <span class="keyword">var</span> verticalOffset =</span><br><span class="line">        Vector3.Normalize(cameraUpside) * (<span class="keyword">float</span>) Math.Tan(verticalFov / <span class="number">2</span>) * cameraDirection.Length();</span><br><span class="line">    <span class="keyword">var</span> horizontalOffset =</span><br><span class="line">        Vector3.Normalize(Vector3.Cross(cameraDirection, cameraUpside)) * aspect * verticalOffset.Length();</span><br><span class="line">    <span class="keyword">var</span> unitVerticalOffset = verticalOffset / ((<span class="keyword">float</span>) verticalResolution / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> unitHorizontalOffset = horizontalOffset / (verticalResolution * aspect / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> halfWidth = (<span class="keyword">int</span>) (verticalResolution * aspect / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> halfHeight = verticalResolution / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="keyword">new</span> Image&lt;Rgba32&gt;(<span class="number">2</span> * halfWidth, <span class="number">2</span> * halfHeight);</span><br><span class="line"></span><br><span class="line">    Parallel.For(<span class="number">0</span>, ret.Width, w =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> h = <span class="number">0</span>; h &lt; ret.Height; h++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> target = screenCenterPosition +</span><br><span class="line">                         (w - halfWidth) * unitHorizontalOffset + (halfHeight - h) * unitVerticalOffset;</span><br><span class="line">            <span class="keyword">var</span> ray = <span class="keyword">new</span> Ray(cameraPosition, target - cameraPosition);</span><br><span class="line">            <span class="keyword">var</span> color = GetColor(ray, <span class="number">5</span>);</span><br><span class="line">            ret[w, h] = <span class="keyword">new</span> Rgba32(color.R, color.G, color.B);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>按照原理中的搞法，计算出所有的探测光线计算颜色即可。探测光线的起点自然是摄像机，方向也很容易通过摄像机的一些设置来得出。另外光线渲染比较慢，但是它的每根光线的计算都是独立的，很容易并行化。</p><h2 id="实测结果"><a href="#实测结果" class="headerlink" title="实测结果"></a>实测结果</h2><p>最后随便进行了一些设定并搭了一个场景，然后渲染出来一些图玩。因为没有深究更加科学的光线追踪的实现，所以这些图的效果并不是很好（比如它的阴影处理得相当生硬，没有软阴影的效果），不过比起在 OpenGL 中调 API 画出来的那些简单的图还是有意思一些的。</p><img src="/2018/08/28/CS184-1X-计算机图形学学习笔记-3/A1652D181F92478CB0607B5D3490D4CA.png">]]></content>
      
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS184.1X 计算机图形学学习笔记 (2)</title>
      <link href="/2018/08/22/CS184-1X-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2018/08/22/CS184-1X-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="CS184-1X-计算机图形学学习笔记-2"><a href="#CS184-1X-计算机图形学学习笔记-2" class="headerlink" title="CS184.1X 计算机图形学学习笔记 (2)"></a>CS184.1X 计算机图形学学习笔记 (2)</h1><p>主要是 OpenGL 的一些概念。学习资料主要来自 <a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">LearnOpenGL CN</a>。</p><h2 id="各种矩阵"><a href="#各种矩阵" class="headerlink" title="各种矩阵"></a>各种矩阵</h2><ul><li><strong>模型（model）矩阵</strong>：比如一个模型是存放在文件中的，要描述这个模型，每个顶点的坐标应该是一个相对于某个中心的相对坐标。例如一个人体模型中，头的坐标可能是以相对于人体重心的形式给出的。当要将这个人体加载到世界中时需要使用一个矩阵左乘所有模型中的坐标得到世界坐标，这个矩阵就是模型矩阵。</li><li><strong>观察（view）矩阵</strong>：世界空间中，所有的点都是相对于世界的原点给出坐标的；摄像机空间中所有的点都是相对摄像机给出坐标的，即摄像机是原点。OpenGL 中我们希望能通过移动世界的方式来实现移动画面的移动，故使用一个矩阵左乘世界中所有点的坐标得到摄像机空间中的坐标，这个矩阵就是观察矩阵。在 glm 中可以使用 <code>glm::lookAt</code> 生成一个观察矩阵。</li><li><strong>投影（projection）矩阵</strong>：在摄像机空间中并不是所有的东西都会被显示出来，只有位于一个特定的空间体中的物体会被显示（例如，在透视投影中，是一个四棱台）。如果将这个空间体称为“可视区域”，则通过用一个矩阵左乘摄像机空间中的所有物体，可以将“可视区域”归一化成位于中心的所有棱的范围都是 -1 到 1 的小正方体，这个矩阵就是投影矩阵。此后便可以方便地进行显示。在 glm 中可以使用 <code>glm::perspective</code> 生成一个透视投影的投影矩阵，使用 <code>glm::ortho</code> 生成一个正交投影的投影矩阵。在使用了投影矩阵后可以生成与长宽比无关的符合直觉的图像。</li></ul><p>从描述中可以看到正确的应用顺序是：模型矩阵、观察矩阵、投影矩阵。只要使用矩阵乘法连乘起来即可，会得到 <strong>模型观察投影矩阵</strong>。</p><a id="more"></a><h3 id="glm-lookAt-矩阵的推导"><a href="#glm-lookAt-矩阵的推导" class="headerlink" title="glm::lookAt 矩阵的推导"></a><code>glm::lookAt</code> 矩阵的推导</h3><p><code>glm::lookAt</code> 的签名是接受三个 <code>vec3</code> 分别代表摄像机位置 <code>eye</code>、注视点 <code>center</code> 和摄像机上方向 <code>up</code>，返回一个四阶的观察矩阵。这个观察矩阵左乘世界坐标后从世界的原点以 +y 轴为上方向向 -x 轴观察的效果应该和不左乘的情况下从 <code>eye</code> 以 <code>up</code> 为上方向观察 <code>center</code> 的效果相同。为了得到观察矩阵需要将先平移后旋转。显然平移对应的矩阵应该是<br>$<br>\displaystyle{\left[\begin{array}{cccc}<br>1 &amp; 0 &amp; 0 &amp; -\texttt{center.x} \\<br>0 &amp; 1 &amp; 0 &amp; -\texttt{center.y} \\<br>0 &amp; 0 &amp; 1 &amp; -\texttt{center.z} \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{array}\right]}<br>$，至于旋转对应的矩阵，令 $\displaystyle{\vec w = \frac{\texttt{eye} - \texttt{center}}{||\texttt{eye} - \texttt{center}||}, \vec u = \frac{\vec w\times\texttt{up}}{||\vec w\times\texttt{up}||}, \vec v = \vec w \times \vec u}$，则 $\vec u, \vec v, \vec w$ 三者单位正交成右手系，如果旋转矩阵<br>$<br>\displaystyle{\left[\begin{array}{ccc}<br>x_{\vec u} &amp; y_{\vec u} &amp; z_{\vec u} \\<br>x_{\vec v} &amp; y_{\vec v} &amp; z_{\vec v} \\<br>x_{\vec w} &amp; y_{\vec w} &amp; z_{\vec w} \\<br>\end{array}\right]}<br>$<br>作用在它们上面就可以将其旋转到和 $xyz$ 坐标系重合，设想物体和 $uvw$ 系同步转动，这个刚好是希望得到的，于是旋转矩阵应该是<br>$<br>\displaystyle{\left[\begin{array}{cccc}<br>x_{\vec u} &amp; y_{\vec u} &amp; z_{\vec u} &amp; 0\\<br>x_{\vec v} &amp; y_{\vec v} &amp; z_{\vec v} &amp; 0\\<br>x_{\vec w} &amp; y_{\vec w} &amp; z_{\vec w} &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right]}<br>$。</p><p>最后将这两个矩阵乘起来，得到最后的变换矩阵<br>$<br>\displaystyle{<br>\left[\begin{array}{cccc}<br>x_{\vec u} &amp; y_{\vec u} &amp; z_{\vec u} &amp; 0\\<br>x_{\vec v} &amp; y_{\vec v} &amp; z_{\vec v} &amp; 0\\<br>x_{\vec w} &amp; y_{\vec w} &amp; z_{\vec w} &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right]<br>\left[\begin{array}{cccc}<br>1 &amp; 0 &amp; 0 &amp; -\texttt{center.x} \\<br>0 &amp; 1 &amp; 0 &amp; -\texttt{center.y} \\<br>0 &amp; 0 &amp; 1 &amp; -\texttt{center.z} \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{array}\right]<br>}<br>$。</p><h3 id="glm-perspective-矩阵的推导"><a href="#glm-perspective-矩阵的推导" class="headerlink" title="glm::perspective 矩阵的推导"></a><code>glm::perspective</code> 矩阵的推导</h3><p><code>glm::perspective</code> 接受的参数是 <code>fov</code>、<code>aspect</code>、<code>near</code> 以及 <code>far</code>，返回一个透视投影矩阵。这个投影矩阵会把一个平截头体（什么鬼名字，其实是个四棱台，截面为矩形，截面的边平行于 xy 轴，截面平行于 xOy 平面）映射到一个标准的正方体中，这个正方体的中心位于原点，边长都是 2，OpenGL 只显示这个正方体中的内容。原来在摄像机世界中的坐标经过映射后会得到“标准设备坐标”；另外标准设备坐标使用的是左手坐标系，在这个世界中，摄像机位于原点向 +z 轴方向看。下图是摄像机世界中的四棱台。</p><img src="/2018/08/22/CS184-1X-计算机图形学学习笔记-2/snipaste_20180827_211116.png"><p>在摄像机的世界中，<code>fov</code> 为纵向（y 轴）上的视野（上图中为绿色三角形的顶角），<code>aspect</code> 表示四棱台的截面长宽比（上图中为 4:3），<code>near</code> 对应近平面（四棱台的顶面）的 z 坐标，<code>far</code> 对应远平面（底面）的 z 坐标。提供参数的时候 <code>near</code> 和 <code>far</code> 都需要大于零，所以实际上是对应坐标的相反数。</p><p>推导投影矩阵的过程如下。对于摄像机世界中一个用齐次坐标表示的点 $(x, y, z, 1)^T$，被投影矩阵左乘之后会转换到标准设备坐标所在的世界中。投影矩阵应该和 $x, y, z$ 无关。考虑四棱台内部的一个点 $P = (x, y, z)$，连接原点和该点，连线应该会和近平面有一个交点，设坐标为 $A = (x_n, y_n, z_n)$，显然 $z_n = -\texttt{near}$。由相似三角形得 $\displaystyle{\frac{x}{x_n} = \frac{z}{z_n} = \frac{z}{-\texttt{near}}}$，故 $\displaystyle{x_n = -\frac{x\cdot\texttt{near}}{z}}$，同理 $\displaystyle{y_n = -\frac{y\cdot\texttt{near}}{z}}$，于是交点 $A$ 应该是 $\displaystyle{\left(-\frac{x\cdot\texttt{near}}{z}, -\frac{y\cdot\texttt{near}}{z}, -\texttt{near}\right)}$。由于是透视投影，$A$ 在 $OP$ 上，最后投影出来 $P$ 和 $A$ 会重合。对于在近平面右上角的点 $B$，它投影出来之后坐标应该是 $(1, 1, -1)$，而它现在的坐标可以通过参数计算出：</p><script type="math/tex; mode=display">\frac{y_B}{\texttt{near}} = \tan{\frac{\texttt{fov}}{2}}\Rightarrow y_B = \texttt{near} \cdot \tan\frac{\texttt{fov}}{2}</script><script type="math/tex; mode=display">\frac{x_B}{y_B} = \texttt{aspect} \Rightarrow x_B = \texttt{aspect}\cdot \texttt{near} \cdot \tan\frac{\texttt{fov}}{2}</script><p>则现在的坐标应该是 $\displaystyle{(\texttt{aspect}\cdot \texttt{near} \cdot \tan\frac{\texttt{fov}}{2}, \texttt{near} \cdot \tan\frac{\texttt{fov}}{2}, -\texttt{near})}$，它被投影到了 $(1, 1, -1)$，透视投影的时候线段上的分割点的投影是端点投影的线性插值（此处存疑），由此知道 $A$ 会被投影到 $\displaystyle{\left(\frac{-\frac{x\cdot\texttt{near}}{z}}{\texttt{aspect}\cdot \texttt{near} \cdot \tan\frac{\texttt{fov}}{2}}, \frac{-\frac{y\cdot\texttt{near}}{z}}{\texttt{near} \cdot \tan\frac{\texttt{fov}}{2}}, -1\right)}$ 即 $\displaystyle{\left(\frac{-x}{z \cdot \texttt{aspect}\cdot\tan{\frac{\texttt{fov}}{2}}}, \frac{-y}{z \cdot \tan{\frac{\texttt{fov}}{2}}}, -1\right)}$。对于 $P$ 它投影后的坐标前两个分量和 $A$ 相同，设第三个分量为 $z_0$，因此 $P$ 会被投影到 $\displaystyle{\left(\frac{-x}{z \cdot \texttt{aspect}\cdot\tan{\frac{\texttt{fov}}{2}}}, \frac{-y}{z \cdot \tan{\frac{\texttt{fov}}{2}}}, z_0\right)}$。</p><p>现在我们对透视矩阵一无所知，不过它的每个分量都和 $x, y, z$ 无关，应该都是常数。透视矩阵左乘 $P$ 的齐次坐标后得到新的齐次坐标，设第四个分量为 $w_0$，这可以写出变换后的齐次坐标。进一步由 $P$ 的一般性，有</p><script type="math/tex; mode=display">\Large\left[\begin{array}{cccc}\cdot & \cdot & \cdot & \cdot \\\cdot & \cdot & \cdot & \cdot \\\cdot & \cdot & \cdot & \cdot \\\cdot & \cdot & \cdot & \cdot\end{array}\right]\left[\begin{array}{c}x \\y \\z \\1\end{array}\right] =\left[\begin{array}{cccc}w_0\cdot \frac{-x}{z \cdot \texttt{aspect}\cdot\tan{\frac{\texttt{fov}}{2}}} \\w_0\cdot \frac{-y}{z \cdot \tan{\frac{\texttt{fov}}{2}}} \\w_0\cdot z_0 \\w_0\end{array}\right]</script><p>因为透视矩阵是常矩阵，等号右边的每个分量都应该是 $x, y, z$ 的线性组合，而第一、二个分量中分母含有 $z$，因此只可能是 $w_0$ 是 $z$ 的倍数，不妨让 $\displaystyle{w_0 = -z\cdot\tan\frac{\texttt{fov}}{2}}$，此时可以推出透视矩阵的第一、二行以及最后一行，但第三行因为 $z_0$ 未知，可能是 $x, y, z$ 的函数而暂时不能推出，不过从直观上来看，给定若干个具有相同 z 坐标的点，它们投影后的 z 坐标应该还是相同的，所以 $z_0$ 应该只依赖于 $z$，这样的话第三行的前两列应该都是零，设后两列为 $\alpha, \beta$。综上上式可以写为：</p><script type="math/tex; mode=display">\Large\left[\begin{array}{cccc}\frac{1}{\texttt{aspect}} & 0 & 0 & 0 \\0 & 1 & 0 & 0 \\0 & 0 & \alpha & \beta \\0 & 0 & -\tan{\frac{\texttt{fov}}{2}} & 0\end{array}\right]\left[\begin{array}{c}x \\y \\z \\1\end{array}\right] =\left[\begin{array}{cccc}\frac{x}{\texttt{aspect}} \\y \\-z\cdot\tan\frac{\texttt{fov}}{2}\cdot z_0 \\-z\cdot\tan\frac{\texttt{fov}}{2}\end{array}\right]</script><p>求解 $\alpha, \beta$ 即可。我们知道近平面 $z = -\texttt{near}$ 的点映射后的 z 坐标是 $-1$，处于远平面 $z = -\texttt{far}$ 的点映射后的 z 坐标是 $1$，由此得到</p><script type="math/tex; mode=display">\alpha (-\texttt{near}) + \beta = -(-\texttt{near})\cdot\tan{\frac{\texttt{fov}}{2}}\cdot(-1)</script><script type="math/tex; mode=display">\alpha (-\texttt{far}) + \beta = -(-\texttt{far})\cdot\tan{\frac{\texttt{fov}}{2}}\cdot 1</script><p>解得 $\displaystyle{\alpha = -\frac{\texttt{far}\cdot \tan \left(\frac{\texttt{fov}}{2}\right)+\texttt{near} \cdot \tan \left(\frac{\texttt{fov}}{2}\right)}{\texttt{far}-\texttt{near}}, \beta = \frac{2 \cdot \texttt{far} \cdot \texttt{near}\cdot \tan \left(\frac{\texttt{fov}}{2}\right)}{\texttt{near}-\texttt{far}}}$。</p><p>综上透视投影矩阵为<br>$<br>\Large<br>\displaystyle{<br>\left[\begin{array}{cccc}<br>\frac{1}{\texttt{aspect}} &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; 1 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; -\frac{\texttt{far}\cdot \tan \left(\frac{\texttt{fov}}{2}\right)+\texttt{near} \cdot \tan \left(\frac{\texttt{fov}}{2}\right)}{\texttt{far}-\texttt{near}} &amp; \frac{2 \cdot \texttt{far} \cdot \texttt{near}\cdot \tan \left(\frac{\texttt{fov}}{2}\right)}{\texttt{near}-\texttt{far}} \\<br>0 &amp; 0 &amp; -\tan{\frac{\texttt{fov}}{2}} &amp; 0<br>\end{array}\right]<br>}<br>$<br>，因为得到的是齐次坐标，矩阵本身可以乘非零系数，使用余切获得更简洁的形式：<br>$<br>\Large<br>\displaystyle{<br>\left[\begin{array}{cccc}<br>\frac{1}{\texttt{aspect}}\cdot \cot\frac{\texttt{fov}}{2} &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; \cot\frac{\texttt{fov}}{2} &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; \frac{\texttt{far}+\texttt{near}}{\texttt{near} - \texttt{far}} &amp; \frac{2 \cdot \texttt{far} \cdot \texttt{near}}{\texttt{near}-\texttt{far}} \\<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{array}\right]<br>}<br>$</p><p>（这个结果验证了一下，没有发现问题。）</p><h2 id="着色器与渲染管线"><a href="#着色器与渲染管线" class="headerlink" title="着色器与渲染管线"></a>着色器与渲染管线</h2><ul><li><strong>顶点着色器（vertex shader）</strong>：负责作用于每个顶点，每个顶点在绘制时都会调用这个着色器。它用来进行坐标变换或者对顶点的属性进行处理。需要自己写。</li><li><strong>几何着色器（geometry shader）</strong>：可以从图元（点、折线、三角形等）形式的一系列点生成出新的图元。一般情况下使用默认的即可。</li><li><strong>片段着色器（fragment shader）</strong>：负责作用于每个采样点，比如 4x 抗锯齿下，每个像素具有 4 个采样点。一个片段是渲染一个像素需要的所有数据。需要自己写。</li></ul><p>这些着色器都是文件（或者字符串），使用 OpenGL 着色器语言（GLSL）进行编写，只能在运行时编译。之所以要在运行时编译是因为不同 GPU 之间架构的差异较大，但是 CPU 往往不知道 GPU 的架构，故只能在运行时编译。编译完成后，着色器就是 GPU 上的小程序。一般会封装一个自己的着色器类用来读取这些文件。</p><p>渲染管线是用来处理顶点的程序流程。渲染的抽象流程是：</p><ol><li>获取顶点数据</li><li>对顶点数据调用 <em>顶点着色器</em></li><li>图元装配：将顶点装配成各种图元，例如三角形</li><li>对这些图元调用 <em>几何着色器</em></li><li>光栅化，将生成出来的东西变成会显示的像素并进行裁剪</li><li>对这些像素调用 <em>片段着色器</em></li><li>测试与混合，例如决定哪个图元先显示以及透明度的混合等</li></ol><p>在写完着色器后还需要有一个 <strong>着色器程序</strong>，这个程序实际上是多个着色器链接之后的版本。渲染的时候会调用这个着色器程序。这个着色器程序在链接的过程中会把一个着色器的输出作为另一个着色器的输入，只要它们的类型和名字是一样的。</p><p>典型的使用方式是在顶点着色器后跟一个片段着色器。顶点着色器的输入需要有形如 <code>layout(location = 0) in vec3 position</code> 这样的语句来指定顶点着色器的输入，片段着色器需要输出要给类型为 <code>vec4</code> 的颜色向量，否则渲染将没有颜色。着色器中有一类特殊的变量带有 <code>uniform</code> 标记，这种变量在同一个着色器中类似于静态变量，它会始终保持自己的值直到被外界程序更新。</p><h2 id="顶点数组对象、顶点缓冲对象、索引缓冲对象"><a href="#顶点数组对象、顶点缓冲对象、索引缓冲对象" class="headerlink" title="顶点数组对象、顶点缓冲对象、索引缓冲对象"></a>顶点数组对象、顶点缓冲对象、索引缓冲对象</h2><ul><li><strong>顶点缓冲对象 (Vertex Buffer Object, VBO)</strong> 存的是与顶点有关的数据，例如顶点的位置，顶点的颜色、这个顶点使用的纹理坐标等。</li><li><strong>顶点数组对象 (Vertex Array Object, VAO)</strong> 存的是与顶点数组有关的配置，比如如何读取对应的 VBO 等，方便在不同的顶点数组中进行切换。没有这个东西的话每次切换数组之后可能还得加载一次配置。</li><li><strong>索引缓冲对象 (Element Buffer Object, EBO)</strong> 存的是顶点的索引，可以方便复用顶点。</li></ul><h2 id="UV-坐标"><a href="#UV-坐标" class="headerlink" title="UV 坐标"></a>UV 坐标</h2><p>UV 坐标用来读取纹理。纹理加载好后会被归一化到一个长度为 1 的正方形，在着色器中指定每个顶点的 UV 坐标可以将纹理的一部分应用到物体上。</p><p>纹理中可以使用过滤和 mipmap 技术来进行视觉和性能上的优化。</p><h2 id="摄像机"><a href="#摄像机" class="headerlink" title="摄像机"></a>摄像机</h2><p>OpenGL 中没有摄像机的概念，所谓的摄像机都是通过使用观察矩阵来将世界中的物体转移实现的，可以认为是观察点和观察方向不动，而物体在移动。不过可以通过这种方式来模拟一个摄像机。</p><p>摄像机可以通过提供以下量来实现：</p><ul><li>摄像机的位置（<code>vec3</code>）、朝向（<code>vec3</code>）、向上方向（<code>vec3</code>）</li><li>摄像机的俯仰、航偏（以及翻滚）</li></ul><h2 id="光照与着色"><a href="#光照与着色" class="headerlink" title="光照与着色"></a>光照与着色</h2><h3 id="Gouraud-着色"><a href="#Gouraud-着色" class="headerlink" title="Gouraud 着色"></a>Gouraud 着色</h3><p>使用 Gouraud 着色可以在顶点着色器中完成着色，计算量较少。</p><p>如果已知一个三角形三个顶点的颜色，使用 Gouraud Shading 对一个三角形进行着色时，首先要确定每条边上各个点的颜色，这个可以通过使用线性插值来完成。对于三角形内部的一点，过这一点作一条水平线，会与三角形交于两点，这个点处的颜色就是两个交点的颜色使用线性插值得到的颜色。</p><p>Gouraud 着色得到的颜色在旋转下不能保持一致，只适用于本身已经比较平滑的物体的着色，例如漫反射平面。如果物体本身颜色不平滑，可以考虑将其划分成更多更细的三角形。</p><h3 id="冯氏光照模型"><a href="#冯氏光照模型" class="headerlink" title="冯氏光照模型"></a>冯氏光照模型</h3><p>使用冯氏光照模型需要在片段着色器中完成着色，开销比 Gouraud 着色高，但是效果较好。</p><p>冯氏光照模型是对现实光照的基本模拟，它将一个物体的光照分成三个分量：</p><ul><li><strong>环境光（Ambient）</strong>：黑暗情况下物体也能发出的光亮。</li><li><strong>漫反射（Diffuse）</strong>：物体因为漫反射的光亮，这是最显著的分量。</li><li><strong>镜面反射（Specular）</strong>：物体上的光照亮点。</li></ul><p><strong>环境光的计算</strong>：直接设置一个值就可以了。</p><p><strong>漫反射的计算</strong>：某个点（片段）处的漫反射强度等于这个点的向外的单位法线与单位入射光线反方向（从片段指向光源）的点积，如果小于零的话取等于零。</p><p><strong>镜面反射的计算</strong>：某个点处的镜面反射强度计算如下：先算单位视线方向的反方向（摄像机指向片段）和单位镜面反射光线的点积，如果小于零的话取等于零。这个值算完了之后将其作为底数，<em>反光度</em> 作为指数计算幂，反光度是一个整数，越高则光斑越小越亮。幂的结果即为镜面反射的强度。</p><p>最后调整三种光照之间的比例即可。注意变换后的法线不能直接用变换矩阵乘变换前的法线获得。</p><p>冯氏光照模型可以被精细调整。一种做法是，对于每个物体都设置它的四个属性用来表示这个物体的材质，它们是在白光照射下的环境光颜色、漫反射颜色、镜面反射颜色以及反光度。对于每个光照都设置它的三个属性来表示这个光照的性质，它们是照到白色物体上时的环境光颜色、漫反射颜色以及镜面反射颜色。在着色器中将对应的量乘起来即可。（这个精细调整比较奇怪，比如可以创建一个漫反射为红色但是镜面反射为绿色的材质。）</p><h2 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h2><ul><li><strong>漫反射贴图（Diffuse Map）</strong> 实际上和普通的贴图一致，只不过换了个名字。（使用“材质”这种概念的时候整个物体只能有一种颜色，如果要有贴图的话需要在不同片段上显示不同颜色，需要漫反射题图。）</li><li><strong>镜面光贴图（Specular Map）</strong> 是一张灰度图，它表明了不同材质下的镜面反射强度。通过使用镜面光贴图可以反应诸如“带有生锈的裂缝的钢边箱子”这样的物体在光照下的镜面反射情况。</li><li><strong>放射光贴图（Emission Map）</strong> 存储了片段的发光值，可以覆盖掉光照条件自己发光。</li></ul><p>此外还有法线贴图和反射贴图等。</p><h2 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h2><p>光源可以分成三种：</p><ul><li><strong>平行光（Directional Light）</strong>：无衰减的一列平行光（如阳光），光线只具有方向，不具有位置。</li><li><strong>点光（Point Light）</strong>：会衰减的从一个点光源发出的光（如灯泡），光线只具有位置，不具有方向。</li><li><strong>聚光（Spotlight）</strong>：一个锥形的从点光源发出的光，只有光锥内部会被照亮，光线既具有位置也具有方向。</li></ul><p>点光的衰减通过如下公式给出：$\displaystyle{I = \frac{1.0}{K_c + K_l\cdot d + K_q\cdot d^2}}$，其中 $d$ 是光源到片段的距离，常数 $K_c$ 一般取 $1$ 保证光是衰减的。</p><p>聚光的光锥边缘需要过渡，可以对聚光设置两个角度：外光切角和内光切角，光切角是光锥的母线和中心线的夹角。设内光切角为 $\phi_{i}$，外光切角为 $\phi_{o}$，实际的夹角（关照方向和光源到片段的夹角）为 $\theta$，则亮度系数可以为 $\displaystyle{\operatorname{clamp}(\frac{\cos\theta - \cos\phi_o}{\cos\phi_i - \cos\phi_o}, 0, 1)}$。用余弦而不是角度可以提高性能。</p><p>多个光源的情况按照 RGB 进行叠加即可。</p><hr><p>这些应该够完成第二次作业了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS184.1X 计算机图形学学习笔记 (1)</title>
      <link href="/2018/08/21/CS184-1X-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2018/08/21/CS184-1X-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="CS184-1X-计算机图形学学习笔记-1"><a href="#CS184-1X-计算机图形学学习笔记-1" class="headerlink" title="CS184.1X 计算机图形学学习笔记 (1)"></a>CS184.1X 计算机图形学学习笔记 (1)</h1><h2 id="变换——数学基础"><a href="#变换——数学基础" class="headerlink" title="变换——数学基础"></a>变换——数学基础</h2><h3 id="基本变换"><a href="#基本变换" class="headerlink" title="基本变换"></a>基本变换</h3><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p>二维缩放变换矩阵为 $\displaystyle{\left[\begin{array}{cc}s_x &amp; 0 \\<br> 0 &amp; s_y\end{array}\right]}$，逆变换矩阵为 $\displaystyle{\left[\begin{array}{cc}s_x^{-1} &amp; 0 \\<br> 0 &amp; s_y^{-1} \end{array}\right]}$，其中 $s_x, s_y$ 表示不同轴方向上的缩放系数。</p><p>三维缩放变换矩阵为 $\displaystyle{\left[\begin{array}{ccc}s_x &amp; 0 &amp; 0 \\<br> 0 &amp; s_y &amp; 0 \\<br> 0 &amp; 0 &amp; s_z\end{array}\right]}$，逆变换矩阵为 $\displaystyle{\left[\begin{array}{ccc}s_x^{-1} &amp; 0 &amp; 0 \\<br> 0 &amp; s_y^{-1} &amp; 0 \\<br> 0 &amp; 0 &amp; s_z^{-1} \end{array}\right]}$，其中 $s_x, s_y, s_z$ 表示不同轴方向上的缩放系数。</p><a id="more"></a><h4 id="错切"><a href="#错切" class="headerlink" title="错切"></a>错切</h4><p>二维错切变换矩阵为 $\displaystyle{\left[\begin{array}{cc}1 &amp; a \\<br> 0 &amp; 1\end{array}\right]}$，逆变换矩阵为 $\displaystyle{\left[\begin{array}{cc}1 &amp; -a \\<br> 0 &amp; 1\end{array}\right]}$，其中 $a$ 表示错切量。一条竖直的线在错切后会成为一条倾斜的线，顺时针旋转的角度的正切即为 $a$。</p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>二维旋转变换矩阵为 $\displaystyle{\left[\begin{array}{cc}\cos\theta &amp; -\sin\theta \\<br> \sin\theta &amp; \cos\theta\end{array}\right]}$，逆变换矩阵为 $\displaystyle{\left[\begin{array}{cc}\cos(-\theta) &amp; -\sin(-\theta) \\<br> \sin(-\theta) &amp; \cos(-\theta)\end{array}\right]}$，其中 $\theta$ 表示逆时针旋转的角度。二维的旋转具有交换性。</p><p>三维旋转变换矩阵为 $\displaystyle{\left[\begin{array}{ccc}\vec u_x &amp; \vec u_y &amp; \vec u_z \\<br> \vec v_x &amp; \vec v_y &amp; \vec v_z \\<br> \vec w_x &amp; \vec w_y &amp; \vec w_z\end{array}\right]}$，其中 $\vec u, \vec v, \vec w$ 是三个正交的单位向量，代表一个坐标系。通过将这个变换矩阵乘一个向量我们会得到一个新的向量，这个新向量就是原向量在新坐标系下的坐标。如果将这个坐标运用到原始的坐标系中就会发现原始的物体发生了三维旋转。这个变换矩阵是一个正交矩阵，记这个矩阵为 $\mathbf{R}$，则在原坐标系中为 $\vec{m}$ 的向量在新坐标系中为 $\mathbf{R}\vec{m}$，在新坐标系中为 $\vec{n}$ 的向量在原坐标系中为 $\mathbf{R}^T\vec{n}$。</p><p>三维旋转还有一个公式为轴角公式，即求给定一个单位转轴矢量 $\vec{k}$，对一个向量 $\vec{v}$，它绕着 $\vec{k}$ 逆时针旋转 $\theta$ 角后新的坐标是什么。这个公式叫罗德里格旋转公式，有 $\vec{v}&#39; = \vec{v}\cos\theta + (\vec{k}\times\vec{v})\sin\theta + \vec{k}(\vec{k}\cdot\vec{v})(1 - \cos\theta)$。写成矩阵形式为 $\displaystyle{\mathbf{R}(\vec{k}, \theta) = \mathbf{I}_{3\times 3}\cos\theta + \vec{k}\cdot\vec{k}^T(1 - \cos\theta) + \mathbf{K}^\ast\sin\theta}$，其中 $\mathbf{K}^\ast$ 是 $\vec{k}$ 的 dual matrix，则 $\vec{v}&#39; = R(\vec{k}, \theta)\vec{v}$。</p><blockquote><p>矢量的叉乘可以写成一个矩阵乘以一个矢量：$\vec a\times \vec b = \mathbf{A}^\ast\vec b$，其中 $\mathbf{A}^\ast$ 是向量 $\vec a$ 的 dual matrix，有 $\displaystyle{\mathbf{A}^\ast = \left[\begin{array}{ccc}0 &amp; -z_{\vec a} &amp; y_{\vec a} \\<br>z_{\vec a} &amp; 0 &amp; -x_{\vec a} \\<br>-y_{\vec a} &amp; x_{\vec a} &amp; 0 \end{array}\right]}$。</p></blockquote><h3 id="组合变换"><a href="#组合变换" class="headerlink" title="组合变换"></a>组合变换</h3><p>如果要施加一系列组合变换，只需要将各个分变换的矩阵连乘起来即可。<strong>因为矩阵乘法不具有交换性，所以这些变换的矩阵相乘的时候要保证顺序正确</strong>。如果要求组合变换的逆变换，可以使用公式 $(\mathbf{AB})^{-1} = \mathbf{B}^{-1}\mathbf{A}^{-1}$，即后施加的变换先解除。</p><h3 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h3><p>使用一个矩阵乘一个点表示这个点的平移是不可能做到的，为此需要引入齐次坐标。齐次坐标就是用一个 $n + 1$ 维的矢量 $\vec{v}&#39;$ 表示一个 $n$ 维的点 $\vec{v}$，这样不论 $\vec{v}&#39;$ 乘以什么非零常数，都表示的是同一个点，即表现出齐次性。此外，引入齐次坐标还可以方便地表示位于无穷远处的点。在图形学中使用 $(x, y, z, w)^T$ 表示实际位于 $\displaystyle{(\frac{x}{w}, \frac{y}{w}, \frac{z}{w})^T}$ 处的一个点，在整个计算过程中可以一直使用齐次坐标，只要最后一下转换成实际坐标即可。</p><h4 id="齐次坐标下的平移"><a href="#齐次坐标下的平移" class="headerlink" title="齐次坐标下的平移"></a>齐次坐标下的平移</h4><p>在这种表示下可以使用矩阵乘法来表示点的位移，如果要对具有齐次坐标的点 $(x, y, z, w)^T$ 施加向 $(t_x, t_y, t_z)^T$ 的位移，只要用平移矩阵 $\displaystyle{\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; t_x \\<br> 0 &amp; 1 &amp; 0 &amp; t_y \\<br> 0 &amp; 0 &amp; 1 &amp; t_z \\<br> 0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]}$ 左乘那个齐次坐标即可。为了简单起见，如果齐次坐标中 $w = 1$ 则有 $\displaystyle{\left[\begin{array}{cc}\mathbf{I} &amp; \vec{t} \\<br> \mathbf{0} &amp; 1\end{array}\right]\cdot \left(\begin{array}{c}\vec{v} \\<br> 1\end{array}\right) = \left(\begin{array}{c}\vec{v} + \vec{t} \\<br> 1\end{array}\right)}$，这样可以直观地看出这个平移矩阵的作用。</p><p>如果要实施的变换为缩放、错切或旋转，且变换矩阵为三阶矩阵 $\mathbf{M}$，则在 $w = 1$ 的情况下使用齐次坐标时变换矩阵为四阶矩阵 $\operatorname{diag}(\mathbf{M}, 1)$。</p><p>还是以 $w = 1$ 来研究，对于平移和旋转两种操作，先平移 $\vec{v}$ 再旋转对应于矩阵 $\mathbf{R}$ 的结果和先旋转再平移的结果有何不同。前者是 $\displaystyle{\left[\begin{array}{cc}\mathbf{R} &amp; \mathbf{0} \\<br> \mathbf{0} &amp; 1\end{array}\right]\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; \vec v_x \\<br> 0 &amp; 1 &amp; 0 &amp; \vec v_y \\<br> 0 &amp; 0 &amp; 1 &amp; \vec v_z \\<br> 0 &amp; 0 &amp; 0 &amp; 1\end{array}\right] = \left[\begin{array}{cc}\mathbf{R} &amp; \mathbf{0} \\<br> \mathbf{0} &amp; 1\end{array}\right]\left[\begin{array}{cc}\mathbf{I} &amp; \vec{v} \\<br> \mathbf{0} &amp; 1\end{array}\right] = \left[\begin{array}{cc}\mathbf{R} &amp; \mathbf{R}\vec{v} \\<br> \mathbf{0} &amp; 1\end{array}\right]}$，后者是 $\displaystyle{\left[\begin{array}{cc}\mathbf{I} &amp; \vec{v} \\<br> \mathbf{0} &amp; 1\end{array}\right]\left[\begin{array}{cc}\mathbf{R} &amp; \mathbf{0} \\<br> \mathbf{0} &amp; 1\end{array}\right] = \left[\begin{array}{cc}\mathbf{R} &amp; \vec{v} \\<br> \mathbf{0} &amp; 1\end{array}\right]}$。可见二者是不同的。</p><h4 id="法向变换"><a href="#法向变换" class="headerlink" title="法向变换"></a>法向变换</h4><p>一个平面的法线 $\vec{n}$ 在这个物体经过了变换 $\mathbf{M}$ 之后也会发生变换，成为 $\vec{n}&#39;$，但是 $\vec{n}$ 的变换矩阵并不是 $\mathbf{M}$。为了求出 $\vec{n}$ 的变换矩阵，令 $\vec{n}&#39; = \mathbf{W}\vec{n}$，设原来平面上的任意条切线为 $\vec{t}$，则 $\vec{n}\cdot\vec{t} = 0 \Rightarrow \vec{n}^T\vec{t} = 0$，且变换后满足 $\mathbf{W}\vec{n}\cdot\mathbf{M}\vec{t} = 0\Rightarrow \vec{n}^T\mathbf{W}^T\mathbf{M}\vec{t} = 0$。只要选取 $\mathbf{W} = \mathbf{M}^{-T}$ 即可。需要注意的是这里的转置和求逆都是针对 $\mathbf{M}$ 的左上角的三阶部分而言的，平移不会改变法线的方向。</p><hr><p>数学部分讲完之后作者讲 OpenGL 的速度简直是在开火箭，或许我应该看一下一些比较系统的 OpenGL 教程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手实现简单 TensorFlow</title>
      <link href="/2018/08/20/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95-TensorFlow/"/>
      <url>/2018/08/20/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95-TensorFlow/</url>
      
        <content type="html"><![CDATA[<h1 id="动手实现简单-TensorFlow"><a href="#动手实现简单-TensorFlow" class="headerlink" title="动手实现简单 TensorFlow"></a>动手实现简单 TensorFlow</h1><p>这篇文章是对 <a href="http://www.deepideas.net/deep-learning-from-scratch-theory-and-implementation/" target="_blank" rel="noopener">Deep Learning From Scratch: Theory and Implementation</a> 的学习和整理，原作者使用纯 Python 实现了一个和 TensorFlow 接口类似的框架用来解释深度学习的基本原理以及 TensorFlow 这类框架是如何工作的。此处是看完原博客后的一些总结。（顺便测试一下这个博客系统）</p><h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><p>计算图是一张有向无环图，它可以将一个复杂的函数分解成各种基本的运算，方便后续对各自变量求导。比如一个 $\displaystyle{\vec{y} = \mathbf{A}\vec{x} + \vec{b}}$ 就可以写成如下的计算图：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">|           |</span><br><span class="line">|           |</span><br><span class="line">|     A     +---------+</span><br><span class="line">|           |         |</span><br><span class="line">|           |         |        +-----------+</span><br><span class="line">+-----------+         |        |           |</span><br><span class="line">                      +-------&gt;|           |</span><br><span class="line">                               |     .     +------------+</span><br><span class="line">                      +-------&gt;|           |            |</span><br><span class="line">                      |        |           |            |</span><br><span class="line">+-----------+         |        +-----------+            |       +-----------+</span><br><span class="line">|           |         |                                 |       |           |</span><br><span class="line">|           |         |                                 +------&gt;|           |</span><br><span class="line">|     x     +---------+                                         |     +     |</span><br><span class="line">|           |                                           +------&gt;|           |</span><br><span class="line">|           |                  +-----------+            |       |           |</span><br><span class="line">+-----------+                  |           |            |       +-----------+</span><br><span class="line">                               |           |            |</span><br><span class="line">                               |     b     +------------+</span><br><span class="line">                               |           |</span><br><span class="line">                               |           |</span><br><span class="line">                               +-----------+</span><br></pre></td></tr></table></figure><p>从最后一个结点中出来的结果就是 $\displaystyle{\vec{y}}$。</p><p>在上图中，所有的方框都是一个结点，箭头则是图的边。计算图只是描述了一个函数，没有进行实际的运算。当需要使用计算图进行计算时需要对计算图的所有输入赋一个确定的值，这些值会在计算图中按照箭头的方向和计算结点的计算方式进行计算，直到得到最后的答案。</p><p>为了实现一遍简单的 TensorFlow 需要先实现一个计算图的框架。计算图中所有的结点大致可以分成三类：</p><ul><li><strong>计算结点</strong>：接收若干个结点，进行计算得到新的数据，如上图中的表示矩阵和向量乘积的 $\cdot$ 结点和表示向量之和的 $+$ 结点。</li><li><strong>输入结点</strong>：例如上图中的 $\vec{x}$，需要在计算图开始计算时被提供一个确定的值。</li><li><strong>变量结点</strong>：假如计算图会被多次计算，但是其中有些值不需要每次都被提供，而是初始化一次后直接存储下来（后续可能会被更改），这样的结点为变量结点。例如神经网络中的可学习的权值。</li></ul><p>计算图的结点的基类，其中 <code>self.inputs</code> 是一个列表，用来记录这个结点的输入（即计算图中的前驱结点）有哪些：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        self.inputs = inputs</span><br></pre></td></tr></table></figure><p>然后是三种不同类型的结点。对于计算结点，我们需要 <code>compute</code> 函数用来定义具体的计算行为；对于变量结点，我们需要提供一个初始值；所谓 <code>Placeholder</code> 就是输入结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span><span class="params">(Node)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        super().__init__(inputs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Placeholder</span><span class="params">(Node)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__([])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Variable</span><span class="params">(Node)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initial_value)</span>:</span></span><br><span class="line">        super().__init__([])</span><br><span class="line">        self.value = initial_value</span><br></pre></td></tr></table></figure><p>然后定义两个最简单的运算——矩阵乘法和加法。在定义运算时，假定所有的数据都是 numpy 的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        super().__init__([x, y])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MatMul</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        super().__init__([x, y])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x.dot(y)</span><br></pre></td></tr></table></figure><p>现在可以使用这些已经定义的结点类型和运算构造一个计算图了，但是这只是定义了一个运算，真正的计算过程还需要初始化所有的变量结点，然后提供输入结点的值。为了得到最终的计算结果需要确定计算图中每个结点的运算顺序，显然这个顺序是整张图的拓扑排序的结果（即排序好的序列中，位于前面的结点不可能是位于后面的结点在原图中的前驱，这个序列不唯一），这样保证了每个结点计算时它所有的输入结点的值已经确定了。仿照 TensorFlow 的那一套，我们弄一个 <code>Session</code> 类，然后这个类中定义一个 <code>run</code> 方法，这个方法中会使用一个词典来记录这次计算过程中每个结点得到的中间结果，最后返回要计算的目标结点的结果即可。在依次计算每个结点时，根据这个结点的不同类型需要选择不同的获得中间结果的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, target, feed_dict)</span>:</span></span><br><span class="line">        nodes_sorted = topological_sort(target)</span><br><span class="line">        results = &#123;node: <span class="literal">None</span> <span class="keyword">for</span> node <span class="keyword">in</span> nodes_sorted&#125;</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes_sorted:</span><br><span class="line">            <span class="keyword">if</span> isinstance(node, Variable):</span><br><span class="line">                results[node] = node.value</span><br><span class="line">            <span class="keyword">elif</span> isinstance(node, Placeholder):</span><br><span class="line">                results[node] = feed_dict[node]</span><br><span class="line">            <span class="keyword">elif</span> isinstance(node, Operation):</span><br><span class="line">                results[node] = node.compute(*[results[input_node] <span class="keyword">for</span> input_node <span class="keyword">in</span> node.inputs])</span><br><span class="line">        <span class="keyword">return</span> results[target]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topological_sort</span><span class="params">(node)</span>:</span></span><br><span class="line">    sorted_nodes = []</span><br><span class="line">    queue = [node]</span><br><span class="line">    <span class="keyword">while</span> len(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        head = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> pre_node <span class="keyword">in</span> head.inputs:</span><br><span class="line">            <span class="keyword">if</span> pre_node <span class="keyword">not</span> <span class="keyword">in</span> sorted_nodes <span class="keyword">and</span> pre_node <span class="keyword">not</span> <span class="keyword">in</span> queue:</span><br><span class="line">                queue.append(pre_node)</span><br><span class="line">        sorted_nodes.append(head)</span><br><span class="line">    <span class="keyword">return</span> sorted_nodes[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>现在我们可以写一段简单的代码验证上述的计算图和它的计算结果的正确性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">b = np.ones((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">x = Placeholder()</span><br><span class="line">y = Placeholder()</span><br><span class="line">z = MatMul(x, y)</span><br><span class="line">session = Session()</span><br><span class="line">print(session.run(z, &#123;x: a, y: b&#125;))</span><br></pre></td></tr></table></figure><p>到这里大概就可以猜出来 TensorFlow 取这个名称的原因了，其实还挺形象的。</p><h2 id="更多的计算结点"><a href="#更多的计算结点" class="headerlink" title="更多的计算结点"></a>更多的计算结点</h2><p>这一节中我们会引入更多的计算结点，因为这些计算在神经网络中用得比较广泛。首先是 sigmoid 激活函数 $\displaystyle{\sigma(x) = \frac{1}{1 + e^{-x}}}$、双曲正切激活函数和归一化指数函数 softmax。</p><p>所谓归一化指数函数就是将一个向量归一化成凸显了它们差距且和为 1 的新向量，直观的公式为：</p><script type="math/tex; mode=display">\largesoftmax(\left[\begin{array}{c} x \\ y \\ z \\\end{array}\right]) = \left[\begin{array}{c} \frac{e^x}{e^x+e^y+e^z} \\ \frac{e^y}{e^x+e^y+e^z} \\ \frac{e^z}{e^x+e^y+e^z} \\\end{array}\right]</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sigmoid</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        super().__init__([x])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tanh</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        super().__init__([x])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.tanh(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Softmax</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        super().__init__([x])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.exp(x) / np.sum(np.exp(x), axis=<span class="number">1</span>)[:, <span class="literal">None</span>]</span><br></pre></td></tr></table></figure><p>下面是更多的计算结点。其中 <code>HadamardProduct</code> 是矩阵的逐元素乘积，<code>ReduceSum</code> 表示将一个张量按照某个轴进行加和，默认情况会按照所有轴加和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        super().__init__([x])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.log(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HadamardProduct</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        super().__init__([x, y])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Negative</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__init__([x])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduceSum</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, axis=None)</span>:</span></span><br><span class="line">        self.axis = axis</span><br><span class="line">        <span class="keyword">return</span> super().__init__([x])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.sum(x, self.axis)</span><br></pre></td></tr></table></figure><p>有了这些以后我们可以定义出交叉熵代价函数，这个函数会接受两个结点然后返回表示交叉熵的结点。所谓的交叉熵代价函数可以衡量两个分布之间的距离，代价函数越小表示距离越小，两个分布越接近。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy_loss</span><span class="params">(labels, predictions)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Negative(ReduceSum(HadamardProduct(labels, Log(predictions))))</span><br></pre></td></tr></table></figure><p>最后还是用一小段代码来检查这一节中写的代码的正确性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>]])</span><br><span class="line">b = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">x = Placeholder()</span><br><span class="line">y = Placeholder()</span><br><span class="line">z = Softmax(x)</span><br><span class="line">loss = cross_entropy_loss(y, z)</span><br><span class="line">session = Session()</span><br><span class="line">print(session.run(loss, &#123;x: a, y: b&#125;))</span><br></pre></td></tr></table></figure><h2 id="反向传播与梯度下降"><a href="#反向传播与梯度下降" class="headerlink" title="反向传播与梯度下降"></a>反向传播与梯度下降</h2><p>在得到了交叉熵之后我们需要最小化这个熵，这个操作是通过调整各个变量结点的值来完成的。具体调整的增量是多是少要看交叉熵对这个变量的依赖程度如何，也就是要计算偏导。因为使用了计算图这种模型，我们能比较容易的计算出偏导，它的原理依赖于链式法则，不严谨地举例来说，对于下面这个计算图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----+         +-----+          +-----+           +-----+</span><br><span class="line">|     |         |     |          |     |           |     |</span><br><span class="line">|  a  +--------&gt;|  b  +---------&gt;|  c  +----------&gt;|  d  |</span><br><span class="line">|     |         |     |          |     |           |     |</span><br><span class="line">+-----+         +-----+          +-----+           +-----+</span><br></pre></td></tr></table></figure><p>有 $\displaystyle{\frac{\partial d}{\partial a} = \frac{\partial d}{\partial c}\cdot \frac{\partial c}{\partial b}\cdot\frac{\partial b}{\partial a}}$，其中 $a,b,c,d$ 表示的都是某个结点完成计算后的值。如果出现了分支，那么偏导是各个路径上偏导之和：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                 +-----+</span><br><span class="line">                                 |     |</span><br><span class="line">                           +----&gt;|  c  +-----+</span><br><span class="line">                           |     |     |     |</span><br><span class="line">                           |     +-----+     |</span><br><span class="line">+-----+         +-----+    |                 |     +-----+</span><br><span class="line">|     |         |     +----+                 +----&gt;|     |</span><br><span class="line">|  a  +--------&gt;|  b  |                            |  e  |</span><br><span class="line">|     |         |     +----+                 +----&gt;|     |</span><br><span class="line">+-----+         +-----+    |                 |     +-----+</span><br><span class="line">                           |     +-----+     |</span><br><span class="line">                           |     |     |     |</span><br><span class="line">                           +----&gt;|  d  +-----+</span><br><span class="line">                                 |     |</span><br><span class="line">                                 +-----+</span><br></pre></td></tr></table></figure><p>有 $\displaystyle{\frac{\partial e}{\partial a} =  \frac{\partial e}{\partial c}\cdot \frac{\partial c}{\partial b}\cdot\frac{\partial b}{\partial a} +  \frac{\partial e}{\partial d}\cdot \frac{\partial d}{\partial b}\cdot\frac{\partial b}{\partial a} = \left(\frac{\partial e}{\partial c}\cdot \frac{\partial c}{\partial b} +  \frac{\partial e}{\partial d}\cdot \frac{\partial d}{\partial b}\right)\cdot\frac{\partial b}{\partial a}}$。</p><p>在计算某个结点相对于它的所有前驱（直接的和非直接的）的偏导时我们不希望发生重复的计算，如果目标结点是 T 并且我们已经计算了 T 对结点 A 的偏导，那么对于 A 的直接前驱 B 我们实际上可以很快计算出 T 对 B 的偏导，而不用再像上面一样寻找计算图中的路径。对于一个计算结点来说，如果它的输出为 Z，输入为 X 和 Y，并且我们已经计算出了 T 对 Z 的偏导的值 G，那么在 X 和 Y 不连向其它结点的情况下，T 对 X 以及 T 对 Y 的偏导的值将只和这个计算结点的输入值、计算结点本身以及 G 有关。</p><p>举个例子，对于 $Z = X + Y$ 的情况，如果说 $X$ 和 $Y$ 没有指向其它的计算结点，并且有 $\displaystyle{\frac{\partial T}{\partial Z} = G}$，则 $\displaystyle{\frac{\partial T}{\partial X} = \frac{\partial T}{\partial Z}\cdot\frac{\partial Z}{\partial X} = G \cdot 1 = G}$。如果要算目标结点对某个结点 N 的偏导，但是结点 N 不止作为一个计算结点的输入怎么办？还是用这个办法，对于结点 N 的所有直接后继结点，应用这个算法算一遍目标结点对 N 的偏导然后求和就可以了。在计算目标结点对其所有前驱结点的导数时，计算顺序和使用前驱结点计算目标结点的值时顺序相反，这就是反向传播这个名称的由来。</p><p>为了实现这个算法，我们要在所有的运算结点中都添加一个函数，这个函数负责在已知目标结点对自己的输出的偏导为 <code>gradient_to_this</code> 的情况下给出（忽略输入结点的其它直接后继结点时）目标结点对其所有输入结点的偏导，返回的方式是一个列表，排列的顺序和 <code>compute</code> 参数顺序相同。</p><p>我们需要对结点的定义做一些修改，主要是：</p><ul><li>现在除了 <code>Variable</code>，其它的结点也要记录自己的值，即 <code>Variable</code> 自己的 <code>value</code> 被提到 <code>Node</code> 中去；此外，还要记录每一个结点的直接后继。这些都是为了计算偏导。</li><li>所有的 <code>Operation</code> 都要加上 <code>get_gradient</code> 方法。</li></ul><p>修改后的各结点定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        self.inputs = inputs</span><br><span class="line">        self.outputs = []</span><br><span class="line">        self.value = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> inputs:</span><br><span class="line">            node.outputs.append(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span><span class="params">(Node)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        super().__init__(inputs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span><span class="params">(self, gradient_to_this)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Placeholder</span><span class="params">(Node)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__([])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Variable</span><span class="params">(Node)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initial_value)</span>:</span></span><br><span class="line">        super().__init__([])</span><br><span class="line">        self.value = initial_value</span><br></pre></td></tr></table></figure><p>与此对应地需要修改 <code>Session</code>，现在 <code>Session</code> 中不用存放中间结果了，因为中间结果就在计算图的各个结点中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, target, feed_dict)</span>:</span></span><br><span class="line">        nodes_sorted = topological_sort(target)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes_sorted:</span><br><span class="line">            <span class="keyword">if</span> isinstance(node, Placeholder):</span><br><span class="line">                node.value = feed_dict[node]</span><br><span class="line">            <span class="keyword">elif</span> isinstance(node, Operation):</span><br><span class="line">                node.value = node.compute(*[input_node.value <span class="keyword">for</span> input_node <span class="keyword">in</span> node.inputs])</span><br><span class="line">        <span class="keyword">return</span> target.value</span><br></pre></td></tr></table></figure><p>然后为所有的计算结点添加求导的方法，先处理最简单的 <code>Negative</code>、<code>Sigmoid</code> 以及 <code>Tanh</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Negative</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span><span class="params">(self, gradient_to_this)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [-gradient_to_this]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sigmoid</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        super().__init__([x])</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Sigmoid.sigmoid(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span><span class="params">(self, gradient_to_this)</span>:</span></span><br><span class="line">        value = self.inputs[<span class="number">0</span>].value</span><br><span class="line">        <span class="keyword">return</span> [gradient_to_this * Sigmoid.sigmoid(value) * (<span class="number">1</span> - Sigmoid.sigmoid(value))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tanh</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span><span class="params">(self, gradient_to_this)</span>:</span></span><br><span class="line">        value = self.value</span><br><span class="line">        <span class="keyword">return</span> [gradient_to_this * (<span class="number">1</span> - np.tanh(value) * np.tanh(value))]</span><br></pre></td></tr></table></figure><p>其它的运算以类似的方式给出，但是有些值得说明的地方，先看矩阵的逐元素乘法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HadamardProduct</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span><span class="params">(self, gradient_to_this)</span>:</span></span><br><span class="line">        x_value = self.inputs[<span class="number">0</span>].value</span><br><span class="line">        y_value = self.inputs[<span class="number">1</span>].value</span><br><span class="line">        <span class="keyword">return</span> [gradient_to_this * y_value, gradient_to_this * x_value]</span><br></pre></td></tr></table></figure><p>一个标量对一个矩阵的导数是和这个矩阵形状相同的矩阵，它的每一个元素是原来的标量对原来的矩阵对应位置上的元素的导数。设 $\mathbf{Z} = \mathbf{X} \odot \mathbf{Y}$，如果已知 $\displaystyle{\frac{\partial t}{\partial \mathbf{Z}} = \mathbf{G}}$，则</p><script type="math/tex; mode=display">\displaystyle{\left(\frac{\partial t}{\partial \mathbf{X}}\right)_{ij} = \frac{\partial t}{\partial \mathbf{X}_{ij}} = \frac{\partial t}{\partial \mathbf{Z}_{ij}} \cdot \frac{\partial \mathbf{Z}_{ij}}{\partial \mathbf{X}_{ij}} = \left(\frac{\partial t}{\partial \mathbf{Z}}\right)_{ij} \cdot \frac{\partial (\mathbf{X}_{ij}\mathbf{Y}_{ij})}{\partial \mathbf{X}_{ij}} = \mathbf{G}_{ij}\cdot\mathbf{Y}_{ij}\Rightarrow\frac{\partial t}{\partial \mathbf{X}} = \mathbf{G}\odot\mathbf{Y}}</script><p>其中第二个等号成立的原因是在 $\mathbf{Z}$ 的所有元素中只有 $\mathbf{Z}_{ij}$ 依赖于 $\mathbf{X}_{ij}$。$\displaystyle{\frac{\partial t}{\partial \mathbf{Y}}}$ 使用类似方法推出。</p><p>然后是矩阵乘法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MatMul</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span><span class="params">(self, gradient_to_this)</span>:</span></span><br><span class="line">        x_value = self.inputs[<span class="number">0</span>].value</span><br><span class="line">        y_value = self.inputs[<span class="number">1</span>].value</span><br><span class="line">        <span class="keyword">return</span> [gradient_to_this.dot(y_value.T), x_value.T.dot(gradient_to_this)]</span><br></pre></td></tr></table></figure><p>证明一下若 $\displaystyle{\mathbf{Z} = \mathbf{X}\mathbf{Y}, \frac{\partial t}{\partial \mathbf{Z}} = \mathbf{G}}$，则</p><script type="math/tex; mode=display">\left(\frac{\partial t}{\partial \mathbf{X}}\right)_{ij} = \frac{\partial t}{\partial \mathbf{X}_{ij}} = \sum_k\frac{\partial t}{\partial \mathbf{Z}_{ik}}\cdot\frac{\partial \mathbf{Z}_{ik}}{\partial \mathbf{X}_{ij}} = \sum_k\mathbf{G}_{ik}\frac{\sum\limits_r\partial\mathbf{X}_{ir}\mathbf{Y}_{rk}}{\partial \mathbf{X}_{ij}} = \sum_k\mathbf{G}_{ik}\mathbf{Y}_{jk} = \sum_k\mathbf{G}_{ik}\mathbf{Y}^T_{kj} = (\mathbf{GY}^T)_{ij}</script><p>于是 $\displaystyle{\frac{\partial{t}}{\partial{\mathbf{X}}} = \mathbf{GY}^{T}}$，另一个类似。</p><p>最后解释一下加法，加法存在一个特殊情况是一个矩阵和一个行向量相加，比如神经网络中的偏置就是一个行向量，此时默认将这个行向量加到矩阵的每一行上，这样得到的代码就会是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span><span class="params">(self, gradient_to_this)</span>:</span></span><br><span class="line">        shape_x = self.inputs[<span class="number">0</span>].value.shape</span><br><span class="line">        shape_y = self.inputs[<span class="number">1</span>].value.shape</span><br><span class="line">        <span class="keyword">if</span> len(shape_x) &lt; len(shape_y):</span><br><span class="line">            <span class="keyword">return</span> [np.sum(gradient_to_this, <span class="number">0</span>), gradient_to_this]</span><br><span class="line">        <span class="keyword">if</span> len(shape_x) &gt; len(shape_y):</span><br><span class="line">            <span class="keyword">return</span> [gradient_to_this, np.sum(gradient_to_this, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [gradient_to_this, gradient_to_this]</span><br></pre></td></tr></table></figure><p>然后是其它操作的导数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span><span class="params">(self, gradient_to_this)</span>:</span></span><br><span class="line">        x_value = self.inputs[<span class="number">0</span>].value</span><br><span class="line">        <span class="keyword">return</span> [gradient_to_this / x_value]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduceSum</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span><span class="params">(self, gradient_to_this)</span>:</span></span><br><span class="line">        shape = np.array(self.inputs[<span class="number">0</span>].value.shape)</span><br><span class="line">        shape[self.axis] = <span class="number">1</span></span><br><span class="line">        new_shape = self.inputs[<span class="number">0</span>].value.shape // shape</span><br><span class="line">        gradient = np.reshape(gradient_to_this, shape)</span><br><span class="line">        <span class="keyword">return</span> [np.tile(gradient, new_shape)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Softmax</span><span class="params">(Operation)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span><span class="params">(self, gradient_to_this)</span>:</span></span><br><span class="line">        value = self.value</span><br><span class="line">        <span class="keyword">return</span> [(gradient_to_this - np.reshape(np.sum(gradient_to_this * value, <span class="number">1</span>), [<span class="number">-1</span>, <span class="number">1</span>])) * value]</span><br></pre></td></tr></table></figure><p>到此为止我们在给定一个结点 N 的情况下求出这个结点对它所有的前驱结点的导数。如果这些结点中的变量结点在下一次迭代前沿着导数的方向减去了一个值，那么就更有可能在相同输入的情况下让 N 的输出更小。如果 N 的值就是交叉熵的话就可以最小化交叉熵了，这就是梯度下降。将梯度下降定义为一个 <code>Operation</code>，同时构造的时候传入梯度下降的强度（即学习率），得到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GradientDescentOptimizer</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, learning_rate)</span>:</span></span><br><span class="line">    self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimize</span><span class="params">(self, loss)</span>:</span></span><br><span class="line">    learning_rate = self.learning_rate</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MinimizationOperation</span><span class="params">(Operation)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">            super().__init__([])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self)</span>:</span></span><br><span class="line">            gradients_table = compute_gradients(loss)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> gradients_table:</span><br><span class="line">                <span class="keyword">if</span> isinstance(node, Variable):</span><br><span class="line">                    node.value -= learning_rate * gradients_table[node]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MinimizationOperation()</span><br></pre></td></tr></table></figure><p>其中 <code>compute_gradients</code> 会得到一个词典，键为其参数结点的所有前驱结点，值为对应的导数。它的实现如下。向进行拓扑排序，然后反序地计算导数；对于每个结点，它的导数是所有后继节点按照前述算法计算的导数的和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_gradients</span><span class="params">(target_node)</span>:</span></span><br><span class="line">    gradients_table = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    nodes_sorted = topological_sort(target_node)[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes_sorted:</span><br><span class="line">        <span class="keyword">if</span> node == target_node:</span><br><span class="line">            gradients_table[node] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gradient = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> consumer <span class="keyword">in</span> node.outputs:</span><br><span class="line">                index = consumer.inputs.index(node)</span><br><span class="line">                gradient += consumer.get_gradient(gradients_table[consumer])[index]</span><br><span class="line">            gradients_table[node] = gradient</span><br><span class="line">    <span class="keyword">return</span> gradients_table</span><br></pre></td></tr></table></figure><p>完成后我们就得到了一个简单的 TensorFlow，下面用一些实践去检验它。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>通过 sklearn 生成一些数据，然后尝试使用一个简单的 DNN 去对这些数据做二分类。需要注意的是，因为每次计算梯度的时候需要各个节点内有形状正确的 <code>value</code>，可以在每次计算梯度前先算一遍 loss 来强行刷新这个 <code>value</code>。</p><p>生成数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data_x, data_y = make_circles(<span class="number">512</span>, noise=<span class="number">0.1</span>, factor=<span class="number">0.5</span>)</span><br><span class="line">x_max, x_min = data_x[:, <span class="number">0</span>].max(), data_x[:, <span class="number">0</span>].min()</span><br><span class="line">y_max, y_min = data_x[:, <span class="number">1</span>].max(), data_x[:, <span class="number">1</span>].min()</span><br><span class="line"></span><br><span class="line">data_y_one_hot = np.zeros((<span class="number">512</span>, <span class="number">2</span>))</span><br><span class="line">data_y_one_hot[range(<span class="number">512</span>), data_y] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>搭建网络（这一步写起来就像在写 TensorFlow 一样）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">inputs = Placeholder()</span><br><span class="line">labels = Placeholder()</span><br><span class="line">dense_1 = Tanh(Add(MatMul(inputs, Variable(np.random.rand(<span class="number">2</span>, <span class="number">16</span>))), Variable(np.random.rand(<span class="number">16</span>))))</span><br><span class="line">dense_2 = Tanh(Add(MatMul(dense_1, Variable(np.random.rand(<span class="number">16</span>, <span class="number">16</span>))), Variable(np.random.rand(<span class="number">16</span>))))</span><br><span class="line">logits = Add(MatMul(dense_2, Variable(np.random.rand(<span class="number">16</span>, <span class="number">2</span>))), Variable(np.random.rand(<span class="number">2</span>)))</span><br><span class="line">predictions = Softmax(logits)</span><br><span class="line">loss = cross_entropy_loss(labels, predictions)</span><br><span class="line">minimization = GradientDescentOptimizer(learning_rate=<span class="number">0.0005</span>).minimize(loss)</span><br><span class="line">session = Session()</span><br><span class="line">print(session.run(loss, feed_dict=&#123;inputs: data_x, labels: data_y_one_hot&#125;))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_result</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    data = np.array([[x, y]])</span><br><span class="line">    result = session.run(predictions, feed_dict=&#123;inputs: data&#125;)</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>训练和运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">2048</span>):</span><br><span class="line">    session.run(loss, feed_dict=&#123;inputs: data_x, labels: data_y_one_hot&#125;)</span><br><span class="line">    session.run(minimization, feed_dict=&#123;inputs: data_x, labels: data_y_one_hot&#125;)</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">64</span> == <span class="number">0</span>:</span><br><span class="line">        print(session.run(loss, feed_dict=&#123;inputs: data_x, labels: data_y_one_hot&#125;))</span><br><span class="line">        xs = np.linspace(x_min * <span class="number">1.1</span>, x_max * <span class="number">1.1</span>)</span><br><span class="line">        ys = np.linspace(y_min * <span class="number">1.1</span>, y_max * <span class="number">1.1</span>)</span><br><span class="line">        xs_mesh, ys_mesh = np.meshgrid(xs, ys)</span><br><span class="line">        plt.contourf(</span><br><span class="line">            xs_mesh, ys_mesh, np.array([[get_result(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> xs] <span class="keyword">for</span> y <span class="keyword">in</span> ys]), vmin=<span class="number">0</span>, vmax=<span class="number">1</span>, alpha=<span class="number">0.3</span></span><br><span class="line">        )</span><br><span class="line">        plt.scatter(data_x[:, <span class="number">0</span>], data_x[:, <span class="number">1</span>], c=data_y)</span><br><span class="line">        plt.savefig(<span class="string">f'./circle/<span class="subst">&#123;epoch&#125;</span>.png'</span>)</span><br><span class="line">        plt.close()</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2018/08/20/动手实现简单-TensorFlow/ezgif-5-c7c0e75a96.gif"><p>另外一个数据集上的运行结果：</p><img src="/2018/08/20/动手实现简单-TensorFlow/ezgif-5-a53c940c71.gif">]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
